---
title: 设计模式学习总结（一）简单工厂模式
date: 2007-04-06 20:22:00
tags: 
- 设计模式
categories: 总结
---

通过封装,继承和多态来把程序的耦合度降低,通过设计模式来将程序更加灵活。

简单工厂模式
通过单独的类去实例化对象

UML类图
类图分三层，第一层显示类的名称，如果是抽象类，就用斜体显示。第二层是类的特性，通常是字段和属性，第三层是类的操作，通常是方法或者行为，+ 表示public，-表示private，# 表示protected。

接口的表现方式：<<interface>>或者是棒棒糖表示法

继承关系的表现方式 空心三角形+实线来表示.

association 关联类,当一个类需要引用另一个类的时候,可以使用关联。关联类用实线表示。


聚合关系，拜师一种弱拥有关系，A对象可以包含B对象，但B对象不是A对象的一部分。用空心菱形和实线箭头来表示。

合成关系，是一种强拥有关系，提心了严格不部分和整体的关系，部分和整体的生命周期一样。用实心菱形和实线箭头来表示。

依赖关系，方法需要入参。用虚线箭头表示。



策略模式:定义了算法家族,分别封装。让他们之间可以互相替换，此模式让算法变化，不会影响到使用算法的客户。


面向对象的编程，并不是类越多越好，类的划分是为了封装，但分类的基础是抽象，具有相同属性和功能的对象的集合才是类。

策略模式是一种定义一系列算法的放大，从概念上来看，所有的额这些算法完成的都是相同的工作，但实现不同，他可以以相同的方式调用所有的算法，减少各种算法类与使用算法类之间的耦合。

策略模式的strategy类层次为context定义了一系列可供重用的算法或行为。继承有助于吸取出这些算法的公共功能。

策略模式优点是简化了单元测试，每个算法都要自己的类，可以通过自己的接口单独测试。


当不同的行为堆砌在一个类中时，就很难避免使用条件语句来选择合适的行为，将这些行为封装在一个个独立的strategy类中，就可以在使用这些行为的类中消除条件语句。

只要在分析过程中听到需要在不同时间应用不同的业务规则时，就可以考虑使用策略模式处理这种变化的可能性。


单一职责原则:就一个类而言,应该仅有一个引起它变化的原因。

如果一个类承担的职责过多，就等于把职责耦合，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力，会导致脆弱的设计以及意想不到的破坏。

软件设计真正要做的许多内容，就是发现职责并把那些职责互相分离。

判断是否应该分离一个类来，就是如果你能想到多于一个动机去改变一个类，那么就值得分离。

开放-封闭原则

对于拓展开放，对于更改封闭。

当变化发生时，我们就创建抽象来隔离以后发生同类的变化。但是开发人员应该仅对程序中呈现出频繁比那话的那些部分抽象，然而，对于应用程序中的每个部分都刻意抽象并不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。

依赖-倒转原则
抽象不应该依赖细节，细节应该依赖于抽象。针对接口编程，而不是对实现编程。

#里氏代换原则

子类必须可以替换掉他们的父类。


正是由于子类型的可替换性才使得父类类型的模块在无需修改的情况下可以拓展。

依赖倒转可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，那就是面向对象的设计。


 装饰模式：
 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。

 需要把所需的功能按照正确的顺序串联起来进行控制。

装饰模式是为已有功能动态添加更多功能的一种方式。当系统需要新功能的时候，向旧的类中增加新的代码。这些新加的代码通常装饰了原有类的核心职责或主要行为。