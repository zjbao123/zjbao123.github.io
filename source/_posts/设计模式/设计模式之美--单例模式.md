---
title: 设计模式之美--单例模式
date: 2020-02-15 22:49:22
tags:
- 心法
categories: 设计模式
---


### 动机

在某一些程序中，只有一个实例非常重要。

* 处理资源访问冲突。
  >例如，我们需要打印东西，只有一台打印机，每次只能有一个打印任务。

* 表示全局唯一的类

<!-- more -->

### 定义

单例模式是对象创建型的一种。它确保一个类只有一个实例，而且自行实例化，并向整个系统提供这个实例。这个类可以保证没有其他实例被创建，而且他可以提供一个访问的方法。

单例模式三个要点：

1. 一个类只能有一个实例；
2. 他必须自行创建这个实例；
3. 他必须自行向整个系统提供这个实例；

### 单例的实现
单例有下面几种经典的实现方式。

#### 饿汉式
饿汉式，是在类加载的期间，就已经将instance静态实例初始化好了，所以，instance实例，的创建是现成安全的，不过，这样的实现方式不支持延迟加载实例。

#### 懒汉式
懒汉式将方法增加同步锁，相对饿汉式的优势就是这种实现方式会导致频繁加锁、释放锁，以及并发度低等问题，频繁调用会导致性能瓶颈。

#### 双重检测
双重检测是一种既支持延迟加载，又支持高并发的单例实现方式，在创建instance的地方加锁。只要instance被创建之后，再调用getInstance()函数都不会进入到加锁逻辑中。所以，这种实现方式解决了懒汉式并发度低的问题。

#### 静态内部类
利用Java静态内部类来实现单例，这种实现方法，既支持延迟加载，也支持高并发，实现起来比双重检测简单。

#### 枚举
最简单的实现方式，基于枚举类型实现，这种实现方式通过Java枚举类型本身的特性，保证了实例创建的线程安全性和实例的唯一性。



### 存在的问题
尽管单例是一个很常用的设计模式，但是有些人称之为`反模式`。那它到底存在哪些问题呢？

1. 单例对OOP特性的支持不友好
>单例的使用方式违背了基于接口而非实现的设计原则，也就违背了广义上理解OOP的抽象特性。对不同需求的变化，需要修改所有用到的地方，改动影响面比较大。除此之外，对继承和多态也不友好，损失了拓展性。

2. 单例会隐藏类之间的依赖关系
>单例类不需要显示创建、不需要依赖参数传递，在函数中可以直接历来，这种调用关系就比较复杂。我们需要查看每个函数的实现，才知道有没有依赖这个单例类。可以使用依赖注入的方式来解决。

3. 单例对代码的扩展性不友好
>单例类只能有一个实例。如果某天，我们需要在代码中创建两个实例，就需要比较大的改动。比如在系统设计的初期，系统中只应有一个数据库连接池，随着系统中一些慢查询语句的产生，导致对数据库连接长时间占用，因此需要单独隔离出一个数据库连接池，来避免影响执行效率。

4. 单例对代码的可测试性不友好
>如果单例类依赖比较重的外部资源，我们在写单元测试的时候，希望可以通过`mock`（构造虚拟对象来以便测试）的方法替换掉，但是单例这种模式，就导致无法替换。

5. 单例不支持有参数的构造函数
>比如我们创建一个连接池的单例对象，我们没办法通过参数来指定连接池的大小。解决方案见代码（IDGeneratorWithParams）。


### 替换解决方案





