{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/README.md","path":"README.md","modified":1,"renderable":0},{"_id":"source/baidu_verify_5aAdmwEHhk.html","path":"baidu_verify_5aAdmwEHhk.html","modified":1,"renderable":0},{"_id":"source/baidu_verify_Oe1Kf7es1V.html","path":"baidu_verify_Oe1Kf7es1V.html","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"ed5d4ae15230b31e87bf3b10395e8e2c0aeca8e8","modified":1567696050328},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1553265876743},{"_id":"source/README.md","hash":"f0c7a5074f949219dee04bb08a0fdf1523150946","modified":1553265876718},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1553265876744},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1553265876744},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1553265876744},{"_id":"source/baidu_verify_5aAdmwEHhk.html","hash":"d6316979071d05bfb4e6fea5ae61ee91dbb35753","modified":1553265876742},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1553265876744},{"_id":"source/baidu_verify_Oe1Kf7es1V.html","hash":"2d880fca8d9f2803d9c5318f874f461e41d1c56c","modified":1553265876742},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1553265876744},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1553265876745},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1553265876745},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1553265876744},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1553265876745},{"_id":"themes/next/README.cn.md","hash":"58ffe752bc4b7f0069fcd6304bbc2d5ff7b80f89","modified":1553265876745},{"_id":"themes/next/README.md","hash":"aa2fb15ef016074b10755323c99025df506d5ca3","modified":1553265876746},{"_id":"themes/next/bower.json","hash":"6d6ae7531cf3fedc97c58cdad664f5793eb3cc88","modified":1553265876746},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1553265876746},{"_id":"themes/next/_config.yml","hash":"39d7b4d9960e98ccdd87b4044c0e2b57be56d694","modified":1567955574835},{"_id":"themes/next/package.json","hash":"93a74dbc0fe3a1208a02e9cec3c15c2375339cc1","modified":1553265876761},{"_id":"source/_posts/.DS_Store","hash":"d6201b4207f4363a6083305a05a95420617e01ee","modified":1580913303556},{"_id":"source/about/index.md","hash":"d8ae148b8ce40bf3d5213d106570d6d99798f7f9","modified":1553265876742},{"_id":"source/categories/index.md","hash":"76e70f7f25c7f4914c8f0ce8efaf3b019f4634da","modified":1553265876743},{"_id":"source/guestbook/index.md","hash":"8ff7f2c49f7bc6ab809e8ff56a6384e90bbabbef","modified":1553265876743},{"_id":"source/tags/index.md","hash":"2eb36842c1c7c690bfd809dd17509ed245af0f0c","modified":1553265876743},{"_id":"source/notes/index.md","hash":"3593b2d3eed56bca23ee733c7352e993ea43dc2e","modified":1568724462257},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1553265876746},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1553265876747},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1553265876747},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1553265876747},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1553265876747},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1553265876747},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1553265876747},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1553265876747},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1553265876747},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1553265876748},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1553265876748},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1553265876748},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1553265876748},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1553265876748},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1553265876748},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1553265876749},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1553265876749},{"_id":"themes/next/layout/.DS_Store","hash":"9fbe164aabbb36f72825a1eba30a3da4c78c5a90","modified":1557331256786},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1553265876760},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1553265876760},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1553265876761},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1553265876761},{"_id":"themes/next/scripts/merge-configs.js","hash":"cb617ddf692f56e6b6129564d52e302f50b28243","modified":1553265876761},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1553265876761},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1553265876760},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1553265876760},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1553265876762},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1553265876822},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1553265876822},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1553265876822},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553265876781},{"_id":"source/_posts/C#/网络时间的获取与同步.md","hash":"dcef62d14aba6730c3141565cb492f74689c0bf4","modified":1553265876719},{"_id":"source/_posts/C#/opc开发小结.md","hash":"ff7809ce94a3416fde2d531c2755dff4237d9139","modified":1553265876719},{"_id":"source/_posts/C++/C++ API设计.md","hash":"ac5558291607ca073cab6f1bba02d179480bf0dd","modified":1553265876719},{"_id":"source/_posts/C++/C++陷阱.md","hash":"8aa784af3deb358633d4463c519c7ba01b7014b1","modified":1553265876719},{"_id":"source/_posts/WEB交互/HTTP协议入门.md","hash":"4903b35d4d302c6518f923424c19fabe5f6fef87","modified":1553265876719},{"_id":"source/_posts/WEB交互/互联网协议入门(2).md","hash":"459b7e4c4f230162b93fe11bb8c9f73751250297","modified":1553265876720},{"_id":"source/_posts/WEB交互/互联网协议入门(1).md","hash":"25d8e07e1d90c29905a90e5aa2e731ae0d5d9c1c","modified":1553265876720},{"_id":"source/_posts/WEB交互/网络是如何连接的(1).md","hash":"640e9569e9fe4517a497000d65d08014fde2543a","modified":1553265876720},{"_id":"source/_posts/javaweb/javaweb总结(一)基础概念.md","hash":"7fb44f994d46df7d18a0e41a558c8bb7ebe8e89a","modified":1553265876720},{"_id":"source/_posts/java学习/IOC.md","hash":"a871fdabeec40038a8acd7c4f35a510f980f1a99","modified":1553265876720},{"_id":"source/_posts/java学习/IoC Service Provider.md","hash":"f555c97ebfed059563796431a6a779b33d84bf4d","modified":1553265876721},{"_id":"source/_posts/java学习/Java反射机制.md","hash":"b92591f083d47f2819316553a3558215b71bc197","modified":1553265876721},{"_id":"source/_posts/java学习/String、StringBuffer、StringBuilder的区别.md","hash":"f2bbb36a86f272ab31ca32e505d8ec2d11cfc36e","modified":1553265876721},{"_id":"source/_posts/java学习/java的理解.md","hash":"32b512fa680ab7150f30d50e8eb91153b02e7eb7","modified":1553265876721},{"_id":"source/_posts/java学习/基础知识点杂记.md","hash":"570f5644b4ce818c530c70db81730ebe86ff1592","modified":1553265876721},{"_id":"source/_posts/java学习/java学习总结（一）Java基础.md","hash":"9ba36a6e597df58fb68ff8b038a5d8f30e7da97c","modified":1556984764285},{"_id":"source/_posts/java学习/多线程.md","hash":"d9776d7456be6c84d0f68d55c2ed7c6212ea5385","modified":1553265876721},{"_id":"source/_posts/java学习/容器如何实现线程安全.md","hash":"f15451bfa7dc12c90e5e001175ef964cd40b00fb","modified":1553265876722},{"_id":"source/_posts/java学习/引用的类型.md","hash":"72f27d84bcac2780d79b2518ab31b33a7712dcdf","modified":1553265876722},{"_id":"source/_posts/mysql/Mysql分析-show PROCESSLIST.md","hash":"3c1d34fb0085e70eaf6103b30de790b575497a4f","modified":1553265876722},{"_id":"source/_posts/mysql/SQL语言的数据查询.md","hash":"ec40067c1214307a17ad6dd41649c94b9d0e21ab","modified":1553265876722},{"_id":"source/_posts/mysql/Mysql数据导出至文件.md","hash":"b3c039e4b298d6150a2320b3329452d5bb9dcf9b","modified":1553265876722},{"_id":"source/_posts/mysql/.DS_Store","hash":"1bbead29147c2a652dafedfff1255ae4baffbda2","modified":1557329537818},{"_id":"source/_posts/mysql/mysql上遇到的坑.md","hash":"e2fe06e0fed78b247f72a4e7c5e2f23be5c0b3df","modified":1553265876723},{"_id":"source/_posts/mysql/mysql学习小结-范式.md","hash":"31ff3b0a9b418bd68335c747cf6b7dfb2efcaeaa","modified":1553265876723},{"_id":"source/_posts/mysql/mysql存储过程异常处理.md","hash":"13fb9d6dfa87cd2bb294d9948b477aa0b2cbf8f3","modified":1553265876723},{"_id":"source/_posts/java学习/final、finally、 finalize 有何不同.md","hash":"0e0bce7344bb8ac4e0275b0d8b5917e3bdea6628","modified":1554733698128},{"_id":"source/_posts/mysql/一条SQL查询是如何执行的.md","hash":"096ed4b4413f4ff14a63b91b09bca5f39c09c38f","modified":1554084813555},{"_id":"source/_posts/mysql/存储过程学习小结.md","hash":"6dc55b20b925702ec2d7fb7ff2a108e8866767c1","modified":1553265876727},{"_id":"source/_posts/mysql/数据库原理.md","hash":"f87bee7ec86d8f08dd816beac914f8c438783934","modified":1553265876728},{"_id":"source/_posts/python/Python模块分发.md","hash":"c7afe19c9a3895b4fa208b35c7247637bf994d8b","modified":1553265876728},{"_id":"source/_posts/python/python哲学之道.md","hash":"dc6c822cfecfd442cd1cd5fa8caba80f3f96bf59","modified":1553265876728},{"_id":"source/_posts/mysql/数据库杂记.md","hash":"2b3c1adcb82109384baa796f0a6eb2986a2c10e2","modified":1553265876728},{"_id":"source/_posts/python/python大闯关(5-6).md","hash":"97faa698fa1138dfc008583a980a23cc662dd2cf","modified":1553265876729},{"_id":"source/_posts/python/python大闯关(0-4).md","hash":"c923c0f2b4bf4ed2d5dfe8f6f3a17d6dccc7b611","modified":1553265876728},{"_id":"source/_posts/python/python爬虫入门(1).md","hash":"5821b02f87746251d4a9f13c0325d432f31bfc7b","modified":1553265876729},{"_id":"source/_posts/python/python爬虫入门(2).md","hash":"1ff30ff99b20fb6712e80b0cdc6f9e7376ec92ee","modified":1553265876729},{"_id":"source/_posts/python/python爬虫入门(3).md","hash":"5c79e3aa8a4fb22542365e3441a6aca87bacece0","modified":1553265876729},{"_id":"source/_posts/python/【python】random模块.md","hash":"f9f191a5f4fb6c5e23ba15e8b0ef5faf75f8639c","modified":1553265876729},{"_id":"source/_posts/python/【python】用python自动发微博.md","hash":"b1545398cebe5ee95d6134c9ec3e040f18d0590f","modified":1553265876729},{"_id":"source/_posts/python/初探Python(3)高级特性.md","hash":"1a51726910ba2775ee5fe8ae7ea726d2bb6b8378","modified":1553265876730},{"_id":"source/_posts/python/初探python(1)基础知识.md","hash":"3732da7753eb61b51209ebcb0daaf78a77748d5d","modified":1553265876730},{"_id":"source/_posts/python/初探python(10)进程与线程.md","hash":"143f4be5a838c9625008222d3f0ee4186cb60ead","modified":1553265876730},{"_id":"source/_posts/python/初探python(11)常用的内建模块.md","hash":"a016bee5d2477f2721a64cec329fa0e7625a73ad","modified":1553265876730},{"_id":"source/_posts/python/初探python(12)web开发.md","hash":"ce163accb36094774e1973157a060aa6054e69a8","modified":1553265876731},{"_id":"source/_posts/python/初探python(2)函数.md","hash":"f9ec597448e94d49e1a49b80e0c0353b646ef578","modified":1553265876731},{"_id":"source/_posts/python/初探python(5)模块.md","hash":"4b3825842c8d010ce9ea5dc682cd61bd69d1d6df","modified":1553265876731},{"_id":"source/_posts/python/初探python(4)函数式编程.md","hash":"60b70d25e0544cc4efafbc7f1f5fa4dcdf7a7c6d","modified":1553265876731},{"_id":"source/_posts/python/初探python(6)面向对象编程.md","hash":"fec964d1ddc02480a213ceee54eb094d11291a38","modified":1553265876731},{"_id":"source/_posts/python/初探python(7)面向对象高级编程.md","hash":"ce891d27eae4d47b3ad5439eabb1d5f0baaa1b11","modified":1553265876731},{"_id":"source/_posts/python/初探python(9)IO编程.md","hash":"39362fc578119183e295a3ca952b1c90f2b57c85","modified":1553265876732},{"_id":"source/_posts/python/初探python(8)错误、调试与测试.md","hash":"9d994dd2324b487838aa4c7d7f8f45eb6b3c3325","modified":1553265876732},{"_id":"source/_posts/python/数据库杂谈.md","hash":"c9e56c96bf54a30c022b1012ca4ab642671ab40f","modified":1553265876732},{"_id":"source/_posts/todo/.DS_Store","hash":"24bfefe68d79dc4817789d3d10785441e60db683","modified":1557329634085},{"_id":"source/_posts/业务知识总结/业务报表学习1.md","hash":"d0ba01606818d6ba1e0c8b58495575694e9e551e","modified":1553265876736},{"_id":"source/_posts/todo/计算机科学课.md","hash":"a9d2162b06e107b7c4c592a91acb8c8d7e80c564","modified":1564154694917},{"_id":"source/_posts/todo/项目管理实战.md","hash":"68d8568a629d4715536768a1fdfce98c8d205ef1","modified":1556984668320},{"_id":"source/_posts/业务知识总结/沪港通,深港通总结.md","hash":"cc0b66792fa1aacdbef38433b730f68541c57a7d","modified":1553265876736},{"_id":"source/_posts/业务知识总结/股票命名规则总结.md","hash":"75f18cb49cd107727fdaf2b9c4cd6a25dab5d92b","modified":1553265876736},{"_id":"source/_posts/前端相关学习/bootstrap学习小结.md","hash":"ba045e73b3948c10da16de1a16ebc8b7a4f37de6","modified":1553265876736},{"_id":"source/_posts/博客相关/hello blog.md","hash":"84421afd7765ae6ffa9ca284c26bfb459da24677","modified":1553265876737},{"_id":"source/_posts/博客相关/优化你的 nexT.md","hash":"6d5f7134bf7015e67c917fd6d865ee1c08206203","modified":1553265876737},{"_id":"source/_posts/博客相关/同步博客到coding.md","hash":"2d0c04e253d6ef3b63116103cbb233e3ac066a4f","modified":1553265876737},{"_id":"source/_posts/摘录/TED-雪莉·桑德伯格哈佛14毕业典礼演讲.md","hash":"6b6bd09b4ace7f1bf7433a035f383b1e0168ac99","modified":1553265876738},{"_id":"source/_posts/摘录/【TED】为掌握而学习而不是分数.md","hash":"13e90a295340c43c76346e212f95013bef7ee8fc","modified":1553265876738},{"_id":"source/_posts/摘录/刘备为什么三顾茅庐.md","hash":"342cb397465265607c91138d20dacff324a21a95","modified":1553265876738},{"_id":"source/_posts/摘录/历史上的经济泡沫.md","hash":"caa05196549d1437402a9116bb6ec2c035967820","modified":1581089518713},{"_id":"source/_posts/学做操盘手/.DS_Store","hash":"633dfae2f602e698c9590b3e68dbe11987e720eb","modified":1567697835917},{"_id":"source/_posts/摘录/提问的智慧.md","hash":"f40be661c7c084f44d4e75155e840e74a1e30d5d","modified":1553265876738},{"_id":"source/_posts/摘录/我们培养了很多高学历的野蛮人.md","hash":"87febdfc738175afef30794513aad06a4e4e36ba","modified":1553265876738},{"_id":"source/_posts/摘录/知乎live分享——我的读书经验.md","hash":"43f1537e91d9b4e780ae02a7dd5222505056ef0d","modified":1553265876738},{"_id":"source/_posts/业务知识总结/技术管理.md","hash":"1379f2b3da5fbb568581f86be11e563e035a75ff","modified":1553533904188},{"_id":"source/_posts/学做操盘手/K线的基础知识.md","hash":"ed1b22ea5120b73d7a82b83ca2b1d0d2a82f5c51","modified":1567956260626},{"_id":"source/_posts/数字货币/HB10是啥玩意.md","hash":"a6c60f121da527157e88cb0ec5a8caacd6c63aa4","modified":1553265876739},{"_id":"source/_posts/数字货币/搬砖进阶.md","hash":"08de620eb9ca24c036d26794115e04efae2304de","modified":1553265876739},{"_id":"source/_posts/架构学习/何为框架.md","hash":"9a86dca2cd35391a14b0935a20b61310c7579125","modified":1553265876739},{"_id":"source/_posts/每日计划/一年书单.md","hash":"939274502315d697043f287194cff7aa1ef10e5e","modified":1553265876739},{"_id":"source/_posts/每日计划/每日计划.md","hash":"4210cdc564b33798a2ca51cdda0522499afa9139","modified":1553265876739},{"_id":"source/_posts/架构学习/消息队列.md","hash":"4bfe0154c26221b7b874313097bbf2a6f81b6a67","modified":1571675501927},{"_id":"source/_posts/架构学习/.DS_Store","hash":"c300f3086379fe7e144833d6b2a21ff0fbb3a8e1","modified":1580913303556},{"_id":"source/_posts/设计模式/设计模式之实战.md","hash":"3d4214eff90cc67d13feb7b95aab4ca6e684b1a9","modified":1580916727870},{"_id":"source/_posts/架构学习/RabbitMQ的高可用性.md","hash":"136411e97db7a392a74eca0ed0d96038a26b71d2","modified":1571675661612},{"_id":"source/_posts/设计模式/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1580916479214},{"_id":"source/_posts/设计模式/设计模式之美--面向对象.md","hash":"aa0192ef65d33087bd2953999c73ed1dc356999e","modified":1580915770670},{"_id":"source/_posts/设计模式/设计模式之设计模式原则.md","hash":"8969a3712a76b951e92ac4f8e7bb00cc0228d86c","modified":1581002141444},{"_id":"source/_posts/通向自由之路/通向自由之路(1)起步篇.md","hash":"5dc48fdb94f6ef95592466f49b4402d471688628","modified":1553265876739},{"_id":"source/_posts/通向自由之路/通向自由之路(2)资本篇.md","hash":"01e4b33f9ef0061549ba47db023eb453d2ca5d34","modified":1553265876740},{"_id":"source/_posts/通向自由之路/通向自由之路(3)落后篇.md","hash":"5897e828bb578ce5be4b689059b95a48095b9f32","modified":1553265876740},{"_id":"source/_posts/设计模式/设计模式之设计原则.md","hash":"fb374dd4c96c232deb07ccd6a38b056dc3964145","modified":1580996468169},{"_id":"source/_posts/设计模式/设计模式之美--抽象类与接口.md","hash":"8afc86ed5d64541a518b02a2d69fb0de8f16e736","modified":1580913741973},{"_id":"source/_posts/通向自由之路/通向自由之路(6)元认知能力提高篇.md","hash":"7a52c0d5f42da24c6cb4ab3e38bcb26dc128b1de","modified":1553265876740},{"_id":"source/_posts/通向自由之路/通向自由之路(4)多维竞争篇.md","hash":"863df0982c4668cfb228d1258d809c32fb2e073e","modified":1553265876740},{"_id":"source/_posts/通向自由之路/通向自由之路(5)元认知能力篇.md","hash":"90d4f4fb2901477d2dfb439cdcd19c19aef9a19b","modified":1553265876740},{"_id":"source/_posts/通向自由之路/通向自由之路(7)钥匙篇.md","hash":"f4ec79ec42e0f23501f8776affabd7e718a6ccf2","modified":1553265876741},{"_id":"source/_posts/通向自由之路/通向自由之路(8)所谓“坚持”.md","hash":"93d25f7f0f501eb527bfea59ac1916370add5249","modified":1553265876741},{"_id":"source/_posts/通用杂货/buying_Amercia.md","hash":"4e32d53565f873d119454fcd3a39614138a312e8","modified":1553265876741},{"_id":"source/_posts/通用杂货/手动下载github Desktop.md","hash":"76acdb9dc953bc6fb5807d04b42c5e37ade8969e","modified":1553265876741},{"_id":"source/_posts/通用杂货/排序性能比较.md","hash":"05a4fc5ba0ec31eb441142f5a24122e7c8c157c6","modified":1553265876741},{"_id":"source/_posts/通用杂货/敏捷开发.md","hash":"d2e9af7e8933a19a0bcb9467d167241a183d048c","modified":1553265876741},{"_id":"source/_posts/通用杂货/正则表达式.md","hash":"4b794ce189458172883aa0821bffcdc0a44801d2","modified":1553265876742},{"_id":"source/_posts/通用杂货/聪明的投资者.md","hash":"8cb5ef4dba46bfa1889a9f6be1717b66fa1edb59","modified":1553265876742},{"_id":"source/_posts/随记/神TM矛盾纠结体.md","hash":"5b371a62c50eec06e060ebb4cf140b7d62d1fd15","modified":1553265876742},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1553265876749},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1553265876749},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1553265876749},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1553265876750},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1553265876750},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1553265876750},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9efc455894921a66bbc074055d3b39c8a34a48a4","modified":1553265876750},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1553265876750},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1553265876753},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1553265876753},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1553265876754},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1553265876750},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1553265876751},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1553265876751},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1553265876751},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1553265876751},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1553265876751},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1553265876752},{"_id":"themes/next/layout/_third-party/.DS_Store","hash":"f14bcbaeddcb98cd2fb1df7b1cda923b5504b10e","modified":1557331256787},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1553265876758},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1553265876758},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1553265876758},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1553265876758},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1553265876758},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1553265876758},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1553265876758},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1553265876762},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1553265876762},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1553265876762},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1553265876763},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1553265876763},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1553265876763},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1553265876763},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1553265876763},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1553265876763},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1553265876781},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1553265876782},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1553265876781},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1553265876782},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1553265876783},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1553265876783},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1553265876783},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1553265876784},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1553265876784},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1553265876784},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1553265876784},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1553265876784},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1553265876785},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1553265876785},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1553265876784},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1553265876785},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1553265876785},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1553265876785},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1553265876785},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553265876753},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553265876753},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553265876775},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553265876775},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553265876776},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553265876780},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1553265876781},{"_id":"themes/next/source/images/avatar.jpg","hash":"67bbf5c9d5fc5cb215c1632567f81fa27f2a63e2","modified":1553265876783},{"_id":"source/_posts/前端相关学习/js/JavaScript学习(3).md","hash":"ee7f8830dbeb6062f7c21caea12538bf2cdaf091","modified":1553265876736},{"_id":"source/_posts/前端相关学习/js/javascript学习(1).md","hash":"546162fbe4b44455095fbe6decf8943a2e53f66d","modified":1553265876737},{"_id":"source/_posts/前端相关学习/js/javascript学习(2).md","hash":"5c87f6edc729b746b3e7991e5839bdbc02f0f27b","modified":1553265876737},{"_id":"source/_posts/前端相关学习/js/javascript学习(4)函数.md","hash":"501c3b5178c809d17d71955ce9384e5007ee7114","modified":1553265876737},{"_id":"source/_posts/学做操盘手/K线的基础知识/.DS_Store","hash":"4c9933f56ec9586736e0bfe736afcef4e54172a9","modified":1557329654863},{"_id":"source/_posts/学做操盘手/K线的基础知识/葛南维八大买卖法.jpeg","hash":"a8ef67a3a7cd5dfa5c633cc6a66d6ca2722d124a","modified":1557329397435},{"_id":"source/_posts/架构学习/RabbitMQ的高可用性/RabbitMQ普通集群.png","hash":"cb2fbaeb6a209bf5a2dce2f729d61c645c730e8a","modified":1571674385251},{"_id":"source/_posts/架构学习/消息队列/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1571675395950},{"_id":"source/_posts/架构学习/消息队列/system.png","hash":"3d01de1a0436022ec847bf4143bc74f31f340c46","modified":1570459916170},{"_id":"source/_posts/架构学习/消息队列/systemAfter.png","hash":"89cbf489aa9013d4165712d5c609cd8e178d4cc8","modified":1570459944752},{"_id":"source/_posts/架构学习/消息队列/systemTiming.png","hash":"3e51d3ddb1119c2c8fecd9ae4ced251ad354d7d5","modified":1570459928421},{"_id":"source/_posts/架构学习/消息队列/systemTimingAfter.png","hash":"591546037fe47823352b000b7a263b15cfc55536","modified":1570460025215},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1553265876753},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1553265876753},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1553265876753},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1553265876751},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1553265876751},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1553265876752},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1553265876752},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1553265876752},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1553265876752},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1553265876752},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1553265876752},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1553265876752},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1553265876754},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1553265876754},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1553265876754},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1553265876754},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1553265876754},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1553265876755},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1553265876755},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1553265876755},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1553265876755},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1553265876755},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1553265876756},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1553265876756},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1553265876756},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1553265876756},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1553265876757},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1553265876757},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1553265876757},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1553265876756},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1553265876757},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1553265876757},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1553265876758},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"6547225f1dc941f45aef502171780b1921d89308","modified":1567954404743},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1553265876759},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1553265876760},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1553265876760},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1553265876759},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1553265876775},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1553265876775},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1553265876775},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1553265876776},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1553265876780},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1553265876780},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1553265876781},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1553265876781},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1553265876786},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1553265876786},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1553265876786},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1553265876786},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1553265876786},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1553265876786},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1553265876787},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1553265876786},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1553265876787},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1553265876787},{"_id":"themes/next/source/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1553265876787},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1553265876793},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1553265876791},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1553265876793},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1553265876798},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1553265876798},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1553265876799},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1553265876798},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1553265876798},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1553265876800},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1553265876799},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1553265876800},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1553265876800},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1553265876810},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1553265876811},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1553265876812},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1553265876812},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1553265876812},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1553265876812},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1553265876812},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1553265876813},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1553265876813},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1553265876813},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1553265876816},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1553265876816},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1553265876816},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1553265876813},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1553265876813},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1553265876813},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1553265876814},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1553265876814},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1553265876814},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1553265876814},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1553265876814},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1553265876814},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1553265876814},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1553265876815},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1553265876815},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1553265876815},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1553265876815},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1553265876819},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1553265876819},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1553265876821},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1553265876821},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1553265876821},{"_id":"source/_posts/java学习/Java的锁事/锁.png","hash":"fb7c8d594094df4980e089a00f00dc1e79a72067","modified":1554084813554},{"_id":"source/_posts/学做操盘手/K线的基础知识/整个二浪.png","hash":"f09ec0784984ca43b635985a486db4a73d06903a","modified":1567956186390},{"_id":"source/_posts/架构学习/RabbitMQ的高可用性/RabbitMQ镜像模式.png","hash":"3bb2f1c5cd57c2ec67d1d52b974286eeea6c53c4","modified":1571674407263},{"_id":"source/_posts/架构学习/RabbitMQ的高可用性/Kafka.png","hash":"4d46fb62e13094a5a42cb88c9a36d1cb09e5ed1f","modified":1571674434714},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1553265876811},{"_id":"source/_posts/学做操盘手/K线的基础知识/波浪.png","hash":"0c94b02d38c6307da015b562a0681e67c308c2dc","modified":1567956122250},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1553265876759},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1553265876759},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1553265876764},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1553265876764},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1553265876764},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1553265876764},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1553265876764},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1553265876767},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1553265876771},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1553265876774},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1553265876774},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1553265876774},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1553265876774},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1553265876774},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1553265876774},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1553265876775},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1553265876776},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1553265876776},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1553265876776},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1553265876776},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1553265876777},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1553265876777},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1553265876777},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1553265876777},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1553265876778},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1553265876778},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"02fb8fa6b6c252b6bed469539cd057716606a787","modified":1553265876778},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1553265876778},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1553265876778},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1553265876779},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1553265876779},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1553265876780},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1553265876779},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"bcf52192942c0afc410c74a0fb458e7936ddc3d5","modified":1553265876780},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1553265876780},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1553265876787},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1553265876791},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1553265876794},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1553265876790},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1553265876794},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1553265876795},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1553265876794},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1553265876794},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1553265876795},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1553265876797},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1553265876797},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1553265876799},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1553265876796},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1553265876801},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1553265876800},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1553265876801},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1553265876819},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1553265876819},{"_id":"source/_posts/学做操盘手/K线的基础知识/头肩底.png","hash":"2287dc21f92261c6b3494485c984ab30ae732d12","modified":1567346776685},{"_id":"source/_posts/学做操盘手/K线的基础知识/浪形宽度.png","hash":"d5f004838cf7602b5882996d17a80836eab942b8","modified":1567948897206},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1553265876789},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1553265876799},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1553265876810},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1553265876765},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1553265876764},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1553265876765},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1553265876765},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1553265876765},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1553265876765},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1553265876766},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1553265876766},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1553265876766},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1553265876766},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1553265876765},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1553265876766},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1553265876766},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1553265876766},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1553265876767},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1553265876767},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1553265876767},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1553265876767},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1553265876768},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1553265876768},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1553265876768},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1553265876768},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1553265876768},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1553265876768},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1553265876768},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1553265876769},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1553265876769},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"262debfd4442fa03d9919ceb88b948339df03fb0","modified":1553265876769},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1553265876769},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1553265876771},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1553265876771},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1553265876771},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1553265876771},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1553265876771},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1553265876772},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1553265876772},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1553265876772},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1553265876772},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1553265876769},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1553265876769},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1553265876769},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1553265876770},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1553265876770},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1553265876770},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"77c92a449ce84d558d26d052681f2e0dd77c70c9","modified":1553265876770},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1553265876770},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1553265876770},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1553265876770},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1553265876772},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1553265876772},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1553265876772},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1553265876773},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1553265876773},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1553265876773},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1553265876773},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1553265876773},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1553265876773},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1553265876773},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1553265876778},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1553265876777},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1553265876779},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1553265876788},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1553265876789},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1553265876788},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1553265876789},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1553265876788},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1553265876795},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1553265876790},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1553265876795},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1553265876796},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1553265876796},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1553265876796},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1553265876796},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1553265876802},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1553265876809},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1553265876821},{"_id":"source/_posts/学做操盘手/K线的基础知识/四浪.png","hash":"59740f6a0f841dd79de653473e17eda527f7121d","modified":1567948567891},{"_id":"source/_posts/学做操盘手/K线的基础知识/箱体.png","hash":"46c0075414f92ae6a0e6b32cc47212a35092badc","modified":1567697653012},{"_id":"source/_posts/学做操盘手/K线的基础知识/趋势线.png","hash":"440762f6baa2545a575fa1662243030c5cf476f5","modified":1567696945983},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1553265876809},{"_id":"source/_posts/学做操盘手/K线的基础知识/三角形.png","hash":"b5a64b5a6695a849a55247e72c67ef814eddf667","modified":1567697604840},{"_id":"source/_posts/学做操盘手/K线的基础知识/二浪.png","hash":"3fb19b5853269c91b454ec6f3d4ce87c4c034fd4","modified":1567948551686},{"_id":"source/_posts/学做操盘手/K线的基础知识/Wdi.png","hash":"cfdc54256aad58f2cd0fdb9d03a11f1172e391e6","modified":1567345969022},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1553265876804},{"_id":"source/_posts/学做操盘手/K线的基础知识/底背离.png","hash":"829ef0532e60b1ab4bd99b0f95dafe75de2717cf","modified":1567950287775},{"_id":"source/_posts/学做操盘手/K线的基础知识/MACD.png","hash":"559adb67a2a00e93e3949f3f59298369a9462488","modified":1567949901280},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1553265876819},{"_id":"source/_posts/mysql/一条SQL查询是如何执行的/MySQL逻辑.png","hash":"0399712737ef6427d49e48d5d63dfbd23bf40e4d","modified":1553265876727},{"_id":"source/_posts/学做操盘手/K线的基础知识/KDJ.png","hash":"7aff41db3de48c653f1bb0ed5b6a0d6835402523","modified":1567950924186},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1553265876793},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1553265876807},{"_id":"source/_posts/学做操盘手/K线的基础知识/看大盘.png","hash":"35c95d43a1a67ff5b9c16ffd54d3b3cfc97fc5c7","modified":1567952313548},{"_id":"source/_posts/学做操盘手/K线的基础知识/委买委卖.png","hash":"f7289f12a409be3499ad1554b2f03b59336268c8","modified":1567952092237},{"_id":"source/_posts/学做操盘手/K线的基础知识/个股盘口.png","hash":"b0a66a8dbb468c641192f4e46c5e9272a5b9b5cd","modified":1567951800323},{"_id":"source/_posts/学做操盘手/K线的基础知识/BOLL.png","hash":"632aa0db37ede3513857730a01adf544ece8d99b","modified":1567951249272},{"_id":"source/_posts/学做操盘手/K线的基础知识/MACD背离.png","hash":"7e55098058fa7b8b6987aba39873b0b2d3d15abd","modified":1567950100115},{"_id":"public/about/index.html","hash":"f45d96743313a90b3bec625220bb721b93e14eed","modified":1581089583074},{"_id":"public/categories/index.html","hash":"6163933e7b62c507a88bbdf8439ca71fa285f0c4","modified":1581089583075},{"_id":"public/guestbook/index.html","hash":"c22eb5e8e811e3a0e01034c33fc08fc3e229ac55","modified":1581089583075},{"_id":"public/tags/index.html","hash":"0e65d20003ffe93e08598cf99376ee9ca4483577","modified":1581089583075},{"_id":"public/2008/11/20/通用杂货/聪明的投资者/index.html","hash":"e5f929860d8ac944f354ce4d95526f9b9646b753","modified":1581089583075},{"_id":"public/2008/08/27/java学习/多线程/index.html","hash":"bd8680fe60e0b15c1f372ff52ea7b6b1692e6dd1","modified":1581089583075},{"_id":"public/archives/page/11/index.html","hash":"9e9998484dfb2709ff52d929cfffffe0694f87ea","modified":1581089583075},{"_id":"public/archives/2007/index.html","hash":"7a8e3fb39737a99f0af09d59ef65cd1685103063","modified":1581089583076},{"_id":"public/archives/2007/04/index.html","hash":"96d2584bf9d6a2c19617896e4ab8b89973b6e03c","modified":1581089583076},{"_id":"public/archives/2008/index.html","hash":"cfe5b72b342c71e52010bb6d8316caadb039b0b0","modified":1581089583076},{"_id":"public/archives/2008/05/index.html","hash":"05521c0d0cc47002bbccf1d6096fc9451b6379b4","modified":1581089583076},{"_id":"public/archives/2008/08/index.html","hash":"95956ceb2aa655de2f9f17017156764d8ce1805b","modified":1581089583076},{"_id":"public/archives/2008/11/index.html","hash":"83feb49a10274fcbf7ad540b6ddcecb89769fa6e","modified":1581089583077},{"_id":"public/archives/2016/01/index.html","hash":"b3cce3fda2fdd92599f987054b6c3ed271a9cf69","modified":1581089583077},{"_id":"public/archives/2016/04/index.html","hash":"30b48e0a525e1d511829d0938dbe395b81909672","modified":1581089583077},{"_id":"public/archives/2016/05/index.html","hash":"1136ee1e31f09f264dbfba70cf85ec6d0c2ff302","modified":1581089583077},{"_id":"public/archives/2016/06/index.html","hash":"ae51d9582676a4821abad17cb20b92334eccf1e8","modified":1581089583077},{"_id":"public/archives/2016/07/index.html","hash":"a2813413b37faa6d2b9c7b7d8e3dcfea4cdcd9ea","modified":1581089583077},{"_id":"public/archives/2016/08/index.html","hash":"00878801622ade68b9b8f44a2eccef9061021b65","modified":1581089583077},{"_id":"public/archives/2016/11/index.html","hash":"ee102057278756f24195cad50291a8b42d8e1c11","modified":1581089583077},{"_id":"public/archives/2016/12/index.html","hash":"0b2e31891b8857aff40024769daf00d55009e8e0","modified":1581089583077},{"_id":"public/archives/2017/page/2/index.html","hash":"748bc48e874181118b58c833b1aa65f2e03ed1c3","modified":1581089583077},{"_id":"public/archives/2017/01/index.html","hash":"066a4a4bf8bd49caff7ae9c5c838857db65d7018","modified":1581089583077},{"_id":"public/archives/2017/02/index.html","hash":"f10903d5f1ec9975d9b99e85d42773213ceddb7b","modified":1581089583077},{"_id":"public/archives/2017/04/index.html","hash":"02cc01f340c5c330692a3d01dd4e2f0cc93866f2","modified":1581089583077},{"_id":"public/archives/2017/09/index.html","hash":"bce23e0c8e66382cc8b9db394ee49a124405f573","modified":1581089583077},{"_id":"public/archives/2017/10/index.html","hash":"83bd7d83a1cd92478c208881944d443946423f6a","modified":1581089583077},{"_id":"public/archives/2017/11/index.html","hash":"c589dc40cefa6cbb23a748b230e0bcc6732c768e","modified":1581089583077},{"_id":"public/archives/2017/12/index.html","hash":"fa52bf120e611f326f708e4dbfa99eb1921b84aa","modified":1581089583077},{"_id":"public/archives/2018/page/2/index.html","hash":"fa7e5657d74454bd025de0b662b2f5e9fb01ec15","modified":1581089583077},{"_id":"public/archives/2018/04/index.html","hash":"d6771a621c7962fdd4220d0187d53a223690f772","modified":1581089583078},{"_id":"public/archives/2018/05/index.html","hash":"4c6720d06f4d42d1ae935bb7068265be5e0e9c33","modified":1581089583078},{"_id":"public/archives/2018/06/index.html","hash":"cc8059802247afb89870daf2c967daf1ae69b2ae","modified":1581089583078},{"_id":"public/archives/2018/08/index.html","hash":"7fdd2afeb7c0cfb3fddefb5571b43cb0f024ed26","modified":1581089583078},{"_id":"public/archives/2018/09/index.html","hash":"a629ed6bb72d3f01dddf43f7d6d02d50cf2711ba","modified":1581089583078},{"_id":"public/archives/2018/10/index.html","hash":"9552117872980d073ae5b34d776a97840babab2c","modified":1581089583078},{"_id":"public/archives/2018/11/index.html","hash":"83fa1914b81219a3b0d5ef072869ef3a3045ff76","modified":1581089583078},{"_id":"public/archives/2018/12/index.html","hash":"2014c37891d4db549165b715b42e0b257b460bca","modified":1581089583078},{"_id":"public/archives/2019/03/index.html","hash":"e9076c255408864e83d6955c99337d348bcaa939","modified":1581089583078},{"_id":"public/archives/2019/07/index.html","hash":"33c293fba766eaa9bd8a17b1a3b69dca8aae5887","modified":1581089583078},{"_id":"public/archives/2019/09/index.html","hash":"0ab7af2d24033ec7e0f1a64dd2b2d775ad392143","modified":1581089583078},{"_id":"public/archives/2019/10/index.html","hash":"fa1184df0285c14e983f57ce276191785897d66f","modified":1581089583078},{"_id":"public/archives/2019/11/index.html","hash":"6809268406698624121738f023127afdf8b7aa9e","modified":1581089583078},{"_id":"public/archives/2020/index.html","hash":"2a352961510004eb168c4e4077de9e39c47a8b74","modified":1581089583078},{"_id":"public/archives/2020/02/index.html","hash":"5311a19651b0154b4381a593f93c2707e7afccb5","modified":1581089583078},{"_id":"public/categories/c/index.html","hash":"f331c13565d729b9756d4af9ad452e6a978f7894","modified":1581089583078},{"_id":"public/categories/总结/index.html","hash":"59698192e0a356ebcc95e2c5297bbfb4f4cc6c4c","modified":1581089583079},{"_id":"public/categories/java/index.html","hash":"351335253fd5375081fb0fb06224a6f4595cc853","modified":1581089583079},{"_id":"public/categories/有趣/index.html","hash":"7426f3afc7d78f11b05ce85bab5c210dbd1ba701","modified":1581089583079},{"_id":"public/categories/管理/index.html","hash":"78f05497ebcbea396ee1cd26d5870ccfcff5edf2","modified":1581089583079},{"_id":"public/categories/学习/index.html","hash":"130527e99f861fe329f299f735953db300081f42","modified":1581089583079},{"_id":"public/categories/测试/index.html","hash":"c1d5f08c714b3946181efca5e59f1744c22501b7","modified":1581089583079},{"_id":"public/categories/方法学习/index.html","hash":"8ed083d44255a1d113a58b1776bdacac3d85169c","modified":1581089583079},{"_id":"public/categories/数字货币/index.html","hash":"773e6319595b137172914fcf491e7a66172b87b3","modified":1581089583079},{"_id":"public/categories/计划/index.html","hash":"7e8efadd1758754d7577f8dd731c8e40f35a1976","modified":1581089583079},{"_id":"public/categories/Java/index.html","hash":"ab7c8f0845f59389bc814c8a4abbaa98f5848460","modified":1581089583079},{"_id":"public/categories/设计模式/index.html","hash":"708a22e864b960123e756a4f7ac88a3b8e0dea57","modified":1581089583079},{"_id":"public/categories/杂谈/index.html","hash":"4e54f8718479ba9bdd5746f9783a8d58fdebcda3","modified":1581089583079},{"_id":"public/categories/优化/index.html","hash":"a9dd4a35325276f7dd85d4793fe7d1f98aee2078","modified":1581089583079},{"_id":"public/categories/学做操盘手/index.html","hash":"b5e263772a7f3bfc9d2e18189e3097bc3a0323a1","modified":1581089583079},{"_id":"public/tags/c/index.html","hash":"be060d69c7b49aef967f73079162f4c68d490aa6","modified":1581089583079},{"_id":"public/tags/C/index.html","hash":"513531d43c4ed425ea49fbe7d314d03ad8e4a2c0","modified":1581089583079},{"_id":"public/tags/javaweb/index.html","hash":"a125607f092dbb92ff93f1947074650da20964b3","modified":1581089583079},{"_id":"public/tags/WEB交互/index.html","hash":"03af9dea52740d78e52c2dcdd78ad6be6b055581","modified":1581089583080},{"_id":"public/tags/java/page/2/index.html","hash":"de7c2c2d0b99f9a851ab4c8a938a53a7ebba2015","modified":1581089583080},{"_id":"public/tags/spring/index.html","hash":"7ce985cc77f04c7c3dbbdea4ca8f5d88d3cf31bc","modified":1581089583080},{"_id":"public/tags/mysql/index.html","hash":"0b15392198ae5663bac33355059e577d7c4a7103","modified":1581089583080},{"_id":"public/tags/数据库/index.html","hash":"79d14bd52ba1ef20928c1d30120f42e328ef6ddc","modified":1581089583080},{"_id":"public/tags/存储过程/index.html","hash":"3c0101a3baff0de72d3af0adf68ace1e9bc7eef9","modified":1581089583080},{"_id":"public/tags/MySQL/index.html","hash":"439d1a65a1bb47cae8f9c875431b3f8724755958","modified":1581089583080},{"_id":"public/tags/协议/index.html","hash":"aa04fd4bb72cdf0e4189acf01203aa5434cf6320","modified":1581089583080},{"_id":"public/tags/爬虫/index.html","hash":"4919bf258b759122ace4b48112bf14daeb000975","modified":1581089583080},{"_id":"public/tags/趣玩/index.html","hash":"8ede161fdba5ffceea372598a182e543994a462e","modified":1581089583080},{"_id":"public/tags/python教程/page/2/index.html","hash":"ad2c3e195eaa26632547a02ef0d269e4cb6038bf","modified":1581089583080},{"_id":"public/tags/项目管理/index.html","hash":"92350087d1e240120428cab2c8dca35531959174","modified":1581089583080},{"_id":"public/tags/计算机科学/index.html","hash":"8abdf8776ad30bc845825c71b344b1685db0908e","modified":1581089583080},{"_id":"public/tags/财务报表/index.html","hash":"9602579a359b359daebbedc530bafaf127873c7f","modified":1581089583080},{"_id":"public/tags/金融业务/index.html","hash":"9344d7e2d4b7c76b099a674101c855cfc3fef4a1","modified":1581089583080},{"_id":"public/tags/html/index.html","hash":"a8e6180a213c213a6ccd1265d103de34ae67865d","modified":1581089583080},{"_id":"public/tags/bootstrap/index.html","hash":"ee38a16843c3e8a6af672ecb35e1157e59421d28","modified":1581089583080},{"_id":"public/tags/Hexo/index.html","hash":"7ba25772041de740f304f31a1e56f934eef4611b","modified":1581089583081},{"_id":"public/tags/博客优化/index.html","hash":"4ad77f9053121150b3d1b646f95fefc9cfb670be","modified":1581089583081},{"_id":"public/tags/TED/index.html","hash":"fdc04986a44238143a482278f53f45d641d6f4f8","modified":1581089583081},{"_id":"public/tags/杂谈/index.html","hash":"4263cf6ebf3c2c1771966b055b14c55504bb0196","modified":1581089583081},{"_id":"public/tags/摘录/index.html","hash":"f2c2c40a892c9716f197d14ea1347079ba747266","modified":1581089583081},{"_id":"public/tags/总结/index.html","hash":"e9fb289dc0008b5a3d552ed3f688ca54581a3af8","modified":1581089583081},{"_id":"public/tags/数字货币/index.html","hash":"65c4e4c9c3c917742e198f6ebc61747d04ed4ff3","modified":1581089583081},{"_id":"public/tags/框架/index.html","hash":"cd7f80b78e89cb03cf6307b6c1c27e585d66128d","modified":1581089583081},{"_id":"public/tags/目标/index.html","hash":"e5ffe76908a928a3391fddc962d5062936170613","modified":1581089583081},{"_id":"public/tags/Java进阶/index.html","hash":"ad5c7433a84e9fb03bb361ed8044fd261ef334bd","modified":1581089583081},{"_id":"public/tags/心法/index.html","hash":"6503743ffdae939e206df16d86fb8c313e3d583b","modified":1581089583081},{"_id":"public/tags/github/index.html","hash":"2ba9a80c404835aaa3cc427b4296cca52103a427","modified":1581089583081},{"_id":"public/tags/敏捷开发/index.html","hash":"0b0842d26db699eaade6a1a3331022f245f72376","modified":1581089583081},{"_id":"public/tags/投资/index.html","hash":"2e85c9cac3a1b94acb8a0ae29db7e1cf0f385ff3","modified":1581089583081},{"_id":"public/tags/胡思/index.html","hash":"bbb1cf7818856d3b7fd60c6f0d15517debf3b965","modified":1581089583081},{"_id":"public/tags/串口/index.html","hash":"91a60794e35e36751ba6405127aeb979e8a05743","modified":1581089583081},{"_id":"public/tags/hexo/index.html","hash":"380854a6baf425703cf4638f4e620c368f5fa1f9","modified":1581089583081},{"_id":"public/tags/nexT优化/index.html","hash":"3510d6a327f8ee71c27c2a555f59af3da6049c35","modified":1581089583081},{"_id":"public/tags/读书/index.html","hash":"29c3b2065dc0398783a4e2afb83a3932d8118724","modified":1581089583081},{"_id":"public/tags/K线/index.html","hash":"e20bab785f6a6f578e804f1da9a94b8a293a2b49","modified":1581089583081},{"_id":"public/tags/正则表达式/index.html","hash":"7bd8d3cb2ed14b22f8a39698f6896aabaf5a2da3","modified":1581089583082},{"_id":"public/tags/算法/index.html","hash":"39b783a51a0b2541ec95aae7cfe17f62fd92aa97","modified":1581089583082},{"_id":"public/tags/JavaScript/index.html","hash":"16e6e1561ef6d39a6c6dae7697f68b5314e3c933","modified":1581089583082},{"_id":"public/notes/index.html","hash":"377db586ae8228c583d1c011209a106840ac2f80","modified":1581089583082},{"_id":"public/2020/02/07/摘录/历史上的经济泡沫/index.html","hash":"a5f2cc29c77b7ec6c3bdaa0ff64ae8ceebd311c1","modified":1581089583082},{"_id":"public/2020/02/06/设计模式/设计模式之设计模式原则/index.html","hash":"0bd7bce735e0c2ea760c30a88f1f36ebbd3bfc01","modified":1581089583082},{"_id":"public/2020/02/05/设计模式/设计模式之实战/index.html","hash":"e0b53421ee00b76f084da68682ae5613d6df3471","modified":1581089583082},{"_id":"public/2019/11/23/设计模式/设计模式之美--抽象类与接口/index.html","hash":"8d5b7dff934452381e16ea3a1e305eb5431740d3","modified":1581089583082},{"_id":"public/2020/02/04/设计模式/设计模式之设计原则/index.html","hash":"2c913c3eec6827d5d2f8c2ebffb4f2ff4dc8d782","modified":1581089583082},{"_id":"public/2019/11/20/设计模式/设计模式之美--面向对象/index.html","hash":"b381e0ead93e96acf094e82a90384f3cbf941efb","modified":1581089583082},{"_id":"public/2019/10/22/架构学习/RabbitMQ的高可用性/index.html","hash":"548c4fbec5b3046161d4ff60c339af45a1c93554","modified":1581089583082},{"_id":"public/2019/10/07/架构学习/消息队列/index.html","hash":"23eca45b6b586d4c84524292b9aa81873d9f7792","modified":1581089583082},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/index.html","hash":"1c91af2032739f845e5ac27bf1bdb6c4b059e2bd","modified":1581089583082},{"_id":"public/2019/07/26/todo/计算机科学课/index.html","hash":"4db08a885c104388262ffdad20b75fca36ce58f0","modified":1581089583082},{"_id":"public/2019/03/25/业务知识总结/技术管理/index.html","hash":"b0641acf2a0b8c684b2c7c39f1df3cfba3a0bf63","modified":1581089583082},{"_id":"public/2019/03/14/java学习/容器如何实现线程安全/index.html","hash":"d4a4220ec9cca4b35c5c2b9321c5f913a24558cc","modified":1581089583082},{"_id":"public/2018/12/04/mysql/一条SQL查询是如何执行的/index.html","hash":"b6a304a99d490e692cd934df15dcfa78d6052050","modified":1581089583082},{"_id":"public/2018/11/19/java学习/Java反射机制/index.html","hash":"6bf2c8bfe32662704c3c1ccb95821a886619ad10","modified":1581089583082},{"_id":"public/2018/11/16/java学习/String、StringBuffer、StringBuilder的区别/index.html","hash":"baf8b96bdd78ee6d1fe9eee7f7212515f6efcd80","modified":1581089583083},{"_id":"public/2018/11/15/java学习/引用的类型/index.html","hash":"cd2e28e059e5235f5de62cb3abe2ac11ef43cce2","modified":1581089583083},{"_id":"public/2018/11/12/java学习/final、finally、 finalize 有何不同/index.html","hash":"383d069df0b62e495b88b105c6aa23ae3de8360c","modified":1581089583083},{"_id":"public/2018/11/08/java学习/java的理解/index.html","hash":"f2af2999103dd8c3b87ac43c4325ee3dbd173577","modified":1581089583083},{"_id":"public/2018/11/05/通用杂货/敏捷开发/index.html","hash":"e3b89b818851a1c00f97ef8dcc0ab3d5531aa5b4","modified":1581089583083},{"_id":"public/2018/10/13/通用杂货/buying_Amercia/index.html","hash":"cbc09422aff75604f1ea9453f397c591f4ae83f8","modified":1581089583083},{"_id":"public/2018/09/25/mysql/mysql存储过程异常处理/index.html","hash":"4d3597bbb4fbd1bba5b6b0d8c3e8247d34d6c194","modified":1581089583083},{"_id":"public/2018/08/27/数字货币/搬砖进阶/index.html","hash":"99cdcf312b535ae3223bfd52c619cf4032404c82","modified":1581089583083},{"_id":"public/2018/06/07/数字货币/HB10是啥玩意/index.html","hash":"2ffdd415d5f0de27abc473944c9b6c61718b073d","modified":1581089583083},{"_id":"public/2018/05/12/java学习/IOC/index.html","hash":"7e23f4988027ea8a89770688bb56503ca59b9e7f","modified":1581089583083},{"_id":"public/2018/04/23/C++/C++陷阱/index.html","hash":"84cb29c7b611a87f2da32661d808f90a10d5c6f7","modified":1581089583083},{"_id":"public/2017/12/18/业务知识总结/股票命名规则总结/index.html","hash":"9560f47f46b7c2bde34a19b20403809fd11a8389","modified":1581089583083},{"_id":"public/2017/12/12/mysql/Mysql分析-show PROCESSLIST/index.html","hash":"4983ae2058d03fbe2cb0efaa687694ee9c8465ad","modified":1581089583083},{"_id":"public/2017/12/06/业务知识总结/沪港通,深港通总结/index.html","hash":"b733d09c520abe49aed056ad7c2f5bd8634cfb94","modified":1581089583083},{"_id":"public/2017/12/01/mysql/Mysql数据导出至文件/index.html","hash":"016d3fe86d3fae75dcc88d7f76404d7291c36680","modified":1581089583083},{"_id":"public/2017/11/29/python/python大闯关(5-6)/index.html","hash":"903ed4481d4360b50b1165fbac11b2d23aa7a67e","modified":1581089583083},{"_id":"public/2017/11/28/mysql/mysql上遇到的坑/index.html","hash":"ff309af38b4172b3ee60846b8051852b9b9cc185","modified":1581089583083},{"_id":"public/2017/10/18/博客相关/同步博客到coding/index.html","hash":"c1d2fb4eb692e7e597a41285ee06ad35d66b6b70","modified":1581089583083},{"_id":"public/2017/09/27/摘录/提问的智慧/index.html","hash":"58b1ab203f06ee5f86fa2fd862b0482b7c18c77d","modified":1581089583083},{"_id":"public/2017/04/19/python/Python模块分发/index.html","hash":"41c2fd6052e16d8a4e0d544988ee9f8c4869ef3f","modified":1581089583084},{"_id":"public/2017/02/15/摘录/我们培养了很多高学历的野蛮人/index.html","hash":"e3738f129605e6821d7d6f78b1ef5b99c263ec14","modified":1581089583084},{"_id":"public/2017/02/14/javaweb/javaweb总结(一)基础概念/index.html","hash":"4ef397290960cf536522bbe775429be7bd1185df","modified":1581089583084},{"_id":"public/2017/01/22/mysql/数据库原理/index.html","hash":"58631d9b8654d2084f84f3059f647ae639669ed8","modified":1581089583084},{"_id":"public/2016/12/27/mysql/存储过程学习小结/index.html","hash":"322f634d5b5aa4287221da272f39fbebc901c287","modified":1581089583084},{"_id":"public/2016/12/15/mysql/mysql学习小结-范式/index.html","hash":"30f8189246320aedbdc09456f4be24ff76f79e7b","modified":1581089583084},{"_id":"public/2016/11/29/通用杂货/手动下载github Desktop/index.html","hash":"f0af43ceb76028ac29cc360f6336cf2e149e87cc","modified":1581089583084},{"_id":"public/2016/11/11/通向自由之路/通向自由之路(8)所谓“坚持”/index.html","hash":"5dda58df23ed2e7760fbc683e6dd45691fed8d87","modified":1581089583084},{"_id":"public/2016/11/06/python/初探python(11)常用的内建模块/index.html","hash":"8add067036835876969d01c6268d4b88b1e76030","modified":1581089583084},{"_id":"public/2016/11/06/通向自由之路/通向自由之路(7)钥匙篇/index.html","hash":"c5dc9d1b0faa8f2c0ed9f9725e57978c184a5444","modified":1581089583084},{"_id":"public/2016/11/02/通向自由之路/通向自由之路(6)元认知能力提高篇/index.html","hash":"faa3df5e6227df9755b4893af7836cd4c95be73a","modified":1581089583084},{"_id":"public/2016/10/27/mysql/SQL语言的数据查询/index.html","hash":"3458c2e028fb4da35005def2fb960ecb7345242c","modified":1581089583084},{"_id":"public/2016/10/26/python/数据库杂谈/index.html","hash":"0cc12d5823963c39bff01af41ce0e47b1f7b5220","modified":1581089583084},{"_id":"public/2016/10/25/通用杂货/排序性能比较/index.html","hash":"6ed59f9e7b2eb831b33207446d5071d6b3e8be35","modified":1581089583084},{"_id":"public/2016/10/23/python/【python】用python自动发微博/index.html","hash":"6e11952f79689e983a74f5e46dc444ed47b8fde8","modified":1581089583084},{"_id":"public/2016/10/23/随记/神TM矛盾纠结体/index.html","hash":"7625b7db21f7527592604cfb26cfdbd347f77360","modified":1581089583084},{"_id":"public/2016/10/21/mysql/数据库杂记/index.html","hash":"c72ce80a27471960a903999ee107b138e8ec89ab","modified":1581089583085},{"_id":"public/2016/10/20/python/初探python(10)进程与线程/index.html","hash":"02acd117e2fc551ae673509ac722b38ec9448d0c","modified":1581089583085},{"_id":"public/2016/10/18/python/python大闯关(0-4)/index.html","hash":"e2e874714dec9ca2ea00729ce80d9d2d2b62360e","modified":1581089583085},{"_id":"public/2016/10/17/python/python爬虫入门(3)/index.html","hash":"4b91355cff1e9abcbc651c8c840e76af4be71de5","modified":1581089583085},{"_id":"public/2016/10/16/python/python爬虫入门(2)/index.html","hash":"77a9b61f1817bc07b5d1e0c24ecc899d8b1894b8","modified":1581089583085},{"_id":"public/2016/10/16/python/python爬虫入门(1)/index.html","hash":"88ee82b9500a6754f9b36e785ad52fe3d9d1f5ba","modified":1581089583085},{"_id":"public/2016/10/16/python/【python】random模块/index.html","hash":"83cd3d60149859ad9f49daf9a065ad29e13e0243","modified":1581089583085},{"_id":"public/2016/10/14/每日计划/一年书单/index.html","hash":"f618e3678ca7d9984665c7483eb769861df9698c","modified":1581089583085},{"_id":"public/2016/10/13/python/初探python(9)IO编程/index.html","hash":"81a811c9b16c84bb7bcb69b18eb56d8338673c78","modified":1581089583085},{"_id":"public/2016/10/12/python/初探python(8)错误、调试与测试/index.html","hash":"54bc2b4af3fb4cfc58d67cabee3b20a20669ab22","modified":1581089583085},{"_id":"public/2016/10/10/python/初探python(7)面向对象高级编程/index.html","hash":"3c35c85888cfb44dbdc4ad9d8c134d05b23d4316","modified":1581089583085},{"_id":"public/2016/10/09/通向自由之路/通向自由之路(5)元认知能力篇/index.html","hash":"432f1d51d867b2fa28907e3cdc6949960e0f9e57","modified":1581089583085},{"_id":"public/2016/10/06/python/初探python(6)面向对象编程/index.html","hash":"61d97156d1aaed2d664b92307d2ca5a4c9980001","modified":1581089583085},{"_id":"public/2016/09/29/C++/C++ API设计/index.html","hash":"497babc59331a42a05368ed2e85890f43ce7ad36","modified":1581089583085},{"_id":"public/2016/09/29/摘录/【TED】为掌握而学习而不是分数/index.html","hash":"c8751124b3239927104a70234eba9d9959100fc1","modified":1581089583085},{"_id":"public/2016/09/26/python/初探python(5)模块/index.html","hash":"8b703e97fff35a868afc370cf565293f529bee09","modified":1581089583085},{"_id":"public/2016/09/26/python/初探python(4)函数式编程/index.html","hash":"9ab53ed15751958937bbdc4d790b8721dfea8d95","modified":1581089583085},{"_id":"public/2016/09/25/通向自由之路/通向自由之路(4)多维竞争篇/index.html","hash":"3f74be5bba14766342ed9c199605285ba62c0405","modified":1581089583086},{"_id":"public/2016/09/20/python/初探Python(3)高级特性/index.html","hash":"eaeb8d46a2857bee62b2ab637fed5b0c9318c866","modified":1581089583086},{"_id":"public/2016/09/20/摘录/知乎live分享——我的读书经验/index.html","hash":"4c5684610513db0ab118514785921d500e5732e0","modified":1581089583086},{"_id":"public/2016/09/19/python/初探python(2)函数/index.html","hash":"9d192802ca3c384693ac89c3ecaeb0d369e5a1a9","modified":1581089583086},{"_id":"public/2016/09/19/通向自由之路/通向自由之路(3)落后篇/index.html","hash":"7adbf711cbc6afd4cae5711e92d16511b527ebbb","modified":1581089583086},{"_id":"public/2016/09/17/摘录/TED-雪莉·桑德伯格哈佛14毕业典礼演讲/index.html","hash":"e4c12872d162ec0df18750db5f0ed6697d199486","modified":1581089583086},{"_id":"public/2016/09/16/前端相关学习/js/javascript学习(4)函数/index.html","hash":"22aaba33f005406a3a8ee8f7df79f1bb32012a46","modified":1581089583086},{"_id":"public/2016/09/13/python/初探python(12)web开发/index.html","hash":"754a20b85e0c6b6979e183e8a64d284d74792156","modified":1581089583086},{"_id":"public/2016/09/13/python/初探python(1)基础知识/index.html","hash":"f1726066aaec2a1eac7de35a02412332b4dae570","modified":1581089583086},{"_id":"public/2016/09/12/WEB交互/网络是如何连接的(1)/index.html","hash":"1f14bb19b5a5bf84a5a6a41f190f6690aa8062d9","modified":1581089583086},{"_id":"public/2016/09/12/WEB交互/HTTP协议入门/index.html","hash":"86470cc1eed100bc551e96b679f4741667bf46a4","modified":1581089583086},{"_id":"public/2016/09/10/WEB交互/互联网协议入门(2)/index.html","hash":"a2a3d8d7bad72773d47ede7bb9bf29df26148eba","modified":1581089583087},{"_id":"public/2016/09/06/通向自由之路/通向自由之路(2)资本篇/index.html","hash":"b90b5050a910ecb250bca0a64f60bd000e1e645c","modified":1581089583087},{"_id":"public/2016/08/31/前端相关学习/js/JavaScript学习(3)/index.html","hash":"4a2ffcaaff310c454f9cc0a5fee93853206bb7f1","modified":1581089583087},{"_id":"public/2016/08/30/摘录/刘备为什么三顾茅庐/index.html","hash":"9aaf9b4496279bb89b65cd067d56d543b79966dd","modified":1581089583087},{"_id":"public/2016/08/30/通向自由之路/通向自由之路(1)起步篇/index.html","hash":"856224ebc4195204d7797b753b401ad061465392","modified":1581089583087},{"_id":"public/2016/08/27/WEB交互/互联网协议入门(1)/index.html","hash":"62a80bc0b85d237dfd37a650406fa4d22d775ed9","modified":1581089583087},{"_id":"public/2016/08/24/前端相关学习/js/javascript学习(2)/index.html","hash":"db6193a72f881d1b24957bc6727bb33d37fdc557","modified":1581089583087},{"_id":"public/2016/08/22/前端相关学习/js/javascript学习(1)/index.html","hash":"8b447a15bd6ca6b39a24442e48b5dd71435b09ce","modified":1581089583087},{"_id":"public/2016/07/22/通用杂货/正则表达式/index.html","hash":"8de841fac91f62213c5b221c8046305f95fdd941","modified":1581089583087},{"_id":"public/2016/07/20/前端相关学习/bootstrap学习小结/index.html","hash":"3858901976eeb4977f2d394539c432c043cb1aae","modified":1581089583087},{"_id":"public/2016/06/21/C#/网络时间的获取与同步/index.html","hash":"fee7999f8ea89f65e7f7c52e28d8f630dfe0c1f6","modified":1581089583087},{"_id":"public/2016/05/21/C#/opc开发小结/index.html","hash":"4299f5d723f953ef27058a04bd8f32b849de0e69","modified":1581089583087},{"_id":"public/2016/04/20/python/python哲学之道/index.html","hash":"25a8593e551459817da646529b1ed0ac66f01cf9","modified":1581089583087},{"_id":"public/2016/04/20/todo/项目管理实战/index.html","hash":"de1ac7f260c03d0655631849e38029b55e78199f","modified":1581089583087},{"_id":"public/2016/04/15/每日计划/每日计划/index.html","hash":"553f9f435e4b6d02945b720157fd9d8508764906","modified":1581089583087},{"_id":"public/2016/04/07/博客相关/优化你的 nexT/index.html","hash":"48576d2e53a34fdf109d7c58760889139ec9781c","modified":1581089583088},{"_id":"public/2016/04/05/博客相关/hello blog/index.html","hash":"7362c4e81ce06863252202d6a58a0e2c0fc59ef4","modified":1581089583088},{"_id":"public/2016/01/12/架构学习/何为框架/index.html","hash":"b3a892306cc499f6b0174e906abceb65eab63c2b","modified":1581089583088},{"_id":"public/2008/05/12/java学习/IoC Service Provider/index.html","hash":"aa7c290f3f48488bfc322fc91a9037cad8239eff","modified":1581089583088},{"_id":"public/2007/04/06/java学习/基础知识点杂记/index.html","hash":"9f106c515132e21fe4e73bb63bc728b122b8b632","modified":1581089583088},{"_id":"public/2007/04/06/java学习/java学习总结（一）Java基础/index.html","hash":"7aa02f702a0e67f6afdd9c4306eca90d647ede91","modified":1581089583088},{"_id":"public/2007/04/06/业务知识总结/业务报表学习1/index.html","hash":"8353e393bb0690e7abef3be87dfc84ff1821c140","modified":1581089583088},{"_id":"public/archives/index.html","hash":"4858ab1822e27840d4e235e9b86794dfb647c071","modified":1581089583088},{"_id":"public/archives/page/2/index.html","hash":"4ab116681812a8827cf660033527e9045456901a","modified":1581089583088},{"_id":"public/archives/page/3/index.html","hash":"e5e7b96a97cfcdb9c72b6994550a4dfeaaf65c7c","modified":1581089583088},{"_id":"public/archives/page/4/index.html","hash":"67c617a69a415b7439f3e5fc0880e9ccbc7a1c20","modified":1581089583088},{"_id":"public/archives/page/5/index.html","hash":"bec87092765806c8d246e798d9a465411c2b84ae","modified":1581089583088},{"_id":"public/archives/page/6/index.html","hash":"17f593a80173ed698b49644221d84bbe8ca9e683","modified":1581089583088},{"_id":"public/archives/page/7/index.html","hash":"4ba2754fea643ba4e40f92f52677c39e0a41490c","modified":1581089583088},{"_id":"public/archives/page/8/index.html","hash":"aa3f394b5c245e6e9d0a91e74f7ada83134de8f7","modified":1581089583088},{"_id":"public/archives/page/9/index.html","hash":"a2cbe13368fa1f1ddccbde2bd2f2c7e9845b46ca","modified":1581089583088},{"_id":"public/archives/page/10/index.html","hash":"51e617a4ff89d536cfe85490f4c2ad2651c62740","modified":1581089583088},{"_id":"public/archives/2016/index.html","hash":"a1940e4102c9f9f4fa6b9e1f532bcfdad93d8ee9","modified":1581089583089},{"_id":"public/archives/2016/page/2/index.html","hash":"38b7a8f5faa4b60758be13e4aac50f643d50c846","modified":1581089583089},{"_id":"public/archives/2016/page/3/index.html","hash":"edf0cc4a87fa7a67de42d9ff0fdae5fc618dc107","modified":1581089583089},{"_id":"public/archives/2016/page/4/index.html","hash":"bedbc66c981ed15e771ed90245764bbf3f98635f","modified":1581089583089},{"_id":"public/archives/2016/page/5/index.html","hash":"2a0e189e202c08fb673e66e1a69d89f4b7a35054","modified":1581089583089},{"_id":"public/archives/2016/page/6/index.html","hash":"79236a581c92702ab07622a64f6bb8659639c938","modified":1581089583089},{"_id":"public/archives/2016/09/index.html","hash":"82fe8ebd4f884ac2f715660066d3132a595fa74c","modified":1581089583089},{"_id":"public/archives/2016/09/page/2/index.html","hash":"e7fbfdc657102d249c8b57e980fc0e04c3cb6916","modified":1581089583089},{"_id":"public/archives/2016/10/index.html","hash":"a048497c59aa7ef12a5591a2876b4867372dd582","modified":1581089583089},{"_id":"public/archives/2016/10/page/2/index.html","hash":"99390ef41d2b53699e53c520d9fd955509d4fff1","modified":1581089583089},{"_id":"public/archives/2017/index.html","hash":"769bc08cff0be7e2f810f812e329b5172521df23","modified":1581089583089},{"_id":"public/archives/2018/index.html","hash":"73000ae4cb16cc14054c8bdbd8bca125cf31f5d3","modified":1581089583089},{"_id":"public/archives/2019/index.html","hash":"3a57fc2d39d3bc1654d281550a42cabaf20031b1","modified":1581089583089},{"_id":"public/categories/总结/page/2/index.html","hash":"ce4d3622f4b8c7d6371a5c19e4e1d6ec930ba866","modified":1581089583089},{"_id":"public/categories/总结/page/3/index.html","hash":"15f6b54a25af6c2b7f868a4d33af023263f069c6","modified":1581089583089},{"_id":"public/categories/总结/page/4/index.html","hash":"19186dcf8ac4fc7e87dc216344569e1f72894456","modified":1581089583089},{"_id":"public/categories/总结/page/5/index.html","hash":"d140020b082c1cb3d7a0c5b69fcec6ccdb206bfb","modified":1581089583089},{"_id":"public/categories/总结/page/6/index.html","hash":"d10127b07fe3f71033aa81e4b784ef9777c15460","modified":1581089583089},{"_id":"public/categories/总结/page/7/index.html","hash":"c6935b108e2687b9c5f8b80802a357540de06895","modified":1581089583089},{"_id":"public/categories/反思/index.html","hash":"90644ed597f3ec3359548e2efc0e424c080be4e0","modified":1581089583090},{"_id":"public/tags/java/index.html","hash":"1b375fa19d364b403cf3db90214215abf03d4ead","modified":1581089583090},{"_id":"public/tags/python/index.html","hash":"f5cf968fb14fc5936880e9ccb2dfc8f6b8c50ca4","modified":1581089583090},{"_id":"public/tags/python/page/2/index.html","hash":"9fba6eb80ce29b7458a4c17b03a0af3fc5b75fe3","modified":1581089583090},{"_id":"public/tags/python教程/index.html","hash":"a642d4be6a0935cb4ae85ade5066eb6ce36efe7e","modified":1581089583090},{"_id":"public/tags/通向自由之路/index.html","hash":"61987a8efc6a1778c218fea11dfae06d4a767795","modified":1581089583090},{"_id":"public/index.html","hash":"dab9bc078cb4a3855bc3cf503896149695b78e55","modified":1581089583090},{"_id":"public/page/2/index.html","hash":"9bd9c4cb03d120842469fddf6358bde8cc3cb53e","modified":1581089583090},{"_id":"public/page/3/index.html","hash":"34855a14f1c39a03d277eb460901f7aa84d92a6d","modified":1581089583090},{"_id":"public/page/4/index.html","hash":"4b0376bcb7c9884b909fe6c95b821febb75befee","modified":1581089583090},{"_id":"public/page/5/index.html","hash":"8816dd5cd54247ba29e4f13b8d34f086d298729a","modified":1581089583090},{"_id":"public/page/6/index.html","hash":"68bfebbe899f0df65d083a708513d01e435e839d","modified":1581089583090},{"_id":"public/page/7/index.html","hash":"9ff38c2ce437d0fda577a82d0ce4919fc1aabc1c","modified":1581089583090},{"_id":"public/page/8/index.html","hash":"62ed870223052deb696f016d0fce037703a7d1d8","modified":1581089583090},{"_id":"public/page/9/index.html","hash":"dfdd08b0788cba097bf6b44e640615ec9922027c","modified":1581089583090},{"_id":"public/page/10/index.html","hash":"eb40f1129de89ad7044f28ad90885de2e1c144c0","modified":1581089583091},{"_id":"public/page/11/index.html","hash":"231a5ccd80351b13ba7870f6853196f55cb793a0","modified":1581089583091},{"_id":"public/README.md","hash":"f0c7a5074f949219dee04bb08a0fdf1523150946","modified":1581089583111},{"_id":"public/baidu_verify_5aAdmwEHhk.html","hash":"d6316979071d05bfb4e6fea5ae61ee91dbb35753","modified":1581089583111},{"_id":"public/baidu_verify_Oe1Kf7es1V.html","hash":"2d880fca8d9f2803d9c5318f874f461e41d1c56c","modified":1581089583111},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1581089583112},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1581089583112},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1581089583112},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1581089583112},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1581089583112},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1581089583112},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1581089583112},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1581089583112},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1581089583112},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1581089583112},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1581089583112},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1581089583112},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1581089583112},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1581089583112},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1581089583112},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1581089583112},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1581089583112},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1581089583112},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1581089583112},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1581089583112},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1581089583112},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1581089583112},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1581089583112},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1581089583112},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1581089583112},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1581089583112},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1581089583113},{"_id":"public/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1581089583113},{"_id":"public/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1581089583113},{"_id":"public/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1581089583113},{"_id":"public/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1581089583113},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1581089583113},{"_id":"public/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1581089583113},{"_id":"public/2019/10/22/架构学习/RabbitMQ的高可用性/RabbitMQ普通集群.png","hash":"cb2fbaeb6a209bf5a2dce2f729d61c645c730e8a","modified":1581089583113},{"_id":"public/2019/10/07/架构学习/消息队列/system.png","hash":"3d01de1a0436022ec847bf4143bc74f31f340c46","modified":1581089583113},{"_id":"public/2019/10/22/架构学习/RabbitMQ的高可用性/RabbitMQ镜像模式.png","hash":"3bb2f1c5cd57c2ec67d1d52b974286eeea6c53c4","modified":1581089583113},{"_id":"public/2019/10/07/架构学习/消息队列/systemAfter.png","hash":"89cbf489aa9013d4165712d5c609cd8e178d4cc8","modified":1581089583113},{"_id":"public/2019/10/07/架构学习/消息队列/systemTiming.png","hash":"3e51d3ddb1119c2c8fecd9ae4ced251ad354d7d5","modified":1581089583113},{"_id":"public/2019/10/07/架构学习/消息队列/systemTimingAfter.png","hash":"591546037fe47823352b000b7a263b15cfc55536","modified":1581089583113},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/葛南维八大买卖法.jpeg","hash":"a8ef67a3a7cd5dfa5c633cc6a66d6ca2722d124a","modified":1581089583113},{"_id":"public/images/avatar.jpg","hash":"67bbf5c9d5fc5cb215c1632567f81fa27f2a63e2","modified":1581089583566},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1581089583569},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1581089583571},{"_id":"public/2019/10/22/架构学习/RabbitMQ的高可用性/Kafka.png","hash":"4d46fb62e13094a5a42cb88c9a36d1cb09e5ed1f","modified":1581089583571},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/整个二浪.png","hash":"f09ec0784984ca43b635985a486db4a73d06903a","modified":1581089583572},{"_id":"public/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1581089583584},{"_id":"public/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1581089583584},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1581089583585},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1581089583585},{"_id":"public/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1581089583585},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1581089583585},{"_id":"public/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1581089583585},{"_id":"public/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1581089583585},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1581089583585},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1581089583585},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1581089583585},{"_id":"public/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1581089583585},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1581089583585},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1581089583585},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1581089583585},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1581089583585},{"_id":"public/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1581089583585},{"_id":"public/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1581089583585},{"_id":"public/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1581089583585},{"_id":"public/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1581089583586},{"_id":"public/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1581089583586},{"_id":"public/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1581089583586},{"_id":"public/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1581089583586},{"_id":"public/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1581089583586},{"_id":"public/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1581089583586},{"_id":"public/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1581089583586},{"_id":"public/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1581089583587},{"_id":"public/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1581089583587},{"_id":"public/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1581089583587},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1581089583587},{"_id":"public/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1581089583587},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1581089583587},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1581089583587},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1581089583587},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1581089583587},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1581089583587},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1581089583587},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1581089583587},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1581089583587},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1581089583587},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1581089583587},{"_id":"public/css/main.css","hash":"30ac39f28a29af9fa8a8ff6437cbbfbb08b18786","modified":1581089583588},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1581089583588},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1581089583588},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1581089583588},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/波浪.png","hash":"0c94b02d38c6307da015b562a0681e67c308c2dc","modified":1581089583588},{"_id":"public/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1581089583612},{"_id":"public/js/src/utils.js","hash":"dbdc3d1300eec7da9632608ebc0e5b697779dad7","modified":1581089583612},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1581089583613},{"_id":"public/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1581089583613},{"_id":"public/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1581089583613},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1581089583613},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1581089583613},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1581089583613},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/头肩底.png","hash":"2287dc21f92261c6b3494485c984ab30ae732d12","modified":1581089583613},{"_id":"public/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1581089583638},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1581089583638},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/浪形宽度.png","hash":"d5f004838cf7602b5882996d17a80836eab942b8","modified":1581089583639},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/趋势线.png","hash":"440762f6baa2545a575fa1662243030c5cf476f5","modified":1581089583639},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1581089583664},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1581089583664},{"_id":"public/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1581089583695},{"_id":"public/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1581089583696},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1581089583698},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1581089583698},{"_id":"public/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1581089583698},{"_id":"public/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1581089583698},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1581089583698},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/箱体.png","hash":"46c0075414f92ae6a0e6b32cc47212a35092badc","modified":1581089583699},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/四浪.png","hash":"59740f6a0f841dd79de653473e17eda527f7121d","modified":1581089583699},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/三角形.png","hash":"b5a64b5a6695a849a55247e72c67ef814eddf667","modified":1581089583699},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/Wdi.png","hash":"cfdc54256aad58f2cd0fdb9d03a11f1172e391e6","modified":1581089583699},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/二浪.png","hash":"3fb19b5853269c91b454ec6f3d4ce87c4c034fd4","modified":1581089583699},{"_id":"public/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1581089583727},{"_id":"public/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1581089583727},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1581089583728},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/底背离.png","hash":"829ef0532e60b1ab4bd99b0f95dafe75de2717cf","modified":1581089583728},{"_id":"public/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1581089583751},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1581089583751},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/MACD.png","hash":"559adb67a2a00e93e3949f3f59298369a9462488","modified":1581089583751},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/KDJ.png","hash":"7aff41db3de48c653f1bb0ed5b6a0d6835402523","modified":1581089583770},{"_id":"public/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1581089583782},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1581089583787},{"_id":"public/2018/12/04/mysql/一条SQL查询是如何执行的/MySQL逻辑.png","hash":"0399712737ef6427d49e48d5d63dfbd23bf40e4d","modified":1581089583845},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/看大盘.png","hash":"35c95d43a1a67ff5b9c16ffd54d3b3cfc97fc5c7","modified":1581089583845},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/个股盘口.png","hash":"b0a66a8dbb468c641192f4e46c5e9272a5b9b5cd","modified":1581089583852},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/委买委卖.png","hash":"f7289f12a409be3499ad1554b2f03b59336268c8","modified":1581089583856},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/BOLL.png","hash":"632aa0db37ede3513857730a01adf544ece8d99b","modified":1581089583864},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1581089583866},{"_id":"public/2019/09/08/学做操盘手/K线的基础知识/MACD背离.png","hash":"7e55098058fa7b8b6987aba39873b0b2d3d15abd","modified":1581089583867},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1581089583884},{"_id":"public/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1581089583889}],"Category":[{"name":"c#","_id":"ck6cbwmvh00074l3n6ayumw3j"},{"name":"总结","_id":"ck6cbwmvo000c4l3n7y7qiqxm"},{"name":"java","_id":"ck6cbwmw100124l3n18jn89lt"},{"name":"有趣","_id":"ck6cbwmwf00214l3n3aaz6h39"},{"name":"管理","_id":"ck6cbwmwx00304l3nqm7kgltp"},{"name":"学习","_id":"ck6cbwmwz00384l3nosq3gzbz"},{"name":"测试","_id":"ck6cbwmx1003g4l3n72xqwxfe"},{"name":"反思","_id":"ck6cbwmx7003t4l3n4onasplt"},{"name":"方法学习","_id":"ck6cbwmxd00484l3n2pwpf6p1"},{"name":"数字货币","_id":"ck6cbwmxf004g4l3ntat2rdyi"},{"name":"计划","_id":"ck6cbwmxj004t4l3nezky3u8a"},{"name":"Java","_id":"ck6cbwmxo00554l3nji8g9ady"},{"name":"设计模式","_id":"ck6cbwmxs005f4l3nfxxuvrfy"},{"name":"杂谈","_id":"ck6cbwmy1006c4l3n32qek509"},{"name":"总结/","_id":"ck6cbwn0m009p4l3n6zbecaim"},{"name":"优化","_id":"ck6cbwn0u00a74l3nb8topg2r"},{"name":"学做操盘手","_id":"ck6cbwn0y00aj4l3n66kwvb5j"}],"Data":[],"Page":[{"title":"about","date":"2016-04-06T04:31:38.000Z","comments":0,"_content":"**Name**\n\n鲍苏坤\n\n**I Am**\n\n通信工程，喜欢心理学，动漫，经济学，乐于尝试新鲜事物，行走在漫漫人生路上的一只小码农，向着大牛大步流星。\n\n\n**Contact**\n\n\n\n微博：[脸大的没边的鲍先生](http://weibo.com/3822772562)\n\n\n知乎：[鲍lucky](http://www.zhihu.com/people/bao-lucky)\n\n\nGitHub：[zjbao123](https://github.com/zjbao123)\n\n\nEmail：345232213@qq.com\n\n\n--------------\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2016-04-06 12:31:38\ncomments: false\n---\n**Name**\n\n鲍苏坤\n\n**I Am**\n\n通信工程，喜欢心理学，动漫，经济学，乐于尝试新鲜事物，行走在漫漫人生路上的一只小码农，向着大牛大步流星。\n\n\n**Contact**\n\n\n\n微博：[脸大的没边的鲍先生](http://weibo.com/3822772562)\n\n\n知乎：[鲍lucky](http://www.zhihu.com/people/bao-lucky)\n\n\nGitHub：[zjbao123](https://github.com/zjbao123)\n\n\nEmail：345232213@qq.com\n\n\n--------------\n\n","updated":"2019-03-22T14:44:36.742Z","path":"about/index.html","layout":"page","_id":"ck6cbwmu600004l3npguiwpyq","content":"<p><strong>Name</strong></p>\n<p>鲍苏坤</p>\n<p><strong>I Am</strong></p>\n<p>通信工程，喜欢心理学，动漫，经济学，乐于尝试新鲜事物，行走在漫漫人生路上的一只小码农，向着大牛大步流星。</p>\n<p><strong>Contact</strong></p>\n<p>微博：<a href=\"http://weibo.com/3822772562\" target=\"_blank\" rel=\"noopener\">脸大的没边的鲍先生</a></p>\n<p>知乎：<a href=\"http://www.zhihu.com/people/bao-lucky\" target=\"_blank\" rel=\"noopener\">鲍lucky</a></p>\n<p>GitHub：<a href=\"https://github.com/zjbao123\" target=\"_blank\" rel=\"noopener\">zjbao123</a></p>\n<p>Email：<a href=\"mailto:345232213@qq.com\" target=\"_blank\" rel=\"noopener\">345232213@qq.com</a></p>\n<hr>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>Name</strong></p>\n<p>鲍苏坤</p>\n<p><strong>I Am</strong></p>\n<p>通信工程，喜欢心理学，动漫，经济学，乐于尝试新鲜事物，行走在漫漫人生路上的一只小码农，向着大牛大步流星。</p>\n<p><strong>Contact</strong></p>\n<p>微博：<a href=\"http://weibo.com/3822772562\" target=\"_blank\" rel=\"noopener\">脸大的没边的鲍先生</a></p>\n<p>知乎：<a href=\"http://www.zhihu.com/people/bao-lucky\" target=\"_blank\" rel=\"noopener\">鲍lucky</a></p>\n<p>GitHub：<a href=\"https://github.com/zjbao123\" target=\"_blank\" rel=\"noopener\">zjbao123</a></p>\n<p>Email：<a href=\"mailto:345232213@qq.com\" target=\"_blank\" rel=\"noopener\">345232213@qq.com</a></p>\n<hr>\n"},{"title":"categories","date":"2016-04-07T04:41:03.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2016-04-07 12:41:03\ntype: \"categories\"\ncomments: false\n---\n","updated":"2019-03-22T14:44:36.743Z","path":"categories/index.html","layout":"page","_id":"ck6cbwmu800014l3ng2dxfuwb","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"guestbook","date":"2016-04-06T11:00:26.000Z","_content":"<blockquote class=\"blockquote-center\"> 常联系</blockquote>\n<div\nclass=\"ds-recent-visitors\"\t//指定显示最近访客容器\ndata-num-items=\"28\"\t//显示最近访客的数量\ndata-avatar-size=\"42\"\t//显示最近访客头像尺寸大小\nid=\"ds-recent-visitors\"></div>\n","source":"guestbook/index.md","raw":"---\ntitle: guestbook\ndate: 2016-04-06 19:00:26\n---\n<blockquote class=\"blockquote-center\"> 常联系</blockquote>\n<div\nclass=\"ds-recent-visitors\"\t//指定显示最近访客容器\ndata-num-items=\"28\"\t//显示最近访客的数量\ndata-avatar-size=\"42\"\t//显示最近访客头像尺寸大小\nid=\"ds-recent-visitors\"></div>\n","updated":"2019-03-22T14:44:36.743Z","path":"guestbook/index.html","comments":1,"layout":"page","_id":"ck6cbwmu900024l3nr5nb1tnh","content":"<p><blockquote class=\"blockquote-center\"> 常联系</blockquote></p>\n&lt;div<br>class=”ds-recent-visitors”    //指定显示最近访客容器<br>data-num-items=”28”    //显示最近访客的数量<br>data-avatar-size=”42”    //显示最近访客头像尺寸大小<br>id=”ds-recent-visitors”&gt;\n","site":{"data":{}},"excerpt":"","more":"<p><blockquote class=\"blockquote-center\"> 常联系</blockquote></p>\n&lt;div<br>class=”ds-recent-visitors”    //指定显示最近访客容器<br>data-num-items=”28”    //显示最近访客的数量<br>data-avatar-size=”42”    //显示最近访客头像尺寸大小<br>id=”ds-recent-visitors”&gt;\n"},{"title":"notes","date":"2016-10-17T08:05:08.000Z","comments":0,"_content":"2019.09.17\n\n**只有回看走过的路，比较别人的路，远眺前行的路，弄清楚我们从哪儿来、往哪儿去，很多问题才能看得深、把得准。**\n\n2019.03.26\n\n**我们当下所处的世界已经是一个信息超级大爆炸的世界，知识多到我们根本看不过来，你会发现只要你单点突破了，才会有所开窍。任何人都一样，所以在成长的路上不用太过焦虑，沉下心来：单点突破。**\n\n2019.01.17\n\n**“我相信每个孩子，都曾在心底许下‘孝’的宏愿，相信来日方长，相信水到渠成，相信自己必有功成名就、衣锦还乡的那一天，可以从容尽孝。**\n\n**可人们忘了，忘了时间的残酷，忘了人生的短暂，忘了世上有永远无法报答的恩情，忘了生命本身有不堪一击的脆弱。”**\n\n2018.10.31\n\n**当你的能力还驾驭不了你的目标时，就应该沉下心来，历练。**\n\n2018.2.23\n\n**朱光潜先生有一个人生信念，是我十分佩服，并想贯彻到底的。**\n\n**凡此身应该做而且能够做的事，决不推诿给别人。**\n\n**凡此时应该做而且能够做的事，决不推延到将来。**\n\n**凡此地应该做而且能够做的事，决不等待想象中更好的境地。**\n\n**其实这段文字，可以总结成六个字：**\n\n**此身、此时、此地。**\n\n2018.1.31\n\n**千秋邈矣独留我，百战归来再读书。**\n\n\n2018.1.23\n\n**好的爱情是投射，你在她身上，永远能看到那个翩翩少年与慈爱父亲合二为一的自己。如果你在她身上无法投射出更好的自己，宁可失去她，也不要失去自己。**\n\n**拥有一件东西的最好办法是成为配的上它的人，想成为一个成功的男士，首先也必须自身能拥有这些品性。**\n\n2018.1.15\n\n**我一直以为人是慢慢变老的，其实不是，人是一瞬间变老的。人变老不是从第一道皱纹、第一根白发开始的，而是从放弃自己的那一刻开始的。只有对自己不放弃的人，才能活得不会老，老去的只是年龄，不老的是气质。让人不老的特质是必须有一颗童心，注重仪表，经常旅行，学习到老……    --村上春树**\n\n2017.12.22\n\n**你要琢磨清楚自己想在什么行业发展，使用何种技术，做什么产品或服务，给自己设立目标，让这个目标指引着你前进。**\n\n2017.12.15\n\n**1.我们的世界是由极端、未知和非常不可能发生的事物主导的。**\n\n**2.不要相信中等风险事件，也就是不要相信稳定。人们一般都明白高风险和零风险的概念，但是中等风险则有很大的迷惑性，因为它受巨大的测量误差的影响。**\n\n**3.观察过去的经验得出未来的规律，出现的问题可能比我们想像的要严重。因为相同的过去的数据既可以证明一个理论，又可以同时证明另一个完全相反的理论。如果你明年还活着，可能意味着你更接近长生不老，或者你更接近死亡？**\n\n**4.预测是不靠谱的，但是我们可以判断出哪一个事物是脆弱的，哪一个事物是强韧的。我们只要押注脆弱的事物最终会崩溃即可。**\n\n\n**所以风险并不可怕，可怕的是对风险毫无准备。**\n\n2017.11.28\n\n**财富走向定律:**\n\n**1.在地域上，由农村走向城市。**\n\n**2.在人群上，财富走向这些人，正面思考者、把工作当事业而非事情、知道行动与阅历重于知识、爱投资而非购物、崇拜并追随强者、有重复做简单事情的毅力、明天事今天做的人。**\n\n2017.10.18\n\n**三流的点子加一流的执行力，永远比一流的点子加三流的执行力更好。 ——孙正义**\n\n2017.05.09\n\n**编程语言只是用来表达思想的工具，不同的语言在不同方面做了取舍。我们要做的是学好后面的思想，然后为当前的项目选择合适的语言和框架。做到这一点的人会得到码农的荣誉称号：Architect.**\n\n2017.04.21\n\n**在金融行业，十年的业务积累强于十年的技术积累。**\n\n2017.04.13\n\n**如果一件事需要干两次以上,那么你该为它写个自动脚本。**\n\n2017.04.06\n\n**Talking is cheap, show you the code.**\n\n2017.03.21\n\n**志于高者得于中。**\n\n2017.03.09\n\n**与恶龙缠斗过久,自身亦成为恶龙；凝视深渊过久,深渊将回以凝视。**\n\n2017.02.23\n\n**男儿至死是少年，赤心不改真英雄。**\n\n**满地都是六便士，他却抬头看见了月亮。**\n\n2017.02.22\n\n**1.工作经验不是指你做一件事情做了多久，而是指，你用了多久的时间，去思考、优化、改善它；**\n\n**2.无论任何时候，听到任何重要信息、被分配到任何事务，第一直觉不是去执行，也不是去思考，而是记录下来；**\n\n**3.管理时间开销。当你从工作状态切换出去的时候，瞥一眼系统时间；当你重新进入工作的时候，再瞥一眼时间。将这两个时间点记下来；**\n\n**4.文档命名增加版本号，格式要明确，存放位置要固定；**\n\n**5.做checklist。**\n\n2017.02.21\n\n**遍身罗绮者，不是养蚕人。**\n\n2017.02.16\n\n**对于互联网产品公司来说，有海量用户，还看不到清晰的盈利模式，是最好的投资时机。**\n\n2017.02.15\n\n**有时候，“虚惊一场”这四个字是人世间最美好的成语，比起什么兴高采烈，五彩缤纷，一帆风顺都要美好百倍。你可懂什么叫失去。这些时间来，更觉如此。愿悲伤恐惧能够过去，事外之人更懂珍惜。——韩寒**\n\n2017.02.08\n\n**君子生非异也，善假于物也。**\n\n**因为一旦这种终极快感这么简单就能获得的话，你就不会在对其他各种通过努力获得的快感产生兴趣。——《蜗居》**\n\n2017.01.19\n\n**You can be anything,but you can't be everything.**\n\n2017.01.10\n\n**失去了对世界的探索之心，努力求稳，求可以安安稳稳地度过余生，这便是老了。**\n**你以为我也是庸碌之辈吗？你们知道我多么伟大吗？我曾经无数次战胜自己，我没有尽头，我不可阻挡。**\n\n2017.01.07\n\n**Money is the McMancion in Sarasota, that starts falling apart after ten years,Power is the old stone building that stands for centuries.  ——《纸牌屋》**\n\n2016.12.06\n\n**程序其实是给人看的，只是机器恰好可以运行它。**\n**因为人性，因为贪婪，因为恐惧。必要的时候不敢扣动扳机，危险的时候，又被吓得不敢动弹。**\n\n2016.11.22\n\n**大多数人死在了25岁，却一直到75岁才埋葬。**\n**我宁愿酗酒吸毒，34岁就家破人亡，但成为别人餐桌上的话题，也不要腰缠万贯红光满面地活到90岁但没人记得我。   ——安德鲁，爆裂鼓手**\n\n2016.11.18\n\n**我们内心的懒惰、恐惧和侥幸附带各种各样的借口，在本该有的行动之前树起了重重无形的阻碍。这些心理的阻碍往往超越了这些行动本身的难度。**\n\n2016.11.05\n\n**Your best is yet to come.**\n\n2016.10.27\n\n**在python中写程序有时候是一种喜悦的分享，而不是一种迫于竞争的追求。学习它的新特性，欣赏它的设计，它的优雅，它的洗练，完全是一种乐趣。**\n\n2016.10.14\n\n**莫道君行早，更有早行人。全心敲代码，天道自酬勤。**\n\n2016.10.12\n\n**好好学习，天天向上。**\n\n2016.09.26\n\n**花儿依旧那么香，鸟儿依旧在欢唱，这个城市就是这样，人来人往，匆匆忙忙。**\n\n2016.09.19\n\n**English,for me ,means freedom.**\n\n2016.09.12\n\n**人生三坑：一，莫名其妙地凑热闹：二，心急火燎地随大流，三，操碎了别人的心肝。**\n\n2016.09.11\n\n**our luck is turning around.**\n\n2016.08.08\n\n**自律给我自由**\n\n2016.08.06\n\n**I'm a slow walker , but I never walk back.**","source":"notes/index.md","raw":"---\ntitle: notes\ndate: 2016-10-17 16:05:08\ncomments: false\n---\n2019.09.17\n\n**只有回看走过的路，比较别人的路，远眺前行的路，弄清楚我们从哪儿来、往哪儿去，很多问题才能看得深、把得准。**\n\n2019.03.26\n\n**我们当下所处的世界已经是一个信息超级大爆炸的世界，知识多到我们根本看不过来，你会发现只要你单点突破了，才会有所开窍。任何人都一样，所以在成长的路上不用太过焦虑，沉下心来：单点突破。**\n\n2019.01.17\n\n**“我相信每个孩子，都曾在心底许下‘孝’的宏愿，相信来日方长，相信水到渠成，相信自己必有功成名就、衣锦还乡的那一天，可以从容尽孝。**\n\n**可人们忘了，忘了时间的残酷，忘了人生的短暂，忘了世上有永远无法报答的恩情，忘了生命本身有不堪一击的脆弱。”**\n\n2018.10.31\n\n**当你的能力还驾驭不了你的目标时，就应该沉下心来，历练。**\n\n2018.2.23\n\n**朱光潜先生有一个人生信念，是我十分佩服，并想贯彻到底的。**\n\n**凡此身应该做而且能够做的事，决不推诿给别人。**\n\n**凡此时应该做而且能够做的事，决不推延到将来。**\n\n**凡此地应该做而且能够做的事，决不等待想象中更好的境地。**\n\n**其实这段文字，可以总结成六个字：**\n\n**此身、此时、此地。**\n\n2018.1.31\n\n**千秋邈矣独留我，百战归来再读书。**\n\n\n2018.1.23\n\n**好的爱情是投射，你在她身上，永远能看到那个翩翩少年与慈爱父亲合二为一的自己。如果你在她身上无法投射出更好的自己，宁可失去她，也不要失去自己。**\n\n**拥有一件东西的最好办法是成为配的上它的人，想成为一个成功的男士，首先也必须自身能拥有这些品性。**\n\n2018.1.15\n\n**我一直以为人是慢慢变老的，其实不是，人是一瞬间变老的。人变老不是从第一道皱纹、第一根白发开始的，而是从放弃自己的那一刻开始的。只有对自己不放弃的人，才能活得不会老，老去的只是年龄，不老的是气质。让人不老的特质是必须有一颗童心，注重仪表，经常旅行，学习到老……    --村上春树**\n\n2017.12.22\n\n**你要琢磨清楚自己想在什么行业发展，使用何种技术，做什么产品或服务，给自己设立目标，让这个目标指引着你前进。**\n\n2017.12.15\n\n**1.我们的世界是由极端、未知和非常不可能发生的事物主导的。**\n\n**2.不要相信中等风险事件，也就是不要相信稳定。人们一般都明白高风险和零风险的概念，但是中等风险则有很大的迷惑性，因为它受巨大的测量误差的影响。**\n\n**3.观察过去的经验得出未来的规律，出现的问题可能比我们想像的要严重。因为相同的过去的数据既可以证明一个理论，又可以同时证明另一个完全相反的理论。如果你明年还活着，可能意味着你更接近长生不老，或者你更接近死亡？**\n\n**4.预测是不靠谱的，但是我们可以判断出哪一个事物是脆弱的，哪一个事物是强韧的。我们只要押注脆弱的事物最终会崩溃即可。**\n\n\n**所以风险并不可怕，可怕的是对风险毫无准备。**\n\n2017.11.28\n\n**财富走向定律:**\n\n**1.在地域上，由农村走向城市。**\n\n**2.在人群上，财富走向这些人，正面思考者、把工作当事业而非事情、知道行动与阅历重于知识、爱投资而非购物、崇拜并追随强者、有重复做简单事情的毅力、明天事今天做的人。**\n\n2017.10.18\n\n**三流的点子加一流的执行力，永远比一流的点子加三流的执行力更好。 ——孙正义**\n\n2017.05.09\n\n**编程语言只是用来表达思想的工具，不同的语言在不同方面做了取舍。我们要做的是学好后面的思想，然后为当前的项目选择合适的语言和框架。做到这一点的人会得到码农的荣誉称号：Architect.**\n\n2017.04.21\n\n**在金融行业，十年的业务积累强于十年的技术积累。**\n\n2017.04.13\n\n**如果一件事需要干两次以上,那么你该为它写个自动脚本。**\n\n2017.04.06\n\n**Talking is cheap, show you the code.**\n\n2017.03.21\n\n**志于高者得于中。**\n\n2017.03.09\n\n**与恶龙缠斗过久,自身亦成为恶龙；凝视深渊过久,深渊将回以凝视。**\n\n2017.02.23\n\n**男儿至死是少年，赤心不改真英雄。**\n\n**满地都是六便士，他却抬头看见了月亮。**\n\n2017.02.22\n\n**1.工作经验不是指你做一件事情做了多久，而是指，你用了多久的时间，去思考、优化、改善它；**\n\n**2.无论任何时候，听到任何重要信息、被分配到任何事务，第一直觉不是去执行，也不是去思考，而是记录下来；**\n\n**3.管理时间开销。当你从工作状态切换出去的时候，瞥一眼系统时间；当你重新进入工作的时候，再瞥一眼时间。将这两个时间点记下来；**\n\n**4.文档命名增加版本号，格式要明确，存放位置要固定；**\n\n**5.做checklist。**\n\n2017.02.21\n\n**遍身罗绮者，不是养蚕人。**\n\n2017.02.16\n\n**对于互联网产品公司来说，有海量用户，还看不到清晰的盈利模式，是最好的投资时机。**\n\n2017.02.15\n\n**有时候，“虚惊一场”这四个字是人世间最美好的成语，比起什么兴高采烈，五彩缤纷，一帆风顺都要美好百倍。你可懂什么叫失去。这些时间来，更觉如此。愿悲伤恐惧能够过去，事外之人更懂珍惜。——韩寒**\n\n2017.02.08\n\n**君子生非异也，善假于物也。**\n\n**因为一旦这种终极快感这么简单就能获得的话，你就不会在对其他各种通过努力获得的快感产生兴趣。——《蜗居》**\n\n2017.01.19\n\n**You can be anything,but you can't be everything.**\n\n2017.01.10\n\n**失去了对世界的探索之心，努力求稳，求可以安安稳稳地度过余生，这便是老了。**\n**你以为我也是庸碌之辈吗？你们知道我多么伟大吗？我曾经无数次战胜自己，我没有尽头，我不可阻挡。**\n\n2017.01.07\n\n**Money is the McMancion in Sarasota, that starts falling apart after ten years,Power is the old stone building that stands for centuries.  ——《纸牌屋》**\n\n2016.12.06\n\n**程序其实是给人看的，只是机器恰好可以运行它。**\n**因为人性，因为贪婪，因为恐惧。必要的时候不敢扣动扳机，危险的时候，又被吓得不敢动弹。**\n\n2016.11.22\n\n**大多数人死在了25岁，却一直到75岁才埋葬。**\n**我宁愿酗酒吸毒，34岁就家破人亡，但成为别人餐桌上的话题，也不要腰缠万贯红光满面地活到90岁但没人记得我。   ——安德鲁，爆裂鼓手**\n\n2016.11.18\n\n**我们内心的懒惰、恐惧和侥幸附带各种各样的借口，在本该有的行动之前树起了重重无形的阻碍。这些心理的阻碍往往超越了这些行动本身的难度。**\n\n2016.11.05\n\n**Your best is yet to come.**\n\n2016.10.27\n\n**在python中写程序有时候是一种喜悦的分享，而不是一种迫于竞争的追求。学习它的新特性，欣赏它的设计，它的优雅，它的洗练，完全是一种乐趣。**\n\n2016.10.14\n\n**莫道君行早，更有早行人。全心敲代码，天道自酬勤。**\n\n2016.10.12\n\n**好好学习，天天向上。**\n\n2016.09.26\n\n**花儿依旧那么香，鸟儿依旧在欢唱，这个城市就是这样，人来人往，匆匆忙忙。**\n\n2016.09.19\n\n**English,for me ,means freedom.**\n\n2016.09.12\n\n**人生三坑：一，莫名其妙地凑热闹：二，心急火燎地随大流，三，操碎了别人的心肝。**\n\n2016.09.11\n\n**our luck is turning around.**\n\n2016.08.08\n\n**自律给我自由**\n\n2016.08.06\n\n**I'm a slow walker , but I never walk back.**","updated":"2019-09-17T12:47:42.257Z","path":"notes/index.html","layout":"page","_id":"ck6cbwmua00034l3ngsl4l4uj","content":"<p>2019.09.17</p>\n<p><strong>只有回看走过的路，比较别人的路，远眺前行的路，弄清楚我们从哪儿来、往哪儿去，很多问题才能看得深、把得准。</strong></p>\n<p>2019.03.26</p>\n<p><strong>我们当下所处的世界已经是一个信息超级大爆炸的世界，知识多到我们根本看不过来，你会发现只要你单点突破了，才会有所开窍。任何人都一样，所以在成长的路上不用太过焦虑，沉下心来：单点突破。</strong></p>\n<p>2019.01.17</p>\n<p><strong>“我相信每个孩子，都曾在心底许下‘孝’的宏愿，相信来日方长，相信水到渠成，相信自己必有功成名就、衣锦还乡的那一天，可以从容尽孝。</strong></p>\n<p><strong>可人们忘了，忘了时间的残酷，忘了人生的短暂，忘了世上有永远无法报答的恩情，忘了生命本身有不堪一击的脆弱。”</strong></p>\n<p>2018.10.31</p>\n<p><strong>当你的能力还驾驭不了你的目标时，就应该沉下心来，历练。</strong></p>\n<p>2018.2.23</p>\n<p><strong>朱光潜先生有一个人生信念，是我十分佩服，并想贯彻到底的。</strong></p>\n<p><strong>凡此身应该做而且能够做的事，决不推诿给别人。</strong></p>\n<p><strong>凡此时应该做而且能够做的事，决不推延到将来。</strong></p>\n<p><strong>凡此地应该做而且能够做的事，决不等待想象中更好的境地。</strong></p>\n<p><strong>其实这段文字，可以总结成六个字：</strong></p>\n<p><strong>此身、此时、此地。</strong></p>\n<p>2018.1.31</p>\n<p><strong>千秋邈矣独留我，百战归来再读书。</strong></p>\n<p>2018.1.23</p>\n<p><strong>好的爱情是投射，你在她身上，永远能看到那个翩翩少年与慈爱父亲合二为一的自己。如果你在她身上无法投射出更好的自己，宁可失去她，也不要失去自己。</strong></p>\n<p><strong>拥有一件东西的最好办法是成为配的上它的人，想成为一个成功的男士，首先也必须自身能拥有这些品性。</strong></p>\n<p>2018.1.15</p>\n<p><strong>我一直以为人是慢慢变老的，其实不是，人是一瞬间变老的。人变老不是从第一道皱纹、第一根白发开始的，而是从放弃自己的那一刻开始的。只有对自己不放弃的人，才能活得不会老，老去的只是年龄，不老的是气质。让人不老的特质是必须有一颗童心，注重仪表，经常旅行，学习到老……    –村上春树</strong></p>\n<p>2017.12.22</p>\n<p><strong>你要琢磨清楚自己想在什么行业发展，使用何种技术，做什么产品或服务，给自己设立目标，让这个目标指引着你前进。</strong></p>\n<p>2017.12.15</p>\n<p><strong>1.我们的世界是由极端、未知和非常不可能发生的事物主导的。</strong></p>\n<p><strong>2.不要相信中等风险事件，也就是不要相信稳定。人们一般都明白高风险和零风险的概念，但是中等风险则有很大的迷惑性，因为它受巨大的测量误差的影响。</strong></p>\n<p><strong>3.观察过去的经验得出未来的规律，出现的问题可能比我们想像的要严重。因为相同的过去的数据既可以证明一个理论，又可以同时证明另一个完全相反的理论。如果你明年还活着，可能意味着你更接近长生不老，或者你更接近死亡？</strong></p>\n<p><strong>4.预测是不靠谱的，但是我们可以判断出哪一个事物是脆弱的，哪一个事物是强韧的。我们只要押注脆弱的事物最终会崩溃即可。</strong></p>\n<p><strong>所以风险并不可怕，可怕的是对风险毫无准备。</strong></p>\n<p>2017.11.28</p>\n<p><strong>财富走向定律:</strong></p>\n<p><strong>1.在地域上，由农村走向城市。</strong></p>\n<p><strong>2.在人群上，财富走向这些人，正面思考者、把工作当事业而非事情、知道行动与阅历重于知识、爱投资而非购物、崇拜并追随强者、有重复做简单事情的毅力、明天事今天做的人。</strong></p>\n<p>2017.10.18</p>\n<p><strong>三流的点子加一流的执行力，永远比一流的点子加三流的执行力更好。 ——孙正义</strong></p>\n<p>2017.05.09</p>\n<p><strong>编程语言只是用来表达思想的工具，不同的语言在不同方面做了取舍。我们要做的是学好后面的思想，然后为当前的项目选择合适的语言和框架。做到这一点的人会得到码农的荣誉称号：Architect.</strong></p>\n<p>2017.04.21</p>\n<p><strong>在金融行业，十年的业务积累强于十年的技术积累。</strong></p>\n<p>2017.04.13</p>\n<p><strong>如果一件事需要干两次以上,那么你该为它写个自动脚本。</strong></p>\n<p>2017.04.06</p>\n<p><strong>Talking is cheap, show you the code.</strong></p>\n<p>2017.03.21</p>\n<p><strong>志于高者得于中。</strong></p>\n<p>2017.03.09</p>\n<p><strong>与恶龙缠斗过久,自身亦成为恶龙；凝视深渊过久,深渊将回以凝视。</strong></p>\n<p>2017.02.23</p>\n<p><strong>男儿至死是少年，赤心不改真英雄。</strong></p>\n<p><strong>满地都是六便士，他却抬头看见了月亮。</strong></p>\n<p>2017.02.22</p>\n<p><strong>1.工作经验不是指你做一件事情做了多久，而是指，你用了多久的时间，去思考、优化、改善它；</strong></p>\n<p><strong>2.无论任何时候，听到任何重要信息、被分配到任何事务，第一直觉不是去执行，也不是去思考，而是记录下来；</strong></p>\n<p><strong>3.管理时间开销。当你从工作状态切换出去的时候，瞥一眼系统时间；当你重新进入工作的时候，再瞥一眼时间。将这两个时间点记下来；</strong></p>\n<p><strong>4.文档命名增加版本号，格式要明确，存放位置要固定；</strong></p>\n<p><strong>5.做checklist。</strong></p>\n<p>2017.02.21</p>\n<p><strong>遍身罗绮者，不是养蚕人。</strong></p>\n<p>2017.02.16</p>\n<p><strong>对于互联网产品公司来说，有海量用户，还看不到清晰的盈利模式，是最好的投资时机。</strong></p>\n<p>2017.02.15</p>\n<p><strong>有时候，“虚惊一场”这四个字是人世间最美好的成语，比起什么兴高采烈，五彩缤纷，一帆风顺都要美好百倍。你可懂什么叫失去。这些时间来，更觉如此。愿悲伤恐惧能够过去，事外之人更懂珍惜。——韩寒</strong></p>\n<p>2017.02.08</p>\n<p><strong>君子生非异也，善假于物也。</strong></p>\n<p><strong>因为一旦这种终极快感这么简单就能获得的话，你就不会在对其他各种通过努力获得的快感产生兴趣。——《蜗居》</strong></p>\n<p>2017.01.19</p>\n<p><strong>You can be anything,but you can’t be everything.</strong></p>\n<p>2017.01.10</p>\n<p><strong>失去了对世界的探索之心，努力求稳，求可以安安稳稳地度过余生，这便是老了。</strong><br><strong>你以为我也是庸碌之辈吗？你们知道我多么伟大吗？我曾经无数次战胜自己，我没有尽头，我不可阻挡。</strong></p>\n<p>2017.01.07</p>\n<p><strong>Money is the McMancion in Sarasota, that starts falling apart after ten years,Power is the old stone building that stands for centuries.  ——《纸牌屋》</strong></p>\n<p>2016.12.06</p>\n<p><strong>程序其实是给人看的，只是机器恰好可以运行它。</strong><br><strong>因为人性，因为贪婪，因为恐惧。必要的时候不敢扣动扳机，危险的时候，又被吓得不敢动弹。</strong></p>\n<p>2016.11.22</p>\n<p><strong>大多数人死在了25岁，却一直到75岁才埋葬。</strong><br><strong>我宁愿酗酒吸毒，34岁就家破人亡，但成为别人餐桌上的话题，也不要腰缠万贯红光满面地活到90岁但没人记得我。   ——安德鲁，爆裂鼓手</strong></p>\n<p>2016.11.18</p>\n<p><strong>我们内心的懒惰、恐惧和侥幸附带各种各样的借口，在本该有的行动之前树起了重重无形的阻碍。这些心理的阻碍往往超越了这些行动本身的难度。</strong></p>\n<p>2016.11.05</p>\n<p><strong>Your best is yet to come.</strong></p>\n<p>2016.10.27</p>\n<p><strong>在python中写程序有时候是一种喜悦的分享，而不是一种迫于竞争的追求。学习它的新特性，欣赏它的设计，它的优雅，它的洗练，完全是一种乐趣。</strong></p>\n<p>2016.10.14</p>\n<p><strong>莫道君行早，更有早行人。全心敲代码，天道自酬勤。</strong></p>\n<p>2016.10.12</p>\n<p><strong>好好学习，天天向上。</strong></p>\n<p>2016.09.26</p>\n<p><strong>花儿依旧那么香，鸟儿依旧在欢唱，这个城市就是这样，人来人往，匆匆忙忙。</strong></p>\n<p>2016.09.19</p>\n<p><strong>English,for me ,means freedom.</strong></p>\n<p>2016.09.12</p>\n<p><strong>人生三坑：一，莫名其妙地凑热闹：二，心急火燎地随大流，三，操碎了别人的心肝。</strong></p>\n<p>2016.09.11</p>\n<p><strong>our luck is turning around.</strong></p>\n<p>2016.08.08</p>\n<p><strong>自律给我自由</strong></p>\n<p>2016.08.06</p>\n<p><strong>I’m a slow walker , but I never walk back.</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>2019.09.17</p>\n<p><strong>只有回看走过的路，比较别人的路，远眺前行的路，弄清楚我们从哪儿来、往哪儿去，很多问题才能看得深、把得准。</strong></p>\n<p>2019.03.26</p>\n<p><strong>我们当下所处的世界已经是一个信息超级大爆炸的世界，知识多到我们根本看不过来，你会发现只要你单点突破了，才会有所开窍。任何人都一样，所以在成长的路上不用太过焦虑，沉下心来：单点突破。</strong></p>\n<p>2019.01.17</p>\n<p><strong>“我相信每个孩子，都曾在心底许下‘孝’的宏愿，相信来日方长，相信水到渠成，相信自己必有功成名就、衣锦还乡的那一天，可以从容尽孝。</strong></p>\n<p><strong>可人们忘了，忘了时间的残酷，忘了人生的短暂，忘了世上有永远无法报答的恩情，忘了生命本身有不堪一击的脆弱。”</strong></p>\n<p>2018.10.31</p>\n<p><strong>当你的能力还驾驭不了你的目标时，就应该沉下心来，历练。</strong></p>\n<p>2018.2.23</p>\n<p><strong>朱光潜先生有一个人生信念，是我十分佩服，并想贯彻到底的。</strong></p>\n<p><strong>凡此身应该做而且能够做的事，决不推诿给别人。</strong></p>\n<p><strong>凡此时应该做而且能够做的事，决不推延到将来。</strong></p>\n<p><strong>凡此地应该做而且能够做的事，决不等待想象中更好的境地。</strong></p>\n<p><strong>其实这段文字，可以总结成六个字：</strong></p>\n<p><strong>此身、此时、此地。</strong></p>\n<p>2018.1.31</p>\n<p><strong>千秋邈矣独留我，百战归来再读书。</strong></p>\n<p>2018.1.23</p>\n<p><strong>好的爱情是投射，你在她身上，永远能看到那个翩翩少年与慈爱父亲合二为一的自己。如果你在她身上无法投射出更好的自己，宁可失去她，也不要失去自己。</strong></p>\n<p><strong>拥有一件东西的最好办法是成为配的上它的人，想成为一个成功的男士，首先也必须自身能拥有这些品性。</strong></p>\n<p>2018.1.15</p>\n<p><strong>我一直以为人是慢慢变老的，其实不是，人是一瞬间变老的。人变老不是从第一道皱纹、第一根白发开始的，而是从放弃自己的那一刻开始的。只有对自己不放弃的人，才能活得不会老，老去的只是年龄，不老的是气质。让人不老的特质是必须有一颗童心，注重仪表，经常旅行，学习到老……    –村上春树</strong></p>\n<p>2017.12.22</p>\n<p><strong>你要琢磨清楚自己想在什么行业发展，使用何种技术，做什么产品或服务，给自己设立目标，让这个目标指引着你前进。</strong></p>\n<p>2017.12.15</p>\n<p><strong>1.我们的世界是由极端、未知和非常不可能发生的事物主导的。</strong></p>\n<p><strong>2.不要相信中等风险事件，也就是不要相信稳定。人们一般都明白高风险和零风险的概念，但是中等风险则有很大的迷惑性，因为它受巨大的测量误差的影响。</strong></p>\n<p><strong>3.观察过去的经验得出未来的规律，出现的问题可能比我们想像的要严重。因为相同的过去的数据既可以证明一个理论，又可以同时证明另一个完全相反的理论。如果你明年还活着，可能意味着你更接近长生不老，或者你更接近死亡？</strong></p>\n<p><strong>4.预测是不靠谱的，但是我们可以判断出哪一个事物是脆弱的，哪一个事物是强韧的。我们只要押注脆弱的事物最终会崩溃即可。</strong></p>\n<p><strong>所以风险并不可怕，可怕的是对风险毫无准备。</strong></p>\n<p>2017.11.28</p>\n<p><strong>财富走向定律:</strong></p>\n<p><strong>1.在地域上，由农村走向城市。</strong></p>\n<p><strong>2.在人群上，财富走向这些人，正面思考者、把工作当事业而非事情、知道行动与阅历重于知识、爱投资而非购物、崇拜并追随强者、有重复做简单事情的毅力、明天事今天做的人。</strong></p>\n<p>2017.10.18</p>\n<p><strong>三流的点子加一流的执行力，永远比一流的点子加三流的执行力更好。 ——孙正义</strong></p>\n<p>2017.05.09</p>\n<p><strong>编程语言只是用来表达思想的工具，不同的语言在不同方面做了取舍。我们要做的是学好后面的思想，然后为当前的项目选择合适的语言和框架。做到这一点的人会得到码农的荣誉称号：Architect.</strong></p>\n<p>2017.04.21</p>\n<p><strong>在金融行业，十年的业务积累强于十年的技术积累。</strong></p>\n<p>2017.04.13</p>\n<p><strong>如果一件事需要干两次以上,那么你该为它写个自动脚本。</strong></p>\n<p>2017.04.06</p>\n<p><strong>Talking is cheap, show you the code.</strong></p>\n<p>2017.03.21</p>\n<p><strong>志于高者得于中。</strong></p>\n<p>2017.03.09</p>\n<p><strong>与恶龙缠斗过久,自身亦成为恶龙；凝视深渊过久,深渊将回以凝视。</strong></p>\n<p>2017.02.23</p>\n<p><strong>男儿至死是少年，赤心不改真英雄。</strong></p>\n<p><strong>满地都是六便士，他却抬头看见了月亮。</strong></p>\n<p>2017.02.22</p>\n<p><strong>1.工作经验不是指你做一件事情做了多久，而是指，你用了多久的时间，去思考、优化、改善它；</strong></p>\n<p><strong>2.无论任何时候，听到任何重要信息、被分配到任何事务，第一直觉不是去执行，也不是去思考，而是记录下来；</strong></p>\n<p><strong>3.管理时间开销。当你从工作状态切换出去的时候，瞥一眼系统时间；当你重新进入工作的时候，再瞥一眼时间。将这两个时间点记下来；</strong></p>\n<p><strong>4.文档命名增加版本号，格式要明确，存放位置要固定；</strong></p>\n<p><strong>5.做checklist。</strong></p>\n<p>2017.02.21</p>\n<p><strong>遍身罗绮者，不是养蚕人。</strong></p>\n<p>2017.02.16</p>\n<p><strong>对于互联网产品公司来说，有海量用户，还看不到清晰的盈利模式，是最好的投资时机。</strong></p>\n<p>2017.02.15</p>\n<p><strong>有时候，“虚惊一场”这四个字是人世间最美好的成语，比起什么兴高采烈，五彩缤纷，一帆风顺都要美好百倍。你可懂什么叫失去。这些时间来，更觉如此。愿悲伤恐惧能够过去，事外之人更懂珍惜。——韩寒</strong></p>\n<p>2017.02.08</p>\n<p><strong>君子生非异也，善假于物也。</strong></p>\n<p><strong>因为一旦这种终极快感这么简单就能获得的话，你就不会在对其他各种通过努力获得的快感产生兴趣。——《蜗居》</strong></p>\n<p>2017.01.19</p>\n<p><strong>You can be anything,but you can’t be everything.</strong></p>\n<p>2017.01.10</p>\n<p><strong>失去了对世界的探索之心，努力求稳，求可以安安稳稳地度过余生，这便是老了。</strong><br><strong>你以为我也是庸碌之辈吗？你们知道我多么伟大吗？我曾经无数次战胜自己，我没有尽头，我不可阻挡。</strong></p>\n<p>2017.01.07</p>\n<p><strong>Money is the McMancion in Sarasota, that starts falling apart after ten years,Power is the old stone building that stands for centuries.  ——《纸牌屋》</strong></p>\n<p>2016.12.06</p>\n<p><strong>程序其实是给人看的，只是机器恰好可以运行它。</strong><br><strong>因为人性，因为贪婪，因为恐惧。必要的时候不敢扣动扳机，危险的时候，又被吓得不敢动弹。</strong></p>\n<p>2016.11.22</p>\n<p><strong>大多数人死在了25岁，却一直到75岁才埋葬。</strong><br><strong>我宁愿酗酒吸毒，34岁就家破人亡，但成为别人餐桌上的话题，也不要腰缠万贯红光满面地活到90岁但没人记得我。   ——安德鲁，爆裂鼓手</strong></p>\n<p>2016.11.18</p>\n<p><strong>我们内心的懒惰、恐惧和侥幸附带各种各样的借口，在本该有的行动之前树起了重重无形的阻碍。这些心理的阻碍往往超越了这些行动本身的难度。</strong></p>\n<p>2016.11.05</p>\n<p><strong>Your best is yet to come.</strong></p>\n<p>2016.10.27</p>\n<p><strong>在python中写程序有时候是一种喜悦的分享，而不是一种迫于竞争的追求。学习它的新特性，欣赏它的设计，它的优雅，它的洗练，完全是一种乐趣。</strong></p>\n<p>2016.10.14</p>\n<p><strong>莫道君行早，更有早行人。全心敲代码，天道自酬勤。</strong></p>\n<p>2016.10.12</p>\n<p><strong>好好学习，天天向上。</strong></p>\n<p>2016.09.26</p>\n<p><strong>花儿依旧那么香，鸟儿依旧在欢唱，这个城市就是这样，人来人往，匆匆忙忙。</strong></p>\n<p>2016.09.19</p>\n<p><strong>English,for me ,means freedom.</strong></p>\n<p>2016.09.12</p>\n<p><strong>人生三坑：一，莫名其妙地凑热闹：二，心急火燎地随大流，三，操碎了别人的心肝。</strong></p>\n<p>2016.09.11</p>\n<p><strong>our luck is turning around.</strong></p>\n<p>2016.08.08</p>\n<p><strong>自律给我自由</strong></p>\n<p>2016.08.06</p>\n<p><strong>I’m a slow walker , but I never walk back.</strong></p>\n"},{"title":"All tags","date":"2016-04-07T03:29:22.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: All tags\ndate: 2016-04-07 11:29:22\ntype: \"tags\"\ncomments: false\n---\n","updated":"2019-03-22T14:44:36.743Z","path":"tags/index.html","layout":"page","_id":"ck6cbwmub00044l3nltr3zecr","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"网络时间的获取与同步","date":"2016-06-21T15:54:52.000Z","_content":"![图片](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-6-21/25375430.jpg)\n最近接到新的任务，由于窗体应用程序上传的时间是基于电脑系统的时间，有可能在不同电脑所获取的时间不一致，因此需要增加一个打开应用时获取网络时间并进行本机时间的同步。网上也参考了一些例子，发现都多多少少存在问题。这里封装了两个类，之后直接调用该类即可。自己动手，丰衣足食。\n<!-- more -->\n\n## 网络时间的获取\n\n```\n public class NetTime\n {\n     ///<summary>\n     /// 获取标准北京时间\n     ///</summary>\n     ///<returns></returns>\n     public DateTime GetStandardTime()\n     {\n\n         DateTime dt;\n         WebRequest wrt = null;\n         WebResponse wrp = null;\n         try\n         {\n             wrt = WebRequest.Create(\"http://www.hko.gov.hk/cgi-bin/gts/time5a.pr?a=2\");\n             wrt.Credentials = CredentialCache.DefaultCredentials;\n\n             wrp = wrt.GetResponse();\n             StreamReader sr = new StreamReader(wrp.GetResponseStream(), Encoding.UTF8);\n             string html = sr.ReadToEnd();\n\n             sr.Close();\n             wrp.Close(); \n             char[] timeStamp=new char[10];\n             html.CopyTo(2,timeStamp,0,10);//CopyTo中 sourceindex表示需要复制的字符的起始位置，destination表示目标字符数组， destinatonindex指定目标数组中开始存放的位置，count表示要复制的字符个数\n             string ts = new string(timeStamp);\n             DateTime dtStart = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1));\n             long lTime = long.Parse(ts+\"0000000\");\n             TimeSpan toNow = new TimeSpan(lTime);\n             return dtStart.Add(toNow);\n         }\n         catch (WebException)\n         {\n             return DateTime.Parse(\"2011-1-1\");\n         }\n         catch (Exception)\n         {\n             return DateTime.Parse(\"2011-1-1\");\n         }\n         finally\n         {\n             if (wrp != null)\n                 wrp.Close();\n             if (wrt != null)\n                 wrt.Abort();\n         }\n     }\n\n}\n```\n\n## 同步到本机时间\n\n\n```\n   public class UpdateTime\n    {\n        //设置系统时间的API函数\n        [DllImport(\"kernel32.dll\")]\n        private static extern bool SetLocalTime(ref SYSTEMTIME time);\n        [StructLayout(LayoutKind.Sequential)]\n        private struct SYSTEMTIME\n        {\n            public short year;\n            public short month;\n            public short dayOfWeek;\n            public short day;\n            public short hour;\n            public short minute;\n            public short second;\n            public short milliseconds;\n        }\n        /// <summary>\n        /// 设置系统时间\n        /// </summary>\n        /// <param name=\"dt\">需要设置的时间</param>\n        /// <returns>返回系统时间设置状态，true为成功，false为失败</returns>\n        public static bool SetDate(DateTime dt)\n        {\n            SYSTEMTIME st;\n            st.year = (short)dt.Year;\n            st.month = (short)dt.Month;\n            st.dayOfWeek = (short)dt.DayOfWeek;\n            st.day = (short)dt.Day;\n            st.hour = (short)dt.Hour;\n            st.minute = (short)dt.Minute;\n            st.second = (short)dt.Second;\n            st.milliseconds = (short)dt.Millisecond;\n            bool rt = SetLocalTime(ref st);\n            return rt;\n        }\n    }\n```","source":"_posts/C#/网络时间的获取与同步.md","raw":"---\ntitle: 网络时间的获取与同步\ndate: 2016-06-21 23:54:52\ntags:\n- c#\ncategories: c#\n---\n![图片](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-6-21/25375430.jpg)\n最近接到新的任务，由于窗体应用程序上传的时间是基于电脑系统的时间，有可能在不同电脑所获取的时间不一致，因此需要增加一个打开应用时获取网络时间并进行本机时间的同步。网上也参考了一些例子，发现都多多少少存在问题。这里封装了两个类，之后直接调用该类即可。自己动手，丰衣足食。\n<!-- more -->\n\n## 网络时间的获取\n\n```\n public class NetTime\n {\n     ///<summary>\n     /// 获取标准北京时间\n     ///</summary>\n     ///<returns></returns>\n     public DateTime GetStandardTime()\n     {\n\n         DateTime dt;\n         WebRequest wrt = null;\n         WebResponse wrp = null;\n         try\n         {\n             wrt = WebRequest.Create(\"http://www.hko.gov.hk/cgi-bin/gts/time5a.pr?a=2\");\n             wrt.Credentials = CredentialCache.DefaultCredentials;\n\n             wrp = wrt.GetResponse();\n             StreamReader sr = new StreamReader(wrp.GetResponseStream(), Encoding.UTF8);\n             string html = sr.ReadToEnd();\n\n             sr.Close();\n             wrp.Close(); \n             char[] timeStamp=new char[10];\n             html.CopyTo(2,timeStamp,0,10);//CopyTo中 sourceindex表示需要复制的字符的起始位置，destination表示目标字符数组， destinatonindex指定目标数组中开始存放的位置，count表示要复制的字符个数\n             string ts = new string(timeStamp);\n             DateTime dtStart = TimeZone.CurrentTimeZone.ToLocalTime(new DateTime(1970, 1, 1));\n             long lTime = long.Parse(ts+\"0000000\");\n             TimeSpan toNow = new TimeSpan(lTime);\n             return dtStart.Add(toNow);\n         }\n         catch (WebException)\n         {\n             return DateTime.Parse(\"2011-1-1\");\n         }\n         catch (Exception)\n         {\n             return DateTime.Parse(\"2011-1-1\");\n         }\n         finally\n         {\n             if (wrp != null)\n                 wrp.Close();\n             if (wrt != null)\n                 wrt.Abort();\n         }\n     }\n\n}\n```\n\n## 同步到本机时间\n\n\n```\n   public class UpdateTime\n    {\n        //设置系统时间的API函数\n        [DllImport(\"kernel32.dll\")]\n        private static extern bool SetLocalTime(ref SYSTEMTIME time);\n        [StructLayout(LayoutKind.Sequential)]\n        private struct SYSTEMTIME\n        {\n            public short year;\n            public short month;\n            public short dayOfWeek;\n            public short day;\n            public short hour;\n            public short minute;\n            public short second;\n            public short milliseconds;\n        }\n        /// <summary>\n        /// 设置系统时间\n        /// </summary>\n        /// <param name=\"dt\">需要设置的时间</param>\n        /// <returns>返回系统时间设置状态，true为成功，false为失败</returns>\n        public static bool SetDate(DateTime dt)\n        {\n            SYSTEMTIME st;\n            st.year = (short)dt.Year;\n            st.month = (short)dt.Month;\n            st.dayOfWeek = (short)dt.DayOfWeek;\n            st.day = (short)dt.Day;\n            st.hour = (short)dt.Hour;\n            st.minute = (short)dt.Minute;\n            st.second = (short)dt.Second;\n            st.milliseconds = (short)dt.Millisecond;\n            bool rt = SetLocalTime(ref st);\n            return rt;\n        }\n    }\n```","slug":"C#/网络时间的获取与同步","published":1,"updated":"2019-03-22T14:44:36.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmva00054l3naxsu8gs7","content":"<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-6-21/25375430.jpg\" alt=\"图片\"><br>最近接到新的任务，由于窗体应用程序上传的时间是基于电脑系统的时间，有可能在不同电脑所获取的时间不一致，因此需要增加一个打开应用时获取网络时间并进行本机时间的同步。网上也参考了一些例子，发现都多多少少存在问题。这里封装了两个类，之后直接调用该类即可。自己动手，丰衣足食。<br><a id=\"more\"></a></p>\n<h2 id=\"网络时间的获取\"><a href=\"#网络时间的获取\" class=\"headerlink\" title=\"网络时间的获取\"></a>网络时间的获取</h2><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">NetTime</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span><span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> 获取标准北京时间</span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span><span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span><span class=\"doctag\">&lt;returns&gt;</span><span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> DateTime <span class=\"title\">GetStandardTime</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>     &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         DateTime dt;</span><br><span class=\"line\">         WebRequest wrt = <span class=\"literal\">null</span>;</span><br><span class=\"line\">         WebResponse wrp = <span class=\"literal\">null</span>;</span><br><span class=\"line\">         <span class=\"keyword\">try</span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             wrt = WebRequest.Create(<span class=\"string\">\"http://www.hko.gov.hk/cgi-bin/gts/time5a.pr?a=2\"</span>);</span><br><span class=\"line\">             wrt.Credentials = CredentialCache.DefaultCredentials;</span><br><span class=\"line\"></span><br><span class=\"line\">             wrp = wrt.GetResponse();</span><br><span class=\"line\">             StreamReader sr = <span class=\"keyword\">new</span> StreamReader(wrp.GetResponseStream(), Encoding.UTF8);</span><br><span class=\"line\">             <span class=\"keyword\">string</span> html = sr.ReadToEnd();</span><br><span class=\"line\"></span><br><span class=\"line\">             sr.Close();</span><br><span class=\"line\">             wrp.Close(); </span><br><span class=\"line\">             <span class=\"keyword\">char</span>[] timeStamp=<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">             html.CopyTo(<span class=\"number\">2</span>,timeStamp,<span class=\"number\">0</span>,<span class=\"number\">10</span>);<span class=\"comment\">//CopyTo中 sourceindex表示需要复制的字符的起始位置，destination表示目标字符数组， destinatonindex指定目标数组中开始存放的位置，count表示要复制的字符个数</span></span><br><span class=\"line\">             <span class=\"keyword\">string</span> ts = <span class=\"keyword\">new</span> <span class=\"keyword\">string</span>(timeStamp);</span><br><span class=\"line\">             DateTime dtStart = TimeZone.CurrentTimeZone.ToLocalTime(<span class=\"keyword\">new</span> DateTime(<span class=\"number\">1970</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">             <span class=\"keyword\">long</span> lTime = <span class=\"keyword\">long</span>.Parse(ts+<span class=\"string\">\"0000000\"</span>);</span><br><span class=\"line\">             TimeSpan toNow = <span class=\"keyword\">new</span> TimeSpan(lTime);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> dtStart.Add(toNow);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">catch</span> (WebException)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> DateTime.Parse(<span class=\"string\">\"2011-1-1\"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">catch</span> (Exception)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> DateTime.Parse(<span class=\"string\">\"2011-1-1\"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">finally</span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (wrp != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                 wrp.Close();</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (wrt != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                 wrt.Abort();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"同步到本机时间\"><a href=\"#同步到本机时间\" class=\"headerlink\" title=\"同步到本机时间\"></a>同步到本机时间</h2><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UpdateTime</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//设置系统时间的API函数</span></span><br><span class=\"line\">     [<span class=\"meta\">DllImport(<span class=\"meta-string\">\"kernel32.dll\"</span>)</span>]</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> <span class=\"keyword\">bool</span> <span class=\"title\">SetLocalTime</span>(<span class=\"params\"><span class=\"keyword\">ref</span> SYSTEMTIME time</span>)</span>;</span><br><span class=\"line\">     [<span class=\"meta\">StructLayout(LayoutKind.Sequential)</span>]</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">struct</span> SYSTEMTIME</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> year;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> month;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> dayOfWeek;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> day;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> hour;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> minute;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> second;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> milliseconds;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> 设置系统时间</span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=\"dt\"&gt;</span>需要设置的时间<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span>返回系统时间设置状态，true为成功，false为失败<span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">SetDate</span>(<span class=\"params\">DateTime dt</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>     &#123;</span><br><span class=\"line\">         SYSTEMTIME st;</span><br><span class=\"line\">         st.year = (<span class=\"keyword\">short</span>)dt.Year;</span><br><span class=\"line\">         st.month = (<span class=\"keyword\">short</span>)dt.Month;</span><br><span class=\"line\">         st.dayOfWeek = (<span class=\"keyword\">short</span>)dt.DayOfWeek;</span><br><span class=\"line\">         st.day = (<span class=\"keyword\">short</span>)dt.Day;</span><br><span class=\"line\">         st.hour = (<span class=\"keyword\">short</span>)dt.Hour;</span><br><span class=\"line\">         st.minute = (<span class=\"keyword\">short</span>)dt.Minute;</span><br><span class=\"line\">         st.second = (<span class=\"keyword\">short</span>)dt.Second;</span><br><span class=\"line\">         st.milliseconds = (<span class=\"keyword\">short</span>)dt.Millisecond;</span><br><span class=\"line\">         <span class=\"keyword\">bool</span> rt = SetLocalTime(<span class=\"keyword\">ref</span> st);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> rt;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-6-21/25375430.jpg\" alt=\"图片\"><br>最近接到新的任务，由于窗体应用程序上传的时间是基于电脑系统的时间，有可能在不同电脑所获取的时间不一致，因此需要增加一个打开应用时获取网络时间并进行本机时间的同步。网上也参考了一些例子，发现都多多少少存在问题。这里封装了两个类，之后直接调用该类即可。自己动手，丰衣足食。<br></p>","more":"<p></p>\n<h2 id=\"网络时间的获取\"><a href=\"#网络时间的获取\" class=\"headerlink\" title=\"网络时间的获取\"></a>网络时间的获取</h2><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">NetTime</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span><span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> 获取标准北京时间</span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span><span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span><span class=\"doctag\">&lt;returns&gt;</span><span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> DateTime <span class=\"title\">GetStandardTime</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>     &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">         DateTime dt;</span><br><span class=\"line\">         WebRequest wrt = <span class=\"literal\">null</span>;</span><br><span class=\"line\">         WebResponse wrp = <span class=\"literal\">null</span>;</span><br><span class=\"line\">         <span class=\"keyword\">try</span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             wrt = WebRequest.Create(<span class=\"string\">\"http://www.hko.gov.hk/cgi-bin/gts/time5a.pr?a=2\"</span>);</span><br><span class=\"line\">             wrt.Credentials = CredentialCache.DefaultCredentials;</span><br><span class=\"line\"></span><br><span class=\"line\">             wrp = wrt.GetResponse();</span><br><span class=\"line\">             StreamReader sr = <span class=\"keyword\">new</span> StreamReader(wrp.GetResponseStream(), Encoding.UTF8);</span><br><span class=\"line\">             <span class=\"keyword\">string</span> html = sr.ReadToEnd();</span><br><span class=\"line\"></span><br><span class=\"line\">             sr.Close();</span><br><span class=\"line\">             wrp.Close(); </span><br><span class=\"line\">             <span class=\"keyword\">char</span>[] timeStamp=<span class=\"keyword\">new</span> <span class=\"keyword\">char</span>[<span class=\"number\">10</span>];</span><br><span class=\"line\">             html.CopyTo(<span class=\"number\">2</span>,timeStamp,<span class=\"number\">0</span>,<span class=\"number\">10</span>);<span class=\"comment\">//CopyTo中 sourceindex表示需要复制的字符的起始位置，destination表示目标字符数组， destinatonindex指定目标数组中开始存放的位置，count表示要复制的字符个数</span></span><br><span class=\"line\">             <span class=\"keyword\">string</span> ts = <span class=\"keyword\">new</span> <span class=\"keyword\">string</span>(timeStamp);</span><br><span class=\"line\">             DateTime dtStart = TimeZone.CurrentTimeZone.ToLocalTime(<span class=\"keyword\">new</span> DateTime(<span class=\"number\">1970</span>, <span class=\"number\">1</span>, <span class=\"number\">1</span>));</span><br><span class=\"line\">             <span class=\"keyword\">long</span> lTime = <span class=\"keyword\">long</span>.Parse(ts+<span class=\"string\">\"0000000\"</span>);</span><br><span class=\"line\">             TimeSpan toNow = <span class=\"keyword\">new</span> TimeSpan(lTime);</span><br><span class=\"line\">             <span class=\"keyword\">return</span> dtStart.Add(toNow);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">catch</span> (WebException)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> DateTime.Parse(<span class=\"string\">\"2011-1-1\"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">catch</span> (Exception)</span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             <span class=\"keyword\">return</span> DateTime.Parse(<span class=\"string\">\"2011-1-1\"</span>);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">         <span class=\"keyword\">finally</span></span><br><span class=\"line\">         &#123;</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (wrp != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                 wrp.Close();</span><br><span class=\"line\">             <span class=\"keyword\">if</span> (wrt != <span class=\"literal\">null</span>)</span><br><span class=\"line\">                 wrt.Abort();</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"同步到本机时间\"><a href=\"#同步到本机时间\" class=\"headerlink\" title=\"同步到本机时间\"></a>同步到本机时间</h2><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">class</span> <span class=\"title\">UpdateTime</span></span><br><span class=\"line\"> &#123;</span><br><span class=\"line\">     <span class=\"comment\">//设置系统时间的API函数</span></span><br><span class=\"line\">     [<span class=\"meta\">DllImport(<span class=\"meta-string\">\"kernel32.dll\"</span>)</span>]</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">extern</span> <span class=\"keyword\">bool</span> <span class=\"title\">SetLocalTime</span>(<span class=\"params\"><span class=\"keyword\">ref</span> SYSTEMTIME time</span>)</span>;</span><br><span class=\"line\">     [<span class=\"meta\">StructLayout(LayoutKind.Sequential)</span>]</span><br><span class=\"line\">     <span class=\"keyword\">private</span> <span class=\"keyword\">struct</span> SYSTEMTIME</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> year;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> month;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> dayOfWeek;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> day;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> hour;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> minute;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> second;</span><br><span class=\"line\">         <span class=\"keyword\">public</span> <span class=\"keyword\">short</span> milliseconds;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> 设置系统时间</span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=\"dt\"&gt;</span>需要设置的时间<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">     <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span>返回系统时间设置状态，true为成功，false为失败<span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">bool</span> <span class=\"title\">SetDate</span>(<span class=\"params\">DateTime dt</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>     &#123;</span><br><span class=\"line\">         SYSTEMTIME st;</span><br><span class=\"line\">         st.year = (<span class=\"keyword\">short</span>)dt.Year;</span><br><span class=\"line\">         st.month = (<span class=\"keyword\">short</span>)dt.Month;</span><br><span class=\"line\">         st.dayOfWeek = (<span class=\"keyword\">short</span>)dt.DayOfWeek;</span><br><span class=\"line\">         st.day = (<span class=\"keyword\">short</span>)dt.Day;</span><br><span class=\"line\">         st.hour = (<span class=\"keyword\">short</span>)dt.Hour;</span><br><span class=\"line\">         st.minute = (<span class=\"keyword\">short</span>)dt.Minute;</span><br><span class=\"line\">         st.second = (<span class=\"keyword\">short</span>)dt.Second;</span><br><span class=\"line\">         st.milliseconds = (<span class=\"keyword\">short</span>)dt.Millisecond;</span><br><span class=\"line\">         <span class=\"keyword\">bool</span> rt = SetLocalTime(<span class=\"keyword\">ref</span> st);</span><br><span class=\"line\">         <span class=\"keyword\">return</span> rt;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>"},{"title":"C++ API设计","date":"2016-09-29T15:14:50.000Z","_content":"\n## 什么是API\n\nAPI(Application Programming Interface)提供了对某个问题的抽象，以及客户和解决该问题软件组件之间进行交互的方式。\n\n组件通常以软件类库的形式分发，可以在多个应用程序中使用。目前的应用程序往往是由很多API建立而成，而这些API往往依赖于其他API。\n\nAPI的目的是为某个组件的功能提供一个逻辑接口，同时隐藏该模块的具体实现。即代码只能通过该API的公共接口进行访问。也就是说，提供了一个抽象的接口，所以更多的将API理解为Abstract Programming Interface。\n\n### C++中的API\n\n在C++中一般包含三个部分：\n1.一个或多个头文件，定义了接口，使得客户端能够对其进行编译。开源API还包括其`.cpp`文件。\n\n2.库文件，某个API的特定实现可以被链接到用户程序的库文件中。可以为静态库，如Windows下的`.lib`文件和Linux，Mac OS下的`.a`文件。又或者是动态库，如Windows下的`.dll`文件和Linux，Mac OS下的`.so`文件。\n\n3.辅助文档，如何使用API的概述信息。通常包括为API中所有的类和函数自动生成的文档。\n\n### API设计的注意事项\n\n1.**API是给开发者设计的接口。** 设计拙劣的API很有可能让你的用户转向竞争者的怀抱。\n\n2.**多应用共享一个API。** 一旦出错，造成的影响巨大。\n\n3.**修改API时必须保证向后兼容。** 在计算机中指在一个程序或者类库更新到较新的版本后，用旧的版本程序创建的文档或系统仍能被正常操作或使用，或在旧版本的类库的基础上开发的程序仍能正常编译运行的情况。\n\n4.**API必须有良好的设计、文档、回归测试，并且保证发布之间的稳定性。** \n\n### SDK与API\nSDK(软件开发工具包)为安装在计算机特定平台的包，目的是使用一个或多个API来构建应用。除了上述API所要求的东西之外，还要包含支持其他帮助使用API的资源。\n\n## 特征\n\n### 良好的抽象\n\n在设计API时，应该阐述在选定问题域内有意义的深层概念，而不是公开底层实现细节。当你把API文档提供给一位非程序员是，他应该能够理解接口中的概念并且知道他的工作机制。一种API不仅仅只有一种方式建模，每种方式都可以提供良好的抽象和易用的接口，关键是API应该有一致且合理的支撑体系。\n\n![UML](http://7xsp7y.com1.z0.glb.clouddn.com/blog/20170509/163752039.png)\n\n这边先介绍一下UML类图。UML规范定义了一组面向对象软件系统的可视化建模符号。类用方框表示，该方框被分成三个区域，上层为类名，中层为列出类的属性，下层区域为类的方法。\n\n方框中每条记录都可以添加前缀符，来对因属性或方法的可见性。`+` 表示共有类成员，`-` 表示私有类成员，`#` 表示受保护的类成员。\n\n类之间的关系可以用多种样式的连接线和箭头表示。\n\n关联：两个类之间的简单的依赖关系，两者互不从属于对方，用实线表示。带有方向，UML用开放箭头表示方向，比如“>”。\n\n聚合：“has-a”关系，或者整体与部分的关系，两个类互不从属对方。用空心菱形的直线表示。\n\n组合：“contain-a”关系，部分和整体具有统一的生存期。用带有实心菱形的直线表示。\n\n泛化：类之间的父子关系，用带空心三角箭头的直线表示。\n\n对象间的各种关系可以在某个对象边用注释定义，这样就能分辨出他们的关系是一对一还是多对一还是多对多。常见的一些关系有：`0..1` 表示零个或一个实例，`1`表示一个实例，`0..*` 表示0个或多个实例， `1..*` 表示一个或多个实例。","source":"_posts/C++/C++ API设计.md","raw":"---\ntitle: C++ API设计\ndate: 2016-09-29 23:14:50\ntags: \n- C++\ncategories: 总结\n---\n\n## 什么是API\n\nAPI(Application Programming Interface)提供了对某个问题的抽象，以及客户和解决该问题软件组件之间进行交互的方式。\n\n组件通常以软件类库的形式分发，可以在多个应用程序中使用。目前的应用程序往往是由很多API建立而成，而这些API往往依赖于其他API。\n\nAPI的目的是为某个组件的功能提供一个逻辑接口，同时隐藏该模块的具体实现。即代码只能通过该API的公共接口进行访问。也就是说，提供了一个抽象的接口，所以更多的将API理解为Abstract Programming Interface。\n\n### C++中的API\n\n在C++中一般包含三个部分：\n1.一个或多个头文件，定义了接口，使得客户端能够对其进行编译。开源API还包括其`.cpp`文件。\n\n2.库文件，某个API的特定实现可以被链接到用户程序的库文件中。可以为静态库，如Windows下的`.lib`文件和Linux，Mac OS下的`.a`文件。又或者是动态库，如Windows下的`.dll`文件和Linux，Mac OS下的`.so`文件。\n\n3.辅助文档，如何使用API的概述信息。通常包括为API中所有的类和函数自动生成的文档。\n\n### API设计的注意事项\n\n1.**API是给开发者设计的接口。** 设计拙劣的API很有可能让你的用户转向竞争者的怀抱。\n\n2.**多应用共享一个API。** 一旦出错，造成的影响巨大。\n\n3.**修改API时必须保证向后兼容。** 在计算机中指在一个程序或者类库更新到较新的版本后，用旧的版本程序创建的文档或系统仍能被正常操作或使用，或在旧版本的类库的基础上开发的程序仍能正常编译运行的情况。\n\n4.**API必须有良好的设计、文档、回归测试，并且保证发布之间的稳定性。** \n\n### SDK与API\nSDK(软件开发工具包)为安装在计算机特定平台的包，目的是使用一个或多个API来构建应用。除了上述API所要求的东西之外，还要包含支持其他帮助使用API的资源。\n\n## 特征\n\n### 良好的抽象\n\n在设计API时，应该阐述在选定问题域内有意义的深层概念，而不是公开底层实现细节。当你把API文档提供给一位非程序员是，他应该能够理解接口中的概念并且知道他的工作机制。一种API不仅仅只有一种方式建模，每种方式都可以提供良好的抽象和易用的接口，关键是API应该有一致且合理的支撑体系。\n\n![UML](http://7xsp7y.com1.z0.glb.clouddn.com/blog/20170509/163752039.png)\n\n这边先介绍一下UML类图。UML规范定义了一组面向对象软件系统的可视化建模符号。类用方框表示，该方框被分成三个区域，上层为类名，中层为列出类的属性，下层区域为类的方法。\n\n方框中每条记录都可以添加前缀符，来对因属性或方法的可见性。`+` 表示共有类成员，`-` 表示私有类成员，`#` 表示受保护的类成员。\n\n类之间的关系可以用多种样式的连接线和箭头表示。\n\n关联：两个类之间的简单的依赖关系，两者互不从属于对方，用实线表示。带有方向，UML用开放箭头表示方向，比如“>”。\n\n聚合：“has-a”关系，或者整体与部分的关系，两个类互不从属对方。用空心菱形的直线表示。\n\n组合：“contain-a”关系，部分和整体具有统一的生存期。用带有实心菱形的直线表示。\n\n泛化：类之间的父子关系，用带空心三角箭头的直线表示。\n\n对象间的各种关系可以在某个对象边用注释定义，这样就能分辨出他们的关系是一对一还是多对一还是多对多。常见的一些关系有：`0..1` 表示零个或一个实例，`1`表示一个实例，`0..*` 表示0个或多个实例， `1..*` 表示一个或多个实例。","slug":"C++/C++ API设计","published":1,"updated":"2019-03-22T14:44:36.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmvf00064l3nh8d2dy52","content":"<h2 id=\"什么是API\"><a href=\"#什么是API\" class=\"headerlink\" title=\"什么是API\"></a>什么是API</h2><p>API(Application Programming Interface)提供了对某个问题的抽象，以及客户和解决该问题软件组件之间进行交互的方式。</p>\n<p>组件通常以软件类库的形式分发，可以在多个应用程序中使用。目前的应用程序往往是由很多API建立而成，而这些API往往依赖于其他API。</p>\n<p>API的目的是为某个组件的功能提供一个逻辑接口，同时隐藏该模块的具体实现。即代码只能通过该API的公共接口进行访问。也就是说，提供了一个抽象的接口，所以更多的将API理解为Abstract Programming Interface。</p>\n<h3 id=\"C-中的API\"><a href=\"#C-中的API\" class=\"headerlink\" title=\"C++中的API\"></a>C++中的API</h3><p>在C++中一般包含三个部分：<br>1.一个或多个头文件，定义了接口，使得客户端能够对其进行编译。开源API还包括其<code>.cpp</code>文件。</p>\n<p>2.库文件，某个API的特定实现可以被链接到用户程序的库文件中。可以为静态库，如Windows下的<code>.lib</code>文件和Linux，Mac OS下的<code>.a</code>文件。又或者是动态库，如Windows下的<code>.dll</code>文件和Linux，Mac OS下的<code>.so</code>文件。</p>\n<p>3.辅助文档，如何使用API的概述信息。通常包括为API中所有的类和函数自动生成的文档。</p>\n<h3 id=\"API设计的注意事项\"><a href=\"#API设计的注意事项\" class=\"headerlink\" title=\"API设计的注意事项\"></a>API设计的注意事项</h3><p>1.<strong>API是给开发者设计的接口。</strong> 设计拙劣的API很有可能让你的用户转向竞争者的怀抱。</p>\n<p>2.<strong>多应用共享一个API。</strong> 一旦出错，造成的影响巨大。</p>\n<p>3.<strong>修改API时必须保证向后兼容。</strong> 在计算机中指在一个程序或者类库更新到较新的版本后，用旧的版本程序创建的文档或系统仍能被正常操作或使用，或在旧版本的类库的基础上开发的程序仍能正常编译运行的情况。</p>\n<p>4.<strong>API必须有良好的设计、文档、回归测试，并且保证发布之间的稳定性。</strong> </p>\n<h3 id=\"SDK与API\"><a href=\"#SDK与API\" class=\"headerlink\" title=\"SDK与API\"></a>SDK与API</h3><p>SDK(软件开发工具包)为安装在计算机特定平台的包，目的是使用一个或多个API来构建应用。除了上述API所要求的东西之外，还要包含支持其他帮助使用API的资源。</p>\n<h2 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h2><h3 id=\"良好的抽象\"><a href=\"#良好的抽象\" class=\"headerlink\" title=\"良好的抽象\"></a>良好的抽象</h3><p>在设计API时，应该阐述在选定问题域内有意义的深层概念，而不是公开底层实现细节。当你把API文档提供给一位非程序员是，他应该能够理解接口中的概念并且知道他的工作机制。一种API不仅仅只有一种方式建模，每种方式都可以提供良好的抽象和易用的接口，关键是API应该有一致且合理的支撑体系。</p>\n<p><img src=\"http://7xsp7y.com1.z0.glb.clouddn.com/blog/20170509/163752039.png\" alt=\"UML\"></p>\n<p>这边先介绍一下UML类图。UML规范定义了一组面向对象软件系统的可视化建模符号。类用方框表示，该方框被分成三个区域，上层为类名，中层为列出类的属性，下层区域为类的方法。</p>\n<p>方框中每条记录都可以添加前缀符，来对因属性或方法的可见性。<code>+</code> 表示共有类成员，<code>-</code> 表示私有类成员，<code>#</code> 表示受保护的类成员。</p>\n<p>类之间的关系可以用多种样式的连接线和箭头表示。</p>\n<p>关联：两个类之间的简单的依赖关系，两者互不从属于对方，用实线表示。带有方向，UML用开放箭头表示方向，比如“&gt;”。</p>\n<p>聚合：“has-a”关系，或者整体与部分的关系，两个类互不从属对方。用空心菱形的直线表示。</p>\n<p>组合：“contain-a”关系，部分和整体具有统一的生存期。用带有实心菱形的直线表示。</p>\n<p>泛化：类之间的父子关系，用带空心三角箭头的直线表示。</p>\n<p>对象间的各种关系可以在某个对象边用注释定义，这样就能分辨出他们的关系是一对一还是多对一还是多对多。常见的一些关系有：<code>0..1</code> 表示零个或一个实例，<code>1</code>表示一个实例，<code>0..*</code> 表示0个或多个实例， <code>1..*</code> 表示一个或多个实例。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"什么是API\"><a href=\"#什么是API\" class=\"headerlink\" title=\"什么是API\"></a>什么是API</h2><p>API(Application Programming Interface)提供了对某个问题的抽象，以及客户和解决该问题软件组件之间进行交互的方式。</p>\n<p>组件通常以软件类库的形式分发，可以在多个应用程序中使用。目前的应用程序往往是由很多API建立而成，而这些API往往依赖于其他API。</p>\n<p>API的目的是为某个组件的功能提供一个逻辑接口，同时隐藏该模块的具体实现。即代码只能通过该API的公共接口进行访问。也就是说，提供了一个抽象的接口，所以更多的将API理解为Abstract Programming Interface。</p>\n<h3 id=\"C-中的API\"><a href=\"#C-中的API\" class=\"headerlink\" title=\"C++中的API\"></a>C++中的API</h3><p>在C++中一般包含三个部分：<br>1.一个或多个头文件，定义了接口，使得客户端能够对其进行编译。开源API还包括其<code>.cpp</code>文件。</p>\n<p>2.库文件，某个API的特定实现可以被链接到用户程序的库文件中。可以为静态库，如Windows下的<code>.lib</code>文件和Linux，Mac OS下的<code>.a</code>文件。又或者是动态库，如Windows下的<code>.dll</code>文件和Linux，Mac OS下的<code>.so</code>文件。</p>\n<p>3.辅助文档，如何使用API的概述信息。通常包括为API中所有的类和函数自动生成的文档。</p>\n<h3 id=\"API设计的注意事项\"><a href=\"#API设计的注意事项\" class=\"headerlink\" title=\"API设计的注意事项\"></a>API设计的注意事项</h3><p>1.<strong>API是给开发者设计的接口。</strong> 设计拙劣的API很有可能让你的用户转向竞争者的怀抱。</p>\n<p>2.<strong>多应用共享一个API。</strong> 一旦出错，造成的影响巨大。</p>\n<p>3.<strong>修改API时必须保证向后兼容。</strong> 在计算机中指在一个程序或者类库更新到较新的版本后，用旧的版本程序创建的文档或系统仍能被正常操作或使用，或在旧版本的类库的基础上开发的程序仍能正常编译运行的情况。</p>\n<p>4.<strong>API必须有良好的设计、文档、回归测试，并且保证发布之间的稳定性。</strong> </p>\n<h3 id=\"SDK与API\"><a href=\"#SDK与API\" class=\"headerlink\" title=\"SDK与API\"></a>SDK与API</h3><p>SDK(软件开发工具包)为安装在计算机特定平台的包，目的是使用一个或多个API来构建应用。除了上述API所要求的东西之外，还要包含支持其他帮助使用API的资源。</p>\n<h2 id=\"特征\"><a href=\"#特征\" class=\"headerlink\" title=\"特征\"></a>特征</h2><h3 id=\"良好的抽象\"><a href=\"#良好的抽象\" class=\"headerlink\" title=\"良好的抽象\"></a>良好的抽象</h3><p>在设计API时，应该阐述在选定问题域内有意义的深层概念，而不是公开底层实现细节。当你把API文档提供给一位非程序员是，他应该能够理解接口中的概念并且知道他的工作机制。一种API不仅仅只有一种方式建模，每种方式都可以提供良好的抽象和易用的接口，关键是API应该有一致且合理的支撑体系。</p>\n<p><img src=\"http://7xsp7y.com1.z0.glb.clouddn.com/blog/20170509/163752039.png\" alt=\"UML\"></p>\n<p>这边先介绍一下UML类图。UML规范定义了一组面向对象软件系统的可视化建模符号。类用方框表示，该方框被分成三个区域，上层为类名，中层为列出类的属性，下层区域为类的方法。</p>\n<p>方框中每条记录都可以添加前缀符，来对因属性或方法的可见性。<code>+</code> 表示共有类成员，<code>-</code> 表示私有类成员，<code>#</code> 表示受保护的类成员。</p>\n<p>类之间的关系可以用多种样式的连接线和箭头表示。</p>\n<p>关联：两个类之间的简单的依赖关系，两者互不从属于对方，用实线表示。带有方向，UML用开放箭头表示方向，比如“&gt;”。</p>\n<p>聚合：“has-a”关系，或者整体与部分的关系，两个类互不从属对方。用空心菱形的直线表示。</p>\n<p>组合：“contain-a”关系，部分和整体具有统一的生存期。用带有实心菱形的直线表示。</p>\n<p>泛化：类之间的父子关系，用带空心三角箭头的直线表示。</p>\n<p>对象间的各种关系可以在某个对象边用注释定义，这样就能分辨出他们的关系是一对一还是多对一还是多对多。常见的一些关系有：<code>0..1</code> 表示零个或一个实例，<code>1</code>表示一个实例，<code>0..*</code> 表示0个或多个实例， <code>1..*</code> 表示一个或多个实例。</p>\n"},{"title":"C++常见陷阱","date":"2018-04-23T12:22:00.000Z","_content":"\n最近的一次C++相关培训,让我对C++一些细节开始注意起来,做一个简单的学习记录。\n### 1.数据存放方式\n\n数据存放方式与cpu有关,一般小端存放,服务器大端存放。因此，在网络进行数据传输,需要hton(主机序到网络序)和ntoh互相转换,传输以网络序为主。同理，当作为文件存放时，若需要跨机器，则需要转网络序。\n<!--more-->\n\n### 2.strlen()的坑\n\n当你要获取长度的字符串有`\\0`存在的时候，获取得到的不是真正的长度。\n\n### 3.函数调用\n\n当函数调用需要对字符串进行操作时,不要在函数内部进行声明局部变量，因为在`return`时便已经不复存在这个变量了,其所指的地址已经被破坏。有些人的改法是作为函数内的静态变量引入，但多线程的情况下对静态变量重复赋值会导致问题。最好的方式便是字符串作为入参,以保证数据的一致性。很多标准库的函数也不是如此做的，为了保证线程安全，linux标准库采用 `_r`结尾来表示该函数线程安全，同时也提供了原函数，但不保证线程安全。\n\n### 4.对临时变量的正确认识\n\n函数内的临时变量是在栈内存中生成的，栈空间（2M）十分有限，作为临时变量，其充分条件为尽量小，需小于栈空间。必要条件则是临时用。当需要很大的临时变量时，需动态生成，但必须记得释放。\n\n### 5.移位操作的陷阱\n\nC++中时常会用到移位操作，当其为一般数据都没有问题。但要注意对负数进行移位操作，需要考虑到符号位的影响，当取补码的时候，需要将原码取反加一，然后移位，将会导致得不到想要的数。\n\n### 6. 对象清零的风险点\n\n有些时候需要将对象清零,为了图方便会使用memset清零,但是这同时也导致了一个问题,清空后将无法使用。原因是有些用到虚函数的类，在初始化的时候便会创建虚表，memset将会破坏虚表,导致对象无法使用。同理，对于结构体内存在有特殊的成员变量（例如其他对象）则也慎用memset清空，最好的办法还是一一清空。\n关于虚表的推荐书籍:《深入探索C++模型》\n\n### 7.cmap的使用\ncmap的使用,本质是HashMap,而map的本质是红黑树,Cmap在大数据量的情况下效率会很低。\n\n### 8.浮点数的存放方式\na.分别计算整数,小数\nb.二进制表达法\nc.规则化移位\n符号 指数部分移码 + 01111111111\n精度分析\n\n### 9. 一些常见的计算时长分析\n(1)数学运算 <1ns\n(2)内存  100ns\n(3)I/O -网络  60us(高度调优) 100us\n    -文件  100ns~10ms\n    -控制台  100us~1ms \n\n\n### 10.写在最后\n尽量避免频繁内存的申请和释放。另外还有注意命名规范，例如全局用 `g_`开头 , 成员 `m_`开头, 静态 `s_`开头, 指针 `lp`开头, int  `i_`开头, double `df`开头, float `f`开头等等，可以避免一些由于命名不规范导致的问题，例如sprinf参数格式对不上之类的。\n\n\n","source":"_posts/C++/C++陷阱.md","raw":"---\ntitle: C++常见陷阱\ndate: 2018-04-23 20:22:00\ntags: \n- C++\ncategories: 总结\n---\n\n最近的一次C++相关培训,让我对C++一些细节开始注意起来,做一个简单的学习记录。\n### 1.数据存放方式\n\n数据存放方式与cpu有关,一般小端存放,服务器大端存放。因此，在网络进行数据传输,需要hton(主机序到网络序)和ntoh互相转换,传输以网络序为主。同理，当作为文件存放时，若需要跨机器，则需要转网络序。\n<!--more-->\n\n### 2.strlen()的坑\n\n当你要获取长度的字符串有`\\0`存在的时候，获取得到的不是真正的长度。\n\n### 3.函数调用\n\n当函数调用需要对字符串进行操作时,不要在函数内部进行声明局部变量，因为在`return`时便已经不复存在这个变量了,其所指的地址已经被破坏。有些人的改法是作为函数内的静态变量引入，但多线程的情况下对静态变量重复赋值会导致问题。最好的方式便是字符串作为入参,以保证数据的一致性。很多标准库的函数也不是如此做的，为了保证线程安全，linux标准库采用 `_r`结尾来表示该函数线程安全，同时也提供了原函数，但不保证线程安全。\n\n### 4.对临时变量的正确认识\n\n函数内的临时变量是在栈内存中生成的，栈空间（2M）十分有限，作为临时变量，其充分条件为尽量小，需小于栈空间。必要条件则是临时用。当需要很大的临时变量时，需动态生成，但必须记得释放。\n\n### 5.移位操作的陷阱\n\nC++中时常会用到移位操作，当其为一般数据都没有问题。但要注意对负数进行移位操作，需要考虑到符号位的影响，当取补码的时候，需要将原码取反加一，然后移位，将会导致得不到想要的数。\n\n### 6. 对象清零的风险点\n\n有些时候需要将对象清零,为了图方便会使用memset清零,但是这同时也导致了一个问题,清空后将无法使用。原因是有些用到虚函数的类，在初始化的时候便会创建虚表，memset将会破坏虚表,导致对象无法使用。同理，对于结构体内存在有特殊的成员变量（例如其他对象）则也慎用memset清空，最好的办法还是一一清空。\n关于虚表的推荐书籍:《深入探索C++模型》\n\n### 7.cmap的使用\ncmap的使用,本质是HashMap,而map的本质是红黑树,Cmap在大数据量的情况下效率会很低。\n\n### 8.浮点数的存放方式\na.分别计算整数,小数\nb.二进制表达法\nc.规则化移位\n符号 指数部分移码 + 01111111111\n精度分析\n\n### 9. 一些常见的计算时长分析\n(1)数学运算 <1ns\n(2)内存  100ns\n(3)I/O -网络  60us(高度调优) 100us\n    -文件  100ns~10ms\n    -控制台  100us~1ms \n\n\n### 10.写在最后\n尽量避免频繁内存的申请和释放。另外还有注意命名规范，例如全局用 `g_`开头 , 成员 `m_`开头, 静态 `s_`开头, 指针 `lp`开头, int  `i_`开头, double `df`开头, float `f`开头等等，可以避免一些由于命名不规范导致的问题，例如sprinf参数格式对不上之类的。\n\n\n","slug":"C++/C++陷阱","published":1,"updated":"2019-03-22T14:44:36.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmvk00094l3nob0xl898","content":"<p>最近的一次C++相关培训,让我对C++一些细节开始注意起来,做一个简单的学习记录。</p>\n<h3 id=\"1-数据存放方式\"><a href=\"#1-数据存放方式\" class=\"headerlink\" title=\"1.数据存放方式\"></a>1.数据存放方式</h3><p>数据存放方式与cpu有关,一般小端存放,服务器大端存放。因此，在网络进行数据传输,需要hton(主机序到网络序)和ntoh互相转换,传输以网络序为主。同理，当作为文件存放时，若需要跨机器，则需要转网络序。<br><a id=\"more\"></a></p>\n<h3 id=\"2-strlen-的坑\"><a href=\"#2-strlen-的坑\" class=\"headerlink\" title=\"2.strlen()的坑\"></a>2.strlen()的坑</h3><p>当你要获取长度的字符串有<code>\\0</code>存在的时候，获取得到的不是真正的长度。</p>\n<h3 id=\"3-函数调用\"><a href=\"#3-函数调用\" class=\"headerlink\" title=\"3.函数调用\"></a>3.函数调用</h3><p>当函数调用需要对字符串进行操作时,不要在函数内部进行声明局部变量，因为在<code>return</code>时便已经不复存在这个变量了,其所指的地址已经被破坏。有些人的改法是作为函数内的静态变量引入，但多线程的情况下对静态变量重复赋值会导致问题。最好的方式便是字符串作为入参,以保证数据的一致性。很多标准库的函数也不是如此做的，为了保证线程安全，linux标准库采用 <code>_r</code>结尾来表示该函数线程安全，同时也提供了原函数，但不保证线程安全。</p>\n<h3 id=\"4-对临时变量的正确认识\"><a href=\"#4-对临时变量的正确认识\" class=\"headerlink\" title=\"4.对临时变量的正确认识\"></a>4.对临时变量的正确认识</h3><p>函数内的临时变量是在栈内存中生成的，栈空间（2M）十分有限，作为临时变量，其充分条件为尽量小，需小于栈空间。必要条件则是临时用。当需要很大的临时变量时，需动态生成，但必须记得释放。</p>\n<h3 id=\"5-移位操作的陷阱\"><a href=\"#5-移位操作的陷阱\" class=\"headerlink\" title=\"5.移位操作的陷阱\"></a>5.移位操作的陷阱</h3><p>C++中时常会用到移位操作，当其为一般数据都没有问题。但要注意对负数进行移位操作，需要考虑到符号位的影响，当取补码的时候，需要将原码取反加一，然后移位，将会导致得不到想要的数。</p>\n<h3 id=\"6-对象清零的风险点\"><a href=\"#6-对象清零的风险点\" class=\"headerlink\" title=\"6. 对象清零的风险点\"></a>6. 对象清零的风险点</h3><p>有些时候需要将对象清零,为了图方便会使用memset清零,但是这同时也导致了一个问题,清空后将无法使用。原因是有些用到虚函数的类，在初始化的时候便会创建虚表，memset将会破坏虚表,导致对象无法使用。同理，对于结构体内存在有特殊的成员变量（例如其他对象）则也慎用memset清空，最好的办法还是一一清空。<br>关于虚表的推荐书籍:《深入探索C++模型》</p>\n<h3 id=\"7-cmap的使用\"><a href=\"#7-cmap的使用\" class=\"headerlink\" title=\"7.cmap的使用\"></a>7.cmap的使用</h3><p>cmap的使用,本质是HashMap,而map的本质是红黑树,Cmap在大数据量的情况下效率会很低。</p>\n<h3 id=\"8-浮点数的存放方式\"><a href=\"#8-浮点数的存放方式\" class=\"headerlink\" title=\"8.浮点数的存放方式\"></a>8.浮点数的存放方式</h3><p>a.分别计算整数,小数<br>b.二进制表达法<br>c.规则化移位<br>符号 指数部分移码 + 01111111111<br>精度分析</p>\n<h3 id=\"9-一些常见的计算时长分析\"><a href=\"#9-一些常见的计算时长分析\" class=\"headerlink\" title=\"9. 一些常见的计算时长分析\"></a>9. 一些常见的计算时长分析</h3><p>(1)数学运算 &lt;1ns<br>(2)内存  100ns<br>(3)I/O -网络  60us(高度调优) 100us<br>    -文件  100ns~10ms<br>    -控制台  100us~1ms </p>\n<h3 id=\"10-写在最后\"><a href=\"#10-写在最后\" class=\"headerlink\" title=\"10.写在最后\"></a>10.写在最后</h3><p>尽量避免频繁内存的申请和释放。另外还有注意命名规范，例如全局用 <code>g_</code>开头 , 成员 <code>m_</code>开头, 静态 <code>s_</code>开头, 指针 <code>lp</code>开头, int  <code>i_</code>开头, double <code>df</code>开头, float <code>f</code>开头等等，可以避免一些由于命名不规范导致的问题，例如sprinf参数格式对不上之类的。</p>\n","site":{"data":{}},"excerpt":"<p>最近的一次C++相关培训,让我对C++一些细节开始注意起来,做一个简单的学习记录。</p>\n<h3 id=\"1-数据存放方式\"><a href=\"#1-数据存放方式\" class=\"headerlink\" title=\"1.数据存放方式\"></a>1.数据存放方式</h3><p>数据存放方式与cpu有关,一般小端存放,服务器大端存放。因此，在网络进行数据传输,需要hton(主机序到网络序)和ntoh互相转换,传输以网络序为主。同理，当作为文件存放时，若需要跨机器，则需要转网络序。<br></p>","more":"<p></p>\n<h3 id=\"2-strlen-的坑\"><a href=\"#2-strlen-的坑\" class=\"headerlink\" title=\"2.strlen()的坑\"></a>2.strlen()的坑</h3><p>当你要获取长度的字符串有<code>\\0</code>存在的时候，获取得到的不是真正的长度。</p>\n<h3 id=\"3-函数调用\"><a href=\"#3-函数调用\" class=\"headerlink\" title=\"3.函数调用\"></a>3.函数调用</h3><p>当函数调用需要对字符串进行操作时,不要在函数内部进行声明局部变量，因为在<code>return</code>时便已经不复存在这个变量了,其所指的地址已经被破坏。有些人的改法是作为函数内的静态变量引入，但多线程的情况下对静态变量重复赋值会导致问题。最好的方式便是字符串作为入参,以保证数据的一致性。很多标准库的函数也不是如此做的，为了保证线程安全，linux标准库采用 <code>_r</code>结尾来表示该函数线程安全，同时也提供了原函数，但不保证线程安全。</p>\n<h3 id=\"4-对临时变量的正确认识\"><a href=\"#4-对临时变量的正确认识\" class=\"headerlink\" title=\"4.对临时变量的正确认识\"></a>4.对临时变量的正确认识</h3><p>函数内的临时变量是在栈内存中生成的，栈空间（2M）十分有限，作为临时变量，其充分条件为尽量小，需小于栈空间。必要条件则是临时用。当需要很大的临时变量时，需动态生成，但必须记得释放。</p>\n<h3 id=\"5-移位操作的陷阱\"><a href=\"#5-移位操作的陷阱\" class=\"headerlink\" title=\"5.移位操作的陷阱\"></a>5.移位操作的陷阱</h3><p>C++中时常会用到移位操作，当其为一般数据都没有问题。但要注意对负数进行移位操作，需要考虑到符号位的影响，当取补码的时候，需要将原码取反加一，然后移位，将会导致得不到想要的数。</p>\n<h3 id=\"6-对象清零的风险点\"><a href=\"#6-对象清零的风险点\" class=\"headerlink\" title=\"6. 对象清零的风险点\"></a>6. 对象清零的风险点</h3><p>有些时候需要将对象清零,为了图方便会使用memset清零,但是这同时也导致了一个问题,清空后将无法使用。原因是有些用到虚函数的类，在初始化的时候便会创建虚表，memset将会破坏虚表,导致对象无法使用。同理，对于结构体内存在有特殊的成员变量（例如其他对象）则也慎用memset清空，最好的办法还是一一清空。<br>关于虚表的推荐书籍:《深入探索C++模型》</p>\n<h3 id=\"7-cmap的使用\"><a href=\"#7-cmap的使用\" class=\"headerlink\" title=\"7.cmap的使用\"></a>7.cmap的使用</h3><p>cmap的使用,本质是HashMap,而map的本质是红黑树,Cmap在大数据量的情况下效率会很低。</p>\n<h3 id=\"8-浮点数的存放方式\"><a href=\"#8-浮点数的存放方式\" class=\"headerlink\" title=\"8.浮点数的存放方式\"></a>8.浮点数的存放方式</h3><p>a.分别计算整数,小数<br>b.二进制表达法<br>c.规则化移位<br>符号 指数部分移码 + 01111111111<br>精度分析</p>\n<h3 id=\"9-一些常见的计算时长分析\"><a href=\"#9-一些常见的计算时长分析\" class=\"headerlink\" title=\"9. 一些常见的计算时长分析\"></a>9. 一些常见的计算时长分析</h3><p>(1)数学运算 &lt;1ns<br>(2)内存  100ns<br>(3)I/O -网络  60us(高度调优) 100us<br>    -文件  100ns~10ms<br>    -控制台  100us~1ms </p>\n<h3 id=\"10-写在最后\"><a href=\"#10-写在最后\" class=\"headerlink\" title=\"10.写在最后\"></a>10.写在最后</h3><p>尽量避免频繁内存的申请和释放。另外还有注意命名规范，例如全局用 <code>g_</code>开头 , 成员 <code>m_</code>开头, 静态 <code>s_</code>开头, 指针 <code>lp</code>开头, int  <code>i_</code>开头, double <code>df</code>开头, float <code>f</code>开头等等，可以避免一些由于命名不规范导致的问题，例如sprinf参数格式对不上之类的。</p>"},{"title":"javaweb总结（一）基础概念","date":"2017-02-14T14:22:50.000Z","_content":"毕设所需，之前的学习先停一下，先主攻`javaweb`。学习参考：\n\n[孤傲苍狼 博客](http://www.cnblogs.com/xdp-gacl/p/3729033.html)\n\n-------\n\n## 静态web\n静态web（如html 页面）：指web页面中供人们浏览的数据始终是不变。其存在以下几个缺点：\n1、Web页面中的内容无法动态更新，所有的用户每时每刻看见的内容和最终效果都是一样的。\n   为了可以让静态的WEB的显示更加好看，可以加入了JavaScript以完成一些页面上的显示特效，但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。\n2、静态WEB无法连接数据库，无法实现和用户的交互。\n\n<!-- more -->\n\n## 动态web\n动态web：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。常用动态web资源开发技术：JSP/Servlet、ASP、PHP等。动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server Plugin（服务器插件）来处理，此插件用于区分是请求的是静态资源(*.htm或者是*.htm)还是动态资源。\n\n如果WEB Server Plugin发现客户端请求的是静态资源(*.htm或者是*.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。\n\n如果WEB Server Plugin发现客户端请求的是动态资源（*.jsp、*.asp/*.aspx、*.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。\n\n### 动态Web的实现方式\n\n动态WEB现在的实现手段非常多，较为常见的有以下几种：\n\n1.Microsoft ASP、ASP.NET\n\n微软公司动态WEB开发是比较早的，而且最早在国内最流行的是ASP。ASP就是在HTML语言之中增加了VB脚本，但是标准的开发应用应该是使用ASP+COM，但是实际情况来看，在开发ASP的时候基本上都在一个页面中写上成百上千的代码，页面代码极其混乱。\n\nASP本身有开发平台的限制：Windows+IIS+SQL Server/Access，ASP只能运行在Windows操作系统上，ASP现在基本上已经淘汰，现在基本上都是使用ASP.NET进行开发，ASP.NET在性能有了很大的改善，而且开发迅速，但是依然受限于平台。ASP.NET中主要是使用C#语言。\n\n2.PHP\n\nPHP开发速度很快，功能强大，跨平台(平台指的就是运行的操作系统)，而且代码也简单。\n\n3.JAVA Servlet/JSP\n\n这是SUN公司(SUN现在已经被Oracle公司收购)主推的B/S架构的实现语言，是基于JAVA语言发展起来的，因为JAVA语言足够简单，而且很干净。\nServlet/JSP技术的性能也是非常高的，不受平台的限制，各个平台基本上都可以使用。而且在运行中是使用多线程的处理方式，所以性能非常高。\n\nSUN公司最早推出的WEB技术推出的是Servlet程序，Servlet程序本身使用的时候有一些问题，所有的程序是采用JAVA代码+HTML的方式编写的，即，要使用JAVA输出语句，一行一行地输出所有的HTML代码，之后，SUN公司受到了ASP的启发，发展出了JSP(Java Server Page)，JSP某些代码的编写效果与ASP是非常相似的。这样可以很方便地使一些ASP程序员转向JSP的学习，加大市场的竞争力度。\n\n## Tomcat\n我们这边使用到的是Tomcat作为我们的WEB服务器。Tomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范。\n\n我们在使用中，在其安装位置所在的`conf\\server.xml`中可以对服务器进行配置。\n\n### 端口配置\n```\n<Connector port=\"8080\" protocol=\"HTTP/1.1\"\n                connectionTimeout=\"20000\"\n                redirectPort=\"8443\" />\n```\n将其`port=\"8080\"`可改为任意不冲突端口。\n\n### 虚拟目录的映射方式\n\n在`<Host></Host>`这对标签加上`<Context path=\"/JavaWebApp\" docBase=\"F:\\JavaWebDemoProject\" />`即可将在F盘下的`JavaWebDemoProject`这个JavaWeb应用映射到`JavaWebApp`这个虚拟目录上，JavaWebApp这个虚拟目录是由Tomcat服务器管理的，JavaWebApp是一个硬盘上不存在的目录，是我们自己随便写的一个目录，也就是虚拟的一个目录，所以称之为\"虚拟目录\".\n\n## 浏览器与服务器交互的过程\n\n1. 浏览器发出请求，到host文件查询主机名对应的IP；\n2. 如果没找到，浏览器去互联网上的dns服务器查询主机名对应的IP；\n3. 浏览器根据查询的IP连上web服务器；\n4. 浏览器连接到web服务器后，就使用http协议向服务器发送`get`请求，浏览器会向Web服务器以Stream(流)的形式传输数据，告诉Web服务器要访问服务器里面的哪个Web应用下的Web资源；\n5. 之后浏览器开始等待，web服务器从http请求中解析出客户机要访问的主机名；\n6. web服务器从http请求中解析出客户机要访问的web应用；\n7. web服务器从http请求中解析出客户机要访问的web资源；\n8. web服务器从对应路径的web资源数据；\n9. web服务器回送数据。\n10. 浏览器拿到服务器传输给它的数据之后，就可以把数据展现给用户看了。\n\n## JavaWeb应用的组成结构\n\n开发JavaWeb应用时，不同类型的文件有严格的存放规则，否则不仅可能会使web应用无法访问，还会导致web服务器启动报错。\n\n`WEB-INF`：此文件夹用来存放java类、jar包、web应用的配置文件如`web.xml`，**该目录下的文件外界无法非法直接访问，由web服务器负责调用。**\n而与此文件夹位于同一文件夹内的文件可以直接访问。","source":"_posts/javaweb/javaweb总结(一)基础概念.md","raw":"---\ntitle: javaweb总结（一）基础概念\ndate: 2017-02-14 22:22:50\ntags: \n- javaweb\ncategories: 总结\n---\n毕设所需，之前的学习先停一下，先主攻`javaweb`。学习参考：\n\n[孤傲苍狼 博客](http://www.cnblogs.com/xdp-gacl/p/3729033.html)\n\n-------\n\n## 静态web\n静态web（如html 页面）：指web页面中供人们浏览的数据始终是不变。其存在以下几个缺点：\n1、Web页面中的内容无法动态更新，所有的用户每时每刻看见的内容和最终效果都是一样的。\n   为了可以让静态的WEB的显示更加好看，可以加入了JavaScript以完成一些页面上的显示特效，但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。\n2、静态WEB无法连接数据库，无法实现和用户的交互。\n\n<!-- more -->\n\n## 动态web\n动态web：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。常用动态web资源开发技术：JSP/Servlet、ASP、PHP等。动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server Plugin（服务器插件）来处理，此插件用于区分是请求的是静态资源(*.htm或者是*.htm)还是动态资源。\n\n如果WEB Server Plugin发现客户端请求的是静态资源(*.htm或者是*.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。\n\n如果WEB Server Plugin发现客户端请求的是动态资源（*.jsp、*.asp/*.aspx、*.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。\n\n### 动态Web的实现方式\n\n动态WEB现在的实现手段非常多，较为常见的有以下几种：\n\n1.Microsoft ASP、ASP.NET\n\n微软公司动态WEB开发是比较早的，而且最早在国内最流行的是ASP。ASP就是在HTML语言之中增加了VB脚本，但是标准的开发应用应该是使用ASP+COM，但是实际情况来看，在开发ASP的时候基本上都在一个页面中写上成百上千的代码，页面代码极其混乱。\n\nASP本身有开发平台的限制：Windows+IIS+SQL Server/Access，ASP只能运行在Windows操作系统上，ASP现在基本上已经淘汰，现在基本上都是使用ASP.NET进行开发，ASP.NET在性能有了很大的改善，而且开发迅速，但是依然受限于平台。ASP.NET中主要是使用C#语言。\n\n2.PHP\n\nPHP开发速度很快，功能强大，跨平台(平台指的就是运行的操作系统)，而且代码也简单。\n\n3.JAVA Servlet/JSP\n\n这是SUN公司(SUN现在已经被Oracle公司收购)主推的B/S架构的实现语言，是基于JAVA语言发展起来的，因为JAVA语言足够简单，而且很干净。\nServlet/JSP技术的性能也是非常高的，不受平台的限制，各个平台基本上都可以使用。而且在运行中是使用多线程的处理方式，所以性能非常高。\n\nSUN公司最早推出的WEB技术推出的是Servlet程序，Servlet程序本身使用的时候有一些问题，所有的程序是采用JAVA代码+HTML的方式编写的，即，要使用JAVA输出语句，一行一行地输出所有的HTML代码，之后，SUN公司受到了ASP的启发，发展出了JSP(Java Server Page)，JSP某些代码的编写效果与ASP是非常相似的。这样可以很方便地使一些ASP程序员转向JSP的学习，加大市场的竞争力度。\n\n## Tomcat\n我们这边使用到的是Tomcat作为我们的WEB服务器。Tomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范。\n\n我们在使用中，在其安装位置所在的`conf\\server.xml`中可以对服务器进行配置。\n\n### 端口配置\n```\n<Connector port=\"8080\" protocol=\"HTTP/1.1\"\n                connectionTimeout=\"20000\"\n                redirectPort=\"8443\" />\n```\n将其`port=\"8080\"`可改为任意不冲突端口。\n\n### 虚拟目录的映射方式\n\n在`<Host></Host>`这对标签加上`<Context path=\"/JavaWebApp\" docBase=\"F:\\JavaWebDemoProject\" />`即可将在F盘下的`JavaWebDemoProject`这个JavaWeb应用映射到`JavaWebApp`这个虚拟目录上，JavaWebApp这个虚拟目录是由Tomcat服务器管理的，JavaWebApp是一个硬盘上不存在的目录，是我们自己随便写的一个目录，也就是虚拟的一个目录，所以称之为\"虚拟目录\".\n\n## 浏览器与服务器交互的过程\n\n1. 浏览器发出请求，到host文件查询主机名对应的IP；\n2. 如果没找到，浏览器去互联网上的dns服务器查询主机名对应的IP；\n3. 浏览器根据查询的IP连上web服务器；\n4. 浏览器连接到web服务器后，就使用http协议向服务器发送`get`请求，浏览器会向Web服务器以Stream(流)的形式传输数据，告诉Web服务器要访问服务器里面的哪个Web应用下的Web资源；\n5. 之后浏览器开始等待，web服务器从http请求中解析出客户机要访问的主机名；\n6. web服务器从http请求中解析出客户机要访问的web应用；\n7. web服务器从http请求中解析出客户机要访问的web资源；\n8. web服务器从对应路径的web资源数据；\n9. web服务器回送数据。\n10. 浏览器拿到服务器传输给它的数据之后，就可以把数据展现给用户看了。\n\n## JavaWeb应用的组成结构\n\n开发JavaWeb应用时，不同类型的文件有严格的存放规则，否则不仅可能会使web应用无法访问，还会导致web服务器启动报错。\n\n`WEB-INF`：此文件夹用来存放java类、jar包、web应用的配置文件如`web.xml`，**该目录下的文件外界无法非法直接访问，由web服务器负责调用。**\n而与此文件夹位于同一文件夹内的文件可以直接访问。","slug":"javaweb/javaweb总结(一)基础概念","published":1,"updated":"2019-03-22T14:44:36.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmvl000a4l3n29wwvsz5","content":"<p>毕设所需，之前的学习先停一下，先主攻<code>javaweb</code>。学习参考：</p>\n<p><a href=\"http://www.cnblogs.com/xdp-gacl/p/3729033.html\" target=\"_blank\" rel=\"noopener\">孤傲苍狼 博客</a></p>\n<hr>\n<h2 id=\"静态web\"><a href=\"#静态web\" class=\"headerlink\" title=\"静态web\"></a>静态web</h2><p>静态web（如html 页面）：指web页面中供人们浏览的数据始终是不变。其存在以下几个缺点：<br>1、Web页面中的内容无法动态更新，所有的用户每时每刻看见的内容和最终效果都是一样的。<br>   为了可以让静态的WEB的显示更加好看，可以加入了JavaScript以完成一些页面上的显示特效，但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。<br>2、静态WEB无法连接数据库，无法实现和用户的交互。</p>\n<a id=\"more\"></a>\n<h2 id=\"动态web\"><a href=\"#动态web\" class=\"headerlink\" title=\"动态web\"></a>动态web</h2><p>动态web：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。常用动态web资源开发技术：JSP/Servlet、ASP、PHP等。动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server Plugin（服务器插件）来处理，此插件用于区分是请求的是静态资源(<em>.htm或者是</em>.htm)还是动态资源。</p>\n<p>如果WEB Server Plugin发现客户端请求的是静态资源(<em>.htm或者是</em>.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。</p>\n<p>如果WEB Server Plugin发现客户端请求的是动态资源（<em>.jsp、</em>.asp/<em>.aspx、</em>.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。</p>\n<h3 id=\"动态Web的实现方式\"><a href=\"#动态Web的实现方式\" class=\"headerlink\" title=\"动态Web的实现方式\"></a>动态Web的实现方式</h3><p>动态WEB现在的实现手段非常多，较为常见的有以下几种：</p>\n<p>1.Microsoft ASP、ASP.NET</p>\n<p>微软公司动态WEB开发是比较早的，而且最早在国内最流行的是ASP。ASP就是在HTML语言之中增加了VB脚本，但是标准的开发应用应该是使用ASP+COM，但是实际情况来看，在开发ASP的时候基本上都在一个页面中写上成百上千的代码，页面代码极其混乱。</p>\n<p>ASP本身有开发平台的限制：Windows+IIS+SQL Server/Access，ASP只能运行在Windows操作系统上，ASP现在基本上已经淘汰，现在基本上都是使用ASP.NET进行开发，ASP.NET在性能有了很大的改善，而且开发迅速，但是依然受限于平台。ASP.NET中主要是使用C#语言。</p>\n<p>2.PHP</p>\n<p>PHP开发速度很快，功能强大，跨平台(平台指的就是运行的操作系统)，而且代码也简单。</p>\n<p>3.JAVA Servlet/JSP</p>\n<p>这是SUN公司(SUN现在已经被Oracle公司收购)主推的B/S架构的实现语言，是基于JAVA语言发展起来的，因为JAVA语言足够简单，而且很干净。<br>Servlet/JSP技术的性能也是非常高的，不受平台的限制，各个平台基本上都可以使用。而且在运行中是使用多线程的处理方式，所以性能非常高。</p>\n<p>SUN公司最早推出的WEB技术推出的是Servlet程序，Servlet程序本身使用的时候有一些问题，所有的程序是采用JAVA代码+HTML的方式编写的，即，要使用JAVA输出语句，一行一行地输出所有的HTML代码，之后，SUN公司受到了ASP的启发，发展出了JSP(Java Server Page)，JSP某些代码的编写效果与ASP是非常相似的。这样可以很方便地使一些ASP程序员转向JSP的学习，加大市场的竞争力度。</p>\n<h2 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h2><p>我们这边使用到的是Tomcat作为我们的WEB服务器。Tomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范。</p>\n<p>我们在使用中，在其安装位置所在的<code>conf\\server.xml</code>中可以对服务器进行配置。</p>\n<h3 id=\"端口配置\"><a href=\"#端口配置\" class=\"headerlink\" title=\"端口配置\"></a>端口配置</h3><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector <span class=\"attribute\">port</span>=<span class=\"string\">\"8080\"</span> <span class=\"attribute\">protocol</span>=<span class=\"string\">\"HTTP/1.1\"</span></span><br><span class=\"line\">                <span class=\"attribute\">connectionTimeout</span>=<span class=\"string\">\"20000\"</span></span><br><span class=\"line\">                <span class=\"attribute\">redirectPort</span>=<span class=\"string\">\"8443\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>将其<code>port=&quot;8080&quot;</code>可改为任意不冲突端口。</p>\n<h3 id=\"虚拟目录的映射方式\"><a href=\"#虚拟目录的映射方式\" class=\"headerlink\" title=\"虚拟目录的映射方式\"></a>虚拟目录的映射方式</h3><p>在<code>&lt;Host&gt;&lt;/Host&gt;</code>这对标签加上<code>&lt;Context path=&quot;/JavaWebApp&quot; docBase=&quot;F:\\JavaWebDemoProject&quot; /&gt;</code>即可将在F盘下的<code>JavaWebDemoProject</code>这个JavaWeb应用映射到<code>JavaWebApp</code>这个虚拟目录上，JavaWebApp这个虚拟目录是由Tomcat服务器管理的，JavaWebApp是一个硬盘上不存在的目录，是我们自己随便写的一个目录，也就是虚拟的一个目录，所以称之为”虚拟目录”.</p>\n<h2 id=\"浏览器与服务器交互的过程\"><a href=\"#浏览器与服务器交互的过程\" class=\"headerlink\" title=\"浏览器与服务器交互的过程\"></a>浏览器与服务器交互的过程</h2><ol>\n<li>浏览器发出请求，到host文件查询主机名对应的IP；</li>\n<li>如果没找到，浏览器去互联网上的dns服务器查询主机名对应的IP；</li>\n<li>浏览器根据查询的IP连上web服务器；</li>\n<li>浏览器连接到web服务器后，就使用http协议向服务器发送<code>get</code>请求，浏览器会向Web服务器以Stream(流)的形式传输数据，告诉Web服务器要访问服务器里面的哪个Web应用下的Web资源；</li>\n<li>之后浏览器开始等待，web服务器从http请求中解析出客户机要访问的主机名；</li>\n<li>web服务器从http请求中解析出客户机要访问的web应用；</li>\n<li>web服务器从http请求中解析出客户机要访问的web资源；</li>\n<li>web服务器从对应路径的web资源数据；</li>\n<li>web服务器回送数据。</li>\n<li>浏览器拿到服务器传输给它的数据之后，就可以把数据展现给用户看了。</li>\n</ol>\n<h2 id=\"JavaWeb应用的组成结构\"><a href=\"#JavaWeb应用的组成结构\" class=\"headerlink\" title=\"JavaWeb应用的组成结构\"></a>JavaWeb应用的组成结构</h2><p>开发JavaWeb应用时，不同类型的文件有严格的存放规则，否则不仅可能会使web应用无法访问，还会导致web服务器启动报错。</p>\n<p><code>WEB-INF</code>：此文件夹用来存放java类、jar包、web应用的配置文件如<code>web.xml</code>，<strong>该目录下的文件外界无法非法直接访问，由web服务器负责调用。</strong><br>而与此文件夹位于同一文件夹内的文件可以直接访问。</p>\n","site":{"data":{}},"excerpt":"<p>毕设所需，之前的学习先停一下，先主攻<code>javaweb</code>。学习参考：</p>\n<p><a href=\"http://www.cnblogs.com/xdp-gacl/p/3729033.html\" target=\"_blank\" rel=\"noopener\">孤傲苍狼 博客</a></p>\n<hr>\n<h2 id=\"静态web\"><a href=\"#静态web\" class=\"headerlink\" title=\"静态web\"></a>静态web</h2><p>静态web（如html 页面）：指web页面中供人们浏览的数据始终是不变。其存在以下几个缺点：<br>1、Web页面中的内容无法动态更新，所有的用户每时每刻看见的内容和最终效果都是一样的。<br>   为了可以让静态的WEB的显示更加好看，可以加入了JavaScript以完成一些页面上的显示特效，但是这些特效都是在客户端上借助于浏览器展现给用户的，所以在服务器上本身并没有任何的变化。<br>2、静态WEB无法连接数据库，无法实现和用户的交互。</p>","more":"<h2 id=\"动态web\"><a href=\"#动态web\" class=\"headerlink\" title=\"动态web\"></a>动态web</h2><p>动态web：指web页面中供人们浏览的数据是由程序产生的，不同时间点访问web页面看到的内容各不相同。常用动态web资源开发技术：JSP/Servlet、ASP、PHP等。动态WEB中，程序依然使用客户端和服务端，客户端依然使用浏览器（IE、FireFox等），通过网络(Network)连接到服务器上，使用HTTP协议发起请求（Request），现在的所有请求都先经过一个WEB Server Plugin（服务器插件）来处理，此插件用于区分是请求的是静态资源(<em>.htm或者是</em>.htm)还是动态资源。</p>\n<p>如果WEB Server Plugin发现客户端请求的是静态资源(<em>.htm或者是</em>.htm)，则将请求直接转交给WEB服务器，之后WEB服务器从文件系统中取出内容，发送回客户端浏览器进行解析执行。</p>\n<p>如果WEB Server Plugin发现客户端请求的是动态资源（<em>.jsp、</em>.asp/<em>.aspx、</em>.php），则先将请求转交给WEB Container(WEB容器)，在WEB Container中连接数据库，从数据库中取出数据等一系列操作后动态拼凑页面的展示内容，拼凑页面的展示内容后，把所有的展示内容交给WEB服务器，之后通过WEB服务器将内容发送回客户端浏览器进行解析执行。</p>\n<h3 id=\"动态Web的实现方式\"><a href=\"#动态Web的实现方式\" class=\"headerlink\" title=\"动态Web的实现方式\"></a>动态Web的实现方式</h3><p>动态WEB现在的实现手段非常多，较为常见的有以下几种：</p>\n<p>1.Microsoft ASP、ASP.NET</p>\n<p>微软公司动态WEB开发是比较早的，而且最早在国内最流行的是ASP。ASP就是在HTML语言之中增加了VB脚本，但是标准的开发应用应该是使用ASP+COM，但是实际情况来看，在开发ASP的时候基本上都在一个页面中写上成百上千的代码，页面代码极其混乱。</p>\n<p>ASP本身有开发平台的限制：Windows+IIS+SQL Server/Access，ASP只能运行在Windows操作系统上，ASP现在基本上已经淘汰，现在基本上都是使用ASP.NET进行开发，ASP.NET在性能有了很大的改善，而且开发迅速，但是依然受限于平台。ASP.NET中主要是使用C#语言。</p>\n<p>2.PHP</p>\n<p>PHP开发速度很快，功能强大，跨平台(平台指的就是运行的操作系统)，而且代码也简单。</p>\n<p>3.JAVA Servlet/JSP</p>\n<p>这是SUN公司(SUN现在已经被Oracle公司收购)主推的B/S架构的实现语言，是基于JAVA语言发展起来的，因为JAVA语言足够简单，而且很干净。<br>Servlet/JSP技术的性能也是非常高的，不受平台的限制，各个平台基本上都可以使用。而且在运行中是使用多线程的处理方式，所以性能非常高。</p>\n<p>SUN公司最早推出的WEB技术推出的是Servlet程序，Servlet程序本身使用的时候有一些问题，所有的程序是采用JAVA代码+HTML的方式编写的，即，要使用JAVA输出语句，一行一行地输出所有的HTML代码，之后，SUN公司受到了ASP的启发，发展出了JSP(Java Server Page)，JSP某些代码的编写效果与ASP是非常相似的。这样可以很方便地使一些ASP程序员转向JSP的学习，加大市场的竞争力度。</p>\n<h2 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h2><p>我们这边使用到的是Tomcat作为我们的WEB服务器。Tomcat是一个实现了JAVA EE标准的最小的WEB服务器，是Apache 软件基金会的Jakarta项目中的一个核心项目，由Apache、Sun 和其他一些公司及个人共同开发而成。因为Tomcat 技术先进、性能稳定，而且开源免费，因而深受Java 爱好者的喜爱并得到了部分软件开发商的认可，成为目前比较流行的Web 应用服务器。学习JavaWeb开发一般都使用Tomcat服务器，该服务器支持全部JSP以及Servlet规范。</p>\n<p>我们在使用中，在其安装位置所在的<code>conf\\server.xml</code>中可以对服务器进行配置。</p>\n<h3 id=\"端口配置\"><a href=\"#端口配置\" class=\"headerlink\" title=\"端口配置\"></a>端口配置</h3><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;Connector <span class=\"attribute\">port</span>=<span class=\"string\">\"8080\"</span> <span class=\"attribute\">protocol</span>=<span class=\"string\">\"HTTP/1.1\"</span></span><br><span class=\"line\">                <span class=\"attribute\">connectionTimeout</span>=<span class=\"string\">\"20000\"</span></span><br><span class=\"line\">                <span class=\"attribute\">redirectPort</span>=<span class=\"string\">\"8443\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n<p>将其<code>port=&quot;8080&quot;</code>可改为任意不冲突端口。</p>\n<h3 id=\"虚拟目录的映射方式\"><a href=\"#虚拟目录的映射方式\" class=\"headerlink\" title=\"虚拟目录的映射方式\"></a>虚拟目录的映射方式</h3><p>在<code>&lt;Host&gt;&lt;/Host&gt;</code>这对标签加上<code>&lt;Context path=&quot;/JavaWebApp&quot; docBase=&quot;F:\\JavaWebDemoProject&quot; /&gt;</code>即可将在F盘下的<code>JavaWebDemoProject</code>这个JavaWeb应用映射到<code>JavaWebApp</code>这个虚拟目录上，JavaWebApp这个虚拟目录是由Tomcat服务器管理的，JavaWebApp是一个硬盘上不存在的目录，是我们自己随便写的一个目录，也就是虚拟的一个目录，所以称之为”虚拟目录”.</p>\n<h2 id=\"浏览器与服务器交互的过程\"><a href=\"#浏览器与服务器交互的过程\" class=\"headerlink\" title=\"浏览器与服务器交互的过程\"></a>浏览器与服务器交互的过程</h2><ol>\n<li>浏览器发出请求，到host文件查询主机名对应的IP；</li>\n<li>如果没找到，浏览器去互联网上的dns服务器查询主机名对应的IP；</li>\n<li>浏览器根据查询的IP连上web服务器；</li>\n<li>浏览器连接到web服务器后，就使用http协议向服务器发送<code>get</code>请求，浏览器会向Web服务器以Stream(流)的形式传输数据，告诉Web服务器要访问服务器里面的哪个Web应用下的Web资源；</li>\n<li>之后浏览器开始等待，web服务器从http请求中解析出客户机要访问的主机名；</li>\n<li>web服务器从http请求中解析出客户机要访问的web应用；</li>\n<li>web服务器从http请求中解析出客户机要访问的web资源；</li>\n<li>web服务器从对应路径的web资源数据；</li>\n<li>web服务器回送数据。</li>\n<li>浏览器拿到服务器传输给它的数据之后，就可以把数据展现给用户看了。</li>\n</ol>\n<h2 id=\"JavaWeb应用的组成结构\"><a href=\"#JavaWeb应用的组成结构\" class=\"headerlink\" title=\"JavaWeb应用的组成结构\"></a>JavaWeb应用的组成结构</h2><p>开发JavaWeb应用时，不同类型的文件有严格的存放规则，否则不仅可能会使web应用无法访问，还会导致web服务器启动报错。</p>\n<p><code>WEB-INF</code>：此文件夹用来存放java类、jar包、web应用的配置文件如<code>web.xml</code>，<strong>该目录下的文件外界无法非法直接访问，由web服务器负责调用。</strong><br>而与此文件夹位于同一文件夹内的文件可以直接访问。</p>"},{"title":"网络是如何连接的(1)","date":"2016-09-12T13:22:50.000Z","_content":"浏览器发出信息,首先会通过协议栈将消息打包,加上目的地址等控制信息,,接下来,将包交给网卡,将包转换成电信号通过网线发出。\n\n\n* 1.协议栈是指网络中各层协议的总和，其形象的反映了一个网络中文件传输的过程：由上层协议到底层协议，再由底层协议到上层协议\n","source":"_posts/WEB交互/网络是如何连接的(1).md","raw":"---\ntitle: 网络是如何连接的(1)\ndate: 2016-09-12 21:22:50\ntags: \n- WEB交互\ncategories: 总结\n---\n浏览器发出信息,首先会通过协议栈将消息打包,加上目的地址等控制信息,,接下来,将包交给网卡,将包转换成电信号通过网线发出。\n\n\n* 1.协议栈是指网络中各层协议的总和，其形象的反映了一个网络中文件传输的过程：由上层协议到底层协议，再由底层协议到上层协议\n","slug":"WEB交互/网络是如何连接的(1)","published":1,"updated":"2019-03-22T14:44:36.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmvo000b4l3ne01blqch","content":"<p>浏览器发出信息,首先会通过协议栈将消息打包,加上目的地址等控制信息,,接下来,将包交给网卡,将包转换成电信号通过网线发出。</p>\n<ul>\n<li>1.协议栈是指网络中各层协议的总和，其形象的反映了一个网络中文件传输的过程：由上层协议到底层协议，再由底层协议到上层协议</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>浏览器发出信息,首先会通过协议栈将消息打包,加上目的地址等控制信息,,接下来,将包交给网卡,将包转换成电信号通过网线发出。</p>\n<ul>\n<li>1.协议栈是指网络中各层协议的总和，其形象的反映了一个网络中文件传输的过程：由上层协议到底层协议，再由底层协议到上层协议</li>\n</ul>\n"},{"title":"Java反射机制和动态代理","date":"2018-11-19T09:35:00.000Z","_content":"编程语言按照不同的类型可区分为动态类型和静态类型,简单的区分他们是在运行时检查,还是在编译时检查.\n\n那么Java呢?通常认为,Java是静态的强类型语言,因为提供了类似反射等机制,也具备了部分动态类型语言的能力。\n\n<!-- more -->\n\n### 何为反射机制\n\n反射机制是Java语言提供的额一种基础功能,赋予程序在运行时自省(introspect)的能力.通过反射我们直接操作类或者对象,比如获取某个对象的类定义,获取类声明的属性和方法,调用方法或者构造对象,甚至可以运行时修改类定义。\n\n动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制来做到的，比如来包装RPC调用、面向切面的编程（AOP）。\n\n实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。\n\n反射，它就像是一种魔法，引入运行时自省能力，赋予了 Java 语言令人意外的活力，通过运行时操作元数据或对象，Java 可以灵活地操作运行时才能确定的信息。而动态代理，则是延伸出来的一种广泛应用于产品开发中的技术，很多繁琐的重复编程，都可以被动态代理机制优雅地解决。\n\n","source":"_posts/java学习/Java反射机制.md","raw":"---\ntitle: Java反射机制和动态代理\ndate: 2018-11-19 17:35:00\ntags: \n- java\ncategories: 总结\n---\n编程语言按照不同的类型可区分为动态类型和静态类型,简单的区分他们是在运行时检查,还是在编译时检查.\n\n那么Java呢?通常认为,Java是静态的强类型语言,因为提供了类似反射等机制,也具备了部分动态类型语言的能力。\n\n<!-- more -->\n\n### 何为反射机制\n\n反射机制是Java语言提供的额一种基础功能,赋予程序在运行时自省(introspect)的能力.通过反射我们直接操作类或者对象,比如获取某个对象的类定义,获取类声明的属性和方法,调用方法或者构造对象,甚至可以运行时修改类定义。\n\n动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制来做到的，比如来包装RPC调用、面向切面的编程（AOP）。\n\n实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。\n\n反射，它就像是一种魔法，引入运行时自省能力，赋予了 Java 语言令人意外的活力，通过运行时操作元数据或对象，Java 可以灵活地操作运行时才能确定的信息。而动态代理，则是延伸出来的一种广泛应用于产品开发中的技术，很多繁琐的重复编程，都可以被动态代理机制优雅地解决。\n\n","slug":"java学习/Java反射机制","published":1,"updated":"2019-03-22T14:44:36.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmvp000f4l3n2yfrtjlw","content":"<p>编程语言按照不同的类型可区分为动态类型和静态类型,简单的区分他们是在运行时检查,还是在编译时检查.</p>\n<p>那么Java呢?通常认为,Java是静态的强类型语言,因为提供了类似反射等机制,也具备了部分动态类型语言的能力。</p>\n<a id=\"more\"></a>\n<h3 id=\"何为反射机制\"><a href=\"#何为反射机制\" class=\"headerlink\" title=\"何为反射机制\"></a>何为反射机制</h3><p>反射机制是Java语言提供的额一种基础功能,赋予程序在运行时自省(introspect)的能力.通过反射我们直接操作类或者对象,比如获取某个对象的类定义,获取类声明的属性和方法,调用方法或者构造对象,甚至可以运行时修改类定义。</p>\n<p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制来做到的，比如来包装RPC调用、面向切面的编程（AOP）。</p>\n<p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p>\n<p>反射，它就像是一种魔法，引入运行时自省能力，赋予了 Java 语言令人意外的活力，通过运行时操作元数据或对象，Java 可以灵活地操作运行时才能确定的信息。而动态代理，则是延伸出来的一种广泛应用于产品开发中的技术，很多繁琐的重复编程，都可以被动态代理机制优雅地解决。</p>\n","site":{"data":{}},"excerpt":"<p>编程语言按照不同的类型可区分为动态类型和静态类型,简单的区分他们是在运行时检查,还是在编译时检查.</p>\n<p>那么Java呢?通常认为,Java是静态的强类型语言,因为提供了类似反射等机制,也具备了部分动态类型语言的能力。</p>","more":"<h3 id=\"何为反射机制\"><a href=\"#何为反射机制\" class=\"headerlink\" title=\"何为反射机制\"></a>何为反射机制</h3><p>反射机制是Java语言提供的额一种基础功能,赋予程序在运行时自省(introspect)的能力.通过反射我们直接操作类或者对象,比如获取某个对象的类定义,获取类声明的属性和方法,调用方法或者构造对象,甚至可以运行时修改类定义。</p>\n<p>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制，很多场景都是利用类似机制来做到的，比如来包装RPC调用、面向切面的编程（AOP）。</p>\n<p>实现动态代理的方式很多，比如 JDK 自身提供的动态代理，就是主要利用了上面提到的反射机制。还有其他的实现方式，比如利用传说中更高性能的字节码操作机制，类似 ASM、cglib（基于 ASM）、Javassist 等。</p>\n<p>反射，它就像是一种魔法，引入运行时自省能力，赋予了 Java 语言令人意外的活力，通过运行时操作元数据或对象，Java 可以灵活地操作运行时才能确定的信息。而动态代理，则是延伸出来的一种广泛应用于产品开发中的技术，很多繁琐的重复编程，都可以被动态代理机制优雅地解决。</p>"},{"title":"java spring学习总结（一）Ioc基本概念","date":"2018-05-12T07:35:00.000Z","_content":"\n最近在学习spring相关的知识点，推荐比较多的便是这本《spring 揭秘》，一边看一边做记录吧，以便反刍。\n\n<!-- more -->\n### Don’t call us, we will call you\nIoc(Inversion of Control),控制反转.被翻译的比较多的另一个名字是`依赖注入`。正如标题名所言,Ioc的精华就在于此。\n\n通常我需要依赖某个对象或服务时,最简单的方式便是在类的构造函数里直接新建相应的依赖类.好比是造新房时需要家具,我们直接打造一个出来。\n是回头想想，我们自己每次用到什么依赖对象都要主动地去获取，这是否真的必要？我们最终所要做的，其实就是直接调用依赖对象所提供的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。\n\n这里就引入了依赖注入的关系。被注入者会直接依赖于被依赖对象。通过`Ioc Service Provider`来统一管理两者的关系。从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转。\n\n### 三种注入方式\n在Martin Fowler的那篇文章“Inversion of Control Containers andthe Dependency Injection pattern”中， 提到了三种依赖注入的方式，即构造方法注入（constructor\ninjection）、 setter方法注入（setter injection）以及接口注入（interface injection）。\n\n构造方法注入，顾名思义，即在对象的构造方法时编带入依赖对象，这种注入方式比较直观，不会重复，且伴随整个生命周期，对象被构造完成后，即进入就绪状态，可以马上使用。但缺点就是在依赖的对象比较多的时候，构造方法参数的处理会比较困难，维护和使用比较困难。\n\nsetter方法注入，即在让对象构造完成后即可使用，但相对来说更宽松一些，可以在对象构造完成后再调用setter方法注入。有点事setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。\n\n接口注入，通过接口来依赖注入依赖对象。通过方法来将依赖的对象注入。这种方式的注入强制注入了不必要的接口，带有入侵性。而构造方法和setter方法注入则不需要如此。\n\n### Ioc的附加值\n使用Ioc的方式，不只是一个方向上的改变，不会对业务对象构成比较强的入侵性，使用Ioc模式之后，对象具有更好的可测试性、可重用性和可拓展性等。当需要新加依赖对象的时候，便体现出了可重用性。并且在编写测试案例时也非常的方便。Ioc是一种可以帮助我们解耦各业务对象依赖关系的对象绑定方式。\n\n","source":"_posts/java学习/IOC.md","raw":"---\ntitle: java spring学习总结（一）Ioc基本概念\ndate: 2018-05-12 15:35:00\ntags: \n- java\n- spring\ncategories: 总结\n---\n\n最近在学习spring相关的知识点，推荐比较多的便是这本《spring 揭秘》，一边看一边做记录吧，以便反刍。\n\n<!-- more -->\n### Don’t call us, we will call you\nIoc(Inversion of Control),控制反转.被翻译的比较多的另一个名字是`依赖注入`。正如标题名所言,Ioc的精华就在于此。\n\n通常我需要依赖某个对象或服务时,最简单的方式便是在类的构造函数里直接新建相应的依赖类.好比是造新房时需要家具,我们直接打造一个出来。\n是回头想想，我们自己每次用到什么依赖对象都要主动地去获取，这是否真的必要？我们最终所要做的，其实就是直接调用依赖对象所提供的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。\n\n这里就引入了依赖注入的关系。被注入者会直接依赖于被依赖对象。通过`Ioc Service Provider`来统一管理两者的关系。从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转。\n\n### 三种注入方式\n在Martin Fowler的那篇文章“Inversion of Control Containers andthe Dependency Injection pattern”中， 提到了三种依赖注入的方式，即构造方法注入（constructor\ninjection）、 setter方法注入（setter injection）以及接口注入（interface injection）。\n\n构造方法注入，顾名思义，即在对象的构造方法时编带入依赖对象，这种注入方式比较直观，不会重复，且伴随整个生命周期，对象被构造完成后，即进入就绪状态，可以马上使用。但缺点就是在依赖的对象比较多的时候，构造方法参数的处理会比较困难，维护和使用比较困难。\n\nsetter方法注入，即在让对象构造完成后即可使用，但相对来说更宽松一些，可以在对象构造完成后再调用setter方法注入。有点事setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。\n\n接口注入，通过接口来依赖注入依赖对象。通过方法来将依赖的对象注入。这种方式的注入强制注入了不必要的接口，带有入侵性。而构造方法和setter方法注入则不需要如此。\n\n### Ioc的附加值\n使用Ioc的方式，不只是一个方向上的改变，不会对业务对象构成比较强的入侵性，使用Ioc模式之后，对象具有更好的可测试性、可重用性和可拓展性等。当需要新加依赖对象的时候，便体现出了可重用性。并且在编写测试案例时也非常的方便。Ioc是一种可以帮助我们解耦各业务对象依赖关系的对象绑定方式。\n\n","slug":"java学习/IOC","published":1,"updated":"2019-03-22T14:44:36.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmvq000g4l3ndv34i5yv","content":"<p>最近在学习spring相关的知识点，推荐比较多的便是这本《spring 揭秘》，一边看一边做记录吧，以便反刍。</p>\n<a id=\"more\"></a>\n<h3 id=\"Don’t-call-us-we-will-call-you\"><a href=\"#Don’t-call-us-we-will-call-you\" class=\"headerlink\" title=\"Don’t call us, we will call you\"></a>Don’t call us, we will call you</h3><p>Ioc(Inversion of Control),控制反转.被翻译的比较多的另一个名字是<code>依赖注入</code>。正如标题名所言,Ioc的精华就在于此。</p>\n<p>通常我需要依赖某个对象或服务时,最简单的方式便是在类的构造函数里直接新建相应的依赖类.好比是造新房时需要家具,我们直接打造一个出来。<br>是回头想想，我们自己每次用到什么依赖对象都要主动地去获取，这是否真的必要？我们最终所要做的，其实就是直接调用依赖对象所提供的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。</p>\n<p>这里就引入了依赖注入的关系。被注入者会直接依赖于被依赖对象。通过<code>Ioc Service Provider</code>来统一管理两者的关系。从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转。</p>\n<h3 id=\"三种注入方式\"><a href=\"#三种注入方式\" class=\"headerlink\" title=\"三种注入方式\"></a>三种注入方式</h3><p>在Martin Fowler的那篇文章“Inversion of Control Containers andthe Dependency Injection pattern”中， 提到了三种依赖注入的方式，即构造方法注入（constructor<br>injection）、 setter方法注入（setter injection）以及接口注入（interface injection）。</p>\n<p>构造方法注入，顾名思义，即在对象的构造方法时编带入依赖对象，这种注入方式比较直观，不会重复，且伴随整个生命周期，对象被构造完成后，即进入就绪状态，可以马上使用。但缺点就是在依赖的对象比较多的时候，构造方法参数的处理会比较困难，维护和使用比较困难。</p>\n<p>setter方法注入，即在让对象构造完成后即可使用，但相对来说更宽松一些，可以在对象构造完成后再调用setter方法注入。有点事setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。</p>\n<p>接口注入，通过接口来依赖注入依赖对象。通过方法来将依赖的对象注入。这种方式的注入强制注入了不必要的接口，带有入侵性。而构造方法和setter方法注入则不需要如此。</p>\n<h3 id=\"Ioc的附加值\"><a href=\"#Ioc的附加值\" class=\"headerlink\" title=\"Ioc的附加值\"></a>Ioc的附加值</h3><p>使用Ioc的方式，不只是一个方向上的改变，不会对业务对象构成比较强的入侵性，使用Ioc模式之后，对象具有更好的可测试性、可重用性和可拓展性等。当需要新加依赖对象的时候，便体现出了可重用性。并且在编写测试案例时也非常的方便。Ioc是一种可以帮助我们解耦各业务对象依赖关系的对象绑定方式。</p>\n","site":{"data":{}},"excerpt":"<p>最近在学习spring相关的知识点，推荐比较多的便是这本《spring 揭秘》，一边看一边做记录吧，以便反刍。</p>","more":"<h3 id=\"Don’t-call-us-we-will-call-you\"><a href=\"#Don’t-call-us-we-will-call-you\" class=\"headerlink\" title=\"Don’t call us, we will call you\"></a>Don’t call us, we will call you</h3><p>Ioc(Inversion of Control),控制反转.被翻译的比较多的另一个名字是<code>依赖注入</code>。正如标题名所言,Ioc的精华就在于此。</p>\n<p>通常我需要依赖某个对象或服务时,最简单的方式便是在类的构造函数里直接新建相应的依赖类.好比是造新房时需要家具,我们直接打造一个出来。<br>是回头想想，我们自己每次用到什么依赖对象都要主动地去获取，这是否真的必要？我们最终所要做的，其实就是直接调用依赖对象所提供的某项服务而已。只要用到这个依赖对象的时候，它能够准备就绪，我们完全可以不管这个对象是自己找来的还是别人送过来的。</p>\n<p>这里就引入了依赖注入的关系。被注入者会直接依赖于被依赖对象。通过<code>Ioc Service Provider</code>来统一管理两者的关系。从被注入对象的角度看，与之前直接寻求依赖对象相比，依赖对象的取得方式发生了反转。</p>\n<h3 id=\"三种注入方式\"><a href=\"#三种注入方式\" class=\"headerlink\" title=\"三种注入方式\"></a>三种注入方式</h3><p>在Martin Fowler的那篇文章“Inversion of Control Containers andthe Dependency Injection pattern”中， 提到了三种依赖注入的方式，即构造方法注入（constructor<br>injection）、 setter方法注入（setter injection）以及接口注入（interface injection）。</p>\n<p>构造方法注入，顾名思义，即在对象的构造方法时编带入依赖对象，这种注入方式比较直观，不会重复，且伴随整个生命周期，对象被构造完成后，即进入就绪状态，可以马上使用。但缺点就是在依赖的对象比较多的时候，构造方法参数的处理会比较困难，维护和使用比较困难。</p>\n<p>setter方法注入，即在让对象构造完成后即可使用，但相对来说更宽松一些，可以在对象构造完成后再调用setter方法注入。有点事setter方法可以被继承，允许设置默认值，而且有良好的IDE支持。</p>\n<p>接口注入，通过接口来依赖注入依赖对象。通过方法来将依赖的对象注入。这种方式的注入强制注入了不必要的接口，带有入侵性。而构造方法和setter方法注入则不需要如此。</p>\n<h3 id=\"Ioc的附加值\"><a href=\"#Ioc的附加值\" class=\"headerlink\" title=\"Ioc的附加值\"></a>Ioc的附加值</h3><p>使用Ioc的方式，不只是一个方向上的改变，不会对业务对象构成比较强的入侵性，使用Ioc模式之后，对象具有更好的可测试性、可重用性和可拓展性等。当需要新加依赖对象的时候，便体现出了可重用性。并且在编写测试案例时也非常的方便。Ioc是一种可以帮助我们解耦各业务对象依赖关系的对象绑定方式。</p>"},{"title":"java spring学习总结（二）IoC Service Provider","date":"2008-05-12T07:35:00.000Z","_content":"\nIoC Service Provider其实是一种抽象的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。当需要绑定的业务对象很多时，采取的方式需要一同改变。目前来看，有许多开源的产品通过各种方式为我们做了这部分的工作，Spring的IoC容器就是提供依赖注入服务的IoC Service Provider。\n\n<!-- more -->\n\n## IoC Service Provider的职责\n\nIoC Service Provider的职责主要有两个，业务对象构建管理和业务对象间的依赖绑定。在Ioc场景中，业务对象无需唤醒所依赖的对象如何构建如何获得，IoC Service Provider需要将对象的构建逻辑从客户端对象那里剥离出来。而业务对象间的依赖绑定，是对于IoC Service Provider来说是其最终使命所在，需要保证每个业务对象在使用的时候，可以处于就绪的状态。\n\n对于IoC Service Provider来说，需要知道被注入对象和依赖对象之间的关系。通常有直接编码方式，配置文件方式以及元数据方式。\n\n\nSpring的IoC容器是一个提供IoC支持的轻量级容器，除了基本的IoC支持，它作为轻量级容器还提供了IoC之外的支持。如在Spring的IoC容器之上， Spring还提供了相应的AOP框架支持、企业级服务集成等服务。Spring提供了两种容器类型： BeanFactory和ApplicationContext。\n\n\nBeanFactory是基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略（lazy-load）。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景， BeanFactory是比较合适的IoC容器选择。\n\n\n\nApplicationContext在BeanFactory的基础上构建，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。\nApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说， ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。\n\n\n## Spring 的IoC容器 之 BeanFactory\n\n顾名思义，这就是生产Bean的工厂。","source":"_posts/java学习/IoC Service Provider.md","raw":"---\ntitle: java spring学习总结（二）IoC Service Provider\ndate: 2008-05-12 15:35:00\ntags: \n- java\n- spring\ncategories: 总结\n---\n\nIoC Service Provider其实是一种抽象的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。当需要绑定的业务对象很多时，采取的方式需要一同改变。目前来看，有许多开源的产品通过各种方式为我们做了这部分的工作，Spring的IoC容器就是提供依赖注入服务的IoC Service Provider。\n\n<!-- more -->\n\n## IoC Service Provider的职责\n\nIoC Service Provider的职责主要有两个，业务对象构建管理和业务对象间的依赖绑定。在Ioc场景中，业务对象无需唤醒所依赖的对象如何构建如何获得，IoC Service Provider需要将对象的构建逻辑从客户端对象那里剥离出来。而业务对象间的依赖绑定，是对于IoC Service Provider来说是其最终使命所在，需要保证每个业务对象在使用的时候，可以处于就绪的状态。\n\n对于IoC Service Provider来说，需要知道被注入对象和依赖对象之间的关系。通常有直接编码方式，配置文件方式以及元数据方式。\n\n\nSpring的IoC容器是一个提供IoC支持的轻量级容器，除了基本的IoC支持，它作为轻量级容器还提供了IoC之外的支持。如在Spring的IoC容器之上， Spring还提供了相应的AOP框架支持、企业级服务集成等服务。Spring提供了两种容器类型： BeanFactory和ApplicationContext。\n\n\nBeanFactory是基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略（lazy-load）。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景， BeanFactory是比较合适的IoC容器选择。\n\n\n\nApplicationContext在BeanFactory的基础上构建，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。\nApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说， ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。\n\n\n## Spring 的IoC容器 之 BeanFactory\n\n顾名思义，这就是生产Bean的工厂。","slug":"java学习/IoC Service Provider","published":1,"updated":"2019-03-22T14:44:36.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmvu000k4l3nnnqlp2sw","content":"<p>IoC Service Provider其实是一种抽象的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。当需要绑定的业务对象很多时，采取的方式需要一同改变。目前来看，有许多开源的产品通过各种方式为我们做了这部分的工作，Spring的IoC容器就是提供依赖注入服务的IoC Service Provider。</p>\n<a id=\"more\"></a>\n<h2 id=\"IoC-Service-Provider的职责\"><a href=\"#IoC-Service-Provider的职责\" class=\"headerlink\" title=\"IoC Service Provider的职责\"></a>IoC Service Provider的职责</h2><p>IoC Service Provider的职责主要有两个，业务对象构建管理和业务对象间的依赖绑定。在Ioc场景中，业务对象无需唤醒所依赖的对象如何构建如何获得，IoC Service Provider需要将对象的构建逻辑从客户端对象那里剥离出来。而业务对象间的依赖绑定，是对于IoC Service Provider来说是其最终使命所在，需要保证每个业务对象在使用的时候，可以处于就绪的状态。</p>\n<p>对于IoC Service Provider来说，需要知道被注入对象和依赖对象之间的关系。通常有直接编码方式，配置文件方式以及元数据方式。</p>\n<p>Spring的IoC容器是一个提供IoC支持的轻量级容器，除了基本的IoC支持，它作为轻量级容器还提供了IoC之外的支持。如在Spring的IoC容器之上， Spring还提供了相应的AOP框架支持、企业级服务集成等服务。Spring提供了两种容器类型： BeanFactory和ApplicationContext。</p>\n<p>BeanFactory是基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略（lazy-load）。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景， BeanFactory是比较合适的IoC容器选择。</p>\n<p>ApplicationContext在BeanFactory的基础上构建，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。<br>ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说， ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</p>\n<h2 id=\"Spring-的IoC容器-之-BeanFactory\"><a href=\"#Spring-的IoC容器-之-BeanFactory\" class=\"headerlink\" title=\"Spring 的IoC容器 之 BeanFactory\"></a>Spring 的IoC容器 之 BeanFactory</h2><p>顾名思义，这就是生产Bean的工厂。</p>\n","site":{"data":{}},"excerpt":"<p>IoC Service Provider其实是一种抽象的概念，它可以指代任何将IoC场景中的业务对象绑定到一起的实现方式。当需要绑定的业务对象很多时，采取的方式需要一同改变。目前来看，有许多开源的产品通过各种方式为我们做了这部分的工作，Spring的IoC容器就是提供依赖注入服务的IoC Service Provider。</p>","more":"<h2 id=\"IoC-Service-Provider的职责\"><a href=\"#IoC-Service-Provider的职责\" class=\"headerlink\" title=\"IoC Service Provider的职责\"></a>IoC Service Provider的职责</h2><p>IoC Service Provider的职责主要有两个，业务对象构建管理和业务对象间的依赖绑定。在Ioc场景中，业务对象无需唤醒所依赖的对象如何构建如何获得，IoC Service Provider需要将对象的构建逻辑从客户端对象那里剥离出来。而业务对象间的依赖绑定，是对于IoC Service Provider来说是其最终使命所在，需要保证每个业务对象在使用的时候，可以处于就绪的状态。</p>\n<p>对于IoC Service Provider来说，需要知道被注入对象和依赖对象之间的关系。通常有直接编码方式，配置文件方式以及元数据方式。</p>\n<p>Spring的IoC容器是一个提供IoC支持的轻量级容器，除了基本的IoC支持，它作为轻量级容器还提供了IoC之外的支持。如在Spring的IoC容器之上， Spring还提供了相应的AOP框架支持、企业级服务集成等服务。Spring提供了两种容器类型： BeanFactory和ApplicationContext。</p>\n<p>BeanFactory是基础类型IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延迟初始化策略（lazy-load）。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景， BeanFactory是比较合适的IoC容器选择。</p>\n<p>ApplicationContext在BeanFactory的基础上构建，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。<br>ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说， ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</p>\n<h2 id=\"Spring-的IoC容器-之-BeanFactory\"><a href=\"#Spring-的IoC容器-之-BeanFactory\" class=\"headerlink\" title=\"Spring 的IoC容器 之 BeanFactory\"></a>Spring 的IoC容器 之 BeanFactory</h2><p>顾名思义，这就是生产Bean的工厂。</p>"},{"title":"String、StringBuffer、StringBuilder, StringJoiner 的区别","date":"2018-11-16T15:03:00.000Z","_content":"\n字符串在很多地方都是一个特殊的存在,今天来聊一聊他们之间的区别。\n\n<!-- more -->\n\n### String\n\nString是Java语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。他是典型的Immutable类，被声明为 final class，所有属性都是 final 的。 也由于他的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。这种便利体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。\n\n### StringBuffer\n\nStringBuffer 是为解决上面提到的拼接产生太多中间对象额度问题而提供的类。我们可以用append或者add方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用后继者，也就是 StringBuilder。他的线程安全是通过synchronized\n关键字实现的，非常直白。这种实现方式非常适合我们常见的线程安全类实现，不必纠结于synchronized性能之类的。\n\n\n### StringBuilder\n\nStringBuilder 是Java 1.5新增的，在能力上和StringBuffer没有本质区别，但是它去掉了线程安全的部分，有效减少了开销，是绝大部分情况下进行字符串拼接的首选。\n\nStringBuilder 和 StringBuffer 底层都是利用可修改的（char,JDK 9 以后是byte）数组,都继承了 `AbstractStringBuilder`, 里面包含了基本操作,区别仅在于最终的方法是否加了`synchronized`。\n\n另外，这个内部数组应该创建多大呢？目前的实现是，构建时初始字符串长度加16，我们确定拼接会发生多次，而且大概是可预期的，那么可以指定合适的大小，避免多次扩容的开销，扩容会产生多重开销，因为要抛弃原有数组，创建新的数组，还要进行Arraycopy。\n\n但其实，Java是相当智能的。\n\n```java\n\n  public class StringConcat {\n        public static void main(String[] args) {\n            String myStr = \"aa\" + \"bb\" + \"cc\" + \"dd\";   \n             System.out.println(\"My String:\" + myStr);   \n        } \n    }\n\n```\n\n先编译再反编译,在JDK 8中，字符串拼接操作会自动被javac转换为StringBuilder操作，而在JDK 9 里面,为了更加统一字符串操作优化，提供了`StringConcatFactory`，作为一个统一的入口。\n\n\n### StringJoiner\n\nJava 8在java.util软件包下发布了StringJoiner类。我认为相对于我们使用StringBuffer / StringBuilder的旧式做法来连接字符串，这并非是一个迥然不同的实现。我们一起来看一看StringJoiner的用法和它的内部实现。\n\nStringJoiner有如下两个构造函数。\n\n```\nStringJoiner(CharSequence delimiter)\n```\n\n```\nStringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix)\n```\n\n\n例如，我有两个字符串为“Smart”和“Techie”，我想连接这些字符串为[Smart,Techie]。在这种情况下，我的前缀为“[”，后缀为“]”，以及分隔符为“,”。 \n\n```\n\nStringJoiner sjr = new StringJoiner(\",\", \"[\", \"]\");\nsjr.add(\"Smart\").add(\"Techie\");\nSystem.out.println(\"The final Joined string is \" + sjr);\n```\n例如，我有两个字符串为“Smart”和“Techie”，我想连接这些字符串为Smart,Techie。隔符为“,”。 \n\n```\n\nStringJoiner sjr = new StringJoiner(\",\");\nsjr.add(\"Smart\").add(\"Techie\");\nSystem.out.println(\"The final Joined string is \" + sjr);\n```\n\n\n其实，在查看StringJoiner方法的时候,内部使用的还是StringBuilder,可谓是“旧瓶装新酒”了。\n\n\n### 字符串缓存\n\n把常见应用进行堆转储(Dump Heap)，然后分析对象组成，会发现平均25%的对象是字符串，其中约半数是重复的。如果能避免创建重复字符串，可以有效降低内存消耗和对象创建的开销。\n\nString 在Java 6 以后提供了intern() 方法，目的是提示JVM把相应字符串缓存起来，以备重复使用。但是在Java 6中，不推荐使用 intern() ，因为被缓存的字符串是存在所谓`PermGen`里的，也就是臭名昭著的“永久代”，这个空间是很有有限的，也基本不会被FullGc之外的垃圾收集照顾到。所以，使用不当，OOM就会光顾。\n\n在后续的版本中，这个缓存被放在了堆中，甚至永久代在JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断扩大中，从最初的1009，到7u40以后被修改为60013。可以使用下面参数直接打印具体数字,也可以设置。\n\n```\n-XX:+PrintStringTableStatistics\n```\n\nIntern 是一种显式地排重机制，但是它也有一定的副作用，因为需要开发者写代码时明确调用。另外很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为是一种污染代码的实践。\n\n在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是G1 GC下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，是JVM底层的改变，不需要Java类库的改动。另，这个功能时默认关闭的。\n\n在运行时，字符串的一些基础操作会利用JVM内部的Intrinsic机制，往往运行的就是特殊优化的本地代码，而根本就不是Java代码生成的字节码。Intrinsic可以简单理解为，是一种利用native方式hard-coded的逻辑,算是一种特别的内连。\n\n### String自身的演化\n\n如果你仔细观察过Java的字符串，在历史版本中，他是使用char 数组来存数据的,这样非常直接。但是Java中的 char 是两个 byte 大小,拉丁语系的字符,根本不需要太宽的char,造成一定的浪费。因此归根结底绝大部分任务是用来操作数据的。\n\n其实在Java 6中，Oracle JDK 就提供了压缩字符串的特性，但是这个特性在最新的JDK中已经被移除了。\n\n在 Java 9 中,引入了Compact Strings 的设计,对字符串进行了大刀阔斧的改进，将数据存储方式从char数组，改变为一个byte数组加上一个标识编码的所谓coder，并且将相关字符串操作类都进行了修改。另外，所有相关的Intrinsic之类都进行了重写，以保证没有任何性能损失。\n\n\n\n","source":"_posts/java学习/String、StringBuffer、StringBuilder的区别.md","raw":"---\ntitle: String、StringBuffer、StringBuilder, StringJoiner 的区别\ndate: 2018-11-16 23:03:00\ntags: \n- java\ncategories: 总结\n---\n\n字符串在很多地方都是一个特殊的存在,今天来聊一聊他们之间的区别。\n\n<!-- more -->\n\n### String\n\nString是Java语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。他是典型的Immutable类，被声明为 final class，所有属性都是 final 的。 也由于他的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。这种便利体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。\n\n### StringBuffer\n\nStringBuffer 是为解决上面提到的拼接产生太多中间对象额度问题而提供的类。我们可以用append或者add方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用后继者，也就是 StringBuilder。他的线程安全是通过synchronized\n关键字实现的，非常直白。这种实现方式非常适合我们常见的线程安全类实现，不必纠结于synchronized性能之类的。\n\n\n### StringBuilder\n\nStringBuilder 是Java 1.5新增的，在能力上和StringBuffer没有本质区别，但是它去掉了线程安全的部分，有效减少了开销，是绝大部分情况下进行字符串拼接的首选。\n\nStringBuilder 和 StringBuffer 底层都是利用可修改的（char,JDK 9 以后是byte）数组,都继承了 `AbstractStringBuilder`, 里面包含了基本操作,区别仅在于最终的方法是否加了`synchronized`。\n\n另外，这个内部数组应该创建多大呢？目前的实现是，构建时初始字符串长度加16，我们确定拼接会发生多次，而且大概是可预期的，那么可以指定合适的大小，避免多次扩容的开销，扩容会产生多重开销，因为要抛弃原有数组，创建新的数组，还要进行Arraycopy。\n\n但其实，Java是相当智能的。\n\n```java\n\n  public class StringConcat {\n        public static void main(String[] args) {\n            String myStr = \"aa\" + \"bb\" + \"cc\" + \"dd\";   \n             System.out.println(\"My String:\" + myStr);   \n        } \n    }\n\n```\n\n先编译再反编译,在JDK 8中，字符串拼接操作会自动被javac转换为StringBuilder操作，而在JDK 9 里面,为了更加统一字符串操作优化，提供了`StringConcatFactory`，作为一个统一的入口。\n\n\n### StringJoiner\n\nJava 8在java.util软件包下发布了StringJoiner类。我认为相对于我们使用StringBuffer / StringBuilder的旧式做法来连接字符串，这并非是一个迥然不同的实现。我们一起来看一看StringJoiner的用法和它的内部实现。\n\nStringJoiner有如下两个构造函数。\n\n```\nStringJoiner(CharSequence delimiter)\n```\n\n```\nStringJoiner(CharSequence delimiter, CharSequence prefix, CharSequence suffix)\n```\n\n\n例如，我有两个字符串为“Smart”和“Techie”，我想连接这些字符串为[Smart,Techie]。在这种情况下，我的前缀为“[”，后缀为“]”，以及分隔符为“,”。 \n\n```\n\nStringJoiner sjr = new StringJoiner(\",\", \"[\", \"]\");\nsjr.add(\"Smart\").add(\"Techie\");\nSystem.out.println(\"The final Joined string is \" + sjr);\n```\n例如，我有两个字符串为“Smart”和“Techie”，我想连接这些字符串为Smart,Techie。隔符为“,”。 \n\n```\n\nStringJoiner sjr = new StringJoiner(\",\");\nsjr.add(\"Smart\").add(\"Techie\");\nSystem.out.println(\"The final Joined string is \" + sjr);\n```\n\n\n其实，在查看StringJoiner方法的时候,内部使用的还是StringBuilder,可谓是“旧瓶装新酒”了。\n\n\n### 字符串缓存\n\n把常见应用进行堆转储(Dump Heap)，然后分析对象组成，会发现平均25%的对象是字符串，其中约半数是重复的。如果能避免创建重复字符串，可以有效降低内存消耗和对象创建的开销。\n\nString 在Java 6 以后提供了intern() 方法，目的是提示JVM把相应字符串缓存起来，以备重复使用。但是在Java 6中，不推荐使用 intern() ，因为被缓存的字符串是存在所谓`PermGen`里的，也就是臭名昭著的“永久代”，这个空间是很有有限的，也基本不会被FullGc之外的垃圾收集照顾到。所以，使用不当，OOM就会光顾。\n\n在后续的版本中，这个缓存被放在了堆中，甚至永久代在JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断扩大中，从最初的1009，到7u40以后被修改为60013。可以使用下面参数直接打印具体数字,也可以设置。\n\n```\n-XX:+PrintStringTableStatistics\n```\n\nIntern 是一种显式地排重机制，但是它也有一定的副作用，因为需要开发者写代码时明确调用。另外很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为是一种污染代码的实践。\n\n在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是G1 GC下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，是JVM底层的改变，不需要Java类库的改动。另，这个功能时默认关闭的。\n\n在运行时，字符串的一些基础操作会利用JVM内部的Intrinsic机制，往往运行的就是特殊优化的本地代码，而根本就不是Java代码生成的字节码。Intrinsic可以简单理解为，是一种利用native方式hard-coded的逻辑,算是一种特别的内连。\n\n### String自身的演化\n\n如果你仔细观察过Java的字符串，在历史版本中，他是使用char 数组来存数据的,这样非常直接。但是Java中的 char 是两个 byte 大小,拉丁语系的字符,根本不需要太宽的char,造成一定的浪费。因此归根结底绝大部分任务是用来操作数据的。\n\n其实在Java 6中，Oracle JDK 就提供了压缩字符串的特性，但是这个特性在最新的JDK中已经被移除了。\n\n在 Java 9 中,引入了Compact Strings 的设计,对字符串进行了大刀阔斧的改进，将数据存储方式从char数组，改变为一个byte数组加上一个标识编码的所谓coder，并且将相关字符串操作类都进行了修改。另外，所有相关的Intrinsic之类都进行了重写，以保证没有任何性能损失。\n\n\n\n","slug":"java学习/String、StringBuffer、StringBuilder的区别","published":1,"updated":"2019-03-22T14:44:36.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmvv000m4l3npkjqa4lr","content":"<p>字符串在很多地方都是一个特殊的存在,今天来聊一聊他们之间的区别。</p>\n<a id=\"more\"></a>\n<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>String是Java语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。他是典型的Immutable类，被声明为 final class，所有属性都是 final 的。 也由于他的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。这种便利体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。</p>\n<h3 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h3><p>StringBuffer 是为解决上面提到的拼接产生太多中间对象额度问题而提供的类。我们可以用append或者add方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用后继者，也就是 StringBuilder。他的线程安全是通过synchronized<br>关键字实现的，非常直白。这种实现方式非常适合我们常见的线程安全类实现，不必纠结于synchronized性能之类的。</p>\n<h3 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h3><p>StringBuilder 是Java 1.5新增的，在能力上和StringBuffer没有本质区别，但是它去掉了线程安全的部分，有效减少了开销，是绝大部分情况下进行字符串拼接的首选。</p>\n<p>StringBuilder 和 StringBuffer 底层都是利用可修改的（char,JDK 9 以后是byte）数组,都继承了 <code>AbstractStringBuilder</code>, 里面包含了基本操作,区别仅在于最终的方法是否加了<code>synchronized</code>。</p>\n<p>另外，这个内部数组应该创建多大呢？目前的实现是，构建时初始字符串长度加16，我们确定拼接会发生多次，而且大概是可预期的，那么可以指定合适的大小，避免多次扩容的开销，扩容会产生多重开销，因为要抛弃原有数组，创建新的数组，还要进行Arraycopy。</p>\n<p>但其实，Java是相当智能的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringConcat</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">          String myStr = <span class=\"string\">\"aa\"</span> + <span class=\"string\">\"bb\"</span> + <span class=\"string\">\"cc\"</span> + <span class=\"string\">\"dd\"</span>;   </span><br><span class=\"line\">           System.out.println(<span class=\"string\">\"My String:\"</span> + myStr);   </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>先编译再反编译,在JDK 8中，字符串拼接操作会自动被javac转换为StringBuilder操作，而在JDK 9 里面,为了更加统一字符串操作优化，提供了<code>StringConcatFactory</code>，作为一个统一的入口。</p>\n<h3 id=\"StringJoiner\"><a href=\"#StringJoiner\" class=\"headerlink\" title=\"StringJoiner\"></a>StringJoiner</h3><p>Java 8在java.util软件包下发布了StringJoiner类。我认为相对于我们使用StringBuffer / StringBuilder的旧式做法来连接字符串，这并非是一个迥然不同的实现。我们一起来看一看StringJoiner的用法和它的内部实现。</p>\n<p>StringJoiner有如下两个构造函数。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">StringJoiner</span><span class=\"params\">(CharSequence delimiter)</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">StringJoiner</span><span class=\"params\">(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</span></span></span><br></pre></td></tr></table></figure>\n<p>例如，我有两个字符串为“Smart”和“Techie”，我想连接这些字符串为[Smart,Techie]。在这种情况下，我的前缀为“[”，后缀为“]”，以及分隔符为“,”。 </p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">StringJoiner sjr = <span class=\"keyword\">new</span> StringJoiner(<span class=\"string\">\",\"</span>, <span class=\"string\">\"[\"</span>, <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">sjr.<span class=\"keyword\">add</span>(<span class=\"string\">\"Smart\"</span>).<span class=\"keyword\">add</span>(<span class=\"string\">\"Techie\"</span>);</span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"The final Joined string is \"</span> + sjr);</span><br></pre></td></tr></table></figure>\n<p>例如，我有两个字符串为“Smart”和“Techie”，我想连接这些字符串为Smart,Techie。隔符为“,”。 </p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">StringJoiner sjr = <span class=\"keyword\">new</span> StringJoiner(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">sjr.<span class=\"keyword\">add</span>(<span class=\"string\">\"Smart\"</span>).<span class=\"keyword\">add</span>(<span class=\"string\">\"Techie\"</span>);</span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"The final Joined string is \"</span> + sjr);</span><br></pre></td></tr></table></figure>\n<p>其实，在查看StringJoiner方法的时候,内部使用的还是StringBuilder,可谓是“旧瓶装新酒”了。</p>\n<h3 id=\"字符串缓存\"><a href=\"#字符串缓存\" class=\"headerlink\" title=\"字符串缓存\"></a>字符串缓存</h3><p>把常见应用进行堆转储(Dump Heap)，然后分析对象组成，会发现平均25%的对象是字符串，其中约半数是重复的。如果能避免创建重复字符串，可以有效降低内存消耗和对象创建的开销。</p>\n<p>String 在Java 6 以后提供了intern() 方法，目的是提示JVM把相应字符串缓存起来，以备重复使用。但是在Java 6中，不推荐使用 intern() ，因为被缓存的字符串是存在所谓<code>PermGen</code>里的，也就是臭名昭著的“永久代”，这个空间是很有有限的，也基本不会被FullGc之外的垃圾收集照顾到。所以，使用不当，OOM就会光顾。</p>\n<p>在后续的版本中，这个缓存被放在了堆中，甚至永久代在JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断扩大中，从最初的1009，到7u40以后被修改为60013。可以使用下面参数直接打印具体数字,也可以设置。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-XX</span><span class=\"selector-pseudo\">:+PrintStringTableStatistics</span></span><br></pre></td></tr></table></figure>\n<p>Intern 是一种显式地排重机制，但是它也有一定的副作用，因为需要开发者写代码时明确调用。另外很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为是一种污染代码的实践。</p>\n<p>在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是G1 GC下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，是JVM底层的改变，不需要Java类库的改动。另，这个功能时默认关闭的。</p>\n<p>在运行时，字符串的一些基础操作会利用JVM内部的Intrinsic机制，往往运行的就是特殊优化的本地代码，而根本就不是Java代码生成的字节码。Intrinsic可以简单理解为，是一种利用native方式hard-coded的逻辑,算是一种特别的内连。</p>\n<h3 id=\"String自身的演化\"><a href=\"#String自身的演化\" class=\"headerlink\" title=\"String自身的演化\"></a>String自身的演化</h3><p>如果你仔细观察过Java的字符串，在历史版本中，他是使用char 数组来存数据的,这样非常直接。但是Java中的 char 是两个 byte 大小,拉丁语系的字符,根本不需要太宽的char,造成一定的浪费。因此归根结底绝大部分任务是用来操作数据的。</p>\n<p>其实在Java 6中，Oracle JDK 就提供了压缩字符串的特性，但是这个特性在最新的JDK中已经被移除了。</p>\n<p>在 Java 9 中,引入了Compact Strings 的设计,对字符串进行了大刀阔斧的改进，将数据存储方式从char数组，改变为一个byte数组加上一个标识编码的所谓coder，并且将相关字符串操作类都进行了修改。另外，所有相关的Intrinsic之类都进行了重写，以保证没有任何性能损失。</p>\n","site":{"data":{}},"excerpt":"<p>字符串在很多地方都是一个特殊的存在,今天来聊一聊他们之间的区别。</p>","more":"<h3 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h3><p>String是Java语言非常基础和重要的类，提供了构造和管理字符串的各种基本逻辑。他是典型的Immutable类，被声明为 final class，所有属性都是 final 的。 也由于他的不可变性，类似拼接、裁剪字符串等动作，都会产生新的String对象。由于字符串操作的普遍性，所以相关操作的效率往往对应用性能有明显影响。这种便利体现在拷贝构造函数中，由于不可变，Immutable 对象在拷贝时不需要额外复制数据。</p>\n<h3 id=\"StringBuffer\"><a href=\"#StringBuffer\" class=\"headerlink\" title=\"StringBuffer\"></a>StringBuffer</h3><p>StringBuffer 是为解决上面提到的拼接产生太多中间对象额度问题而提供的类。我们可以用append或者add方法，把字符串添加到已有序列的末尾或者指定位置。StringBuffer本质是一个线程安全的可修改字符序列，它保证了线程安全，也随之带来了额外的性能开销，所以除非有线程安全的需要，不然还是推荐使用后继者，也就是 StringBuilder。他的线程安全是通过synchronized<br>关键字实现的，非常直白。这种实现方式非常适合我们常见的线程安全类实现，不必纠结于synchronized性能之类的。</p>\n<h3 id=\"StringBuilder\"><a href=\"#StringBuilder\" class=\"headerlink\" title=\"StringBuilder\"></a>StringBuilder</h3><p>StringBuilder 是Java 1.5新增的，在能力上和StringBuffer没有本质区别，但是它去掉了线程安全的部分，有效减少了开销，是绝大部分情况下进行字符串拼接的首选。</p>\n<p>StringBuilder 和 StringBuffer 底层都是利用可修改的（char,JDK 9 以后是byte）数组,都继承了 <code>AbstractStringBuilder</code>, 里面包含了基本操作,区别仅在于最终的方法是否加了<code>synchronized</code>。</p>\n<p>另外，这个内部数组应该创建多大呢？目前的实现是，构建时初始字符串长度加16，我们确定拼接会发生多次，而且大概是可预期的，那么可以指定合适的大小，避免多次扩容的开销，扩容会产生多重开销，因为要抛弃原有数组，创建新的数组，还要进行Arraycopy。</p>\n<p>但其实，Java是相当智能的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringConcat</span> </span>&#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">          String myStr = <span class=\"string\">\"aa\"</span> + <span class=\"string\">\"bb\"</span> + <span class=\"string\">\"cc\"</span> + <span class=\"string\">\"dd\"</span>;   </span><br><span class=\"line\">           System.out.println(<span class=\"string\">\"My String:\"</span> + myStr);   </span><br><span class=\"line\">      &#125; </span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<p>先编译再反编译,在JDK 8中，字符串拼接操作会自动被javac转换为StringBuilder操作，而在JDK 9 里面,为了更加统一字符串操作优化，提供了<code>StringConcatFactory</code>，作为一个统一的入口。</p>\n<h3 id=\"StringJoiner\"><a href=\"#StringJoiner\" class=\"headerlink\" title=\"StringJoiner\"></a>StringJoiner</h3><p>Java 8在java.util软件包下发布了StringJoiner类。我认为相对于我们使用StringBuffer / StringBuilder的旧式做法来连接字符串，这并非是一个迥然不同的实现。我们一起来看一看StringJoiner的用法和它的内部实现。</p>\n<p>StringJoiner有如下两个构造函数。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">StringJoiner</span><span class=\"params\">(CharSequence delimiter)</span></span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">StringJoiner</span><span class=\"params\">(CharSequence delimiter, CharSequence prefix, CharSequence suffix)</span></span></span><br></pre></td></tr></table></figure>\n<p>例如，我有两个字符串为“Smart”和“Techie”，我想连接这些字符串为[Smart,Techie]。在这种情况下，我的前缀为“[”，后缀为“]”，以及分隔符为“,”。 </p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">StringJoiner sjr = <span class=\"keyword\">new</span> StringJoiner(<span class=\"string\">\",\"</span>, <span class=\"string\">\"[\"</span>, <span class=\"string\">\"]\"</span>);</span><br><span class=\"line\">sjr.<span class=\"keyword\">add</span>(<span class=\"string\">\"Smart\"</span>).<span class=\"keyword\">add</span>(<span class=\"string\">\"Techie\"</span>);</span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"The final Joined string is \"</span> + sjr);</span><br></pre></td></tr></table></figure>\n<p>例如，我有两个字符串为“Smart”和“Techie”，我想连接这些字符串为Smart,Techie。隔符为“,”。 </p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">StringJoiner sjr = <span class=\"keyword\">new</span> StringJoiner(<span class=\"string\">\",\"</span>);</span><br><span class=\"line\">sjr.<span class=\"keyword\">add</span>(<span class=\"string\">\"Smart\"</span>).<span class=\"keyword\">add</span>(<span class=\"string\">\"Techie\"</span>);</span><br><span class=\"line\">System.<span class=\"keyword\">out</span>.println(<span class=\"string\">\"The final Joined string is \"</span> + sjr);</span><br></pre></td></tr></table></figure>\n<p>其实，在查看StringJoiner方法的时候,内部使用的还是StringBuilder,可谓是“旧瓶装新酒”了。</p>\n<h3 id=\"字符串缓存\"><a href=\"#字符串缓存\" class=\"headerlink\" title=\"字符串缓存\"></a>字符串缓存</h3><p>把常见应用进行堆转储(Dump Heap)，然后分析对象组成，会发现平均25%的对象是字符串，其中约半数是重复的。如果能避免创建重复字符串，可以有效降低内存消耗和对象创建的开销。</p>\n<p>String 在Java 6 以后提供了intern() 方法，目的是提示JVM把相应字符串缓存起来，以备重复使用。但是在Java 6中，不推荐使用 intern() ，因为被缓存的字符串是存在所谓<code>PermGen</code>里的，也就是臭名昭著的“永久代”，这个空间是很有有限的，也基本不会被FullGc之外的垃圾收集照顾到。所以，使用不当，OOM就会光顾。</p>\n<p>在后续的版本中，这个缓存被放在了堆中，甚至永久代在JDK 8 中被 MetaSpace（元数据区）替代了。而且，默认缓存大小也在不断扩大中，从最初的1009，到7u40以后被修改为60013。可以使用下面参数直接打印具体数字,也可以设置。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">-XX</span><span class=\"selector-pseudo\">:+PrintStringTableStatistics</span></span><br></pre></td></tr></table></figure>\n<p>Intern 是一种显式地排重机制，但是它也有一定的副作用，因为需要开发者写代码时明确调用。另外很难保证效率，应用开发阶段很难清楚地预计字符串的重复情况，有人认为是一种污染代码的实践。</p>\n<p>在 Oracle JDK 8u20 之后，推出了一个新的特性，也就是G1 GC下的字符串排重。它是通过将相同数据的字符串指向同一份数据来做到的，是JVM底层的改变，不需要Java类库的改动。另，这个功能时默认关闭的。</p>\n<p>在运行时，字符串的一些基础操作会利用JVM内部的Intrinsic机制，往往运行的就是特殊优化的本地代码，而根本就不是Java代码生成的字节码。Intrinsic可以简单理解为，是一种利用native方式hard-coded的逻辑,算是一种特别的内连。</p>\n<h3 id=\"String自身的演化\"><a href=\"#String自身的演化\" class=\"headerlink\" title=\"String自身的演化\"></a>String自身的演化</h3><p>如果你仔细观察过Java的字符串，在历史版本中，他是使用char 数组来存数据的,这样非常直接。但是Java中的 char 是两个 byte 大小,拉丁语系的字符,根本不需要太宽的char,造成一定的浪费。因此归根结底绝大部分任务是用来操作数据的。</p>\n<p>其实在Java 6中，Oracle JDK 就提供了压缩字符串的特性，但是这个特性在最新的JDK中已经被移除了。</p>\n<p>在 Java 9 中,引入了Compact Strings 的设计,对字符串进行了大刀阔斧的改进，将数据存储方式从char数组，改变为一个byte数组加上一个标识编码的所谓coder，并且将相关字符串操作类都进行了修改。另外，所有相关的Intrinsic之类都进行了重写，以保证没有任何性能损失。</p>"},{"title":"java学习基础（二）基础知识杂记","date":"2007-04-06T12:22:00.000Z","_content":"\n这里会记录一些java语言和其它语言基础的一些小区别和自己觉得需要记忆的内容。\n\n### 数字\n在我们处理数字时,一般使用的是原始数据类型，如 byte，int，long，double 等。\n然而,在开发过程中,我们往往需要使用到对象而不是原始数据类型，此时的java便为我们包装好了类。\n\n所有的包装类 (Integer, Long, Byte, Double, Float, Short) 都继承自抽象类 `Number`(来源于`java.lang` 包)。\n\n#### 装箱\n\n上述这种包装是由编译器处理，这个过程称为装箱。因此，当一个原始数据类型被使用，当需要一个对象时，编译器将原始数据放入其包装类。同样地，编译器也能将对象取出返回到\n原始数据类型。\n\n当 x 被分配整数值，则编译器将整数放入箱中，因为 x 为整数对象。然后，x 被拆箱，以便它们可以被添加为整数。\n\n\n### Number 一些常用方法\n`xxxValue()`：用于将这个Number对象的值转换为XXX的数据类型并返回。\n\n### 字符串\n\n任何其他对象可以通过使用 new 关键字，并通过构造函数创建 String 对象。 String 类有11种构造函数提供使用不同类型的字符串的初始值。\n\nString 类是不可变的，因此，一旦创建了 String 对象那么是不能改变的。如果需要大量修改字符的字符串，那么应该使用 StringBuffer & StringBuilder 类。\n\n\n### 数组\njava的数组编写风格为 `dataType[] arrayRefVar;`, 风格 `dataType arrayRefVar[] `来自于 C/C++ 语言，因为Java 继承 C/C++ 的编程风格,所以可以用,但不推荐使用。 \n\n","source":"_posts/java学习/基础知识点杂记.md","raw":"---\ntitle: java学习基础（二）基础知识杂记\ndate: 2007-04-06 20:22:00\ntags: \n- java\ncategories: 总结\n---\n\n这里会记录一些java语言和其它语言基础的一些小区别和自己觉得需要记忆的内容。\n\n### 数字\n在我们处理数字时,一般使用的是原始数据类型，如 byte，int，long，double 等。\n然而,在开发过程中,我们往往需要使用到对象而不是原始数据类型，此时的java便为我们包装好了类。\n\n所有的包装类 (Integer, Long, Byte, Double, Float, Short) 都继承自抽象类 `Number`(来源于`java.lang` 包)。\n\n#### 装箱\n\n上述这种包装是由编译器处理，这个过程称为装箱。因此，当一个原始数据类型被使用，当需要一个对象时，编译器将原始数据放入其包装类。同样地，编译器也能将对象取出返回到\n原始数据类型。\n\n当 x 被分配整数值，则编译器将整数放入箱中，因为 x 为整数对象。然后，x 被拆箱，以便它们可以被添加为整数。\n\n\n### Number 一些常用方法\n`xxxValue()`：用于将这个Number对象的值转换为XXX的数据类型并返回。\n\n### 字符串\n\n任何其他对象可以通过使用 new 关键字，并通过构造函数创建 String 对象。 String 类有11种构造函数提供使用不同类型的字符串的初始值。\n\nString 类是不可变的，因此，一旦创建了 String 对象那么是不能改变的。如果需要大量修改字符的字符串，那么应该使用 StringBuffer & StringBuilder 类。\n\n\n### 数组\njava的数组编写风格为 `dataType[] arrayRefVar;`, 风格 `dataType arrayRefVar[] `来自于 C/C++ 语言，因为Java 继承 C/C++ 的编程风格,所以可以用,但不推荐使用。 \n\n","slug":"java学习/基础知识点杂记","published":1,"updated":"2019-03-22T14:44:36.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmvx000q4l3nl9bgqbsd","content":"<p>这里会记录一些java语言和其它语言基础的一些小区别和自己觉得需要记忆的内容。</p>\n<h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><p>在我们处理数字时,一般使用的是原始数据类型，如 byte，int，long，double 等。<br>然而,在开发过程中,我们往往需要使用到对象而不是原始数据类型，此时的java便为我们包装好了类。</p>\n<p>所有的包装类 (Integer, Long, Byte, Double, Float, Short) 都继承自抽象类 <code>Number</code>(来源于<code>java.lang</code> 包)。</p>\n<h4 id=\"装箱\"><a href=\"#装箱\" class=\"headerlink\" title=\"装箱\"></a>装箱</h4><p>上述这种包装是由编译器处理，这个过程称为装箱。因此，当一个原始数据类型被使用，当需要一个对象时，编译器将原始数据放入其包装类。同样地，编译器也能将对象取出返回到<br>原始数据类型。</p>\n<p>当 x 被分配整数值，则编译器将整数放入箱中，因为 x 为整数对象。然后，x 被拆箱，以便它们可以被添加为整数。</p>\n<h3 id=\"Number-一些常用方法\"><a href=\"#Number-一些常用方法\" class=\"headerlink\" title=\"Number 一些常用方法\"></a>Number 一些常用方法</h3><p><code>xxxValue()</code>：用于将这个Number对象的值转换为XXX的数据类型并返回。</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>任何其他对象可以通过使用 new 关键字，并通过构造函数创建 String 对象。 String 类有11种构造函数提供使用不同类型的字符串的初始值。</p>\n<p>String 类是不可变的，因此，一旦创建了 String 对象那么是不能改变的。如果需要大量修改字符的字符串，那么应该使用 StringBuffer &amp; StringBuilder 类。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>java的数组编写风格为 <code>dataType[] arrayRefVar;</code>, 风格 <code>dataType arrayRefVar[]</code>来自于 C/C++ 语言，因为Java 继承 C/C++ 的编程风格,所以可以用,但不推荐使用。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>这里会记录一些java语言和其它语言基础的一些小区别和自己觉得需要记忆的内容。</p>\n<h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><p>在我们处理数字时,一般使用的是原始数据类型，如 byte，int，long，double 等。<br>然而,在开发过程中,我们往往需要使用到对象而不是原始数据类型，此时的java便为我们包装好了类。</p>\n<p>所有的包装类 (Integer, Long, Byte, Double, Float, Short) 都继承自抽象类 <code>Number</code>(来源于<code>java.lang</code> 包)。</p>\n<h4 id=\"装箱\"><a href=\"#装箱\" class=\"headerlink\" title=\"装箱\"></a>装箱</h4><p>上述这种包装是由编译器处理，这个过程称为装箱。因此，当一个原始数据类型被使用，当需要一个对象时，编译器将原始数据放入其包装类。同样地，编译器也能将对象取出返回到<br>原始数据类型。</p>\n<p>当 x 被分配整数值，则编译器将整数放入箱中，因为 x 为整数对象。然后，x 被拆箱，以便它们可以被添加为整数。</p>\n<h3 id=\"Number-一些常用方法\"><a href=\"#Number-一些常用方法\" class=\"headerlink\" title=\"Number 一些常用方法\"></a>Number 一些常用方法</h3><p><code>xxxValue()</code>：用于将这个Number对象的值转换为XXX的数据类型并返回。</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>任何其他对象可以通过使用 new 关键字，并通过构造函数创建 String 对象。 String 类有11种构造函数提供使用不同类型的字符串的初始值。</p>\n<p>String 类是不可变的，因此，一旦创建了 String 对象那么是不能改变的。如果需要大量修改字符的字符串，那么应该使用 StringBuffer &amp; StringBuilder 类。</p>\n<h3 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h3><p>java的数组编写风格为 <code>dataType[] arrayRefVar;</code>, 风格 <code>dataType arrayRefVar[]</code>来自于 C/C++ 语言，因为Java 继承 C/C++ 的编程风格,所以可以用,但不推荐使用。 </p>\n"},{"title":"多线程","date":"2008-08-27T14:22:00.000Z","_content":"\njoin()\n让父线程等待子线程结束之后才能继续运行。","source":"_posts/java学习/多线程.md","raw":"---\ntitle: 多线程\ndate: 2008-08-27 22:22:00\ntags: \n- java\ncategories: java\n---\n\njoin()\n让父线程等待子线程结束之后才能继续运行。","slug":"java学习/多线程","published":1,"updated":"2019-03-22T14:44:36.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmvy000t4l3nhz5rlk3r","content":"<p>join()<br>让父线程等待子线程结束之后才能继续运行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>join()<br>让父线程等待子线程结束之后才能继续运行。</p>\n"},{"title":"java学习总结（一）Java基础","date":"2007-04-06T12:22:00.000Z","_content":"OOP的三个特性:对象的行为,对象的状态,对象的标识。\n对象的行为：可以对对象施加哪些方法?\n对象的状态:当施加这些方法时,对象如何响应?\n对象标识:如何辨别具有相同行为与状态的不同对象?\n\n对象的行为通过可调用的方法进行定义。\n对象状态的改变不是自发的，通过调用方法来实现\n\n首先从设计类开始，然后再往每个类之中添加方法。而不是从main开始。\n\n类之间的关系：依赖，聚合，继承\n尽可能的降低耦合。\n\n一个对象变量并没有实际包含一个对象，而仅仅是引用一个对象。","source":"_posts/java学习/java学习总结（一）Java基础.md","raw":"---\ntitle: java学习总结（一）Java基础\ndate: 2007-04-06 20:22:00\ntags: \n- java\ncategories: 总结\n---\nOOP的三个特性:对象的行为,对象的状态,对象的标识。\n对象的行为：可以对对象施加哪些方法?\n对象的状态:当施加这些方法时,对象如何响应?\n对象标识:如何辨别具有相同行为与状态的不同对象?\n\n对象的行为通过可调用的方法进行定义。\n对象状态的改变不是自发的，通过调用方法来实现\n\n首先从设计类开始，然后再往每个类之中添加方法。而不是从main开始。\n\n类之间的关系：依赖，聚合，继承\n尽可能的降低耦合。\n\n一个对象变量并没有实际包含一个对象，而仅仅是引用一个对象。","slug":"java学习/java学习总结（一）Java基础","published":1,"updated":"2019-05-04T15:46:04.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmvz000x4l3nj5m5r3hb","content":"<p>OOP的三个特性:对象的行为,对象的状态,对象的标识。<br>对象的行为：可以对对象施加哪些方法?<br>对象的状态:当施加这些方法时,对象如何响应?<br>对象标识:如何辨别具有相同行为与状态的不同对象?</p>\n<p>对象的行为通过可调用的方法进行定义。<br>对象状态的改变不是自发的，通过调用方法来实现</p>\n<p>首先从设计类开始，然后再往每个类之中添加方法。而不是从main开始。</p>\n<p>类之间的关系：依赖，聚合，继承<br>尽可能的降低耦合。</p>\n<p>一个对象变量并没有实际包含一个对象，而仅仅是引用一个对象。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>OOP的三个特性:对象的行为,对象的状态,对象的标识。<br>对象的行为：可以对对象施加哪些方法?<br>对象的状态:当施加这些方法时,对象如何响应?<br>对象标识:如何辨别具有相同行为与状态的不同对象?</p>\n<p>对象的行为通过可调用的方法进行定义。<br>对象状态的改变不是自发的，通过调用方法来实现</p>\n<p>首先从设计类开始，然后再往每个类之中添加方法。而不是从main开始。</p>\n<p>类之间的关系：依赖，聚合，继承<br>尽可能的降低耦合。</p>\n<p>一个对象变量并没有实际包含一个对象，而仅仅是引用一个对象。</p>\n"},{"title":"Java对象引用类型及其区别","date":"2018-11-15T10:22:00.000Z","_content":"\n在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。\n\n<!-- more -->\n### 引用的来源\n\n引用出现的根源是由于GC内存回收的基本原理—GC回收内存本质上是回首对象，而目前比较流行的回收算法是可达性分析算法，从GC Roots开始按照一定的逻辑判断一个对象是否可达，不可达的话就说明这个对象已死（除此之外另外一种常见的算法就是引用计数法，但是这种算法有个问题就是不能解决相互引用的问题）。基于此Java向用户提供了四种可用的引用：即我们本章讲解到的几种，同时还提供了一种不可被使用的引用—FinalReference，这个引用是和析构函数密切相关的）。强引用，开发者可以通过new的方式创建，其它的几种引用Java提供了相应的类：SoftReference、WeakReference、PhantomReference。如果你去查看源码你会发现，这个类实现的核心是Reference与ReferenceQueue（更通俗地说引用队列）两个类，而且这两个类也特别的简单。Reference类似一个链表结构，通过创建一个守护线程来执行对应引用的清除、Cleaner.clean（如果传入的对象是该类的话）、以及引用的入队操作（需要在创建引用的时候制定一个引用队列）；ReferenceQueue这是制定了引用队列的一些具体操作，简单的来说它也是一个链表结构，并提供了一些基本的链表操作）。而除了强引用外其它的都是继承于此，通过这样的类约束了引用的相关内容，便于和GC进行交互。\n\n不同的引用类型，主要体现的是对象不同的可达性状态和对垃圾收集的影响。判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分。\n### 强引用\n\n特点：我们平常典型编码`Object obj = new Object()`中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。\n\n### 软引用\n\n特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。\n\n应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。例如，“内存缓存”中的图片是以这种引用来保存，使得JVM在发生OOM之前，可以回收这部分缓存。\n\n### 弱引用\n\n弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n应用场景：弱应用同样可用于内存敏感的缓存。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏。\n\n### 虚引用\n\n特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\nReferenceQueue queue = new ReferenceQueue ();\nPhantomReference pr = new PhantomReference (object, queue); \n程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。\n\n应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。通常用来做所谓的Post-Mortem清理机制，Java平台本身的Cleaner机制等，也有人利用幻象引用来监控对象的创建和销毁。\n\n### 还存在的问题\n\n除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过get方法获得原有对象。这就意味着，利用软引用和弱引用，我们可以将访问的对象，重新指向强引用，也就是人为的改变了对象的可达性状态。\n所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。\n\n如果我们错误的保持了强引用，比如赋值给了static变量，那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路。\n\n","source":"_posts/java学习/引用的类型.md","raw":"---\ntitle: Java对象引用类型及其区别\ndate: 2018-11-15 18:22:00\ntags: \n- java\ncategories: java\n---\n\n在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。\n\n<!-- more -->\n### 引用的来源\n\n引用出现的根源是由于GC内存回收的基本原理—GC回收内存本质上是回首对象，而目前比较流行的回收算法是可达性分析算法，从GC Roots开始按照一定的逻辑判断一个对象是否可达，不可达的话就说明这个对象已死（除此之外另外一种常见的算法就是引用计数法，但是这种算法有个问题就是不能解决相互引用的问题）。基于此Java向用户提供了四种可用的引用：即我们本章讲解到的几种，同时还提供了一种不可被使用的引用—FinalReference，这个引用是和析构函数密切相关的）。强引用，开发者可以通过new的方式创建，其它的几种引用Java提供了相应的类：SoftReference、WeakReference、PhantomReference。如果你去查看源码你会发现，这个类实现的核心是Reference与ReferenceQueue（更通俗地说引用队列）两个类，而且这两个类也特别的简单。Reference类似一个链表结构，通过创建一个守护线程来执行对应引用的清除、Cleaner.clean（如果传入的对象是该类的话）、以及引用的入队操作（需要在创建引用的时候制定一个引用队列）；ReferenceQueue这是制定了引用队列的一些具体操作，简单的来说它也是一个链表结构，并提供了一些基本的链表操作）。而除了强引用外其它的都是继承于此，通过这样的类约束了引用的相关内容，便于和GC进行交互。\n\n不同的引用类型，主要体现的是对象不同的可达性状态和对垃圾收集的影响。判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分。\n### 强引用\n\n特点：我们平常典型编码`Object obj = new Object()`中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。\n\n### 软引用\n\n特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。\n\n应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。例如，“内存缓存”中的图片是以这种引用来保存，使得JVM在发生OOM之前，可以回收这部分缓存。\n\n### 弱引用\n\n弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n应用场景：弱应用同样可用于内存敏感的缓存。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏。\n\n### 虚引用\n\n特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。\nReferenceQueue queue = new ReferenceQueue ();\nPhantomReference pr = new PhantomReference (object, queue); \n程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。\n\n应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。通常用来做所谓的Post-Mortem清理机制，Java平台本身的Cleaner机制等，也有人利用幻象引用来监控对象的创建和销毁。\n\n### 还存在的问题\n\n除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过get方法获得原有对象。这就意味着，利用软引用和弱引用，我们可以将访问的对象，重新指向强引用，也就是人为的改变了对象的可达性状态。\n所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。\n\n如果我们错误的保持了强引用，比如赋值给了static变量，那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路。\n\n","slug":"java学习/引用的类型","published":1,"updated":"2019-03-22T14:44:36.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmw000104l3nwwvqxcam","content":"<p>在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。</p>\n<a id=\"more\"></a>\n<h3 id=\"引用的来源\"><a href=\"#引用的来源\" class=\"headerlink\" title=\"引用的来源\"></a>引用的来源</h3><p>引用出现的根源是由于GC内存回收的基本原理—GC回收内存本质上是回首对象，而目前比较流行的回收算法是可达性分析算法，从GC Roots开始按照一定的逻辑判断一个对象是否可达，不可达的话就说明这个对象已死（除此之外另外一种常见的算法就是引用计数法，但是这种算法有个问题就是不能解决相互引用的问题）。基于此Java向用户提供了四种可用的引用：即我们本章讲解到的几种，同时还提供了一种不可被使用的引用—FinalReference，这个引用是和析构函数密切相关的）。强引用，开发者可以通过new的方式创建，其它的几种引用Java提供了相应的类：SoftReference、WeakReference、PhantomReference。如果你去查看源码你会发现，这个类实现的核心是Reference与ReferenceQueue（更通俗地说引用队列）两个类，而且这两个类也特别的简单。Reference类似一个链表结构，通过创建一个守护线程来执行对应引用的清除、Cleaner.clean（如果传入的对象是该类的话）、以及引用的入队操作（需要在创建引用的时候制定一个引用队列）；ReferenceQueue这是制定了引用队列的一些具体操作，简单的来说它也是一个链表结构，并提供了一些基本的链表操作）。而除了强引用外其它的都是继承于此，通过这样的类约束了引用的相关内容，便于和GC进行交互。</p>\n<p>不同的引用类型，主要体现的是对象不同的可达性状态和对垃圾收集的影响。判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分。</p>\n<h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>特点：我们平常典型编码<code>Object obj = new Object()</code>中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。</p>\n<p>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。例如，“内存缓存”中的图片是以这种引用来保存，使得JVM在发生OOM之前，可以回收这部分缓存。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<p>应用场景：弱应用同样可用于内存敏感的缓存。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏。</p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br>ReferenceQueue queue = new ReferenceQueue ();<br>PhantomReference pr = new PhantomReference (object, queue);<br>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。</p>\n<p>应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。通常用来做所谓的Post-Mortem清理机制，Java平台本身的Cleaner机制等，也有人利用幻象引用来监控对象的创建和销毁。</p>\n<h3 id=\"还存在的问题\"><a href=\"#还存在的问题\" class=\"headerlink\" title=\"还存在的问题\"></a>还存在的问题</h3><p>除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过get方法获得原有对象。这就意味着，利用软引用和弱引用，我们可以将访问的对象，重新指向强引用，也就是人为的改变了对象的可达性状态。<br>所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。</p>\n<p>如果我们错误的保持了强引用，比如赋值给了static变量，那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路。</p>\n","site":{"data":{}},"excerpt":"<p>在Java语言中，除了基本数据类型外，其他的都是指向各类对象的对象引用；Java中根据其生命周期的长短，将引用分为4类。</p>","more":"<h3 id=\"引用的来源\"><a href=\"#引用的来源\" class=\"headerlink\" title=\"引用的来源\"></a>引用的来源</h3><p>引用出现的根源是由于GC内存回收的基本原理—GC回收内存本质上是回首对象，而目前比较流行的回收算法是可达性分析算法，从GC Roots开始按照一定的逻辑判断一个对象是否可达，不可达的话就说明这个对象已死（除此之外另外一种常见的算法就是引用计数法，但是这种算法有个问题就是不能解决相互引用的问题）。基于此Java向用户提供了四种可用的引用：即我们本章讲解到的几种，同时还提供了一种不可被使用的引用—FinalReference，这个引用是和析构函数密切相关的）。强引用，开发者可以通过new的方式创建，其它的几种引用Java提供了相应的类：SoftReference、WeakReference、PhantomReference。如果你去查看源码你会发现，这个类实现的核心是Reference与ReferenceQueue（更通俗地说引用队列）两个类，而且这两个类也特别的简单。Reference类似一个链表结构，通过创建一个守护线程来执行对应引用的清除、Cleaner.clean（如果传入的对象是该类的话）、以及引用的入队操作（需要在创建引用的时候制定一个引用队列）；ReferenceQueue这是制定了引用队列的一些具体操作，简单的来说它也是一个链表结构，并提供了一些基本的链表操作）。而除了强引用外其它的都是继承于此，通过这样的类约束了引用的相关内容，便于和GC进行交互。</p>\n<p>不同的引用类型，主要体现的是对象不同的可达性状态和对垃圾收集的影响。判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分。</p>\n<h3 id=\"强引用\"><a href=\"#强引用\" class=\"headerlink\" title=\"强引用\"></a>强引用</h3><p>特点：我们平常典型编码<code>Object obj = new Object()</code>中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。</p>\n<h3 id=\"软引用\"><a href=\"#软引用\" class=\"headerlink\" title=\"软引用\"></a>软引用</h3><p>特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。</p>\n<p>应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。例如，“内存缓存”中的图片是以这种引用来保存，使得JVM在发生OOM之前，可以回收这部分缓存。</p>\n<h3 id=\"弱引用\"><a href=\"#弱引用\" class=\"headerlink\" title=\"弱引用\"></a>弱引用</h3><p>弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<p>应用场景：弱应用同样可用于内存敏感的缓存。例如，一个类发送网络请求，承担callback的静态内部类，则常以虚引用的方式来保存外部类(宿主类)的引用，当外部类需要被JVM回收时，不会因为网络请求没有及时回来，导致外部类不能被回收，引起内存泄漏。</p>\n<h3 id=\"虚引用\"><a href=\"#虚引用\" class=\"headerlink\" title=\"虚引用\"></a>虚引用</h3><p>特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。<br>ReferenceQueue queue = new ReferenceQueue ();<br>PhantomReference pr = new PhantomReference (object, queue);<br>程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。</p>\n<p>应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。通常用来做所谓的Post-Mortem清理机制，Java平台本身的Cleaner机制等，也有人利用幻象引用来监控对象的创建和销毁。</p>\n<h3 id=\"还存在的问题\"><a href=\"#还存在的问题\" class=\"headerlink\" title=\"还存在的问题\"></a>还存在的问题</h3><p>除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过get方法获得原有对象。这就意味着，利用软引用和弱引用，我们可以将访问的对象，重新指向强引用，也就是人为的改变了对象的可达性状态。<br>所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。</p>\n<p>如果我们错误的保持了强引用，比如赋值给了static变量，那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路。</p>"},{"title":"Mysql分析-show PROCESSLIST","date":"2017-12-12T08:22:50.000Z","_content":"\nmysql的`show PROCESSLIST`可以在你的mysql性能出现问题的时候,来查看显示的目前的进程。\n\n<!--more-->\n\n## 各列的含义\n\n1.id：一个标识，你要kill一个语句的时候使用，例如 mysql> kill 207;\n2.user：显示当前用户，如果不是root，这个命令就只显示你权限范围内的sql语句;\n3.host：显示这个语句是从哪个ip 的哪个端口上发出的，可用来追踪出问题语句的用户;\n4.db：显示这个进程目前连接的是哪个;\n5.command：显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接（connect）;\n6.time：此这个状态持续的时间，单位是秒;\n7.state：显示使用当前连接的sql语句的状态，很重要的列，state只是语句执行中的某一个状态，例如查询，需要经过copying\n to tmp table，Sorting result，Sending data等状态才可以完成;\n8.info：显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据\n\n## state名词含义\n\n### Sleep\n\n通常代表资源未释放，如果是通过连接池，sleep状态应该恒定在一定数量范围内，例如：\n数据查询时间为0.1秒，而网络输出需要1秒左右，原本数据连接在0.1秒即可释放，但是因为前端程序未执行close操作，直接输出结果，那么在结果未展现在用户桌面前，该数据库连接一直维持在sleep状态\n\n### Locked\n\n操作被锁定，通常使用innodb可以很好的减少locked状态的产生\n\n### Copy to tmp table\n\n索引及现有结构无法涵盖查询条件时，会建立一个临时表来满足查询要求，产生巨大的i/o压力Copy to tmp table通常与连表查询有关，建议减少关联查询或者深入优化查询语句，如果出现此状态的语句执行时间过长，会严重影响其他操作，此时可以kill掉该操作\n\n### Sending data\n\nSending data并不是发送数据，是从物理磁盘获取数据的进程，如果你的影响结果集较多，那么就需要从不同的磁盘碎片去抽取数据，如果sending\n data连接过多，通常是某查询的影响结果集过大，也就是查询的索引项不够优化\n\n### Storing result to query cache\n\n如果频繁出现此状态，使用set profiling分析，如果存在资源开销在SQL整体开销的比例过大（即便是非常小的开销，看比例），则说明query\n cache碎片较多，使用flush query cache可即时清理，Query cache参数可适当酌情设置.\n","source":"_posts/mysql/Mysql分析-show PROCESSLIST.md","raw":"---\ntitle: Mysql分析-show PROCESSLIST\ndate: 2017-12-12 16:22:50\ntags: \n- mysql\ncategories: 总结\n---\n\nmysql的`show PROCESSLIST`可以在你的mysql性能出现问题的时候,来查看显示的目前的进程。\n\n<!--more-->\n\n## 各列的含义\n\n1.id：一个标识，你要kill一个语句的时候使用，例如 mysql> kill 207;\n2.user：显示当前用户，如果不是root，这个命令就只显示你权限范围内的sql语句;\n3.host：显示这个语句是从哪个ip 的哪个端口上发出的，可用来追踪出问题语句的用户;\n4.db：显示这个进程目前连接的是哪个;\n5.command：显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接（connect）;\n6.time：此这个状态持续的时间，单位是秒;\n7.state：显示使用当前连接的sql语句的状态，很重要的列，state只是语句执行中的某一个状态，例如查询，需要经过copying\n to tmp table，Sorting result，Sending data等状态才可以完成;\n8.info：显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据\n\n## state名词含义\n\n### Sleep\n\n通常代表资源未释放，如果是通过连接池，sleep状态应该恒定在一定数量范围内，例如：\n数据查询时间为0.1秒，而网络输出需要1秒左右，原本数据连接在0.1秒即可释放，但是因为前端程序未执行close操作，直接输出结果，那么在结果未展现在用户桌面前，该数据库连接一直维持在sleep状态\n\n### Locked\n\n操作被锁定，通常使用innodb可以很好的减少locked状态的产生\n\n### Copy to tmp table\n\n索引及现有结构无法涵盖查询条件时，会建立一个临时表来满足查询要求，产生巨大的i/o压力Copy to tmp table通常与连表查询有关，建议减少关联查询或者深入优化查询语句，如果出现此状态的语句执行时间过长，会严重影响其他操作，此时可以kill掉该操作\n\n### Sending data\n\nSending data并不是发送数据，是从物理磁盘获取数据的进程，如果你的影响结果集较多，那么就需要从不同的磁盘碎片去抽取数据，如果sending\n data连接过多，通常是某查询的影响结果集过大，也就是查询的索引项不够优化\n\n### Storing result to query cache\n\n如果频繁出现此状态，使用set profiling分析，如果存在资源开销在SQL整体开销的比例过大（即便是非常小的开销，看比例），则说明query\n cache碎片较多，使用flush query cache可即时清理，Query cache参数可适当酌情设置.\n","slug":"mysql/Mysql分析-show PROCESSLIST","published":1,"updated":"2019-03-22T14:44:36.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmw200144l3ngveiic8g","content":"<p>mysql的<code>show PROCESSLIST</code>可以在你的mysql性能出现问题的时候,来查看显示的目前的进程。</p>\n<a id=\"more\"></a>\n<h2 id=\"各列的含义\"><a href=\"#各列的含义\" class=\"headerlink\" title=\"各列的含义\"></a>各列的含义</h2><p>1.id：一个标识，你要kill一个语句的时候使用，例如 mysql&gt; kill 207;<br>2.user：显示当前用户，如果不是root，这个命令就只显示你权限范围内的sql语句;<br>3.host：显示这个语句是从哪个ip 的哪个端口上发出的，可用来追踪出问题语句的用户;<br>4.db：显示这个进程目前连接的是哪个;<br>5.command：显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接（connect）;<br>6.time：此这个状态持续的时间，单位是秒;<br>7.state：显示使用当前连接的sql语句的状态，很重要的列，state只是语句执行中的某一个状态，例如查询，需要经过copying<br> to tmp table，Sorting result，Sending data等状态才可以完成;<br>8.info：显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据</p>\n<h2 id=\"state名词含义\"><a href=\"#state名词含义\" class=\"headerlink\" title=\"state名词含义\"></a>state名词含义</h2><h3 id=\"Sleep\"><a href=\"#Sleep\" class=\"headerlink\" title=\"Sleep\"></a>Sleep</h3><p>通常代表资源未释放，如果是通过连接池，sleep状态应该恒定在一定数量范围内，例如：<br>数据查询时间为0.1秒，而网络输出需要1秒左右，原本数据连接在0.1秒即可释放，但是因为前端程序未执行close操作，直接输出结果，那么在结果未展现在用户桌面前，该数据库连接一直维持在sleep状态</p>\n<h3 id=\"Locked\"><a href=\"#Locked\" class=\"headerlink\" title=\"Locked\"></a>Locked</h3><p>操作被锁定，通常使用innodb可以很好的减少locked状态的产生</p>\n<h3 id=\"Copy-to-tmp-table\"><a href=\"#Copy-to-tmp-table\" class=\"headerlink\" title=\"Copy to tmp table\"></a>Copy to tmp table</h3><p>索引及现有结构无法涵盖查询条件时，会建立一个临时表来满足查询要求，产生巨大的i/o压力Copy to tmp table通常与连表查询有关，建议减少关联查询或者深入优化查询语句，如果出现此状态的语句执行时间过长，会严重影响其他操作，此时可以kill掉该操作</p>\n<h3 id=\"Sending-data\"><a href=\"#Sending-data\" class=\"headerlink\" title=\"Sending data\"></a>Sending data</h3><p>Sending data并不是发送数据，是从物理磁盘获取数据的进程，如果你的影响结果集较多，那么就需要从不同的磁盘碎片去抽取数据，如果sending<br> data连接过多，通常是某查询的影响结果集过大，也就是查询的索引项不够优化</p>\n<h3 id=\"Storing-result-to-query-cache\"><a href=\"#Storing-result-to-query-cache\" class=\"headerlink\" title=\"Storing result to query cache\"></a>Storing result to query cache</h3><p>如果频繁出现此状态，使用set profiling分析，如果存在资源开销在SQL整体开销的比例过大（即便是非常小的开销，看比例），则说明query<br> cache碎片较多，使用flush query cache可即时清理，Query cache参数可适当酌情设置.</p>\n","site":{"data":{}},"excerpt":"<p>mysql的<code>show PROCESSLIST</code>可以在你的mysql性能出现问题的时候,来查看显示的目前的进程。</p>","more":"<h2 id=\"各列的含义\"><a href=\"#各列的含义\" class=\"headerlink\" title=\"各列的含义\"></a>各列的含义</h2><p>1.id：一个标识，你要kill一个语句的时候使用，例如 mysql&gt; kill 207;<br>2.user：显示当前用户，如果不是root，这个命令就只显示你权限范围内的sql语句;<br>3.host：显示这个语句是从哪个ip 的哪个端口上发出的，可用来追踪出问题语句的用户;<br>4.db：显示这个进程目前连接的是哪个;<br>5.command：显示当前连接的执行的命令，一般就是休眠（sleep），查询（query），连接（connect）;<br>6.time：此这个状态持续的时间，单位是秒;<br>7.state：显示使用当前连接的sql语句的状态，很重要的列，state只是语句执行中的某一个状态，例如查询，需要经过copying<br> to tmp table，Sorting result，Sending data等状态才可以完成;<br>8.info：显示这个sql语句，因为长度有限，所以长的sql语句就显示不全，但是一个判断问题语句的重要依据</p>\n<h2 id=\"state名词含义\"><a href=\"#state名词含义\" class=\"headerlink\" title=\"state名词含义\"></a>state名词含义</h2><h3 id=\"Sleep\"><a href=\"#Sleep\" class=\"headerlink\" title=\"Sleep\"></a>Sleep</h3><p>通常代表资源未释放，如果是通过连接池，sleep状态应该恒定在一定数量范围内，例如：<br>数据查询时间为0.1秒，而网络输出需要1秒左右，原本数据连接在0.1秒即可释放，但是因为前端程序未执行close操作，直接输出结果，那么在结果未展现在用户桌面前，该数据库连接一直维持在sleep状态</p>\n<h3 id=\"Locked\"><a href=\"#Locked\" class=\"headerlink\" title=\"Locked\"></a>Locked</h3><p>操作被锁定，通常使用innodb可以很好的减少locked状态的产生</p>\n<h3 id=\"Copy-to-tmp-table\"><a href=\"#Copy-to-tmp-table\" class=\"headerlink\" title=\"Copy to tmp table\"></a>Copy to tmp table</h3><p>索引及现有结构无法涵盖查询条件时，会建立一个临时表来满足查询要求，产生巨大的i/o压力Copy to tmp table通常与连表查询有关，建议减少关联查询或者深入优化查询语句，如果出现此状态的语句执行时间过长，会严重影响其他操作，此时可以kill掉该操作</p>\n<h3 id=\"Sending-data\"><a href=\"#Sending-data\" class=\"headerlink\" title=\"Sending data\"></a>Sending data</h3><p>Sending data并不是发送数据，是从物理磁盘获取数据的进程，如果你的影响结果集较多，那么就需要从不同的磁盘碎片去抽取数据，如果sending<br> data连接过多，通常是某查询的影响结果集过大，也就是查询的索引项不够优化</p>\n<h3 id=\"Storing-result-to-query-cache\"><a href=\"#Storing-result-to-query-cache\" class=\"headerlink\" title=\"Storing result to query cache\"></a>Storing result to query cache</h3><p>如果频繁出现此状态，使用set profiling分析，如果存在资源开销在SQL整体开销的比例过大（即便是非常小的开销，看比例），则说明query<br> cache碎片较多，使用flush query cache可即时清理，Query cache参数可适当酌情设置.</p>"},{"title":"Mysql数据导出至文件","date":"2017-12-01T03:22:50.000Z","_content":"\n在项目中需要将一些简单的sql语句导出至文件,顺便也把其他的一些操作导出做一个记录.\n\n<!--more-->\n\n```\n#sql语句导出\nmysql -P(port) -h(host) -u(user) -p(password) -D(DBname) -N <(需要导入的查询脚本文件) >(需要导出的生成脚本文件)\n# 数据库内容导出\nmysqldump -P(port) -h(host) -u(user) -p(password) -D(DBname) >(需要导出的生成脚本文件)\n# 数据库内容导出\nmysqldump -P(port) -h(host) -u(user) -p(password) -D(DBname) test(表名) >(需要导出的生成脚本文件)\n# 跨机备份数据库\nmysqldump --host=host1 --opt sourceDDBname | mysql --host=host2 -C targetDb\n#只备份表结构\nmysqldump --no-data --databases mydatabase1 mydatabase2 mydatabase3 > test.dump\n```\n\n1. `-N`: 不展示第一行的列名\n2.`>`: 输出文件\n3.`>`: 输入文件,可用于还原备份,导入sql语句\n4. --opt: 如果加上--opt参数则生成的dump文件中稍有不同：\n\n\t\t. 建表语句包含drop table if exists tableName\n\t\t. insert之前包含一个锁表语句lock tables tableName write，insert之后包含unlock tables\n5.-C: 指示主机间的数据传输使用数据压缩","source":"_posts/mysql/Mysql数据导出至文件.md","raw":"---\ntitle: Mysql数据导出至文件\ndate: 2017-12-01 11:22:50\ntags: \n- 数据库\ncategories: 总结\n---\n\n在项目中需要将一些简单的sql语句导出至文件,顺便也把其他的一些操作导出做一个记录.\n\n<!--more-->\n\n```\n#sql语句导出\nmysql -P(port) -h(host) -u(user) -p(password) -D(DBname) -N <(需要导入的查询脚本文件) >(需要导出的生成脚本文件)\n# 数据库内容导出\nmysqldump -P(port) -h(host) -u(user) -p(password) -D(DBname) >(需要导出的生成脚本文件)\n# 数据库内容导出\nmysqldump -P(port) -h(host) -u(user) -p(password) -D(DBname) test(表名) >(需要导出的生成脚本文件)\n# 跨机备份数据库\nmysqldump --host=host1 --opt sourceDDBname | mysql --host=host2 -C targetDb\n#只备份表结构\nmysqldump --no-data --databases mydatabase1 mydatabase2 mydatabase3 > test.dump\n```\n\n1. `-N`: 不展示第一行的列名\n2.`>`: 输出文件\n3.`>`: 输入文件,可用于还原备份,导入sql语句\n4. --opt: 如果加上--opt参数则生成的dump文件中稍有不同：\n\n\t\t. 建表语句包含drop table if exists tableName\n\t\t. insert之前包含一个锁表语句lock tables tableName write，insert之后包含unlock tables\n5.-C: 指示主机间的数据传输使用数据压缩","slug":"mysql/Mysql数据导出至文件","published":1,"updated":"2019-03-22T14:44:36.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmw300174l3nqfp4p6ox","content":"<p>在项目中需要将一些简单的sql语句导出至文件,顺便也把其他的一些操作导出做一个记录.</p>\n<a id=\"more\"></a>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#sql语句导出</span><br><span class=\"line\"><span class=\"title\">mysql</span> -<span class=\"type\">P</span>(<span class=\"keyword\">port</span>) -h(host) -u(user) -p(password) -D(<span class=\"type\">DBname</span>) -N &lt;(需要导入的查询脚本文件) &gt;(需要导出的生成脚本文件)</span><br><span class=\"line\"># 数据库内容导出</span><br><span class=\"line\">mysqldump -P(port) -h(host) -u(user) -p(password) -D(<span class=\"type\">DBname</span>) &gt;(需要导出的生成脚本文件)</span><br><span class=\"line\"># 数据库内容导出</span><br><span class=\"line\">mysqldump -P(port) -h(host) -u(user) -p(password) -D(<span class=\"type\">DBname</span>) test(表名) &gt;(需要导出的生成脚本文件)</span><br><span class=\"line\"># 跨机备份数据库</span><br><span class=\"line\">mysqldump <span class=\"comment\">--host=host1 --opt sourceDDBname | mysql --host=host2 -C targetDb</span></span><br><span class=\"line\">#只备份表结构</span><br><span class=\"line\">mysqldump <span class=\"comment\">--no-data --databases mydatabase1 mydatabase2 mydatabase3 &gt; test.dump</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>-N</code>: 不展示第一行的列名<br>2.<code>&gt;</code>: 输出文件<br>3.<code>&gt;</code>: 输入文件,可用于还原备份,导入sql语句</li>\n<li><p>–opt: 如果加上–opt参数则生成的dump文件中稍有不同：</p>\n<pre><code>. 建表语句包含drop table if exists tableName\n. insert之前包含一个锁表语句lock tables tableName write，insert之后包含unlock tables\n</code></pre><p>5.-C: 指示主机间的数据传输使用数据压缩</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>在项目中需要将一些简单的sql语句导出至文件,顺便也把其他的一些操作导出做一个记录.</p>","more":"<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#sql语句导出</span><br><span class=\"line\"><span class=\"title\">mysql</span> -<span class=\"type\">P</span>(<span class=\"keyword\">port</span>) -h(host) -u(user) -p(password) -D(<span class=\"type\">DBname</span>) -N &lt;(需要导入的查询脚本文件) &gt;(需要导出的生成脚本文件)</span><br><span class=\"line\"># 数据库内容导出</span><br><span class=\"line\">mysqldump -P(port) -h(host) -u(user) -p(password) -D(<span class=\"type\">DBname</span>) &gt;(需要导出的生成脚本文件)</span><br><span class=\"line\"># 数据库内容导出</span><br><span class=\"line\">mysqldump -P(port) -h(host) -u(user) -p(password) -D(<span class=\"type\">DBname</span>) test(表名) &gt;(需要导出的生成脚本文件)</span><br><span class=\"line\"># 跨机备份数据库</span><br><span class=\"line\">mysqldump <span class=\"comment\">--host=host1 --opt sourceDDBname | mysql --host=host2 -C targetDb</span></span><br><span class=\"line\">#只备份表结构</span><br><span class=\"line\">mysqldump <span class=\"comment\">--no-data --databases mydatabase1 mydatabase2 mydatabase3 &gt; test.dump</span></span><br></pre></td></tr></table></figure>\n<ol>\n<li><code>-N</code>: 不展示第一行的列名<br>2.<code>&gt;</code>: 输出文件<br>3.<code>&gt;</code>: 输入文件,可用于还原备份,导入sql语句</li>\n<li><p>–opt: 如果加上–opt参数则生成的dump文件中稍有不同：</p>\n<pre><code>. 建表语句包含drop table if exists tableName\n. insert之前包含一个锁表语句lock tables tableName write，insert之后包含unlock tables\n</code></pre><p>5.-C: 指示主机间的数据传输使用数据压缩</p>\n</li>\n</ol>"},{"title":"mysql上遇到的坑","date":"2017-11-28T13:22:50.000Z","_content":"\n公司用的是mysql数据库,从一开始只了解些sql语句,到现在逐渐了解数据库的一些特性,自己也踩了不少的坑,也算做一个小总结吧.持续更新哦~\n\n## 配置篇\n<!-- more -->\n\n### 除零报错\n\n先来讲一讲`sql_mode`.其中有一个配置项为`ERROR_FOR_DIVISION_BY_ZERO`,作用为:\n\n在insert或者update过程中，如果数据被零除(或MOD(X,0))则产生错误(否则为警告)。如果未给出该模式，那么数据被零除时，mysql返回NULL。如果用到INSERT IGNORE或者UPDATE IGNORE中，mysql生成被零除警告，但操作结果为NULL。\n\n然而,我在写事务的时候,仿照前人经验,写为了ifnull( q_variable_1 / q_variable_2 , 0),本来有意将除`q_variable_2`为0时报为NULL,导致生产环境始终报了除零(division by 0 )错误,但是测试环境由于配置不一样一直没有报错,之后检查配置了之后发现问题所在.于是乎,一顿修改重启数据库之后,再试一把,发现还是报错,此时配置已经改完,可是依旧报错.最后又重新打了存储过程,竟然可以通过了.\n\n所以!!! 再改完配置之后,不仅需要重启数据库,存储过程也需要重新打!\n\n### group by 死循环\n\n当配置了`ONLY_FULL_GROUP_BY`这个配置项时,在使用游标时,游标开始时的select后加了不完全的`group by`,会导致该游标无限空数据循环,也是纠结了很久之后打了断点发现的问题.","source":"_posts/mysql/mysql上遇到的坑.md","raw":"---\ntitle: mysql上遇到的坑\ndate: 2017-11-28 21:22:50\ntags: \n- 数据库\n- mysql\ncategories: 总结\n---\n\n公司用的是mysql数据库,从一开始只了解些sql语句,到现在逐渐了解数据库的一些特性,自己也踩了不少的坑,也算做一个小总结吧.持续更新哦~\n\n## 配置篇\n<!-- more -->\n\n### 除零报错\n\n先来讲一讲`sql_mode`.其中有一个配置项为`ERROR_FOR_DIVISION_BY_ZERO`,作用为:\n\n在insert或者update过程中，如果数据被零除(或MOD(X,0))则产生错误(否则为警告)。如果未给出该模式，那么数据被零除时，mysql返回NULL。如果用到INSERT IGNORE或者UPDATE IGNORE中，mysql生成被零除警告，但操作结果为NULL。\n\n然而,我在写事务的时候,仿照前人经验,写为了ifnull( q_variable_1 / q_variable_2 , 0),本来有意将除`q_variable_2`为0时报为NULL,导致生产环境始终报了除零(division by 0 )错误,但是测试环境由于配置不一样一直没有报错,之后检查配置了之后发现问题所在.于是乎,一顿修改重启数据库之后,再试一把,发现还是报错,此时配置已经改完,可是依旧报错.最后又重新打了存储过程,竟然可以通过了.\n\n所以!!! 再改完配置之后,不仅需要重启数据库,存储过程也需要重新打!\n\n### group by 死循环\n\n当配置了`ONLY_FULL_GROUP_BY`这个配置项时,在使用游标时,游标开始时的select后加了不完全的`group by`,会导致该游标无限空数据循环,也是纠结了很久之后打了断点发现的问题.","slug":"mysql/mysql上遇到的坑","published":1,"updated":"2019-03-22T14:44:36.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmw4001a4l3nokaarpwk","content":"<p>公司用的是mysql数据库,从一开始只了解些sql语句,到现在逐渐了解数据库的一些特性,自己也踩了不少的坑,也算做一个小总结吧.持续更新哦~</p>\n<h2 id=\"配置篇\"><a href=\"#配置篇\" class=\"headerlink\" title=\"配置篇\"></a>配置篇</h2><a id=\"more\"></a>\n<h3 id=\"除零报错\"><a href=\"#除零报错\" class=\"headerlink\" title=\"除零报错\"></a>除零报错</h3><p>先来讲一讲<code>sql_mode</code>.其中有一个配置项为<code>ERROR_FOR_DIVISION_BY_ZERO</code>,作用为:</p>\n<p>在insert或者update过程中，如果数据被零除(或MOD(X,0))则产生错误(否则为警告)。如果未给出该模式，那么数据被零除时，mysql返回NULL。如果用到INSERT IGNORE或者UPDATE IGNORE中，mysql生成被零除警告，但操作结果为NULL。</p>\n<p>然而,我在写事务的时候,仿照前人经验,写为了ifnull( q_variable_1 / q_variable_2 , 0),本来有意将除<code>q_variable_2</code>为0时报为NULL,导致生产环境始终报了除零(division by 0 )错误,但是测试环境由于配置不一样一直没有报错,之后检查配置了之后发现问题所在.于是乎,一顿修改重启数据库之后,再试一把,发现还是报错,此时配置已经改完,可是依旧报错.最后又重新打了存储过程,竟然可以通过了.</p>\n<p>所以!!! 再改完配置之后,不仅需要重启数据库,存储过程也需要重新打!</p>\n<h3 id=\"group-by-死循环\"><a href=\"#group-by-死循环\" class=\"headerlink\" title=\"group by 死循环\"></a>group by 死循环</h3><p>当配置了<code>ONLY_FULL_GROUP_BY</code>这个配置项时,在使用游标时,游标开始时的select后加了不完全的<code>group by</code>,会导致该游标无限空数据循环,也是纠结了很久之后打了断点发现的问题.</p>\n","site":{"data":{}},"excerpt":"<p>公司用的是mysql数据库,从一开始只了解些sql语句,到现在逐渐了解数据库的一些特性,自己也踩了不少的坑,也算做一个小总结吧.持续更新哦~</p>\n<h2 id=\"配置篇\"><a href=\"#配置篇\" class=\"headerlink\" title=\"配置篇\"></a>配置篇</h2>","more":"<h3 id=\"除零报错\"><a href=\"#除零报错\" class=\"headerlink\" title=\"除零报错\"></a>除零报错</h3><p>先来讲一讲<code>sql_mode</code>.其中有一个配置项为<code>ERROR_FOR_DIVISION_BY_ZERO</code>,作用为:</p>\n<p>在insert或者update过程中，如果数据被零除(或MOD(X,0))则产生错误(否则为警告)。如果未给出该模式，那么数据被零除时，mysql返回NULL。如果用到INSERT IGNORE或者UPDATE IGNORE中，mysql生成被零除警告，但操作结果为NULL。</p>\n<p>然而,我在写事务的时候,仿照前人经验,写为了ifnull( q_variable_1 / q_variable_2 , 0),本来有意将除<code>q_variable_2</code>为0时报为NULL,导致生产环境始终报了除零(division by 0 )错误,但是测试环境由于配置不一样一直没有报错,之后检查配置了之后发现问题所在.于是乎,一顿修改重启数据库之后,再试一把,发现还是报错,此时配置已经改完,可是依旧报错.最后又重新打了存储过程,竟然可以通过了.</p>\n<p>所以!!! 再改完配置之后,不仅需要重启数据库,存储过程也需要重新打!</p>\n<h3 id=\"group-by-死循环\"><a href=\"#group-by-死循环\" class=\"headerlink\" title=\"group by 死循环\"></a>group by 死循环</h3><p>当配置了<code>ONLY_FULL_GROUP_BY</code>这个配置项时,在使用游标时,游标开始时的select后加了不完全的<code>group by</code>,会导致该游标无限空数据循环,也是纠结了很久之后打了断点发现的问题.</p>"},{"title":"final、finally、 finalize 有何不同","date":"2018-11-12T09:35:00.000Z","_content":"\n其实这三者风马牛不相及,尽管这个问题很基础,但是除了语法和使用实践角度出发,还可以从其性能、并发、对象生命周期或垃圾收集基本过程等方面的理解.\n\n<!-- more -->\n### final\n\n`final` 可以用来修饰类、方法、变量,修饰class代表不可以继承扩展,修饰变量代表不可以修改,修饰方法代表不可以重写.初衷就是明确告知别人这些行为是不许修改的.在一些第三方类库中的一些基础类会声明成final class,可以有效避免API使用者更改基础功能,在某种程度上,是保证平台安全的必要手段.\n\n但是需要注意的是,`final`不是`immutable`! 不可变最基本是行为不可变，不提供可变的操作。变量私有化，没有增加，修改等方法，final只是保证指针不可变，无法保证内容不可变。\n\n```java\n final List<String> strList = new ArrayList<>();\n strList.add(\"Hello\");\n strList.add(\"world\"); \n //JDK 9 新特性,不可变\n List<String> unmodifiableStrList = List.of(\"hello\", \"world\");\n unmodifiableStrList.add(\"again\");\n //抛出异常\n```\n\n`final`只能约束`strList`这个引用不可被赋值,但是strList对象行为不被影响.\n\n如果我们真的希望对象本身是不可变的,那么需要相应的类支持不可变的行为.目前Java语言没有原生的不可变支持,如果要实现`immutable`的类,我们需要做到:\n\n* 将class自身声明为final,这样就不能通过扩展来绕过限制\n* 将所有成员变量定义为private和final,并不要实现setter方法\n* 构造对象时,成员变量使用深度拷贝来初始化,而不是直接赋值,防止被人对输入对象修改\n* 如果要实现getter方法或者可能会返回内部状态的放,使用COW(copy-on-write)原则,创建私有的copy.\n\n### finally\n\n`finally `保证重点代码一定要被执行的机制.可以用 try-finally 或者 try-catch-finally 来进行类似关闭JDBC连接,保证unlock锁等动作.\n\n```java\n\ntry {\n  // do something\n  System.exit(1);\n} finally{\n  System.out.println(“Print from finally”);\n}\n\n```\n上面 finally 里面的代码可不会被执行的哦，这是一个特例.\n\n### finalize\n\n`finalize` 是基础类Object的一个方法,他的设计目的是保证对象在被垃圾收集前完成特定资源的回收.finalize 机制现在已经不推荐使用,并且在`JDK 9`开始被标记为`deprecated`.为什么呢?因为你无法保证 `finalize` 何时被执行,执行是否符合预期.使用不当会影响性能,导致程序死锁、挂起等.\n\n通常来说,利用`try-with-resource` 或者`try-finally`机制来进行资源回收.如果需要额外处理们可以考虑Java提供的Cleaner机制或者其他替代方法.\n\n一旦实现了非空的`finalize`方法,就会导致相应对象回收呈现数量级上的变慢,有人专门做过benchmark,大概是40~50倍的下降.\n\n`finalize`被设计为在对象被垃圾收集前调用,finalize()方法是GC(garbage collector) 运行机制的一部分,finalize()方法的作用是什么呢？finalize()方法是在GC清理它所从属的对象时被调用的，如果执行它的过程中抛出了无法捕获的异常（uncaughtexception，GC将终止对改对象的清理，并且该异常会被忽略；直到下一次GC开始清理这个对象时，它的finalize()会被再次调用。这就意味着实现了`finalize`方法的对象,JVM要对他额外处理,本质上对快速回收进行了阻碍,可能导致\n你的对象经过多个垃圾收集周期才能被回收.\n\nJava平台目前逐步使用`java.lang.ref.Cleaner`来替换掉原有的`finalize`实现.Cleaner利用了幻象引用,这是一种常见的post-mortem(验尸) 清理机制,个Cleaner 的操作都是独立的，有自己的运行线程，避免意外死锁的问题。\n\n注意，从可预测性的角度来判断，Cleaner 或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致**幻象引用堆积**，同样会出现问题。所以，Cleaner 适合作为一种最后的保证手段，而不是完全依赖 Cleaner 进行资源回收，不然我们就要再做一遍 finalize 的噩梦了。\n\n很多第三方库自己直接利用幻象引用定制资源收集，比如广泛使用的 MySQL JDBC driver 之一的 mysql-connector-j，就利用了幻象引用机制。幻象引用也可以进行类似链条式依赖关系的动作，比如，进行总量控制的场景，保证只有连接被关闭，相应资源被回收，连接池才能创建新的连接。\n\n另外，这种代码如果稍有不慎添加了对资源的强引用关系，就会导致循环引用关系，前面提到的 MySQL JDBC 就在特定模式下有这种问题，导致内存泄漏。上面的示例代码中，将 State 定义为 static，就是为了避免普通的内部类隐含着对外部对象的强引用，因为那样会使外部对象无法进入幻象可达的状态。","source":"_posts/java学习/final、finally、 finalize 有何不同.md","raw":"---\ntitle: final、finally、 finalize 有何不同\ndate: 2018-11-12 17:35:00\ntags: \n- java\ncategories: 总结\n---\n\n其实这三者风马牛不相及,尽管这个问题很基础,但是除了语法和使用实践角度出发,还可以从其性能、并发、对象生命周期或垃圾收集基本过程等方面的理解.\n\n<!-- more -->\n### final\n\n`final` 可以用来修饰类、方法、变量,修饰class代表不可以继承扩展,修饰变量代表不可以修改,修饰方法代表不可以重写.初衷就是明确告知别人这些行为是不许修改的.在一些第三方类库中的一些基础类会声明成final class,可以有效避免API使用者更改基础功能,在某种程度上,是保证平台安全的必要手段.\n\n但是需要注意的是,`final`不是`immutable`! 不可变最基本是行为不可变，不提供可变的操作。变量私有化，没有增加，修改等方法，final只是保证指针不可变，无法保证内容不可变。\n\n```java\n final List<String> strList = new ArrayList<>();\n strList.add(\"Hello\");\n strList.add(\"world\"); \n //JDK 9 新特性,不可变\n List<String> unmodifiableStrList = List.of(\"hello\", \"world\");\n unmodifiableStrList.add(\"again\");\n //抛出异常\n```\n\n`final`只能约束`strList`这个引用不可被赋值,但是strList对象行为不被影响.\n\n如果我们真的希望对象本身是不可变的,那么需要相应的类支持不可变的行为.目前Java语言没有原生的不可变支持,如果要实现`immutable`的类,我们需要做到:\n\n* 将class自身声明为final,这样就不能通过扩展来绕过限制\n* 将所有成员变量定义为private和final,并不要实现setter方法\n* 构造对象时,成员变量使用深度拷贝来初始化,而不是直接赋值,防止被人对输入对象修改\n* 如果要实现getter方法或者可能会返回内部状态的放,使用COW(copy-on-write)原则,创建私有的copy.\n\n### finally\n\n`finally `保证重点代码一定要被执行的机制.可以用 try-finally 或者 try-catch-finally 来进行类似关闭JDBC连接,保证unlock锁等动作.\n\n```java\n\ntry {\n  // do something\n  System.exit(1);\n} finally{\n  System.out.println(“Print from finally”);\n}\n\n```\n上面 finally 里面的代码可不会被执行的哦，这是一个特例.\n\n### finalize\n\n`finalize` 是基础类Object的一个方法,他的设计目的是保证对象在被垃圾收集前完成特定资源的回收.finalize 机制现在已经不推荐使用,并且在`JDK 9`开始被标记为`deprecated`.为什么呢?因为你无法保证 `finalize` 何时被执行,执行是否符合预期.使用不当会影响性能,导致程序死锁、挂起等.\n\n通常来说,利用`try-with-resource` 或者`try-finally`机制来进行资源回收.如果需要额外处理们可以考虑Java提供的Cleaner机制或者其他替代方法.\n\n一旦实现了非空的`finalize`方法,就会导致相应对象回收呈现数量级上的变慢,有人专门做过benchmark,大概是40~50倍的下降.\n\n`finalize`被设计为在对象被垃圾收集前调用,finalize()方法是GC(garbage collector) 运行机制的一部分,finalize()方法的作用是什么呢？finalize()方法是在GC清理它所从属的对象时被调用的，如果执行它的过程中抛出了无法捕获的异常（uncaughtexception，GC将终止对改对象的清理，并且该异常会被忽略；直到下一次GC开始清理这个对象时，它的finalize()会被再次调用。这就意味着实现了`finalize`方法的对象,JVM要对他额外处理,本质上对快速回收进行了阻碍,可能导致\n你的对象经过多个垃圾收集周期才能被回收.\n\nJava平台目前逐步使用`java.lang.ref.Cleaner`来替换掉原有的`finalize`实现.Cleaner利用了幻象引用,这是一种常见的post-mortem(验尸) 清理机制,个Cleaner 的操作都是独立的，有自己的运行线程，避免意外死锁的问题。\n\n注意，从可预测性的角度来判断，Cleaner 或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致**幻象引用堆积**，同样会出现问题。所以，Cleaner 适合作为一种最后的保证手段，而不是完全依赖 Cleaner 进行资源回收，不然我们就要再做一遍 finalize 的噩梦了。\n\n很多第三方库自己直接利用幻象引用定制资源收集，比如广泛使用的 MySQL JDBC driver 之一的 mysql-connector-j，就利用了幻象引用机制。幻象引用也可以进行类似链条式依赖关系的动作，比如，进行总量控制的场景，保证只有连接被关闭，相应资源被回收，连接池才能创建新的连接。\n\n另外，这种代码如果稍有不慎添加了对资源的强引用关系，就会导致循环引用关系，前面提到的 MySQL JDBC 就在特定模式下有这种问题，导致内存泄漏。上面的示例代码中，将 State 定义为 static，就是为了避免普通的内部类隐含着对外部对象的强引用，因为那样会使外部对象无法进入幻象可达的状态。","slug":"java学习/final、finally、 finalize 有何不同","published":1,"updated":"2019-04-08T14:28:18.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmw5001e4l3n0swfytyc","content":"<p>其实这三者风马牛不相及,尽管这个问题很基础,但是除了语法和使用实践角度出发,还可以从其性能、并发、对象生命周期或垃圾收集基本过程等方面的理解.</p>\n<a id=\"more\"></a>\n<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p><code>final</code> 可以用来修饰类、方法、变量,修饰class代表不可以继承扩展,修饰变量代表不可以修改,修饰方法代表不可以重写.初衷就是明确告知别人这些行为是不许修改的.在一些第三方类库中的一些基础类会声明成final class,可以有效避免API使用者更改基础功能,在某种程度上,是保证平台安全的必要手段.</p>\n<p>但是需要注意的是,<code>final</code>不是<code>immutable</code>! 不可变最基本是行为不可变，不提供可变的操作。变量私有化，没有增加，修改等方法，final只是保证指针不可变，无法保证内容不可变。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; strList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">strList.add(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">strList.add(<span class=\"string\">\"world\"</span>); </span><br><span class=\"line\"><span class=\"comment\">//JDK 9 新特性,不可变</span></span><br><span class=\"line\">List&lt;String&gt; unmodifiableStrList = List.of(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">unmodifiableStrList.add(<span class=\"string\">\"again\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//抛出异常</span></span><br></pre></td></tr></table></figure>\n<p><code>final</code>只能约束<code>strList</code>这个引用不可被赋值,但是strList对象行为不被影响.</p>\n<p>如果我们真的希望对象本身是不可变的,那么需要相应的类支持不可变的行为.目前Java语言没有原生的不可变支持,如果要实现<code>immutable</code>的类,我们需要做到:</p>\n<ul>\n<li>将class自身声明为final,这样就不能通过扩展来绕过限制</li>\n<li>将所有成员变量定义为private和final,并不要实现setter方法</li>\n<li>构造对象时,成员变量使用深度拷贝来初始化,而不是直接赋值,防止被人对输入对象修改</li>\n<li>如果要实现getter方法或者可能会返回内部状态的放,使用COW(copy-on-write)原则,创建私有的copy.</li>\n</ul>\n<h3 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally\"></a>finally</h3><p><code>finally</code>保证重点代码一定要被执行的机制.可以用 try-finally 或者 try-catch-finally 来进行类似关闭JDBC连接,保证unlock锁等动作.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">  System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">  System.out.println(“Print from <span class=\"keyword\">finally</span>”);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面 finally 里面的代码可不会被执行的哦，这是一个特例.</p>\n<h3 id=\"finalize\"><a href=\"#finalize\" class=\"headerlink\" title=\"finalize\"></a>finalize</h3><p><code>finalize</code> 是基础类Object的一个方法,他的设计目的是保证对象在被垃圾收集前完成特定资源的回收.finalize 机制现在已经不推荐使用,并且在<code>JDK 9</code>开始被标记为<code>deprecated</code>.为什么呢?因为你无法保证 <code>finalize</code> 何时被执行,执行是否符合预期.使用不当会影响性能,导致程序死锁、挂起等.</p>\n<p>通常来说,利用<code>try-with-resource</code> 或者<code>try-finally</code>机制来进行资源回收.如果需要额外处理们可以考虑Java提供的Cleaner机制或者其他替代方法.</p>\n<p>一旦实现了非空的<code>finalize</code>方法,就会导致相应对象回收呈现数量级上的变慢,有人专门做过benchmark,大概是40~50倍的下降.</p>\n<p><code>finalize</code>被设计为在对象被垃圾收集前调用,finalize()方法是GC(garbage collector) 运行机制的一部分,finalize()方法的作用是什么呢？finalize()方法是在GC清理它所从属的对象时被调用的，如果执行它的过程中抛出了无法捕获的异常（uncaughtexception，GC将终止对改对象的清理，并且该异常会被忽略；直到下一次GC开始清理这个对象时，它的finalize()会被再次调用。这就意味着实现了<code>finalize</code>方法的对象,JVM要对他额外处理,本质上对快速回收进行了阻碍,可能导致<br>你的对象经过多个垃圾收集周期才能被回收.</p>\n<p>Java平台目前逐步使用<code>java.lang.ref.Cleaner</code>来替换掉原有的<code>finalize</code>实现.Cleaner利用了幻象引用,这是一种常见的post-mortem(验尸) 清理机制,个Cleaner 的操作都是独立的，有自己的运行线程，避免意外死锁的问题。</p>\n<p>注意，从可预测性的角度来判断，Cleaner 或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致<strong>幻象引用堆积</strong>，同样会出现问题。所以，Cleaner 适合作为一种最后的保证手段，而不是完全依赖 Cleaner 进行资源回收，不然我们就要再做一遍 finalize 的噩梦了。</p>\n<p>很多第三方库自己直接利用幻象引用定制资源收集，比如广泛使用的 MySQL JDBC driver 之一的 mysql-connector-j，就利用了幻象引用机制。幻象引用也可以进行类似链条式依赖关系的动作，比如，进行总量控制的场景，保证只有连接被关闭，相应资源被回收，连接池才能创建新的连接。</p>\n<p>另外，这种代码如果稍有不慎添加了对资源的强引用关系，就会导致循环引用关系，前面提到的 MySQL JDBC 就在特定模式下有这种问题，导致内存泄漏。上面的示例代码中，将 State 定义为 static，就是为了避免普通的内部类隐含着对外部对象的强引用，因为那样会使外部对象无法进入幻象可达的状态。</p>\n","site":{"data":{}},"excerpt":"<p>其实这三者风马牛不相及,尽管这个问题很基础,但是除了语法和使用实践角度出发,还可以从其性能、并发、对象生命周期或垃圾收集基本过程等方面的理解.</p>","more":"<h3 id=\"final\"><a href=\"#final\" class=\"headerlink\" title=\"final\"></a>final</h3><p><code>final</code> 可以用来修饰类、方法、变量,修饰class代表不可以继承扩展,修饰变量代表不可以修改,修饰方法代表不可以重写.初衷就是明确告知别人这些行为是不许修改的.在一些第三方类库中的一些基础类会声明成final class,可以有效避免API使用者更改基础功能,在某种程度上,是保证平台安全的必要手段.</p>\n<p>但是需要注意的是,<code>final</code>不是<code>immutable</code>! 不可变最基本是行为不可变，不提供可变的操作。变量私有化，没有增加，修改等方法，final只是保证指针不可变，无法保证内容不可变。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> List&lt;String&gt; strList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">strList.add(<span class=\"string\">\"Hello\"</span>);</span><br><span class=\"line\">strList.add(<span class=\"string\">\"world\"</span>); </span><br><span class=\"line\"><span class=\"comment\">//JDK 9 新特性,不可变</span></span><br><span class=\"line\">List&lt;String&gt; unmodifiableStrList = List.of(<span class=\"string\">\"hello\"</span>, <span class=\"string\">\"world\"</span>);</span><br><span class=\"line\">unmodifiableStrList.add(<span class=\"string\">\"again\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//抛出异常</span></span><br></pre></td></tr></table></figure>\n<p><code>final</code>只能约束<code>strList</code>这个引用不可被赋值,但是strList对象行为不被影响.</p>\n<p>如果我们真的希望对象本身是不可变的,那么需要相应的类支持不可变的行为.目前Java语言没有原生的不可变支持,如果要实现<code>immutable</code>的类,我们需要做到:</p>\n<ul>\n<li>将class自身声明为final,这样就不能通过扩展来绕过限制</li>\n<li>将所有成员变量定义为private和final,并不要实现setter方法</li>\n<li>构造对象时,成员变量使用深度拷贝来初始化,而不是直接赋值,防止被人对输入对象修改</li>\n<li>如果要实现getter方法或者可能会返回内部状态的放,使用COW(copy-on-write)原则,创建私有的copy.</li>\n</ul>\n<h3 id=\"finally\"><a href=\"#finally\" class=\"headerlink\" title=\"finally\"></a>finally</h3><p><code>finally</code>保证重点代码一定要被执行的机制.可以用 try-finally 或者 try-catch-finally 来进行类似关闭JDBC连接,保证unlock锁等动作.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  <span class=\"comment\">// do something</span></span><br><span class=\"line\">  System.exit(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125; <span class=\"keyword\">finally</span>&#123;</span><br><span class=\"line\">  System.out.println(“Print from <span class=\"keyword\">finally</span>”);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>上面 finally 里面的代码可不会被执行的哦，这是一个特例.</p>\n<h3 id=\"finalize\"><a href=\"#finalize\" class=\"headerlink\" title=\"finalize\"></a>finalize</h3><p><code>finalize</code> 是基础类Object的一个方法,他的设计目的是保证对象在被垃圾收集前完成特定资源的回收.finalize 机制现在已经不推荐使用,并且在<code>JDK 9</code>开始被标记为<code>deprecated</code>.为什么呢?因为你无法保证 <code>finalize</code> 何时被执行,执行是否符合预期.使用不当会影响性能,导致程序死锁、挂起等.</p>\n<p>通常来说,利用<code>try-with-resource</code> 或者<code>try-finally</code>机制来进行资源回收.如果需要额外处理们可以考虑Java提供的Cleaner机制或者其他替代方法.</p>\n<p>一旦实现了非空的<code>finalize</code>方法,就会导致相应对象回收呈现数量级上的变慢,有人专门做过benchmark,大概是40~50倍的下降.</p>\n<p><code>finalize</code>被设计为在对象被垃圾收集前调用,finalize()方法是GC(garbage collector) 运行机制的一部分,finalize()方法的作用是什么呢？finalize()方法是在GC清理它所从属的对象时被调用的，如果执行它的过程中抛出了无法捕获的异常（uncaughtexception，GC将终止对改对象的清理，并且该异常会被忽略；直到下一次GC开始清理这个对象时，它的finalize()会被再次调用。这就意味着实现了<code>finalize</code>方法的对象,JVM要对他额外处理,本质上对快速回收进行了阻碍,可能导致<br>你的对象经过多个垃圾收集周期才能被回收.</p>\n<p>Java平台目前逐步使用<code>java.lang.ref.Cleaner</code>来替换掉原有的<code>finalize</code>实现.Cleaner利用了幻象引用,这是一种常见的post-mortem(验尸) 清理机制,个Cleaner 的操作都是独立的，有自己的运行线程，避免意外死锁的问题。</p>\n<p>注意，从可预测性的角度来判断，Cleaner 或者幻象引用改善的程度仍然是有限的，如果由于种种原因导致<strong>幻象引用堆积</strong>，同样会出现问题。所以，Cleaner 适合作为一种最后的保证手段，而不是完全依赖 Cleaner 进行资源回收，不然我们就要再做一遍 finalize 的噩梦了。</p>\n<p>很多第三方库自己直接利用幻象引用定制资源收集，比如广泛使用的 MySQL JDBC driver 之一的 mysql-connector-j，就利用了幻象引用机制。幻象引用也可以进行类似链条式依赖关系的动作，比如，进行总量控制的场景，保证只有连接被关闭，相应资源被回收，连接池才能创建新的连接。</p>\n<p>另外，这种代码如果稍有不慎添加了对资源的强引用关系，就会导致循环引用关系，前面提到的 MySQL JDBC 就在特定模式下有这种问题，导致内存泄漏。上面的示例代码中，将 State 定义为 static，就是为了避免普通的内部类隐含着对外部对象的强引用，因为那样会使外部对象无法进入幻象可达的状态。</p>"},{"title":"mysql 存储过程异常处理","date":"2018-09-25T13:22:50.000Z","_content":"\n\n当我们处理存储过程的时候,难免会遇到如何将存储过程中的报错统一处理之后返回出来。在工作中正好需要用到这方面的知识，所以来学习并做个记录。\n\n<!-- more -->\n\n```\ncreate procedure duplicate_teams(out p int)\nBEGIN\nset p = 1;\ninsert into test values (1,2);\nset p =2;\nEND\n\n```\n\n这里的test表只有一个字段,我们临时测试使用,因此没有在对其创建表。\n在进行调用时:\n\n```\ncall pr_test(@q);\nselect @q;\n```\n\n在默认情况下，当存储过程运行出错时，过程会立即终止，并打印系统错误消息：\n\n```\n1136 - Column count doesn't match value count at row 1\n```\n\n输出为空。\n\n## 1. 定义异常处理\n通过对异常的定义，我们可以对其作出相应的处理步骤。\n\nDECLARE ... HANDLER语句来进行定义处理：\n\n```\n\nDECLARE handler_action HANDLER\n    FOR condition_value [, condition_value] ...\n    statement\n# 定义操作的动作:\n# CONTINUE 继续执行当前程序\n# EXIT 当前程序终止(退出当前declare所在的begin end)；\nhandler_action:\n    CONTINUE\n    | EXIT\n\n# condition_value用以指明触发条件\ncondition_value:\n    mysql_error_code\n    | SQLSTATE [VALUE] sqlstate_value\n    | condition_name\n    | SQLWARNING\n    | NOT FOUND\n    | SQLEXCEPTION\n\n# statement触发的时候需要做的操作\nstatement\n```\n\n## 2. 实践\n将上述代码修改为:\n\n```\ncreate procedure duplicate_teams(out p int)\nBEGIN\n\nDECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    BEGIN\n        set p = \"10086\";\n    END;\n\nset p = 1;\ninsert into test values (1,2);\nset p =2;\nEND\n```\n此时再去调用得到结果为 2,当为EXIT模式时,则返回10086。\n\n\n## 3. 获取错误内容\n\n虽然我们获取了错误,但是并没有很方便的定位到报错位置以及报错信息。`mysql 5.6.4`以后的版本提供了`GET DIAGNOSTICS`来获取缓冲区的报错内容。\n\n\n```\n#关键字CURRENT表示从当前诊断区域检索信息。在MySQL中，它没有任何效果，因为这是默认行为。\nGET [CURRENT] DIAGNOSTICS\n{\n    statement_information_item\n    [, statement_information_item] ...\n  | CONDITION condition_number\n    condition_information_item\n    [, condition_information_item] ...\n}\n\n# \nstatement_information_item:\n    target = statement_information_item_name\n\ncondition_information_item:\n    target = condition_information_item_name\n\nstatement_information_item_name:\n    NUMBER\n  | ROW_COUNT\n\ncondition_information_item_name:\n    CLASS_ORIGIN\n  | SUBCLASS_ORIGIN\n  | RETURNED_SQLSTATE\n  | MESSAGE_TEXT\n  | MYSQL_ERRNO\n  | CONSTRAINT_CATALOG\n  | CONSTRAINT_SCHEMA\n  | CONSTRAINT_NAME\n  | CATALOG_NAME\n  | SCHEMA_NAME\n  | TABLE_NAME\n  | COLUMN_NAME\n  | CURSOR_NAME\n\n\n\n# 要获取语句信息，请将所需的语句项检索到目标变量中。此实例 GET DIAGNOSTICS将可用条件数和受行影响的计数分配给用户变量\nGET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;\n\n#要获取条件信息，请指定条件编号并将所需的条件项检索到目标变量中。此实例GET DIAGNOSTICS将SQLSTATE值和错误消息分配给用户变量\nGET DIAGNOSTICS CONDITION 1 @p3 = RETURNED_SQLSTATE, @p4 = MESSAGE_TEXT;\n\n```\n\n\n代码修正如下:\n\n```\ncreate procedure duplicate_teams(out result varchar(1024))\nBEGIN\nDECLARE code VARCHAR(1024);\nDECLARE msg VARCHAR(1024);\nDECLARE EXIT HANDLER FOR SQLEXCEPTION\n    BEGIN\n\t\tGET DIAGNOSTICS CONDITION 1\n        code = RETURNED_SQLSTATE, msg = MESSAGE_TEXT;\n        SET result = CONCAT('insert failed, error = ',code,', message = ',msg);\n    END;\n\nset result = 1;\ninsert into test values (1,2);\nset result =2;\nEND\n```\n\n输出为:\n\n```\ncall pr_test(@q);\nselect @q;\n\n@q\ninsert failed, error = 21S01, message = Column count doesn't match value count at row 1\n```\n## 4. 补充说明\n\n### 关于错误编号\n\n每个MySQL错误都有一个唯一的数字错误编号(`mysql_error_code`)，每个错误又对应一个5字符的SQLSTATE码(ANSI SQL 采用)。\n\n\nSQLSTATE码对应的处理程序：\n\n　　1、SQLWARNING处理程序：以‘01’开头的所有sqlstate码与之对应,对应为警告\n\n　　2、NOT FOUND处理程序：以‘02’开头的所有sqlstate码与之对应为无数据\n\n　　3、SQLEXCEPTION处理程序：不以‘01’或‘02’开头的所有sqlstate码，也就是所有未被SQLWARNING或NOT FOUND捕获的SQLSTATE(常遇到的MySQL错误就是非‘01’、‘02’开头的)\n\n* 注意：‘01’、‘02’开头和‘1’、‘2’开头是有区别的，是不一样的错误sqlsate码。\n\n","source":"_posts/mysql/mysql存储过程异常处理.md","raw":"---\ntitle: mysql 存储过程异常处理\ndate: 2018-09-25 21:22:50\ntags: \n- 存储过程\n- mysql\ncategories: 总结\n---\n\n\n当我们处理存储过程的时候,难免会遇到如何将存储过程中的报错统一处理之后返回出来。在工作中正好需要用到这方面的知识，所以来学习并做个记录。\n\n<!-- more -->\n\n```\ncreate procedure duplicate_teams(out p int)\nBEGIN\nset p = 1;\ninsert into test values (1,2);\nset p =2;\nEND\n\n```\n\n这里的test表只有一个字段,我们临时测试使用,因此没有在对其创建表。\n在进行调用时:\n\n```\ncall pr_test(@q);\nselect @q;\n```\n\n在默认情况下，当存储过程运行出错时，过程会立即终止，并打印系统错误消息：\n\n```\n1136 - Column count doesn't match value count at row 1\n```\n\n输出为空。\n\n## 1. 定义异常处理\n通过对异常的定义，我们可以对其作出相应的处理步骤。\n\nDECLARE ... HANDLER语句来进行定义处理：\n\n```\n\nDECLARE handler_action HANDLER\n    FOR condition_value [, condition_value] ...\n    statement\n# 定义操作的动作:\n# CONTINUE 继续执行当前程序\n# EXIT 当前程序终止(退出当前declare所在的begin end)；\nhandler_action:\n    CONTINUE\n    | EXIT\n\n# condition_value用以指明触发条件\ncondition_value:\n    mysql_error_code\n    | SQLSTATE [VALUE] sqlstate_value\n    | condition_name\n    | SQLWARNING\n    | NOT FOUND\n    | SQLEXCEPTION\n\n# statement触发的时候需要做的操作\nstatement\n```\n\n## 2. 实践\n将上述代码修改为:\n\n```\ncreate procedure duplicate_teams(out p int)\nBEGIN\n\nDECLARE CONTINUE HANDLER FOR SQLEXCEPTION\n    BEGIN\n        set p = \"10086\";\n    END;\n\nset p = 1;\ninsert into test values (1,2);\nset p =2;\nEND\n```\n此时再去调用得到结果为 2,当为EXIT模式时,则返回10086。\n\n\n## 3. 获取错误内容\n\n虽然我们获取了错误,但是并没有很方便的定位到报错位置以及报错信息。`mysql 5.6.4`以后的版本提供了`GET DIAGNOSTICS`来获取缓冲区的报错内容。\n\n\n```\n#关键字CURRENT表示从当前诊断区域检索信息。在MySQL中，它没有任何效果，因为这是默认行为。\nGET [CURRENT] DIAGNOSTICS\n{\n    statement_information_item\n    [, statement_information_item] ...\n  | CONDITION condition_number\n    condition_information_item\n    [, condition_information_item] ...\n}\n\n# \nstatement_information_item:\n    target = statement_information_item_name\n\ncondition_information_item:\n    target = condition_information_item_name\n\nstatement_information_item_name:\n    NUMBER\n  | ROW_COUNT\n\ncondition_information_item_name:\n    CLASS_ORIGIN\n  | SUBCLASS_ORIGIN\n  | RETURNED_SQLSTATE\n  | MESSAGE_TEXT\n  | MYSQL_ERRNO\n  | CONSTRAINT_CATALOG\n  | CONSTRAINT_SCHEMA\n  | CONSTRAINT_NAME\n  | CATALOG_NAME\n  | SCHEMA_NAME\n  | TABLE_NAME\n  | COLUMN_NAME\n  | CURSOR_NAME\n\n\n\n# 要获取语句信息，请将所需的语句项检索到目标变量中。此实例 GET DIAGNOSTICS将可用条件数和受行影响的计数分配给用户变量\nGET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;\n\n#要获取条件信息，请指定条件编号并将所需的条件项检索到目标变量中。此实例GET DIAGNOSTICS将SQLSTATE值和错误消息分配给用户变量\nGET DIAGNOSTICS CONDITION 1 @p3 = RETURNED_SQLSTATE, @p4 = MESSAGE_TEXT;\n\n```\n\n\n代码修正如下:\n\n```\ncreate procedure duplicate_teams(out result varchar(1024))\nBEGIN\nDECLARE code VARCHAR(1024);\nDECLARE msg VARCHAR(1024);\nDECLARE EXIT HANDLER FOR SQLEXCEPTION\n    BEGIN\n\t\tGET DIAGNOSTICS CONDITION 1\n        code = RETURNED_SQLSTATE, msg = MESSAGE_TEXT;\n        SET result = CONCAT('insert failed, error = ',code,', message = ',msg);\n    END;\n\nset result = 1;\ninsert into test values (1,2);\nset result =2;\nEND\n```\n\n输出为:\n\n```\ncall pr_test(@q);\nselect @q;\n\n@q\ninsert failed, error = 21S01, message = Column count doesn't match value count at row 1\n```\n## 4. 补充说明\n\n### 关于错误编号\n\n每个MySQL错误都有一个唯一的数字错误编号(`mysql_error_code`)，每个错误又对应一个5字符的SQLSTATE码(ANSI SQL 采用)。\n\n\nSQLSTATE码对应的处理程序：\n\n　　1、SQLWARNING处理程序：以‘01’开头的所有sqlstate码与之对应,对应为警告\n\n　　2、NOT FOUND处理程序：以‘02’开头的所有sqlstate码与之对应为无数据\n\n　　3、SQLEXCEPTION处理程序：不以‘01’或‘02’开头的所有sqlstate码，也就是所有未被SQLWARNING或NOT FOUND捕获的SQLSTATE(常遇到的MySQL错误就是非‘01’、‘02’开头的)\n\n* 注意：‘01’、‘02’开头和‘1’、‘2’开头是有区别的，是不一样的错误sqlsate码。\n\n","slug":"mysql/mysql存储过程异常处理","published":1,"updated":"2019-03-22T14:44:36.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmw6001g4l3n485fk38v","content":"<p>当我们处理存储过程的时候,难免会遇到如何将存储过程中的报错统一处理之后返回出来。在工作中正好需要用到这方面的知识，所以来学习并做个记录。</p>\n<a id=\"more\"></a>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"function\"><span class=\"keyword\">procedure</span> <span class=\"title\">duplicate_teams</span><span class=\"params\">(<span class=\"keyword\">out</span> p int)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">BEGIN</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">set</span> <span class=\"title\">p</span> = 1;</span></span><br><span class=\"line\">insert <span class=\"keyword\">into</span> test values (<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">set</span> p =<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n<p>这里的test表只有一个字段,我们临时测试使用,因此没有在对其创建表。<br>在进行调用时:</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">call</span> <span class=\"selector-tag\">pr_test</span>(<span class=\"variable\">@q</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">select</span> @<span class=\"selector-tag\">q</span>;</span><br></pre></td></tr></table></figure>\n<p>在默认情况下，当存储过程运行出错时，过程会立即终止，并打印系统错误消息：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">1136 </span>- Column count doesn<span class=\"comment\">'t match value count at row 1</span></span><br></pre></td></tr></table></figure>\n<p>输出为空。</p>\n<h2 id=\"1-定义异常处理\"><a href=\"#1-定义异常处理\" class=\"headerlink\" title=\"1. 定义异常处理\"></a>1. 定义异常处理</h2><p>通过对异常的定义，我们可以对其作出相应的处理步骤。</p>\n<p>DECLARE … HANDLER语句来进行定义处理：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> handler_action <span class=\"keyword\">HANDLER</span></span><br><span class=\"line\">    <span class=\"keyword\">FOR</span> condition_value [, condition_value] ...</span><br><span class=\"line\">    <span class=\"keyword\">statement</span></span><br><span class=\"line\"><span class=\"comment\"># 定义操作的动作:</span></span><br><span class=\"line\"><span class=\"comment\"># CONTINUE 继续执行当前程序</span></span><br><span class=\"line\"><span class=\"comment\"># EXIT 当前程序终止(退出当前declare所在的begin end)；</span></span><br><span class=\"line\">handler_action:</span><br><span class=\"line\">    CONTINUE</span><br><span class=\"line\">    | <span class=\"keyword\">EXIT</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># condition_value用以指明触发条件</span></span><br><span class=\"line\">condition_value:</span><br><span class=\"line\">    mysql_error_code</span><br><span class=\"line\">    | <span class=\"keyword\">SQLSTATE</span> [<span class=\"keyword\">VALUE</span>] sqlstate_value</span><br><span class=\"line\">    | condition_name</span><br><span class=\"line\">    | SQLWARNING</span><br><span class=\"line\">    | <span class=\"keyword\">NOT</span> <span class=\"keyword\">FOUND</span></span><br><span class=\"line\">    | SQLEXCEPTION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># statement触发的时候需要做的操作</span></span><br><span class=\"line\"><span class=\"keyword\">statement</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-实践\"><a href=\"#2-实践\" class=\"headerlink\" title=\"2. 实践\"></a>2. 实践</h2><p>将上述代码修改为:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">procedure</span> duplicate_teams(<span class=\"keyword\">out</span> p <span class=\"built_in\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> CONTINUE <span class=\"keyword\">HANDLER</span> <span class=\"keyword\">FOR</span> SQLEXCEPTION</span><br><span class=\"line\">    <span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">        <span class=\"keyword\">set</span> p = <span class=\"string\">\"10086\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">END</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> p = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">test</span> <span class=\"keyword\">values</span> (<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">set</span> p =<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n<p>此时再去调用得到结果为 2,当为EXIT模式时,则返回10086。</p>\n<h2 id=\"3-获取错误内容\"><a href=\"#3-获取错误内容\" class=\"headerlink\" title=\"3. 获取错误内容\"></a>3. 获取错误内容</h2><p>虽然我们获取了错误,但是并没有很方便的定位到报错位置以及报错信息。<code>mysql 5.6.4</code>以后的版本提供了<code>GET DIAGNOSTICS</code>来获取缓冲区的报错内容。</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#关键字CURRENT表示从当前诊断区域检索信息。在MySQL中，它没有任何效果，因为这是默认行为。</span></span><br><span class=\"line\">GET [CURRENT] DIAGNOSTICS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    statement_information_item</span><br><span class=\"line\">    [, statement_information_item] ...</span><br><span class=\"line\">  <span class=\"string\">| CONDITION condition_number</span></span><br><span class=\"line\">    condition_information_item</span><br><span class=\"line\">    [, condition_information_item] ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># </span></span><br><span class=\"line\">statement_information_item:</span><br><span class=\"line\">    target = statement_information_item_name</span><br><span class=\"line\"></span><br><span class=\"line\">condition_information_item:</span><br><span class=\"line\">    target = condition_information_item_name</span><br><span class=\"line\"></span><br><span class=\"line\">statement_information_item_name:</span><br><span class=\"line\">    NUMBER</span><br><span class=\"line\">  <span class=\"string\">| ROW_COUNT</span></span><br><span class=\"line\"></span><br><span class=\"line\">condition_information_item_name:</span><br><span class=\"line\">    CLASS_ORIGIN</span><br><span class=\"line\">  <span class=\"string\">| SUBCLASS_ORIGIN</span></span><br><span class=\"line\">  <span class=\"string\">| RETURNED_SQLSTATE</span></span><br><span class=\"line\">  <span class=\"string\">| MESSAGE_TEXT</span></span><br><span class=\"line\">  <span class=\"string\">| MYSQL_ERRNO</span></span><br><span class=\"line\">  <span class=\"string\">| CONSTRAINT_CATALOG</span></span><br><span class=\"line\">  <span class=\"string\">| CONSTRAINT_SCHEMA</span></span><br><span class=\"line\">  <span class=\"string\">| CONSTRAINT_NAME</span></span><br><span class=\"line\">  <span class=\"string\">| CATALOG_NAME</span></span><br><span class=\"line\">  <span class=\"string\">| SCHEMA_NAME</span></span><br><span class=\"line\">  <span class=\"string\">| TABLE_NAME</span></span><br><span class=\"line\">  <span class=\"string\">| COLUMN_NAME</span></span><br><span class=\"line\">  <span class=\"string\">| CURSOR_NAME</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 要获取语句信息，请将所需的语句项检索到目标变量中。此实例 GET DIAGNOSTICS将可用条件数和受行影响的计数分配给用户变量</span></span><br><span class=\"line\">GET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#要获取条件信息，请指定条件编号并将所需的条件项检索到目标变量中。此实例GET DIAGNOSTICS将SQLSTATE值和错误消息分配给用户变量</span></span><br><span class=\"line\">GET DIAGNOSTICS CONDITION <span class=\"number\">1</span> @p3 = RETURNED_SQLSTATE, @p4 = MESSAGE_TEXT;</span><br></pre></td></tr></table></figure>\n<p>代码修正如下:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">procedure</span> duplicate_teams(<span class=\"keyword\">out</span> <span class=\"keyword\">result</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">1024</span>))</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> code <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> msg <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> <span class=\"keyword\">EXIT</span> <span class=\"keyword\">HANDLER</span> <span class=\"keyword\">FOR</span> SQLEXCEPTION</span><br><span class=\"line\">    <span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">GET</span> <span class=\"keyword\">DIAGNOSTICS</span> CONDITION <span class=\"number\">1</span></span><br><span class=\"line\">        code = RETURNED_SQLSTATE, msg = MESSAGE_TEXT;</span><br><span class=\"line\">        <span class=\"keyword\">SET</span> <span class=\"keyword\">result</span> = <span class=\"keyword\">CONCAT</span>(<span class=\"string\">'insert failed, error = '</span>,code,<span class=\"string\">', message = '</span>,msg);</span><br><span class=\"line\">    <span class=\"keyword\">END</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">result</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">test</span> <span class=\"keyword\">values</span> (<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">result</span> =<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n<p>输出为:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">call</span> pr_test(@q);</span><br><span class=\"line\"><span class=\"keyword\">select</span> @q;</span><br><span class=\"line\"></span><br><span class=\"line\">@q</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">failed</span>, <span class=\"keyword\">error</span> = <span class=\"number\">21</span>S01, message = <span class=\"keyword\">Column</span> <span class=\"keyword\">count</span> doesn<span class=\"string\">'t match value count at row 1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-补充说明\"><a href=\"#4-补充说明\" class=\"headerlink\" title=\"4. 补充说明\"></a>4. 补充说明</h2><h3 id=\"关于错误编号\"><a href=\"#关于错误编号\" class=\"headerlink\" title=\"关于错误编号\"></a>关于错误编号</h3><p>每个MySQL错误都有一个唯一的数字错误编号(<code>mysql_error_code</code>)，每个错误又对应一个5字符的SQLSTATE码(ANSI SQL 采用)。</p>\n<p>SQLSTATE码对应的处理程序：</p>\n<p>　　1、SQLWARNING处理程序：以‘01’开头的所有sqlstate码与之对应,对应为警告</p>\n<p>　　2、NOT FOUND处理程序：以‘02’开头的所有sqlstate码与之对应为无数据</p>\n<p>　　3、SQLEXCEPTION处理程序：不以‘01’或‘02’开头的所有sqlstate码，也就是所有未被SQLWARNING或NOT FOUND捕获的SQLSTATE(常遇到的MySQL错误就是非‘01’、‘02’开头的)</p>\n<ul>\n<li>注意：‘01’、‘02’开头和‘1’、‘2’开头是有区别的，是不一样的错误sqlsate码。</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>当我们处理存储过程的时候,难免会遇到如何将存储过程中的报错统一处理之后返回出来。在工作中正好需要用到这方面的知识，所以来学习并做个记录。</p>","more":"<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"function\"><span class=\"keyword\">procedure</span> <span class=\"title\">duplicate_teams</span><span class=\"params\">(<span class=\"keyword\">out</span> p int)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">BEGIN</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">set</span> <span class=\"title\">p</span> = 1;</span></span><br><span class=\"line\">insert <span class=\"keyword\">into</span> test values (<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">set</span> p =<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n<p>这里的test表只有一个字段,我们临时测试使用,因此没有在对其创建表。<br>在进行调用时:</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">call</span> <span class=\"selector-tag\">pr_test</span>(<span class=\"variable\">@q</span>);</span><br><span class=\"line\"><span class=\"selector-tag\">select</span> @<span class=\"selector-tag\">q</span>;</span><br></pre></td></tr></table></figure>\n<p>在默认情况下，当存储过程运行出错时，过程会立即终止，并打印系统错误消息：</p>\n<figure class=\"highlight basic\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">1136 </span>- Column count doesn<span class=\"comment\">'t match value count at row 1</span></span><br></pre></td></tr></table></figure>\n<p>输出为空。</p>\n<h2 id=\"1-定义异常处理\"><a href=\"#1-定义异常处理\" class=\"headerlink\" title=\"1. 定义异常处理\"></a>1. 定义异常处理</h2><p>通过对异常的定义，我们可以对其作出相应的处理步骤。</p>\n<p>DECLARE … HANDLER语句来进行定义处理：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> handler_action <span class=\"keyword\">HANDLER</span></span><br><span class=\"line\">    <span class=\"keyword\">FOR</span> condition_value [, condition_value] ...</span><br><span class=\"line\">    <span class=\"keyword\">statement</span></span><br><span class=\"line\"><span class=\"comment\"># 定义操作的动作:</span></span><br><span class=\"line\"><span class=\"comment\"># CONTINUE 继续执行当前程序</span></span><br><span class=\"line\"><span class=\"comment\"># EXIT 当前程序终止(退出当前declare所在的begin end)；</span></span><br><span class=\"line\">handler_action:</span><br><span class=\"line\">    CONTINUE</span><br><span class=\"line\">    | <span class=\"keyword\">EXIT</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># condition_value用以指明触发条件</span></span><br><span class=\"line\">condition_value:</span><br><span class=\"line\">    mysql_error_code</span><br><span class=\"line\">    | <span class=\"keyword\">SQLSTATE</span> [<span class=\"keyword\">VALUE</span>] sqlstate_value</span><br><span class=\"line\">    | condition_name</span><br><span class=\"line\">    | SQLWARNING</span><br><span class=\"line\">    | <span class=\"keyword\">NOT</span> <span class=\"keyword\">FOUND</span></span><br><span class=\"line\">    | SQLEXCEPTION</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># statement触发的时候需要做的操作</span></span><br><span class=\"line\"><span class=\"keyword\">statement</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"2-实践\"><a href=\"#2-实践\" class=\"headerlink\" title=\"2. 实践\"></a>2. 实践</h2><p>将上述代码修改为:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">procedure</span> duplicate_teams(<span class=\"keyword\">out</span> p <span class=\"built_in\">int</span>)</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> CONTINUE <span class=\"keyword\">HANDLER</span> <span class=\"keyword\">FOR</span> SQLEXCEPTION</span><br><span class=\"line\">    <span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">        <span class=\"keyword\">set</span> p = <span class=\"string\">\"10086\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">END</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> p = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">test</span> <span class=\"keyword\">values</span> (<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">set</span> p =<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n<p>此时再去调用得到结果为 2,当为EXIT模式时,则返回10086。</p>\n<h2 id=\"3-获取错误内容\"><a href=\"#3-获取错误内容\" class=\"headerlink\" title=\"3. 获取错误内容\"></a>3. 获取错误内容</h2><p>虽然我们获取了错误,但是并没有很方便的定位到报错位置以及报错信息。<code>mysql 5.6.4</code>以后的版本提供了<code>GET DIAGNOSTICS</code>来获取缓冲区的报错内容。</p>\n<figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#关键字CURRENT表示从当前诊断区域检索信息。在MySQL中，它没有任何效果，因为这是默认行为。</span></span><br><span class=\"line\">GET [CURRENT] DIAGNOSTICS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    statement_information_item</span><br><span class=\"line\">    [, statement_information_item] ...</span><br><span class=\"line\">  <span class=\"string\">| CONDITION condition_number</span></span><br><span class=\"line\">    condition_information_item</span><br><span class=\"line\">    [, condition_information_item] ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># </span></span><br><span class=\"line\">statement_information_item:</span><br><span class=\"line\">    target = statement_information_item_name</span><br><span class=\"line\"></span><br><span class=\"line\">condition_information_item:</span><br><span class=\"line\">    target = condition_information_item_name</span><br><span class=\"line\"></span><br><span class=\"line\">statement_information_item_name:</span><br><span class=\"line\">    NUMBER</span><br><span class=\"line\">  <span class=\"string\">| ROW_COUNT</span></span><br><span class=\"line\"></span><br><span class=\"line\">condition_information_item_name:</span><br><span class=\"line\">    CLASS_ORIGIN</span><br><span class=\"line\">  <span class=\"string\">| SUBCLASS_ORIGIN</span></span><br><span class=\"line\">  <span class=\"string\">| RETURNED_SQLSTATE</span></span><br><span class=\"line\">  <span class=\"string\">| MESSAGE_TEXT</span></span><br><span class=\"line\">  <span class=\"string\">| MYSQL_ERRNO</span></span><br><span class=\"line\">  <span class=\"string\">| CONSTRAINT_CATALOG</span></span><br><span class=\"line\">  <span class=\"string\">| CONSTRAINT_SCHEMA</span></span><br><span class=\"line\">  <span class=\"string\">| CONSTRAINT_NAME</span></span><br><span class=\"line\">  <span class=\"string\">| CATALOG_NAME</span></span><br><span class=\"line\">  <span class=\"string\">| SCHEMA_NAME</span></span><br><span class=\"line\">  <span class=\"string\">| TABLE_NAME</span></span><br><span class=\"line\">  <span class=\"string\">| COLUMN_NAME</span></span><br><span class=\"line\">  <span class=\"string\">| CURSOR_NAME</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># 要获取语句信息，请将所需的语句项检索到目标变量中。此实例 GET DIAGNOSTICS将可用条件数和受行影响的计数分配给用户变量</span></span><br><span class=\"line\">GET DIAGNOSTICS @p1 = NUMBER, @p2 = ROW_COUNT;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#要获取条件信息，请指定条件编号并将所需的条件项检索到目标变量中。此实例GET DIAGNOSTICS将SQLSTATE值和错误消息分配给用户变量</span></span><br><span class=\"line\">GET DIAGNOSTICS CONDITION <span class=\"number\">1</span> @p3 = RETURNED_SQLSTATE, @p4 = MESSAGE_TEXT;</span><br></pre></td></tr></table></figure>\n<p>代码修正如下:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">procedure</span> duplicate_teams(<span class=\"keyword\">out</span> <span class=\"keyword\">result</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">1024</span>))</span><br><span class=\"line\"><span class=\"keyword\">BEGIN</span></span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> code <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> msg <span class=\"built_in\">VARCHAR</span>(<span class=\"number\">1024</span>);</span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> <span class=\"keyword\">EXIT</span> <span class=\"keyword\">HANDLER</span> <span class=\"keyword\">FOR</span> SQLEXCEPTION</span><br><span class=\"line\">    <span class=\"keyword\">BEGIN</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">GET</span> <span class=\"keyword\">DIAGNOSTICS</span> CONDITION <span class=\"number\">1</span></span><br><span class=\"line\">        code = RETURNED_SQLSTATE, msg = MESSAGE_TEXT;</span><br><span class=\"line\">        <span class=\"keyword\">SET</span> <span class=\"keyword\">result</span> = <span class=\"keyword\">CONCAT</span>(<span class=\"string\">'insert failed, error = '</span>,code,<span class=\"string\">', message = '</span>,msg);</span><br><span class=\"line\">    <span class=\"keyword\">END</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">result</span> = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">into</span> <span class=\"keyword\">test</span> <span class=\"keyword\">values</span> (<span class=\"number\">1</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\"><span class=\"keyword\">set</span> <span class=\"keyword\">result</span> =<span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">END</span></span><br></pre></td></tr></table></figure>\n<p>输出为:</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">call</span> pr_test(@q);</span><br><span class=\"line\"><span class=\"keyword\">select</span> @q;</span><br><span class=\"line\"></span><br><span class=\"line\">@q</span><br><span class=\"line\"><span class=\"keyword\">insert</span> <span class=\"keyword\">failed</span>, <span class=\"keyword\">error</span> = <span class=\"number\">21</span>S01, message = <span class=\"keyword\">Column</span> <span class=\"keyword\">count</span> doesn<span class=\"string\">'t match value count at row 1</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"4-补充说明\"><a href=\"#4-补充说明\" class=\"headerlink\" title=\"4. 补充说明\"></a>4. 补充说明</h2><h3 id=\"关于错误编号\"><a href=\"#关于错误编号\" class=\"headerlink\" title=\"关于错误编号\"></a>关于错误编号</h3><p>每个MySQL错误都有一个唯一的数字错误编号(<code>mysql_error_code</code>)，每个错误又对应一个5字符的SQLSTATE码(ANSI SQL 采用)。</p>\n<p>SQLSTATE码对应的处理程序：</p>\n<p>　　1、SQLWARNING处理程序：以‘01’开头的所有sqlstate码与之对应,对应为警告</p>\n<p>　　2、NOT FOUND处理程序：以‘02’开头的所有sqlstate码与之对应为无数据</p>\n<p>　　3、SQLEXCEPTION处理程序：不以‘01’或‘02’开头的所有sqlstate码，也就是所有未被SQLWARNING或NOT FOUND捕获的SQLSTATE(常遇到的MySQL错误就是非‘01’、‘02’开头的)</p>\n<ul>\n<li>注意：‘01’、‘02’开头和‘1’、‘2’开头是有区别的，是不一样的错误sqlsate码。</li>\n</ul>"},{"title":"mysql学习小结-范式","date":"2016-12-15T04:22:50.000Z","_content":"范式（数据库设计范式，数据库的设计范式）是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。关系数据库中的关系必须满足一定的要求，即满足不同的范式。\n\n<!-- more -->\n\n满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。\n## 第一范式\n第一范式（1NF）：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF（即R符合第一范式）。简单的说，就是每一个列（属性）只有一个，没有重复。\n\n### 要求\n1.必须有主键来加以识别。\n\n2.每个字段只能存放单一的值并确保有数据没有重复的组。\n\n例如：\n\n |姓名|班级|课程|\n |----|----|----|\n |小明|1班|数学,语文|\n |小红|2班|英语|\n |小明|2班|数学|\n\n里面还有重复组并且没有存放单一的值，并不符合第一范式，我们给其增加主键学号加以区别：\n\n|学号|姓名|班级|课程|\n|----|----|----|----|\n|101|小明|1班|数学|\n|101|小明|1班|语文|\n|201|小红|2班|英语|\n|202|小明|2班|数学|\n## 第二范式\n首先要满足第一范式。它的规则是要求数据表里的所有数据都要和该数据表的主键有完全依赖关系。例如有表：\n\n|货物|供应商ID|供应商|价格|供应商地址|\n|----|--------|------|----|----------|\n|毛巾|01|世纪联华|10.0|星光大道|\n|牙刷|01|世纪联华|5.0|星光大道|\n|毛巾|02|十足|12.0|月光大道|\n\n可知，这里的主键有货物和供应商ID，价格和两个主键都有关，可是供应商地址只和供应商ID有依赖关系。那么不符合第二范式，我们可以将其修改为两张表：\n\n|供应商ID|供应商|供应商地址|\n|----|--------|------|\n|01|世纪联华|星光大道|\n|02|十足|月光大道|\n\n|货物|供应商ID|价格|\n|毛巾|01|10.0|\n|牙刷|01|5.0|\n|毛巾|01|12.0|\n\n这样就符合了第二范式要求的表内数据和表内主键完全依赖的关系。\n\n## 第三范式\n在第二范式的基础上，要求所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。\n从上述表来说，供应商和供应商地址是相关的，知道了供应商也就知道了供应商地址（不考虑一厂多址的情况）。可以分为：\n\n|供应商ID|供应商|\n|----|------|\n|01|世纪联华|\n|02|十足|\n\n|供应商ID|供应商地址|\n|----|------|\n|01|星光大道|\n|02|月光大道|","source":"_posts/mysql/mysql学习小结-范式.md","raw":"---\ntitle: mysql学习小结-范式\ndate: 2016-12-15 12:22:50\ntags: \n- mysql\ncategories: 总结\n---\n范式（数据库设计范式，数据库的设计范式）是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。关系数据库中的关系必须满足一定的要求，即满足不同的范式。\n\n<!-- more -->\n\n满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。\n## 第一范式\n第一范式（1NF）：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF（即R符合第一范式）。简单的说，就是每一个列（属性）只有一个，没有重复。\n\n### 要求\n1.必须有主键来加以识别。\n\n2.每个字段只能存放单一的值并确保有数据没有重复的组。\n\n例如：\n\n |姓名|班级|课程|\n |----|----|----|\n |小明|1班|数学,语文|\n |小红|2班|英语|\n |小明|2班|数学|\n\n里面还有重复组并且没有存放单一的值，并不符合第一范式，我们给其增加主键学号加以区别：\n\n|学号|姓名|班级|课程|\n|----|----|----|----|\n|101|小明|1班|数学|\n|101|小明|1班|语文|\n|201|小红|2班|英语|\n|202|小明|2班|数学|\n## 第二范式\n首先要满足第一范式。它的规则是要求数据表里的所有数据都要和该数据表的主键有完全依赖关系。例如有表：\n\n|货物|供应商ID|供应商|价格|供应商地址|\n|----|--------|------|----|----------|\n|毛巾|01|世纪联华|10.0|星光大道|\n|牙刷|01|世纪联华|5.0|星光大道|\n|毛巾|02|十足|12.0|月光大道|\n\n可知，这里的主键有货物和供应商ID，价格和两个主键都有关，可是供应商地址只和供应商ID有依赖关系。那么不符合第二范式，我们可以将其修改为两张表：\n\n|供应商ID|供应商|供应商地址|\n|----|--------|------|\n|01|世纪联华|星光大道|\n|02|十足|月光大道|\n\n|货物|供应商ID|价格|\n|毛巾|01|10.0|\n|牙刷|01|5.0|\n|毛巾|01|12.0|\n\n这样就符合了第二范式要求的表内数据和表内主键完全依赖的关系。\n\n## 第三范式\n在第二范式的基础上，要求所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。\n从上述表来说，供应商和供应商地址是相关的，知道了供应商也就知道了供应商地址（不考虑一厂多址的情况）。可以分为：\n\n|供应商ID|供应商|\n|----|------|\n|01|世纪联华|\n|02|十足|\n\n|供应商ID|供应商地址|\n|----|------|\n|01|星光大道|\n|02|月光大道|","slug":"mysql/mysql学习小结-范式","published":1,"updated":"2019-03-22T14:44:36.723Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmw8001k4l3ndo1cdns1","content":"<p>范式（数据库设计范式，数据库的设计范式）是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。关系数据库中的关系必须满足一定的要求，即满足不同的范式。</p>\n<a id=\"more\"></a>\n<p>满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。</p>\n<h2 id=\"第一范式\"><a href=\"#第一范式\" class=\"headerlink\" title=\"第一范式\"></a>第一范式</h2><p>第一范式（1NF）：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF（即R符合第一范式）。简单的说，就是每一个列（属性）只有一个，没有重复。</p>\n<h3 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a>要求</h3><p>1.必须有主键来加以识别。</p>\n<p>2.每个字段只能存放单一的值并确保有数据没有重复的组。</p>\n<p>例如：</p>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>班级</th>\n<th>课程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>小明</td>\n<td>1班</td>\n<td>数学,语文</td>\n</tr>\n<tr>\n<td>小红</td>\n<td>2班</td>\n<td>英语</td>\n</tr>\n<tr>\n<td>小明</td>\n<td>2班</td>\n<td>数学</td>\n</tr>\n</tbody>\n</table>\n<p>里面还有重复组并且没有存放单一的值，并不符合第一范式，我们给其增加主键学号加以区别：</p>\n<table>\n<thead>\n<tr>\n<th>学号</th>\n<th>姓名</th>\n<th>班级</th>\n<th>课程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>101</td>\n<td>小明</td>\n<td>1班</td>\n<td>数学</td>\n</tr>\n<tr>\n<td>101</td>\n<td>小明</td>\n<td>1班</td>\n<td>语文</td>\n</tr>\n<tr>\n<td>201</td>\n<td>小红</td>\n<td>2班</td>\n<td>英语</td>\n</tr>\n<tr>\n<td>202</td>\n<td>小明</td>\n<td>2班</td>\n<td>数学</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"第二范式\"><a href=\"#第二范式\" class=\"headerlink\" title=\"第二范式\"></a>第二范式</h2><p>首先要满足第一范式。它的规则是要求数据表里的所有数据都要和该数据表的主键有完全依赖关系。例如有表：</p>\n<table>\n<thead>\n<tr>\n<th>货物</th>\n<th>供应商ID</th>\n<th>供应商</th>\n<th>价格</th>\n<th>供应商地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>毛巾</td>\n<td>01</td>\n<td>世纪联华</td>\n<td>10.0</td>\n<td>星光大道</td>\n</tr>\n<tr>\n<td>牙刷</td>\n<td>01</td>\n<td>世纪联华</td>\n<td>5.0</td>\n<td>星光大道</td>\n</tr>\n<tr>\n<td>毛巾</td>\n<td>02</td>\n<td>十足</td>\n<td>12.0</td>\n<td>月光大道</td>\n</tr>\n</tbody>\n</table>\n<p>可知，这里的主键有货物和供应商ID，价格和两个主键都有关，可是供应商地址只和供应商ID有依赖关系。那么不符合第二范式，我们可以将其修改为两张表：</p>\n<table>\n<thead>\n<tr>\n<th>供应商ID</th>\n<th>供应商</th>\n<th>供应商地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>01</td>\n<td>世纪联华</td>\n<td>星光大道</td>\n</tr>\n<tr>\n<td>02</td>\n<td>十足</td>\n<td>月光大道</td>\n</tr>\n</tbody>\n</table>\n<p>|货物|供应商ID|价格|<br>|毛巾|01|10.0|<br>|牙刷|01|5.0|<br>|毛巾|01|12.0|</p>\n<p>这样就符合了第二范式要求的表内数据和表内主键完全依赖的关系。</p>\n<h2 id=\"第三范式\"><a href=\"#第三范式\" class=\"headerlink\" title=\"第三范式\"></a>第三范式</h2><p>在第二范式的基础上，要求所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。<br>从上述表来说，供应商和供应商地址是相关的，知道了供应商也就知道了供应商地址（不考虑一厂多址的情况）。可以分为：</p>\n<table>\n<thead>\n<tr>\n<th>供应商ID</th>\n<th>供应商</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>01</td>\n<td>世纪联华</td>\n</tr>\n<tr>\n<td>02</td>\n<td>十足</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>供应商ID</th>\n<th>供应商地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>01</td>\n<td>星光大道</td>\n</tr>\n<tr>\n<td>02</td>\n<td>月光大道</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"<p>范式（数据库设计范式，数据库的设计范式）是符合某一种级别的关系模式的集合。构造数据库必须遵循一定的规则。在关系数据库中，这种规则就是范式。关系数据库中的关系必须满足一定的要求，即满足不同的范式。</p>","more":"<p>满足最低要求的范式是第一范式（1NF）。在第一范式的基础上进一步满足更多要求的称为第二范式（2NF），其余范式以次类推。一般说来，数据库只需满足第三范式（3NF）就行了。</p>\n<h2 id=\"第一范式\"><a href=\"#第一范式\" class=\"headerlink\" title=\"第一范式\"></a>第一范式</h2><p>第一范式（1NF）：如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF（即R符合第一范式）。简单的说，就是每一个列（属性）只有一个，没有重复。</p>\n<h3 id=\"要求\"><a href=\"#要求\" class=\"headerlink\" title=\"要求\"></a>要求</h3><p>1.必须有主键来加以识别。</p>\n<p>2.每个字段只能存放单一的值并确保有数据没有重复的组。</p>\n<p>例如：</p>\n<table>\n<thead>\n<tr>\n<th>姓名</th>\n<th>班级</th>\n<th>课程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>小明</td>\n<td>1班</td>\n<td>数学,语文</td>\n</tr>\n<tr>\n<td>小红</td>\n<td>2班</td>\n<td>英语</td>\n</tr>\n<tr>\n<td>小明</td>\n<td>2班</td>\n<td>数学</td>\n</tr>\n</tbody>\n</table>\n<p>里面还有重复组并且没有存放单一的值，并不符合第一范式，我们给其增加主键学号加以区别：</p>\n<table>\n<thead>\n<tr>\n<th>学号</th>\n<th>姓名</th>\n<th>班级</th>\n<th>课程</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>101</td>\n<td>小明</td>\n<td>1班</td>\n<td>数学</td>\n</tr>\n<tr>\n<td>101</td>\n<td>小明</td>\n<td>1班</td>\n<td>语文</td>\n</tr>\n<tr>\n<td>201</td>\n<td>小红</td>\n<td>2班</td>\n<td>英语</td>\n</tr>\n<tr>\n<td>202</td>\n<td>小明</td>\n<td>2班</td>\n<td>数学</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"第二范式\"><a href=\"#第二范式\" class=\"headerlink\" title=\"第二范式\"></a>第二范式</h2><p>首先要满足第一范式。它的规则是要求数据表里的所有数据都要和该数据表的主键有完全依赖关系。例如有表：</p>\n<table>\n<thead>\n<tr>\n<th>货物</th>\n<th>供应商ID</th>\n<th>供应商</th>\n<th>价格</th>\n<th>供应商地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>毛巾</td>\n<td>01</td>\n<td>世纪联华</td>\n<td>10.0</td>\n<td>星光大道</td>\n</tr>\n<tr>\n<td>牙刷</td>\n<td>01</td>\n<td>世纪联华</td>\n<td>5.0</td>\n<td>星光大道</td>\n</tr>\n<tr>\n<td>毛巾</td>\n<td>02</td>\n<td>十足</td>\n<td>12.0</td>\n<td>月光大道</td>\n</tr>\n</tbody>\n</table>\n<p>可知，这里的主键有货物和供应商ID，价格和两个主键都有关，可是供应商地址只和供应商ID有依赖关系。那么不符合第二范式，我们可以将其修改为两张表：</p>\n<table>\n<thead>\n<tr>\n<th>供应商ID</th>\n<th>供应商</th>\n<th>供应商地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>01</td>\n<td>世纪联华</td>\n<td>星光大道</td>\n</tr>\n<tr>\n<td>02</td>\n<td>十足</td>\n<td>月光大道</td>\n</tr>\n</tbody>\n</table>\n<p>|货物|供应商ID|价格|<br>|毛巾|01|10.0|<br>|牙刷|01|5.0|<br>|毛巾|01|12.0|</p>\n<p>这样就符合了第二范式要求的表内数据和表内主键完全依赖的关系。</p>\n<h2 id=\"第三范式\"><a href=\"#第三范式\" class=\"headerlink\" title=\"第三范式\"></a>第三范式</h2><p>在第二范式的基础上，要求所有非键属性都只和候选键有相关性，也就是说非键属性之间应该是独立无关的。<br>从上述表来说，供应商和供应商地址是相关的，知道了供应商也就知道了供应商地址（不考虑一厂多址的情况）。可以分为：</p>\n<table>\n<thead>\n<tr>\n<th>供应商ID</th>\n<th>供应商</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>01</td>\n<td>世纪联华</td>\n</tr>\n<tr>\n<td>02</td>\n<td>十足</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>供应商ID</th>\n<th>供应商地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>01</td>\n<td>星光大道</td>\n</tr>\n<tr>\n<td>02</td>\n<td>月光大道</td>\n</tr>\n</tbody>\n</table>"},{"title":"一条SQL查询是如何执行的","date":"2018-12-04T12:35:00.000Z","_content":"\nMySQL大体可分为 Server层 和 存储引擎层两部分。\nServer层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能以及所有内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，试图等。\n\n<!-- more -->\n![MySQL逻辑](一条SQL查询是如何执行的/MySQL逻辑.png)\n\n而存储引擎层负责数据的存储和提取。其架构模式是插件式的。支持InnoDB，MyISAM、Memory等多个存储引擎，而InnoDB是最常用的，也成为了默认存储引擎。可以使用`engine=memory`来指定引擎。\n\n从图中，不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。\n\n### 连接器\n\n连接器负责跟客户端建立连接，获取权限，维持和管理连接。\n连接指令一般这样写:\n\n```\nmysql -h$ip -P$port -u$user -p\n```\n\n一般连接生产环境,建议输完命令后输入密码,直接输入容易导致密码泄露。\n\n在用户名密码验证通过之后，连接器会到权限表里查出你拥有的权限。之后的权限，都依赖与此。也就意味着，在建立成功之后，即使你做了权限的修改，也要再新建连接才会使用新的权限设置。\n\n连接完成之后，如果没有后续动作，这个连接就处于空闲状态，可以在`show processlist`中看到他。太长时间没有动静,在`wait_timeout` 控制其关闭,默认为8小时。\n\n#### 长连接和短链接\n\n在数据库里面,长连接是指在连接成功之后, 如果客户端持续有请求,则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。\n\n因为建立的过程比较复杂，因此要尽量少建立连接的动作，尽量使用长连接。\n但是在使用长连接之后，MySQL的占用内存涨的很快，因为MySQL在执行过程中临时使用的内存是管理在连接对象里的，这些资源会在断开的时候才释放。如果长连接累计下来，可能会导致内存占用太大，被系统强杀，从现象来看，就是MySQL异常重启了。\n\n那么怎么解决呢？\n\n1. 定期断开长连接。\n2. 如果是MySQL或更新版本，可以使用`mysql_reset_connection`来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完的状态。\n\n### 查询缓存\n\n连接建立完成后，MySQL拿到一个查询请求后，会先到查询缓存里看看，这个是否执行过这个语句。之前执行过的语句及其结果会以key-value对的形式，被缓存在内存中。但是查询缓存失效非常频繁，只要有对一个表的更新，这个表上额所有查询缓存都会被清空，对于更新压力大的数据库，查询缓存的命中率很低。除非你的业务就是一张静态表，很长时间更新一次。\n\n好在MySQL提供了\"按需使用\"的方式，在参数中设置`query_cache_type`为`DEMAND`，这样对于默认的SQL语句都不使用查询缓存。而对于要使用的语句，可以如下：\n\n```\nselect SQL_CACHE * from Table where ID = 1;\n```\n\n需要注意的是。**这个功能在MySQL8.0被整块删掉了。**因为其弊大于利。\n\n### 分析器\n\n在没有命中查询缓存之后，就开始真正执行语句了。首先需要对SQL语句做解析。\n\n分析器会先做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。例如，select 拼写错误等。\n\n做完了这些识别之后，就要做\"语法分析\"。根据上面的词法分析的结果，语法分析器会根据语法规则，判断你输入的SQL语句是否满足MySQL语法。\n\n如果语句不对，则会收到“You have an error in your SQL syntax” 的错误提醒。一般会提示第一个出现错误的位置，需要关注`Use near`的后续内容。\n\n### 优化器\n经过了分析器，MySQL就知道你需要做什么了，在开始执行之前，要先经过优化器的处理。\n\n优化器是在表里面有多个索引的时候，决定需要使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。\n\n虽然在不同的执行顺序结果一致，但是执行的效率不同，而优化器的作用就是选择使用哪一个方案。\n\n优化器阶段完成之后，这个语句的执行方案就确定下来了。后续将会继续讲解优化器的具体实现。\n\n### 执行器\n\nMySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是进入了执行器阶段。\n\n在开始执行的时候，先判断一下权限。有权限之后，\n","source":"_posts/mysql/一条SQL查询是如何执行的.md","raw":"---\ntitle: 一条SQL查询是如何执行的\ndate: 2018-12-04 20:35:00\ntags: \n- MySQL\ncategories: 总结\n---\n\nMySQL大体可分为 Server层 和 存储引擎层两部分。\nServer层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能以及所有内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，试图等。\n\n<!-- more -->\n![MySQL逻辑](一条SQL查询是如何执行的/MySQL逻辑.png)\n\n而存储引擎层负责数据的存储和提取。其架构模式是插件式的。支持InnoDB，MyISAM、Memory等多个存储引擎，而InnoDB是最常用的，也成为了默认存储引擎。可以使用`engine=memory`来指定引擎。\n\n从图中，不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。\n\n### 连接器\n\n连接器负责跟客户端建立连接，获取权限，维持和管理连接。\n连接指令一般这样写:\n\n```\nmysql -h$ip -P$port -u$user -p\n```\n\n一般连接生产环境,建议输完命令后输入密码,直接输入容易导致密码泄露。\n\n在用户名密码验证通过之后，连接器会到权限表里查出你拥有的权限。之后的权限，都依赖与此。也就意味着，在建立成功之后，即使你做了权限的修改，也要再新建连接才会使用新的权限设置。\n\n连接完成之后，如果没有后续动作，这个连接就处于空闲状态，可以在`show processlist`中看到他。太长时间没有动静,在`wait_timeout` 控制其关闭,默认为8小时。\n\n#### 长连接和短链接\n\n在数据库里面,长连接是指在连接成功之后, 如果客户端持续有请求,则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。\n\n因为建立的过程比较复杂，因此要尽量少建立连接的动作，尽量使用长连接。\n但是在使用长连接之后，MySQL的占用内存涨的很快，因为MySQL在执行过程中临时使用的内存是管理在连接对象里的，这些资源会在断开的时候才释放。如果长连接累计下来，可能会导致内存占用太大，被系统强杀，从现象来看，就是MySQL异常重启了。\n\n那么怎么解决呢？\n\n1. 定期断开长连接。\n2. 如果是MySQL或更新版本，可以使用`mysql_reset_connection`来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完的状态。\n\n### 查询缓存\n\n连接建立完成后，MySQL拿到一个查询请求后，会先到查询缓存里看看，这个是否执行过这个语句。之前执行过的语句及其结果会以key-value对的形式，被缓存在内存中。但是查询缓存失效非常频繁，只要有对一个表的更新，这个表上额所有查询缓存都会被清空，对于更新压力大的数据库，查询缓存的命中率很低。除非你的业务就是一张静态表，很长时间更新一次。\n\n好在MySQL提供了\"按需使用\"的方式，在参数中设置`query_cache_type`为`DEMAND`，这样对于默认的SQL语句都不使用查询缓存。而对于要使用的语句，可以如下：\n\n```\nselect SQL_CACHE * from Table where ID = 1;\n```\n\n需要注意的是。**这个功能在MySQL8.0被整块删掉了。**因为其弊大于利。\n\n### 分析器\n\n在没有命中查询缓存之后，就开始真正执行语句了。首先需要对SQL语句做解析。\n\n分析器会先做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。例如，select 拼写错误等。\n\n做完了这些识别之后，就要做\"语法分析\"。根据上面的词法分析的结果，语法分析器会根据语法规则，判断你输入的SQL语句是否满足MySQL语法。\n\n如果语句不对，则会收到“You have an error in your SQL syntax” 的错误提醒。一般会提示第一个出现错误的位置，需要关注`Use near`的后续内容。\n\n### 优化器\n经过了分析器，MySQL就知道你需要做什么了，在开始执行之前，要先经过优化器的处理。\n\n优化器是在表里面有多个索引的时候，决定需要使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。\n\n虽然在不同的执行顺序结果一致，但是执行的效率不同，而优化器的作用就是选择使用哪一个方案。\n\n优化器阶段完成之后，这个语句的执行方案就确定下来了。后续将会继续讲解优化器的具体实现。\n\n### 执行器\n\nMySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是进入了执行器阶段。\n\n在开始执行的时候，先判断一下权限。有权限之后，\n","slug":"mysql/一条SQL查询是如何执行的","published":1,"updated":"2019-04-01T02:13:33.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmw9001m4l3nt2qw7819","content":"<p>MySQL大体可分为 Server层 和 存储引擎层两部分。<br>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能以及所有内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，试图等。</p>\n<a id=\"more\"></a>\n<p><img src=\"/2018/12/04/mysql/一条SQL查询是如何执行的/MySQL逻辑.png\" alt=\"MySQL逻辑\"></p>\n<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的。支持InnoDB，MyISAM、Memory等多个存储引擎，而InnoDB是最常用的，也成为了默认存储引擎。可以使用<code>engine=memory</code>来指定引擎。</p>\n<p>从图中，不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。</p>\n<h3 id=\"连接器\"><a href=\"#连接器\" class=\"headerlink\" title=\"连接器\"></a>连接器</h3><p>连接器负责跟客户端建立连接，获取权限，维持和管理连接。<br>连接指令一般这样写:</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">mysql</span> -h<span class=\"variable\">$ip</span> -P<span class=\"variable\">$port</span> -u<span class=\"variable\">$user</span> -p</span><br></pre></td></tr></table></figure>\n<p>一般连接生产环境,建议输完命令后输入密码,直接输入容易导致密码泄露。</p>\n<p>在用户名密码验证通过之后，连接器会到权限表里查出你拥有的权限。之后的权限，都依赖与此。也就意味着，在建立成功之后，即使你做了权限的修改，也要再新建连接才会使用新的权限设置。</p>\n<p>连接完成之后，如果没有后续动作，这个连接就处于空闲状态，可以在<code>show processlist</code>中看到他。太长时间没有动静,在<code>wait_timeout</code> 控制其关闭,默认为8小时。</p>\n<h4 id=\"长连接和短链接\"><a href=\"#长连接和短链接\" class=\"headerlink\" title=\"长连接和短链接\"></a>长连接和短链接</h4><p>在数据库里面,长连接是指在连接成功之后, 如果客户端持续有请求,则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>\n<p>因为建立的过程比较复杂，因此要尽量少建立连接的动作，尽量使用长连接。<br>但是在使用长连接之后，MySQL的占用内存涨的很快，因为MySQL在执行过程中临时使用的内存是管理在连接对象里的，这些资源会在断开的时候才释放。如果长连接累计下来，可能会导致内存占用太大，被系统强杀，从现象来看，就是MySQL异常重启了。</p>\n<p>那么怎么解决呢？</p>\n<ol>\n<li>定期断开长连接。</li>\n<li>如果是MySQL或更新版本，可以使用<code>mysql_reset_connection</code>来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完的状态。</li>\n</ol>\n<h3 id=\"查询缓存\"><a href=\"#查询缓存\" class=\"headerlink\" title=\"查询缓存\"></a>查询缓存</h3><p>连接建立完成后，MySQL拿到一个查询请求后，会先到查询缓存里看看，这个是否执行过这个语句。之前执行过的语句及其结果会以key-value对的形式，被缓存在内存中。但是查询缓存失效非常频繁，只要有对一个表的更新，这个表上额所有查询缓存都会被清空，对于更新压力大的数据库，查询缓存的命中率很低。除非你的业务就是一张静态表，很长时间更新一次。</p>\n<p>好在MySQL提供了”按需使用”的方式，在参数中设置<code>query_cache_type</code>为<code>DEMAND</code>，这样对于默认的SQL语句都不使用查询缓存。而对于要使用的语句，可以如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">SQL_CACHE</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">Table</span> <span class=\"keyword\">where</span> <span class=\"keyword\">ID</span> = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是。<strong>这个功能在MySQL8.0被整块删掉了。</strong>因为其弊大于利。</p>\n<h3 id=\"分析器\"><a href=\"#分析器\" class=\"headerlink\" title=\"分析器\"></a>分析器</h3><p>在没有命中查询缓存之后，就开始真正执行语句了。首先需要对SQL语句做解析。</p>\n<p>分析器会先做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。例如，select 拼写错误等。</p>\n<p>做完了这些识别之后，就要做”语法分析”。根据上面的词法分析的结果，语法分析器会根据语法规则，判断你输入的SQL语句是否满足MySQL语法。</p>\n<p>如果语句不对，则会收到“You have an error in your SQL syntax” 的错误提醒。一般会提示第一个出现错误的位置，需要关注<code>Use near</code>的后续内容。</p>\n<h3 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h3><p>经过了分析器，MySQL就知道你需要做什么了，在开始执行之前，要先经过优化器的处理。</p>\n<p>优化器是在表里面有多个索引的时候，决定需要使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>\n<p>虽然在不同的执行顺序结果一致，但是执行的效率不同，而优化器的作用就是选择使用哪一个方案。</p>\n<p>优化器阶段完成之后，这个语句的执行方案就确定下来了。后续将会继续讲解优化器的具体实现。</p>\n<h3 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h3><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是进入了执行器阶段。</p>\n<p>在开始执行的时候，先判断一下权限。有权限之后，</p>\n","site":{"data":{}},"excerpt":"<p>MySQL大体可分为 Server层 和 存储引擎层两部分。<br>Server层包括连接器、查询缓存、分析器、优化器、执行器等，涵盖MySQL的大多数核心服务功能以及所有内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程，触发器，试图等。</p>","more":"<p><img src=\"/2018/12/04/mysql/一条SQL查询是如何执行的/MySQL逻辑.png\" alt=\"MySQL逻辑\"></p>\n<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的。支持InnoDB，MyISAM、Memory等多个存储引擎，而InnoDB是最常用的，也成为了默认存储引擎。可以使用<code>engine=memory</code>来指定引擎。</p>\n<p>从图中，不同的存储引擎共用一个Server层，也就是从连接器到执行器的部分。</p>\n<h3 id=\"连接器\"><a href=\"#连接器\" class=\"headerlink\" title=\"连接器\"></a>连接器</h3><p>连接器负责跟客户端建立连接，获取权限，维持和管理连接。<br>连接指令一般这样写:</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">mysql</span> -h<span class=\"variable\">$ip</span> -P<span class=\"variable\">$port</span> -u<span class=\"variable\">$user</span> -p</span><br></pre></td></tr></table></figure>\n<p>一般连接生产环境,建议输完命令后输入密码,直接输入容易导致密码泄露。</p>\n<p>在用户名密码验证通过之后，连接器会到权限表里查出你拥有的权限。之后的权限，都依赖与此。也就意味着，在建立成功之后，即使你做了权限的修改，也要再新建连接才会使用新的权限设置。</p>\n<p>连接完成之后，如果没有后续动作，这个连接就处于空闲状态，可以在<code>show processlist</code>中看到他。太长时间没有动静,在<code>wait_timeout</code> 控制其关闭,默认为8小时。</p>\n<h4 id=\"长连接和短链接\"><a href=\"#长连接和短链接\" class=\"headerlink\" title=\"长连接和短链接\"></a>长连接和短链接</h4><p>在数据库里面,长连接是指在连接成功之后, 如果客户端持续有请求,则一直使用同一个连接。短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p>\n<p>因为建立的过程比较复杂，因此要尽量少建立连接的动作，尽量使用长连接。<br>但是在使用长连接之后，MySQL的占用内存涨的很快，因为MySQL在执行过程中临时使用的内存是管理在连接对象里的，这些资源会在断开的时候才释放。如果长连接累计下来，可能会导致内存占用太大，被系统强杀，从现象来看，就是MySQL异常重启了。</p>\n<p>那么怎么解决呢？</p>\n<ol>\n<li>定期断开长连接。</li>\n<li>如果是MySQL或更新版本，可以使用<code>mysql_reset_connection</code>来重新初始化连接资源，这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完的状态。</li>\n</ol>\n<h3 id=\"查询缓存\"><a href=\"#查询缓存\" class=\"headerlink\" title=\"查询缓存\"></a>查询缓存</h3><p>连接建立完成后，MySQL拿到一个查询请求后，会先到查询缓存里看看，这个是否执行过这个语句。之前执行过的语句及其结果会以key-value对的形式，被缓存在内存中。但是查询缓存失效非常频繁，只要有对一个表的更新，这个表上额所有查询缓存都会被清空，对于更新压力大的数据库，查询缓存的命中率很低。除非你的业务就是一张静态表，很长时间更新一次。</p>\n<p>好在MySQL提供了”按需使用”的方式，在参数中设置<code>query_cache_type</code>为<code>DEMAND</code>，这样对于默认的SQL语句都不使用查询缓存。而对于要使用的语句，可以如下：</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">SQL_CACHE</span> * <span class=\"keyword\">from</span> <span class=\"keyword\">Table</span> <span class=\"keyword\">where</span> <span class=\"keyword\">ID</span> = <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>需要注意的是。<strong>这个功能在MySQL8.0被整块删掉了。</strong>因为其弊大于利。</p>\n<h3 id=\"分析器\"><a href=\"#分析器\" class=\"headerlink\" title=\"分析器\"></a>分析器</h3><p>在没有命中查询缓存之后，就开始真正执行语句了。首先需要对SQL语句做解析。</p>\n<p>分析器会先做“词法分析”。你输入的是由多个字符串和空格组成的一条SQL语句，MySQL需要识别出里面的字符串分别是什么，代表什么。例如，select 拼写错误等。</p>\n<p>做完了这些识别之后，就要做”语法分析”。根据上面的词法分析的结果，语法分析器会根据语法规则，判断你输入的SQL语句是否满足MySQL语法。</p>\n<p>如果语句不对，则会收到“You have an error in your SQL syntax” 的错误提醒。一般会提示第一个出现错误的位置，需要关注<code>Use near</code>的后续内容。</p>\n<h3 id=\"优化器\"><a href=\"#优化器\" class=\"headerlink\" title=\"优化器\"></a>优化器</h3><p>经过了分析器，MySQL就知道你需要做什么了，在开始执行之前，要先经过优化器的处理。</p>\n<p>优化器是在表里面有多个索引的时候，决定需要使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</p>\n<p>虽然在不同的执行顺序结果一致，但是执行的效率不同，而优化器的作用就是选择使用哪一个方案。</p>\n<p>优化器阶段完成之后，这个语句的执行方案就确定下来了。后续将会继续讲解优化器的具体实现。</p>\n<h3 id=\"执行器\"><a href=\"#执行器\" class=\"headerlink\" title=\"执行器\"></a>执行器</h3><p>MySQL通过分析器知道了你要做什么，通过优化器知道了该怎么做，于是进入了执行器阶段。</p>\n<p>在开始执行的时候，先判断一下权限。有权限之后，</p>"},{"title":"数据库原理","date":"2017-01-22T02:22:50.000Z","_content":">[伯乐在线](http://blog.jobbole.com/100349/)学习总结\n\n本文会从一些计算机科学方面的知识谈起，比如时间复杂度。我知道有些人讨厌这个概念，但是没有它你就不能理解数据库内部的巧妙之处。由于这是个很大的话题，我将集中探讨我认为必要的内容：数据库处理SQL查询的方式。我仅仅介绍数据库背后的基本概念，以便在读完本文后你会对底层到底发生了什么有个很好的了解。\n\n<!--more-->\n\n本文分为三个部分：\n* 底层和上层数据库组件概况\n* 查询优化过程概况\n* 事务和缓冲池管理概况\n\n算法的复杂度包括：算法的磁盘 I/O 消耗，时间消耗，内存消耗三个方面。这里我们主要讨论时间复杂度。\n## 时间复杂度\n时间复杂度用来检验某个算法处理一定量的数据要花多长时间。O(函数) 这里表达的含义就是：这个算法需要多少次运算才能完成。\n\n大O符号是一种算法复杂度的相对表示方式。这里重要的不是数据量，而是**当数据量增加时运算如何增加。**时间复杂度不会给出确切的运算次数，但是给出的是一种理念。`n^2 +2n`在百万数据时，`2n`的部分根本无关紧要。**我们只关心复杂度最重要的部分。**\n\n时间复杂度经常处于最差情况场景。\n\n## 合并排序\n合并排序有助于我们以后理解数据库常见的联接操作，即合并联接 。\n### 过程\n合并排序是把问题拆分为小问题，通过解决小问题来解决最初的问题（注：这种算法叫分治法，即『分而治之、各个击破』）。\n\n* 拆分阶段，将序列分为更小的序列，有log(N)次运算。\n* 排序阶段，把小的序列合在一起（使用合并算法）来构成更大的序列。每次运算N次，共log(N)次，整体成本是 N*log(N) 次运算。*\n\n### 强大之处\n1.『原地算法』(in-place algorithm)：你可以更改算法，以便于节省内存空间，方法是不创建新的序列而是直接修改输入序列。\n2.『外部排序』(external sorting)：你可以更改算法，以便于同时使用磁盘空间和少量内存而避免巨量磁盘 I/O。方法是只向内存中加载当前处理的部分。在仅仅100MB的内存缓冲区内排序一个几个GB的表时，这是个很重要的技巧。\n3.分布式运行：你可以更改算法，以便于在 多处理器/多线程/多服务器 上运行。\n\n## 阵列，树和哈希表\n\n接下来介绍三种常用的数据结构，此为现代数据库的强大支柱。\n\n### 阵列(array)\n\n二维阵列是最简单的数据结构。一个表可以看作是个阵列，这种方法用来保存和可视化数据确实不错，但是在查找的时候，就需要`N`次运算，那有没有更快的方式呢？这就需要树了。\n\n\n### 树和数据库索引\n二叉查找树(B树)是带有特殊属性的二叉树，每个节点的关键字必须：\n1.比保存在左子树的任何键值都要大；\n2.比保存在右子树的任何键值都要小。\n\n这样，按层找确实运算次数有所减少，变为`log(N)`次。这也是`数据库索引`所做的。\n但是问题又来了，如果你要找的是查找两个值之间的多个元素时，你的运算成本就变为O(N)，因为你需要遍历每一个去寻找符合条件的(例如，使用中序遍历，父节点在中，左中右)。而且，对磁盘I/O消耗巨大。为了解决这个问题，现代数据库使用了一种修订版的树，叫做B+树。\n\n#### B+树\n在一个B+树里：\n1.只有最底层的节点（叶子节点）才保存信息（相关表的行位置）；\n2.其它节点只是在搜索中用来指引到正确节点的。\n\n[B+树](http://jbcdn2.b0.upaiyun.com/2016/05/15c4b064af9ac7f357404a1b17ff1cae.png)\n\n尽管节点更多了（多了两倍）。确实，你有了额外的节点，它们就是帮助你找到正确节点的『决策节点』（正确节点保存着相关表中行的位置）。但是搜索复杂度还是在 O(log(N))（只多了一层）。一个重要的不同点是，最底层的节点是跟后续节点相连接的。\n\n那你想找N之后的M个节点，时间复杂度就是`M+log(N)`。那你就不需要读整个树，减少了I/O的消耗。\n\n然而还有新的问题（又来了！）。如果你在数据库中增加或删除一行（从而在相关的 B+树索引里）：\n\n1.你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。\n2.你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。\n\n换句话说，B+树需要自我整理和自我平衡。B+树需要自我整理和自我平衡。谢天谢地，我们有智能删除和插入。但是这样也带来了成本：在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以导致了**使用太多索引会减慢了快速插入/更新/删除表中的一个行的操作**，因为数据库需要以代价高昂的每索引 O(log(N)) 运算来更新表的索引。再者，增加索引意味着给事务管理器带来更多的工作负荷。\n\n### 哈希表\n当你想快速查找值时，哈希表是非常有用的。而且，理解哈希表会帮助我们接下来理解一个数据库常见的联接操作，叫做『哈希联接』。这个数据结构也被数据库用来保存一些内部的东西（比如锁表或者缓冲池，我们在下文会研究这两个概念）。\n\n哈希表这种数据结构可以用关键字来快速找到一个元素。为了构建一个哈希表，你需要定义：\n\n1.元素的关键字\n2.关键字的哈希函数。关键字计算出来的哈希值给出了元素的位置（叫做哈希桶）。\n3.关键字比较函数。一旦你找到正确的哈希桶，你必须用比较函数在桶内找到你要的元素。\n\n这里面真正的挑战是找到好的哈希函数，让哈希桶里包含非常少的元素。可以使哈希表里搜索的时间复杂度为 O(1)。\n\n#### 那为什么不用阵列呢？\n\n1.阵列需要分配连续的空间，而哈希表的空间是分散的，剩下的哈希桶可以留在硬盘上。\n2.用哈希表的话，你可以选择你要的关键字\n\n## 全局概览\n\n数据库是由多种互相交互的组件构成的。\n\n### 核心组件\n\n\n* 进程管理器（process manager）：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。\n\n* 网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。\n\n* 文件系统管理器（File system manager）：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。\n\n* 内存管理器（memory manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。\n\n* 安全管理器（Security Manager）：用于对用户的验证和授权。\n\n* 客户端管理器（Client manager）：用于管理客户端连接。\n\n* ……\n\n### 工具\n\n* 备份管理器（Backup manager）：用于保存和恢复数据。\n\n* 复原管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。\n\n* 监控管理器（Monitor manager）：用于记录数据库活动信息和提供监控数据库的工具。\n\n* Administration管理器（Administration manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。\n\n* ……\n\n### 查询管理器：\n\n* 查询解析器（Query parser）：用于检查查询是否合法\n\n* 查询重写器（Query rewriter）：用于预优化查询\n\n* 查询优化器（Query optimizer）：用于优化查询\n\n* 查询执行器（Query executor）：用于编译和执行查询\n\n----\n未完！","source":"_posts/mysql/数据库原理.md","raw":"---\ntitle: 数据库原理\ndate: 2017-01-22 10:22:50\ntags: \n- 数据库\ncategories: 总结\n---\n>[伯乐在线](http://blog.jobbole.com/100349/)学习总结\n\n本文会从一些计算机科学方面的知识谈起，比如时间复杂度。我知道有些人讨厌这个概念，但是没有它你就不能理解数据库内部的巧妙之处。由于这是个很大的话题，我将集中探讨我认为必要的内容：数据库处理SQL查询的方式。我仅仅介绍数据库背后的基本概念，以便在读完本文后你会对底层到底发生了什么有个很好的了解。\n\n<!--more-->\n\n本文分为三个部分：\n* 底层和上层数据库组件概况\n* 查询优化过程概况\n* 事务和缓冲池管理概况\n\n算法的复杂度包括：算法的磁盘 I/O 消耗，时间消耗，内存消耗三个方面。这里我们主要讨论时间复杂度。\n## 时间复杂度\n时间复杂度用来检验某个算法处理一定量的数据要花多长时间。O(函数) 这里表达的含义就是：这个算法需要多少次运算才能完成。\n\n大O符号是一种算法复杂度的相对表示方式。这里重要的不是数据量，而是**当数据量增加时运算如何增加。**时间复杂度不会给出确切的运算次数，但是给出的是一种理念。`n^2 +2n`在百万数据时，`2n`的部分根本无关紧要。**我们只关心复杂度最重要的部分。**\n\n时间复杂度经常处于最差情况场景。\n\n## 合并排序\n合并排序有助于我们以后理解数据库常见的联接操作，即合并联接 。\n### 过程\n合并排序是把问题拆分为小问题，通过解决小问题来解决最初的问题（注：这种算法叫分治法，即『分而治之、各个击破』）。\n\n* 拆分阶段，将序列分为更小的序列，有log(N)次运算。\n* 排序阶段，把小的序列合在一起（使用合并算法）来构成更大的序列。每次运算N次，共log(N)次，整体成本是 N*log(N) 次运算。*\n\n### 强大之处\n1.『原地算法』(in-place algorithm)：你可以更改算法，以便于节省内存空间，方法是不创建新的序列而是直接修改输入序列。\n2.『外部排序』(external sorting)：你可以更改算法，以便于同时使用磁盘空间和少量内存而避免巨量磁盘 I/O。方法是只向内存中加载当前处理的部分。在仅仅100MB的内存缓冲区内排序一个几个GB的表时，这是个很重要的技巧。\n3.分布式运行：你可以更改算法，以便于在 多处理器/多线程/多服务器 上运行。\n\n## 阵列，树和哈希表\n\n接下来介绍三种常用的数据结构，此为现代数据库的强大支柱。\n\n### 阵列(array)\n\n二维阵列是最简单的数据结构。一个表可以看作是个阵列，这种方法用来保存和可视化数据确实不错，但是在查找的时候，就需要`N`次运算，那有没有更快的方式呢？这就需要树了。\n\n\n### 树和数据库索引\n二叉查找树(B树)是带有特殊属性的二叉树，每个节点的关键字必须：\n1.比保存在左子树的任何键值都要大；\n2.比保存在右子树的任何键值都要小。\n\n这样，按层找确实运算次数有所减少，变为`log(N)`次。这也是`数据库索引`所做的。\n但是问题又来了，如果你要找的是查找两个值之间的多个元素时，你的运算成本就变为O(N)，因为你需要遍历每一个去寻找符合条件的(例如，使用中序遍历，父节点在中，左中右)。而且，对磁盘I/O消耗巨大。为了解决这个问题，现代数据库使用了一种修订版的树，叫做B+树。\n\n#### B+树\n在一个B+树里：\n1.只有最底层的节点（叶子节点）才保存信息（相关表的行位置）；\n2.其它节点只是在搜索中用来指引到正确节点的。\n\n[B+树](http://jbcdn2.b0.upaiyun.com/2016/05/15c4b064af9ac7f357404a1b17ff1cae.png)\n\n尽管节点更多了（多了两倍）。确实，你有了额外的节点，它们就是帮助你找到正确节点的『决策节点』（正确节点保存着相关表中行的位置）。但是搜索复杂度还是在 O(log(N))（只多了一层）。一个重要的不同点是，最底层的节点是跟后续节点相连接的。\n\n那你想找N之后的M个节点，时间复杂度就是`M+log(N)`。那你就不需要读整个树，减少了I/O的消耗。\n\n然而还有新的问题（又来了！）。如果你在数据库中增加或删除一行（从而在相关的 B+树索引里）：\n\n1.你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。\n2.你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。\n\n换句话说，B+树需要自我整理和自我平衡。B+树需要自我整理和自我平衡。谢天谢地，我们有智能删除和插入。但是这样也带来了成本：在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以导致了**使用太多索引会减慢了快速插入/更新/删除表中的一个行的操作**，因为数据库需要以代价高昂的每索引 O(log(N)) 运算来更新表的索引。再者，增加索引意味着给事务管理器带来更多的工作负荷。\n\n### 哈希表\n当你想快速查找值时，哈希表是非常有用的。而且，理解哈希表会帮助我们接下来理解一个数据库常见的联接操作，叫做『哈希联接』。这个数据结构也被数据库用来保存一些内部的东西（比如锁表或者缓冲池，我们在下文会研究这两个概念）。\n\n哈希表这种数据结构可以用关键字来快速找到一个元素。为了构建一个哈希表，你需要定义：\n\n1.元素的关键字\n2.关键字的哈希函数。关键字计算出来的哈希值给出了元素的位置（叫做哈希桶）。\n3.关键字比较函数。一旦你找到正确的哈希桶，你必须用比较函数在桶内找到你要的元素。\n\n这里面真正的挑战是找到好的哈希函数，让哈希桶里包含非常少的元素。可以使哈希表里搜索的时间复杂度为 O(1)。\n\n#### 那为什么不用阵列呢？\n\n1.阵列需要分配连续的空间，而哈希表的空间是分散的，剩下的哈希桶可以留在硬盘上。\n2.用哈希表的话，你可以选择你要的关键字\n\n## 全局概览\n\n数据库是由多种互相交互的组件构成的。\n\n### 核心组件\n\n\n* 进程管理器（process manager）：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。\n\n* 网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。\n\n* 文件系统管理器（File system manager）：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。\n\n* 内存管理器（memory manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。\n\n* 安全管理器（Security Manager）：用于对用户的验证和授权。\n\n* 客户端管理器（Client manager）：用于管理客户端连接。\n\n* ……\n\n### 工具\n\n* 备份管理器（Backup manager）：用于保存和恢复数据。\n\n* 复原管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。\n\n* 监控管理器（Monitor manager）：用于记录数据库活动信息和提供监控数据库的工具。\n\n* Administration管理器（Administration manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。\n\n* ……\n\n### 查询管理器：\n\n* 查询解析器（Query parser）：用于检查查询是否合法\n\n* 查询重写器（Query rewriter）：用于预优化查询\n\n* 查询优化器（Query optimizer）：用于优化查询\n\n* 查询执行器（Query executor）：用于编译和执行查询\n\n----\n未完！","slug":"mysql/数据库原理","published":1,"updated":"2019-03-22T14:44:36.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwb001p4l3nwerfylmp","content":"<blockquote>\n<p><a href=\"http://blog.jobbole.com/100349/\" target=\"_blank\" rel=\"noopener\">伯乐在线</a>学习总结</p>\n</blockquote>\n<p>本文会从一些计算机科学方面的知识谈起，比如时间复杂度。我知道有些人讨厌这个概念，但是没有它你就不能理解数据库内部的巧妙之处。由于这是个很大的话题，我将集中探讨我认为必要的内容：数据库处理SQL查询的方式。我仅仅介绍数据库背后的基本概念，以便在读完本文后你会对底层到底发生了什么有个很好的了解。</p>\n<a id=\"more\"></a>\n<p>本文分为三个部分：</p>\n<ul>\n<li>底层和上层数据库组件概况</li>\n<li>查询优化过程概况</li>\n<li>事务和缓冲池管理概况</li>\n</ul>\n<p>算法的复杂度包括：算法的磁盘 I/O 消耗，时间消耗，内存消耗三个方面。这里我们主要讨论时间复杂度。</p>\n<h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>时间复杂度用来检验某个算法处理一定量的数据要花多长时间。O(函数) 这里表达的含义就是：这个算法需要多少次运算才能完成。</p>\n<p>大O符号是一种算法复杂度的相对表示方式。这里重要的不是数据量，而是<strong>当数据量增加时运算如何增加。</strong>时间复杂度不会给出确切的运算次数，但是给出的是一种理念。<code>n^2 +2n</code>在百万数据时，<code>2n</code>的部分根本无关紧要。<strong>我们只关心复杂度最重要的部分。</strong></p>\n<p>时间复杂度经常处于最差情况场景。</p>\n<h2 id=\"合并排序\"><a href=\"#合并排序\" class=\"headerlink\" title=\"合并排序\"></a>合并排序</h2><p>合并排序有助于我们以后理解数据库常见的联接操作，即合并联接 。</p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><p>合并排序是把问题拆分为小问题，通过解决小问题来解决最初的问题（注：这种算法叫分治法，即『分而治之、各个击破』）。</p>\n<ul>\n<li>拆分阶段，将序列分为更小的序列，有log(N)次运算。</li>\n<li>排序阶段，把小的序列合在一起（使用合并算法）来构成更大的序列。每次运算N次，共log(N)次，整体成本是 N<em>log(N) 次运算。</em></li>\n</ul>\n<h3 id=\"强大之处\"><a href=\"#强大之处\" class=\"headerlink\" title=\"强大之处\"></a>强大之处</h3><p>1.『原地算法』(in-place algorithm)：你可以更改算法，以便于节省内存空间，方法是不创建新的序列而是直接修改输入序列。<br>2.『外部排序』(external sorting)：你可以更改算法，以便于同时使用磁盘空间和少量内存而避免巨量磁盘 I/O。方法是只向内存中加载当前处理的部分。在仅仅100MB的内存缓冲区内排序一个几个GB的表时，这是个很重要的技巧。<br>3.分布式运行：你可以更改算法，以便于在 多处理器/多线程/多服务器 上运行。</p>\n<h2 id=\"阵列，树和哈希表\"><a href=\"#阵列，树和哈希表\" class=\"headerlink\" title=\"阵列，树和哈希表\"></a>阵列，树和哈希表</h2><p>接下来介绍三种常用的数据结构，此为现代数据库的强大支柱。</p>\n<h3 id=\"阵列-array\"><a href=\"#阵列-array\" class=\"headerlink\" title=\"阵列(array)\"></a>阵列(array)</h3><p>二维阵列是最简单的数据结构。一个表可以看作是个阵列，这种方法用来保存和可视化数据确实不错，但是在查找的时候，就需要<code>N</code>次运算，那有没有更快的方式呢？这就需要树了。</p>\n<h3 id=\"树和数据库索引\"><a href=\"#树和数据库索引\" class=\"headerlink\" title=\"树和数据库索引\"></a>树和数据库索引</h3><p>二叉查找树(B树)是带有特殊属性的二叉树，每个节点的关键字必须：<br>1.比保存在左子树的任何键值都要大；<br>2.比保存在右子树的任何键值都要小。</p>\n<p>这样，按层找确实运算次数有所减少，变为<code>log(N)</code>次。这也是<code>数据库索引</code>所做的。<br>但是问题又来了，如果你要找的是查找两个值之间的多个元素时，你的运算成本就变为O(N)，因为你需要遍历每一个去寻找符合条件的(例如，使用中序遍历，父节点在中，左中右)。而且，对磁盘I/O消耗巨大。为了解决这个问题，现代数据库使用了一种修订版的树，叫做B+树。</p>\n<h4 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h4><p>在一个B+树里：<br>1.只有最底层的节点（叶子节点）才保存信息（相关表的行位置）；<br>2.其它节点只是在搜索中用来指引到正确节点的。</p>\n<p><a href=\"http://jbcdn2.b0.upaiyun.com/2016/05/15c4b064af9ac7f357404a1b17ff1cae.png\" target=\"_blank\" rel=\"noopener\">B+树</a></p>\n<p>尽管节点更多了（多了两倍）。确实，你有了额外的节点，它们就是帮助你找到正确节点的『决策节点』（正确节点保存着相关表中行的位置）。但是搜索复杂度还是在 O(log(N))（只多了一层）。一个重要的不同点是，最底层的节点是跟后续节点相连接的。</p>\n<p>那你想找N之后的M个节点，时间复杂度就是<code>M+log(N)</code>。那你就不需要读整个树，减少了I/O的消耗。</p>\n<p>然而还有新的问题（又来了！）。如果你在数据库中增加或删除一行（从而在相关的 B+树索引里）：</p>\n<p>1.你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。<br>2.你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。</p>\n<p>换句话说，B+树需要自我整理和自我平衡。B+树需要自我整理和自我平衡。谢天谢地，我们有智能删除和插入。但是这样也带来了成本：在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以导致了<strong>使用太多索引会减慢了快速插入/更新/删除表中的一个行的操作</strong>，因为数据库需要以代价高昂的每索引 O(log(N)) 运算来更新表的索引。再者，增加索引意味着给事务管理器带来更多的工作负荷。</p>\n<h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><p>当你想快速查找值时，哈希表是非常有用的。而且，理解哈希表会帮助我们接下来理解一个数据库常见的联接操作，叫做『哈希联接』。这个数据结构也被数据库用来保存一些内部的东西（比如锁表或者缓冲池，我们在下文会研究这两个概念）。</p>\n<p>哈希表这种数据结构可以用关键字来快速找到一个元素。为了构建一个哈希表，你需要定义：</p>\n<p>1.元素的关键字<br>2.关键字的哈希函数。关键字计算出来的哈希值给出了元素的位置（叫做哈希桶）。<br>3.关键字比较函数。一旦你找到正确的哈希桶，你必须用比较函数在桶内找到你要的元素。</p>\n<p>这里面真正的挑战是找到好的哈希函数，让哈希桶里包含非常少的元素。可以使哈希表里搜索的时间复杂度为 O(1)。</p>\n<h4 id=\"那为什么不用阵列呢？\"><a href=\"#那为什么不用阵列呢？\" class=\"headerlink\" title=\"那为什么不用阵列呢？\"></a>那为什么不用阵列呢？</h4><p>1.阵列需要分配连续的空间，而哈希表的空间是分散的，剩下的哈希桶可以留在硬盘上。<br>2.用哈希表的话，你可以选择你要的关键字</p>\n<h2 id=\"全局概览\"><a href=\"#全局概览\" class=\"headerlink\" title=\"全局概览\"></a>全局概览</h2><p>数据库是由多种互相交互的组件构成的。</p>\n<h3 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h3><ul>\n<li><p>进程管理器（process manager）：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。</p>\n</li>\n<li><p>网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。</p>\n</li>\n<li><p>文件系统管理器（File system manager）：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。</p>\n</li>\n<li><p>内存管理器（memory manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。</p>\n</li>\n<li><p>安全管理器（Security Manager）：用于对用户的验证和授权。</p>\n</li>\n<li><p>客户端管理器（Client manager）：用于管理客户端连接。</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><ul>\n<li><p>备份管理器（Backup manager）：用于保存和恢复数据。</p>\n</li>\n<li><p>复原管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。</p>\n</li>\n<li><p>监控管理器（Monitor manager）：用于记录数据库活动信息和提供监控数据库的工具。</p>\n</li>\n<li><p>Administration管理器（Administration manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<h3 id=\"查询管理器：\"><a href=\"#查询管理器：\" class=\"headerlink\" title=\"查询管理器：\"></a>查询管理器：</h3><ul>\n<li><p>查询解析器（Query parser）：用于检查查询是否合法</p>\n</li>\n<li><p>查询重写器（Query rewriter）：用于预优化查询</p>\n</li>\n<li><p>查询优化器（Query optimizer）：用于优化查询</p>\n</li>\n<li><p>查询执行器（Query executor）：用于编译和执行查询</p>\n</li>\n</ul>\n<hr>\n<p>未完！</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><a href=\"http://blog.jobbole.com/100349/\" target=\"_blank\" rel=\"noopener\">伯乐在线</a>学习总结</p>\n</blockquote>\n<p>本文会从一些计算机科学方面的知识谈起，比如时间复杂度。我知道有些人讨厌这个概念，但是没有它你就不能理解数据库内部的巧妙之处。由于这是个很大的话题，我将集中探讨我认为必要的内容：数据库处理SQL查询的方式。我仅仅介绍数据库背后的基本概念，以便在读完本文后你会对底层到底发生了什么有个很好的了解。</p>","more":"<p>本文分为三个部分：</p>\n<ul>\n<li>底层和上层数据库组件概况</li>\n<li>查询优化过程概况</li>\n<li>事务和缓冲池管理概况</li>\n</ul>\n<p>算法的复杂度包括：算法的磁盘 I/O 消耗，时间消耗，内存消耗三个方面。这里我们主要讨论时间复杂度。</p>\n<h2 id=\"时间复杂度\"><a href=\"#时间复杂度\" class=\"headerlink\" title=\"时间复杂度\"></a>时间复杂度</h2><p>时间复杂度用来检验某个算法处理一定量的数据要花多长时间。O(函数) 这里表达的含义就是：这个算法需要多少次运算才能完成。</p>\n<p>大O符号是一种算法复杂度的相对表示方式。这里重要的不是数据量，而是<strong>当数据量增加时运算如何增加。</strong>时间复杂度不会给出确切的运算次数，但是给出的是一种理念。<code>n^2 +2n</code>在百万数据时，<code>2n</code>的部分根本无关紧要。<strong>我们只关心复杂度最重要的部分。</strong></p>\n<p>时间复杂度经常处于最差情况场景。</p>\n<h2 id=\"合并排序\"><a href=\"#合并排序\" class=\"headerlink\" title=\"合并排序\"></a>合并排序</h2><p>合并排序有助于我们以后理解数据库常见的联接操作，即合并联接 。</p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><p>合并排序是把问题拆分为小问题，通过解决小问题来解决最初的问题（注：这种算法叫分治法，即『分而治之、各个击破』）。</p>\n<ul>\n<li>拆分阶段，将序列分为更小的序列，有log(N)次运算。</li>\n<li>排序阶段，把小的序列合在一起（使用合并算法）来构成更大的序列。每次运算N次，共log(N)次，整体成本是 N<em>log(N) 次运算。</em></li>\n</ul>\n<h3 id=\"强大之处\"><a href=\"#强大之处\" class=\"headerlink\" title=\"强大之处\"></a>强大之处</h3><p>1.『原地算法』(in-place algorithm)：你可以更改算法，以便于节省内存空间，方法是不创建新的序列而是直接修改输入序列。<br>2.『外部排序』(external sorting)：你可以更改算法，以便于同时使用磁盘空间和少量内存而避免巨量磁盘 I/O。方法是只向内存中加载当前处理的部分。在仅仅100MB的内存缓冲区内排序一个几个GB的表时，这是个很重要的技巧。<br>3.分布式运行：你可以更改算法，以便于在 多处理器/多线程/多服务器 上运行。</p>\n<h2 id=\"阵列，树和哈希表\"><a href=\"#阵列，树和哈希表\" class=\"headerlink\" title=\"阵列，树和哈希表\"></a>阵列，树和哈希表</h2><p>接下来介绍三种常用的数据结构，此为现代数据库的强大支柱。</p>\n<h3 id=\"阵列-array\"><a href=\"#阵列-array\" class=\"headerlink\" title=\"阵列(array)\"></a>阵列(array)</h3><p>二维阵列是最简单的数据结构。一个表可以看作是个阵列，这种方法用来保存和可视化数据确实不错，但是在查找的时候，就需要<code>N</code>次运算，那有没有更快的方式呢？这就需要树了。</p>\n<h3 id=\"树和数据库索引\"><a href=\"#树和数据库索引\" class=\"headerlink\" title=\"树和数据库索引\"></a>树和数据库索引</h3><p>二叉查找树(B树)是带有特殊属性的二叉树，每个节点的关键字必须：<br>1.比保存在左子树的任何键值都要大；<br>2.比保存在右子树的任何键值都要小。</p>\n<p>这样，按层找确实运算次数有所减少，变为<code>log(N)</code>次。这也是<code>数据库索引</code>所做的。<br>但是问题又来了，如果你要找的是查找两个值之间的多个元素时，你的运算成本就变为O(N)，因为你需要遍历每一个去寻找符合条件的(例如，使用中序遍历，父节点在中，左中右)。而且，对磁盘I/O消耗巨大。为了解决这个问题，现代数据库使用了一种修订版的树，叫做B+树。</p>\n<h4 id=\"B-树\"><a href=\"#B-树\" class=\"headerlink\" title=\"B+树\"></a>B+树</h4><p>在一个B+树里：<br>1.只有最底层的节点（叶子节点）才保存信息（相关表的行位置）；<br>2.其它节点只是在搜索中用来指引到正确节点的。</p>\n<p><a href=\"http://jbcdn2.b0.upaiyun.com/2016/05/15c4b064af9ac7f357404a1b17ff1cae.png\" target=\"_blank\" rel=\"noopener\">B+树</a></p>\n<p>尽管节点更多了（多了两倍）。确实，你有了额外的节点，它们就是帮助你找到正确节点的『决策节点』（正确节点保存着相关表中行的位置）。但是搜索复杂度还是在 O(log(N))（只多了一层）。一个重要的不同点是，最底层的节点是跟后续节点相连接的。</p>\n<p>那你想找N之后的M个节点，时间复杂度就是<code>M+log(N)</code>。那你就不需要读整个树，减少了I/O的消耗。</p>\n<p>然而还有新的问题（又来了！）。如果你在数据库中增加或删除一行（从而在相关的 B+树索引里）：</p>\n<p>1.你必须在B+树中的节点之间保持顺序，否则节点会变得一团糟，你无法从中找到想要的节点。<br>2.你必须尽可能降低B+树的层数，否则 O(log(N)) 复杂度会变成 O(N)。</p>\n<p>换句话说，B+树需要自我整理和自我平衡。B+树需要自我整理和自我平衡。谢天谢地，我们有智能删除和插入。但是这样也带来了成本：在B+树中，插入和删除操作是 O(log(N)) 复杂度。所以导致了<strong>使用太多索引会减慢了快速插入/更新/删除表中的一个行的操作</strong>，因为数据库需要以代价高昂的每索引 O(log(N)) 运算来更新表的索引。再者，增加索引意味着给事务管理器带来更多的工作负荷。</p>\n<h3 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h3><p>当你想快速查找值时，哈希表是非常有用的。而且，理解哈希表会帮助我们接下来理解一个数据库常见的联接操作，叫做『哈希联接』。这个数据结构也被数据库用来保存一些内部的东西（比如锁表或者缓冲池，我们在下文会研究这两个概念）。</p>\n<p>哈希表这种数据结构可以用关键字来快速找到一个元素。为了构建一个哈希表，你需要定义：</p>\n<p>1.元素的关键字<br>2.关键字的哈希函数。关键字计算出来的哈希值给出了元素的位置（叫做哈希桶）。<br>3.关键字比较函数。一旦你找到正确的哈希桶，你必须用比较函数在桶内找到你要的元素。</p>\n<p>这里面真正的挑战是找到好的哈希函数，让哈希桶里包含非常少的元素。可以使哈希表里搜索的时间复杂度为 O(1)。</p>\n<h4 id=\"那为什么不用阵列呢？\"><a href=\"#那为什么不用阵列呢？\" class=\"headerlink\" title=\"那为什么不用阵列呢？\"></a>那为什么不用阵列呢？</h4><p>1.阵列需要分配连续的空间，而哈希表的空间是分散的，剩下的哈希桶可以留在硬盘上。<br>2.用哈希表的话，你可以选择你要的关键字</p>\n<h2 id=\"全局概览\"><a href=\"#全局概览\" class=\"headerlink\" title=\"全局概览\"></a>全局概览</h2><p>数据库是由多种互相交互的组件构成的。</p>\n<h3 id=\"核心组件\"><a href=\"#核心组件\" class=\"headerlink\" title=\"核心组件\"></a>核心组件</h3><ul>\n<li><p>进程管理器（process manager）：很多数据库具备一个需要妥善管理的进程/线程池。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。</p>\n</li>\n<li><p>网络管理器（network manager）：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。</p>\n</li>\n<li><p>文件系统管理器（File system manager）：磁盘I/O是数据库的首要瓶颈。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。</p>\n</li>\n<li><p>内存管理器（memory manager）：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。</p>\n</li>\n<li><p>安全管理器（Security Manager）：用于对用户的验证和授权。</p>\n</li>\n<li><p>客户端管理器（Client manager）：用于管理客户端连接。</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<h3 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h3><ul>\n<li><p>备份管理器（Backup manager）：用于保存和恢复数据。</p>\n</li>\n<li><p>复原管理器（Recovery manager）：用于崩溃后重启数据库到一个一致状态。</p>\n</li>\n<li><p>监控管理器（Monitor manager）：用于记录数据库活动信息和提供监控数据库的工具。</p>\n</li>\n<li><p>Administration管理器（Administration manager）：用于保存元数据（比如表的名称和结构），提供管理数据库、模式、表空间的工具。</p>\n</li>\n<li><p>……</p>\n</li>\n</ul>\n<h3 id=\"查询管理器：\"><a href=\"#查询管理器：\" class=\"headerlink\" title=\"查询管理器：\"></a>查询管理器：</h3><ul>\n<li><p>查询解析器（Query parser）：用于检查查询是否合法</p>\n</li>\n<li><p>查询重写器（Query rewriter）：用于预优化查询</p>\n</li>\n<li><p>查询优化器（Query optimizer）：用于优化查询</p>\n</li>\n<li><p>查询执行器（Query executor）：用于编译和执行查询</p>\n</li>\n</ul>\n<hr>\n<p>未完！</p>"},{"title":"使用Distutils分发自己编写的Python包","date":"2017-04-19T13:22:50.000Z","_content":"\n>翻译自[官方文档](https://docs.python.org/2.7/distutils/index.html)\n\n本文档从模块开发人员的角度描述了Python Distribution Utilities（“Distutils”），介绍了如何使用Distutils将Python模块和扩展程序提供给更加广泛的使用者，并使得构建/释放/安装机制的开销很少。\n\n<!--more-->\n\n## 概念&术语\n\n对于模块开发人员和安装第三方模块的用户/管理员来说，使用Distutils是非常简单的。作为一名开发人员，您的责任（当然除了编写可靠的，有详细记录和经过良好测试的代码）是：\n\n* 写一个安装脚本（按照惯例为setup.py）\n* （可选）写入设置配置文件\n* 建立一个源码分发包\n* （可选）创建一个或多个内置（二进制）分发包\n\n这些都会在本文档中一一提到。\n\n并不是所有的模块开发人员都可以访问多种平台，因此总想着他们可以创建大量的内置分发包是不可行的。希望出现一类称为“packagers”的中介机构，以满足这一需求。packagers将采用模块开发人员发布的源代码，将其构建在一个或多个平台上，并发布生成的内置分发包。因此，最流行的平台上的用户将能够以最自然的方式为他们的平台安装大多数流行的Python模块分发包，而无需运行单个安装脚本或编译一行代码。\n\n## 一个简单实例\n\n安装脚本通常非常简单，尽管由Python编写，但是对于可以使用的脚本没有任何限制，可还是要在安装脚本中应该谨慎处理那些重要的操作。 与`Autoconf`风格的配置脚本不同的是，在构建和安装模块分发包的过程中，安装脚本可能会多次运行。\n\n如果你想做的只是分发一个包含在`foo.py`文件中的`foo`模块，那么你的安装脚本就可以这么简单：\n```\nfrom distutils.core import setup\nsetup(name='foo',\n      version='1.0',\n      py_modules=['foo'],\n      )\n\n```\n一些需要注意的地方：\n\n* 您提供给`Distutils`的大多数信息都作为关键字参数提供给`setup（）`函数\n\n* 这些关键字参数分为两类：包元数据（名称，版本号）以及有关软件包内容的信息（在这种情况下是纯`Python`模块的列表）\n\n* 模块由模块名称指定，而不是文件名（对于包和扩展名也是如此）\n\n* 建议您提供更多元数据，特别是您的名称，电子邮件地址和项目的URL（请参阅编写安装脚本一节）\n\n\n如果要将源码进行分发，你需要在`setup.py`写入上述代码，并从命令行处运行：\n\n```\npython setup.py sdist\n```\n对于Windows用户来说，你需要执行：\n\n```\nsetup.py sdist\n```\n\n`sdist`将创建一个存档文件（例如，Unix上的tarball文件，Windows上的ZIP文件），其中包含您的安装脚本`setup.py`和您的模块`foo.py`。 归档文件将被命名为`foo-1.0.tar.gz（或.zip）`，并将打包到目录`foo-1.0`中。\n\n如果最终用户希望安装您的foo模块，那么她所要做的就是下载`foo-1.0.tar.gz（或.zip）`，解压缩，并从`foo-1.0`目录运行：\n\n```\npython setup.py install\n```\n\n这将最终将`foo.py`复制到Python安装中的第三方模块的相应目录。\n\n这个简单的例子演示了`Distutils`的一些基本概念。 首先，开发人员和安装人员都有相同的基本用户界面，即安装脚本。 区别在于`Distutils`使用的命令：`sdist`命令几乎专门用于模块开发人员，而安装程序更常用于安装程序（尽管大多数开发人员都希望偶尔安装自己的代码）。\n\n如果你想为用户做一些简单的事情，你可以为他们创建一个或多个内置（二进制）的分发包。 例如，如果您正在Windows机器上运行，并希望为其他Windows用户提供方便，则可以使用`bdist_wininst`命令创建一个可执行安装程序（这个平台最合适的构建版本的类型）。 例如：\n```\npython setup.py bdist_wininst\n```\n\n这将在当前目录中创建可执行安装程序`foo-1.0.win32.exe`。\n\n其他有用的内置分发格式是RPM。 例如，以下命令将创建一个名为`foo-1.0.noarch.rpm`的RPM文件：\n\n```\npython setup.py bdist_rpm\n```\n\n>注：bdist_rpm命令使用rpm可执行文件，因此必须在基于RPM的系统上运行，如Red Hat Linux，SuSE Linux或Mandrake Linux。\n\n```\npython setup.py bdist --help-formats\n```\n\n你可以通过这条指令来查看运行了什么样的分发格式。\n\n## 常用的Python术语\n\n**模块(module)**:Python中代码可重用性的基本单位：由一些其他代码导入的代码块。 这里涉及到三种类型的模块：纯Python模块（Python modules），扩展模块（extension modules）和包（packages）。\n\n**纯Python模块（Python modules）**：一个用Python编写并包含在一个.py文件中的模块（也可能是关联的.pyc和/或.pyo文件）。 有时被称为“纯模块”。\n\n**扩展模块（extension modules）**：一个用Python实现的低级语言编写的模块：C / C ++ for Python，Java for Jython。 通常包含在单个可动态加载的预编译文件中。 Unix上的Python扩展的共享对象（.so）文件，Windows上的Python扩展的DLL（给定.pyd扩展名）或Jython扩展的Java类文件。 （请注意，目前，Distutils仅处理Python的C / C ++扩展。）\n\n**包（packages）**:包含其他模块的模块; 通常包含在文件系统中的目录中，并通过存在文件`__init__.py`与其他目录区分开来。\n\n**根包（root packages）**：\n包的层次结构的根。 （这不是一个包，因为它没有一个`__init__.py`文件，但我们必须称之为一些）。绝大多数的标准库是根包，许多小的，独立的第三个 不属于较大模块集合的一个模块。 与常规包不同，根包中的模块可以在许多目录中找到：实际上，`sys.path`中列出的每个目录都向根包提供模块。\n\n## Distutils特定术语\n\n以下术语更具体地适用于使用`Distutils`分发`Python`模块的方面：\n\n**模块分发包**:作为一个可下载的资源一起分发的Python模块的集合，并且要大量安装。一些众所周知的模块分布的例子有数字Python，PyXML，PIL（Python影像库）或mxBase。 （这将被称为包，除了该术语已经在Python上下文中：单个模块分发可能包含零个，一个或多个Python包。）\n\n**纯模块分发包**：一个仅包含纯Python模块和包的模块分发。有时被称为“纯分配”。\n\n**非纯模块分发包**：一个包含至少一个扩展模块的模块分发。有时被称为“非纯分配”。\n\n**根分发包**：源树（或源分发）的顶层目录; setup.py存在的目录。一般来说，setup.py将从此目录运行。","source":"_posts/python/Python模块分发.md","raw":"---\ntitle: 使用Distutils分发自己编写的Python包\ndate: 2017-04-19 21:22:50\ntags: \n- 协议\ncategories: 总结\n---\n\n>翻译自[官方文档](https://docs.python.org/2.7/distutils/index.html)\n\n本文档从模块开发人员的角度描述了Python Distribution Utilities（“Distutils”），介绍了如何使用Distutils将Python模块和扩展程序提供给更加广泛的使用者，并使得构建/释放/安装机制的开销很少。\n\n<!--more-->\n\n## 概念&术语\n\n对于模块开发人员和安装第三方模块的用户/管理员来说，使用Distutils是非常简单的。作为一名开发人员，您的责任（当然除了编写可靠的，有详细记录和经过良好测试的代码）是：\n\n* 写一个安装脚本（按照惯例为setup.py）\n* （可选）写入设置配置文件\n* 建立一个源码分发包\n* （可选）创建一个或多个内置（二进制）分发包\n\n这些都会在本文档中一一提到。\n\n并不是所有的模块开发人员都可以访问多种平台，因此总想着他们可以创建大量的内置分发包是不可行的。希望出现一类称为“packagers”的中介机构，以满足这一需求。packagers将采用模块开发人员发布的源代码，将其构建在一个或多个平台上，并发布生成的内置分发包。因此，最流行的平台上的用户将能够以最自然的方式为他们的平台安装大多数流行的Python模块分发包，而无需运行单个安装脚本或编译一行代码。\n\n## 一个简单实例\n\n安装脚本通常非常简单，尽管由Python编写，但是对于可以使用的脚本没有任何限制，可还是要在安装脚本中应该谨慎处理那些重要的操作。 与`Autoconf`风格的配置脚本不同的是，在构建和安装模块分发包的过程中，安装脚本可能会多次运行。\n\n如果你想做的只是分发一个包含在`foo.py`文件中的`foo`模块，那么你的安装脚本就可以这么简单：\n```\nfrom distutils.core import setup\nsetup(name='foo',\n      version='1.0',\n      py_modules=['foo'],\n      )\n\n```\n一些需要注意的地方：\n\n* 您提供给`Distutils`的大多数信息都作为关键字参数提供给`setup（）`函数\n\n* 这些关键字参数分为两类：包元数据（名称，版本号）以及有关软件包内容的信息（在这种情况下是纯`Python`模块的列表）\n\n* 模块由模块名称指定，而不是文件名（对于包和扩展名也是如此）\n\n* 建议您提供更多元数据，特别是您的名称，电子邮件地址和项目的URL（请参阅编写安装脚本一节）\n\n\n如果要将源码进行分发，你需要在`setup.py`写入上述代码，并从命令行处运行：\n\n```\npython setup.py sdist\n```\n对于Windows用户来说，你需要执行：\n\n```\nsetup.py sdist\n```\n\n`sdist`将创建一个存档文件（例如，Unix上的tarball文件，Windows上的ZIP文件），其中包含您的安装脚本`setup.py`和您的模块`foo.py`。 归档文件将被命名为`foo-1.0.tar.gz（或.zip）`，并将打包到目录`foo-1.0`中。\n\n如果最终用户希望安装您的foo模块，那么她所要做的就是下载`foo-1.0.tar.gz（或.zip）`，解压缩，并从`foo-1.0`目录运行：\n\n```\npython setup.py install\n```\n\n这将最终将`foo.py`复制到Python安装中的第三方模块的相应目录。\n\n这个简单的例子演示了`Distutils`的一些基本概念。 首先，开发人员和安装人员都有相同的基本用户界面，即安装脚本。 区别在于`Distutils`使用的命令：`sdist`命令几乎专门用于模块开发人员，而安装程序更常用于安装程序（尽管大多数开发人员都希望偶尔安装自己的代码）。\n\n如果你想为用户做一些简单的事情，你可以为他们创建一个或多个内置（二进制）的分发包。 例如，如果您正在Windows机器上运行，并希望为其他Windows用户提供方便，则可以使用`bdist_wininst`命令创建一个可执行安装程序（这个平台最合适的构建版本的类型）。 例如：\n```\npython setup.py bdist_wininst\n```\n\n这将在当前目录中创建可执行安装程序`foo-1.0.win32.exe`。\n\n其他有用的内置分发格式是RPM。 例如，以下命令将创建一个名为`foo-1.0.noarch.rpm`的RPM文件：\n\n```\npython setup.py bdist_rpm\n```\n\n>注：bdist_rpm命令使用rpm可执行文件，因此必须在基于RPM的系统上运行，如Red Hat Linux，SuSE Linux或Mandrake Linux。\n\n```\npython setup.py bdist --help-formats\n```\n\n你可以通过这条指令来查看运行了什么样的分发格式。\n\n## 常用的Python术语\n\n**模块(module)**:Python中代码可重用性的基本单位：由一些其他代码导入的代码块。 这里涉及到三种类型的模块：纯Python模块（Python modules），扩展模块（extension modules）和包（packages）。\n\n**纯Python模块（Python modules）**：一个用Python编写并包含在一个.py文件中的模块（也可能是关联的.pyc和/或.pyo文件）。 有时被称为“纯模块”。\n\n**扩展模块（extension modules）**：一个用Python实现的低级语言编写的模块：C / C ++ for Python，Java for Jython。 通常包含在单个可动态加载的预编译文件中。 Unix上的Python扩展的共享对象（.so）文件，Windows上的Python扩展的DLL（给定.pyd扩展名）或Jython扩展的Java类文件。 （请注意，目前，Distutils仅处理Python的C / C ++扩展。）\n\n**包（packages）**:包含其他模块的模块; 通常包含在文件系统中的目录中，并通过存在文件`__init__.py`与其他目录区分开来。\n\n**根包（root packages）**：\n包的层次结构的根。 （这不是一个包，因为它没有一个`__init__.py`文件，但我们必须称之为一些）。绝大多数的标准库是根包，许多小的，独立的第三个 不属于较大模块集合的一个模块。 与常规包不同，根包中的模块可以在许多目录中找到：实际上，`sys.path`中列出的每个目录都向根包提供模块。\n\n## Distutils特定术语\n\n以下术语更具体地适用于使用`Distutils`分发`Python`模块的方面：\n\n**模块分发包**:作为一个可下载的资源一起分发的Python模块的集合，并且要大量安装。一些众所周知的模块分布的例子有数字Python，PyXML，PIL（Python影像库）或mxBase。 （这将被称为包，除了该术语已经在Python上下文中：单个模块分发可能包含零个，一个或多个Python包。）\n\n**纯模块分发包**：一个仅包含纯Python模块和包的模块分发。有时被称为“纯分配”。\n\n**非纯模块分发包**：一个包含至少一个扩展模块的模块分发。有时被称为“非纯分配”。\n\n**根分发包**：源树（或源分发）的顶层目录; setup.py存在的目录。一般来说，setup.py将从此目录运行。","slug":"python/Python模块分发","published":1,"updated":"2019-03-22T14:44:36.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwc001s4l3n4dagzpi7","content":"<blockquote>\n<p>翻译自<a href=\"https://docs.python.org/2.7/distutils/index.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n</blockquote>\n<p>本文档从模块开发人员的角度描述了Python Distribution Utilities（“Distutils”），介绍了如何使用Distutils将Python模块和扩展程序提供给更加广泛的使用者，并使得构建/释放/安装机制的开销很少。</p>\n<a id=\"more\"></a>\n<h2 id=\"概念-amp-术语\"><a href=\"#概念-amp-术语\" class=\"headerlink\" title=\"概念&amp;术语\"></a>概念&amp;术语</h2><p>对于模块开发人员和安装第三方模块的用户/管理员来说，使用Distutils是非常简单的。作为一名开发人员，您的责任（当然除了编写可靠的，有详细记录和经过良好测试的代码）是：</p>\n<ul>\n<li>写一个安装脚本（按照惯例为setup.py）</li>\n<li>（可选）写入设置配置文件</li>\n<li>建立一个源码分发包</li>\n<li>（可选）创建一个或多个内置（二进制）分发包</li>\n</ul>\n<p>这些都会在本文档中一一提到。</p>\n<p>并不是所有的模块开发人员都可以访问多种平台，因此总想着他们可以创建大量的内置分发包是不可行的。希望出现一类称为“packagers”的中介机构，以满足这一需求。packagers将采用模块开发人员发布的源代码，将其构建在一个或多个平台上，并发布生成的内置分发包。因此，最流行的平台上的用户将能够以最自然的方式为他们的平台安装大多数流行的Python模块分发包，而无需运行单个安装脚本或编译一行代码。</p>\n<h2 id=\"一个简单实例\"><a href=\"#一个简单实例\" class=\"headerlink\" title=\"一个简单实例\"></a>一个简单实例</h2><p>安装脚本通常非常简单，尽管由Python编写，但是对于可以使用的脚本没有任何限制，可还是要在安装脚本中应该谨慎处理那些重要的操作。 与<code>Autoconf</code>风格的配置脚本不同的是，在构建和安装模块分发包的过程中，安装脚本可能会多次运行。</p>\n<p>如果你想做的只是分发一个包含在<code>foo.py</code>文件中的<code>foo</code>模块，那么你的安装脚本就可以这么简单：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from distutils.core <span class=\"keyword\">import</span> <span class=\"built_in\">setup</span></span><br><span class=\"line\"><span class=\"built_in\">setup</span>(name=<span class=\"string\">'foo'</span>,</span><br><span class=\"line\">      version=<span class=\"string\">'1.0'</span>,</span><br><span class=\"line\">      py_modules=[<span class=\"string\">'foo'</span>],</span><br><span class=\"line\">      )</span><br></pre></td></tr></table></figure></p>\n<p>一些需要注意的地方：</p>\n<ul>\n<li><p>您提供给<code>Distutils</code>的大多数信息都作为关键字参数提供给<code>setup（）</code>函数</p>\n</li>\n<li><p>这些关键字参数分为两类：包元数据（名称，版本号）以及有关软件包内容的信息（在这种情况下是纯<code>Python</code>模块的列表）</p>\n</li>\n<li><p>模块由模块名称指定，而不是文件名（对于包和扩展名也是如此）</p>\n</li>\n<li><p>建议您提供更多元数据，特别是您的名称，电子邮件地址和项目的URL（请参阅编写安装脚本一节）</p>\n</li>\n</ul>\n<p>如果要将源码进行分发，你需要在<code>setup.py</code>写入上述代码，并从命令行处运行：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python setup<span class=\"selector-class\">.py</span> sdist</span><br></pre></td></tr></table></figure>\n<p>对于Windows用户来说，你需要执行：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup<span class=\"selector-class\">.py</span> sdist</span><br></pre></td></tr></table></figure>\n<p><code>sdist</code>将创建一个存档文件（例如，Unix上的tarball文件，Windows上的ZIP文件），其中包含您的安装脚本<code>setup.py</code>和您的模块<code>foo.py</code>。 归档文件将被命名为<code>foo-1.0.tar.gz（或.zip）</code>，并将打包到目录<code>foo-1.0</code>中。</p>\n<p>如果最终用户希望安装您的foo模块，那么她所要做的就是下载<code>foo-1.0.tar.gz（或.zip）</code>，解压缩，并从<code>foo-1.0</code>目录运行：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python setup<span class=\"selector-class\">.py</span> install</span><br></pre></td></tr></table></figure>\n<p>这将最终将<code>foo.py</code>复制到Python安装中的第三方模块的相应目录。</p>\n<p>这个简单的例子演示了<code>Distutils</code>的一些基本概念。 首先，开发人员和安装人员都有相同的基本用户界面，即安装脚本。 区别在于<code>Distutils</code>使用的命令：<code>sdist</code>命令几乎专门用于模块开发人员，而安装程序更常用于安装程序（尽管大多数开发人员都希望偶尔安装自己的代码）。</p>\n<p>如果你想为用户做一些简单的事情，你可以为他们创建一个或多个内置（二进制）的分发包。 例如，如果您正在Windows机器上运行，并希望为其他Windows用户提供方便，则可以使用<code>bdist_wininst</code>命令创建一个可执行安装程序（这个平台最合适的构建版本的类型）。 例如：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python setup<span class=\"selector-class\">.py</span> bdist_wininst</span><br></pre></td></tr></table></figure></p>\n<p>这将在当前目录中创建可执行安装程序<code>foo-1.0.win32.exe</code>。</p>\n<p>其他有用的内置分发格式是RPM。 例如，以下命令将创建一个名为<code>foo-1.0.noarch.rpm</code>的RPM文件：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python setup<span class=\"selector-class\">.py</span> bdist_rpm</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：bdist_rpm命令使用rpm可执行文件，因此必须在基于RPM的系统上运行，如Red Hat Linux，SuSE Linux或Mandrake Linux。</p>\n</blockquote>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">python</span> setup.<span class=\"keyword\">py</span> bdist --<span class=\"keyword\">help</span>-formats</span><br></pre></td></tr></table></figure>\n<p>你可以通过这条指令来查看运行了什么样的分发格式。</p>\n<h2 id=\"常用的Python术语\"><a href=\"#常用的Python术语\" class=\"headerlink\" title=\"常用的Python术语\"></a>常用的Python术语</h2><p><strong>模块(module)</strong>:Python中代码可重用性的基本单位：由一些其他代码导入的代码块。 这里涉及到三种类型的模块：纯Python模块（Python modules），扩展模块（extension modules）和包（packages）。</p>\n<p><strong>纯Python模块（Python modules）</strong>：一个用Python编写并包含在一个.py文件中的模块（也可能是关联的.pyc和/或.pyo文件）。 有时被称为“纯模块”。</p>\n<p><strong>扩展模块（extension modules）</strong>：一个用Python实现的低级语言编写的模块：C / C ++ for Python，Java for Jython。 通常包含在单个可动态加载的预编译文件中。 Unix上的Python扩展的共享对象（.so）文件，Windows上的Python扩展的DLL（给定.pyd扩展名）或Jython扩展的Java类文件。 （请注意，目前，Distutils仅处理Python的C / C ++扩展。）</p>\n<p><strong>包（packages）</strong>:包含其他模块的模块; 通常包含在文件系统中的目录中，并通过存在文件<code>__init__.py</code>与其他目录区分开来。</p>\n<p><strong>根包（root packages）</strong>：<br>包的层次结构的根。 （这不是一个包，因为它没有一个<code>__init__.py</code>文件，但我们必须称之为一些）。绝大多数的标准库是根包，许多小的，独立的第三个 不属于较大模块集合的一个模块。 与常规包不同，根包中的模块可以在许多目录中找到：实际上，<code>sys.path</code>中列出的每个目录都向根包提供模块。</p>\n<h2 id=\"Distutils特定术语\"><a href=\"#Distutils特定术语\" class=\"headerlink\" title=\"Distutils特定术语\"></a>Distutils特定术语</h2><p>以下术语更具体地适用于使用<code>Distutils</code>分发<code>Python</code>模块的方面：</p>\n<p><strong>模块分发包</strong>:作为一个可下载的资源一起分发的Python模块的集合，并且要大量安装。一些众所周知的模块分布的例子有数字Python，PyXML，PIL（Python影像库）或mxBase。 （这将被称为包，除了该术语已经在Python上下文中：单个模块分发可能包含零个，一个或多个Python包。）</p>\n<p><strong>纯模块分发包</strong>：一个仅包含纯Python模块和包的模块分发。有时被称为“纯分配”。</p>\n<p><strong>非纯模块分发包</strong>：一个包含至少一个扩展模块的模块分发。有时被称为“非纯分配”。</p>\n<p><strong>根分发包</strong>：源树（或源分发）的顶层目录; setup.py存在的目录。一般来说，setup.py将从此目录运行。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>翻译自<a href=\"https://docs.python.org/2.7/distutils/index.html\" target=\"_blank\" rel=\"noopener\">官方文档</a></p>\n</blockquote>\n<p>本文档从模块开发人员的角度描述了Python Distribution Utilities（“Distutils”），介绍了如何使用Distutils将Python模块和扩展程序提供给更加广泛的使用者，并使得构建/释放/安装机制的开销很少。</p>","more":"<h2 id=\"概念-amp-术语\"><a href=\"#概念-amp-术语\" class=\"headerlink\" title=\"概念&amp;术语\"></a>概念&amp;术语</h2><p>对于模块开发人员和安装第三方模块的用户/管理员来说，使用Distutils是非常简单的。作为一名开发人员，您的责任（当然除了编写可靠的，有详细记录和经过良好测试的代码）是：</p>\n<ul>\n<li>写一个安装脚本（按照惯例为setup.py）</li>\n<li>（可选）写入设置配置文件</li>\n<li>建立一个源码分发包</li>\n<li>（可选）创建一个或多个内置（二进制）分发包</li>\n</ul>\n<p>这些都会在本文档中一一提到。</p>\n<p>并不是所有的模块开发人员都可以访问多种平台，因此总想着他们可以创建大量的内置分发包是不可行的。希望出现一类称为“packagers”的中介机构，以满足这一需求。packagers将采用模块开发人员发布的源代码，将其构建在一个或多个平台上，并发布生成的内置分发包。因此，最流行的平台上的用户将能够以最自然的方式为他们的平台安装大多数流行的Python模块分发包，而无需运行单个安装脚本或编译一行代码。</p>\n<h2 id=\"一个简单实例\"><a href=\"#一个简单实例\" class=\"headerlink\" title=\"一个简单实例\"></a>一个简单实例</h2><p>安装脚本通常非常简单，尽管由Python编写，但是对于可以使用的脚本没有任何限制，可还是要在安装脚本中应该谨慎处理那些重要的操作。 与<code>Autoconf</code>风格的配置脚本不同的是，在构建和安装模块分发包的过程中，安装脚本可能会多次运行。</p>\n<p>如果你想做的只是分发一个包含在<code>foo.py</code>文件中的<code>foo</code>模块，那么你的安装脚本就可以这么简单：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from distutils.core <span class=\"keyword\">import</span> <span class=\"built_in\">setup</span></span><br><span class=\"line\"><span class=\"built_in\">setup</span>(name=<span class=\"string\">'foo'</span>,</span><br><span class=\"line\">      version=<span class=\"string\">'1.0'</span>,</span><br><span class=\"line\">      py_modules=[<span class=\"string\">'foo'</span>],</span><br><span class=\"line\">      )</span><br></pre></td></tr></table></figure></p>\n<p>一些需要注意的地方：</p>\n<ul>\n<li><p>您提供给<code>Distutils</code>的大多数信息都作为关键字参数提供给<code>setup（）</code>函数</p>\n</li>\n<li><p>这些关键字参数分为两类：包元数据（名称，版本号）以及有关软件包内容的信息（在这种情况下是纯<code>Python</code>模块的列表）</p>\n</li>\n<li><p>模块由模块名称指定，而不是文件名（对于包和扩展名也是如此）</p>\n</li>\n<li><p>建议您提供更多元数据，特别是您的名称，电子邮件地址和项目的URL（请参阅编写安装脚本一节）</p>\n</li>\n</ul>\n<p>如果要将源码进行分发，你需要在<code>setup.py</code>写入上述代码，并从命令行处运行：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python setup<span class=\"selector-class\">.py</span> sdist</span><br></pre></td></tr></table></figure>\n<p>对于Windows用户来说，你需要执行：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setup<span class=\"selector-class\">.py</span> sdist</span><br></pre></td></tr></table></figure>\n<p><code>sdist</code>将创建一个存档文件（例如，Unix上的tarball文件，Windows上的ZIP文件），其中包含您的安装脚本<code>setup.py</code>和您的模块<code>foo.py</code>。 归档文件将被命名为<code>foo-1.0.tar.gz（或.zip）</code>，并将打包到目录<code>foo-1.0</code>中。</p>\n<p>如果最终用户希望安装您的foo模块，那么她所要做的就是下载<code>foo-1.0.tar.gz（或.zip）</code>，解压缩，并从<code>foo-1.0</code>目录运行：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python setup<span class=\"selector-class\">.py</span> install</span><br></pre></td></tr></table></figure>\n<p>这将最终将<code>foo.py</code>复制到Python安装中的第三方模块的相应目录。</p>\n<p>这个简单的例子演示了<code>Distutils</code>的一些基本概念。 首先，开发人员和安装人员都有相同的基本用户界面，即安装脚本。 区别在于<code>Distutils</code>使用的命令：<code>sdist</code>命令几乎专门用于模块开发人员，而安装程序更常用于安装程序（尽管大多数开发人员都希望偶尔安装自己的代码）。</p>\n<p>如果你想为用户做一些简单的事情，你可以为他们创建一个或多个内置（二进制）的分发包。 例如，如果您正在Windows机器上运行，并希望为其他Windows用户提供方便，则可以使用<code>bdist_wininst</code>命令创建一个可执行安装程序（这个平台最合适的构建版本的类型）。 例如：<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python setup<span class=\"selector-class\">.py</span> bdist_wininst</span><br></pre></td></tr></table></figure></p>\n<p>这将在当前目录中创建可执行安装程序<code>foo-1.0.win32.exe</code>。</p>\n<p>其他有用的内置分发格式是RPM。 例如，以下命令将创建一个名为<code>foo-1.0.noarch.rpm</code>的RPM文件：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python setup<span class=\"selector-class\">.py</span> bdist_rpm</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>注：bdist_rpm命令使用rpm可执行文件，因此必须在基于RPM的系统上运行，如Red Hat Linux，SuSE Linux或Mandrake Linux。</p>\n</blockquote>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">python</span> setup.<span class=\"keyword\">py</span> bdist --<span class=\"keyword\">help</span>-formats</span><br></pre></td></tr></table></figure>\n<p>你可以通过这条指令来查看运行了什么样的分发格式。</p>\n<h2 id=\"常用的Python术语\"><a href=\"#常用的Python术语\" class=\"headerlink\" title=\"常用的Python术语\"></a>常用的Python术语</h2><p><strong>模块(module)</strong>:Python中代码可重用性的基本单位：由一些其他代码导入的代码块。 这里涉及到三种类型的模块：纯Python模块（Python modules），扩展模块（extension modules）和包（packages）。</p>\n<p><strong>纯Python模块（Python modules）</strong>：一个用Python编写并包含在一个.py文件中的模块（也可能是关联的.pyc和/或.pyo文件）。 有时被称为“纯模块”。</p>\n<p><strong>扩展模块（extension modules）</strong>：一个用Python实现的低级语言编写的模块：C / C ++ for Python，Java for Jython。 通常包含在单个可动态加载的预编译文件中。 Unix上的Python扩展的共享对象（.so）文件，Windows上的Python扩展的DLL（给定.pyd扩展名）或Jython扩展的Java类文件。 （请注意，目前，Distutils仅处理Python的C / C ++扩展。）</p>\n<p><strong>包（packages）</strong>:包含其他模块的模块; 通常包含在文件系统中的目录中，并通过存在文件<code>__init__.py</code>与其他目录区分开来。</p>\n<p><strong>根包（root packages）</strong>：<br>包的层次结构的根。 （这不是一个包，因为它没有一个<code>__init__.py</code>文件，但我们必须称之为一些）。绝大多数的标准库是根包，许多小的，独立的第三个 不属于较大模块集合的一个模块。 与常规包不同，根包中的模块可以在许多目录中找到：实际上，<code>sys.path</code>中列出的每个目录都向根包提供模块。</p>\n<h2 id=\"Distutils特定术语\"><a href=\"#Distutils特定术语\" class=\"headerlink\" title=\"Distutils特定术语\"></a>Distutils特定术语</h2><p>以下术语更具体地适用于使用<code>Distutils</code>分发<code>Python</code>模块的方面：</p>\n<p><strong>模块分发包</strong>:作为一个可下载的资源一起分发的Python模块的集合，并且要大量安装。一些众所周知的模块分布的例子有数字Python，PyXML，PIL（Python影像库）或mxBase。 （这将被称为包，除了该术语已经在Python上下文中：单个模块分发可能包含零个，一个或多个Python包。）</p>\n<p><strong>纯模块分发包</strong>：一个仅包含纯Python模块和包的模块分发。有时被称为“纯分配”。</p>\n<p><strong>非纯模块分发包</strong>：一个包含至少一个扩展模块的模块分发。有时被称为“非纯分配”。</p>\n<p><strong>根分发包</strong>：源树（或源分发）的顶层目录; setup.py存在的目录。一般来说，setup.py将从此目录运行。</p>"},{"title":"python哲学之道","date":"2016-04-20T14:49:22.000Z","_content":"![](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-20/91655427.jpg)\n\n最近在找python相关学习资料的时候，发现了一个好玩的东西。\n\n进入 Python 安装目录:`Python/Lib/idlelib/`，运行 `idle.bat`，然后输入 `import this`，你会看到下面的一段话,也尝试着翻译了一下：\n<!--more-->\n\n### The Zen of Python, by Tim Peters\n\n#### python  哲学之道    Tim Peters\n\n--------------------\n\nBeautiful is better than ugly.\n \n美丽胜于丑陋\n\nExplicit is better than implicit.\n\n明示胜于暗喻\n\nSimple is better than complex.\n\n简明胜于复杂\n\nComplex is better than complicated.\n\n复杂胜于混乱\n\nFlat is better than nested.\n\n扁平胜于嵌套\n\nSparse is better than dense.\n\n间隔胜于紧凑\n\nReadability counts.\n\n可读性极为重要\n\nSpecial cases aren't special enough to break the rules.\n\nAlthough practicality beats purity.\n\n尽管实用性出发，特例也必须遵守规则\n\nErrors should never pass silently.\n\nUnless explicitly silenced.\n\n不要包庇错误，除非你有意为之\n\nIn the face of ambiguity, refuse the temptation to guess.\n\n模棱两可时，不要尝试猜测\n\nThere should be one-- and preferably only one --obvious way to do it.\n\n而应该去找一种，最好是唯一一种明显的方案\n\nAlthough that way may not be obvious at first unless you're Dutch.\n\n\n这显然不容易，除非你是Python之父\n\nNow is better than never.\n\n现在做总好于不做\n\nAlthough never is often better than *right* now.\n\n但不假思索就动手还不如不做\n\nIf the implementation is hard to explain, it's a bad idea.\n\nIf the implementation is easy to explain, it may be a good idea.\n\n如果一个方案难以解释，这一定不是个好方案，反之亦然\n\nNamespaces are one honking great idea -- let's do more of those!\n\n命名空间是一个绝妙的主意，我们应多加利用。\n\n\n\n","source":"_posts/python/python哲学之道.md","raw":"---\ntitle: python哲学之道\ndate: 2016-04-20 22:49:22\ntags:\n- python\ncategories: 有趣\n---\n![](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-20/91655427.jpg)\n\n最近在找python相关学习资料的时候，发现了一个好玩的东西。\n\n进入 Python 安装目录:`Python/Lib/idlelib/`，运行 `idle.bat`，然后输入 `import this`，你会看到下面的一段话,也尝试着翻译了一下：\n<!--more-->\n\n### The Zen of Python, by Tim Peters\n\n#### python  哲学之道    Tim Peters\n\n--------------------\n\nBeautiful is better than ugly.\n \n美丽胜于丑陋\n\nExplicit is better than implicit.\n\n明示胜于暗喻\n\nSimple is better than complex.\n\n简明胜于复杂\n\nComplex is better than complicated.\n\n复杂胜于混乱\n\nFlat is better than nested.\n\n扁平胜于嵌套\n\nSparse is better than dense.\n\n间隔胜于紧凑\n\nReadability counts.\n\n可读性极为重要\n\nSpecial cases aren't special enough to break the rules.\n\nAlthough practicality beats purity.\n\n尽管实用性出发，特例也必须遵守规则\n\nErrors should never pass silently.\n\nUnless explicitly silenced.\n\n不要包庇错误，除非你有意为之\n\nIn the face of ambiguity, refuse the temptation to guess.\n\n模棱两可时，不要尝试猜测\n\nThere should be one-- and preferably only one --obvious way to do it.\n\n而应该去找一种，最好是唯一一种明显的方案\n\nAlthough that way may not be obvious at first unless you're Dutch.\n\n\n这显然不容易，除非你是Python之父\n\nNow is better than never.\n\n现在做总好于不做\n\nAlthough never is often better than *right* now.\n\n但不假思索就动手还不如不做\n\nIf the implementation is hard to explain, it's a bad idea.\n\nIf the implementation is easy to explain, it may be a good idea.\n\n如果一个方案难以解释，这一定不是个好方案，反之亦然\n\nNamespaces are one honking great idea -- let's do more of those!\n\n命名空间是一个绝妙的主意，我们应多加利用。\n\n\n\n","slug":"python/python哲学之道","published":1,"updated":"2019-03-22T14:44:36.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwd001w4l3nx8r80990","content":"<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-20/91655427.jpg\" alt></p>\n<p>最近在找python相关学习资料的时候，发现了一个好玩的东西。</p>\n<p>进入 Python 安装目录:<code>Python/Lib/idlelib/</code>，运行 <code>idle.bat</code>，然后输入 <code>import this</code>，你会看到下面的一段话,也尝试着翻译了一下：<br><a id=\"more\"></a></p>\n<h3 id=\"The-Zen-of-Python-by-Tim-Peters\"><a href=\"#The-Zen-of-Python-by-Tim-Peters\" class=\"headerlink\" title=\"The Zen of Python, by Tim Peters\"></a>The Zen of Python, by Tim Peters</h3><h4 id=\"python-哲学之道-Tim-Peters\"><a href=\"#python-哲学之道-Tim-Peters\" class=\"headerlink\" title=\"python  哲学之道    Tim Peters\"></a>python  哲学之道    Tim Peters</h4><hr>\n<p>Beautiful is better than ugly.</p>\n<p>美丽胜于丑陋</p>\n<p>Explicit is better than implicit.</p>\n<p>明示胜于暗喻</p>\n<p>Simple is better than complex.</p>\n<p>简明胜于复杂</p>\n<p>Complex is better than complicated.</p>\n<p>复杂胜于混乱</p>\n<p>Flat is better than nested.</p>\n<p>扁平胜于嵌套</p>\n<p>Sparse is better than dense.</p>\n<p>间隔胜于紧凑</p>\n<p>Readability counts.</p>\n<p>可读性极为重要</p>\n<p>Special cases aren’t special enough to break the rules.</p>\n<p>Although practicality beats purity.</p>\n<p>尽管实用性出发，特例也必须遵守规则</p>\n<p>Errors should never pass silently.</p>\n<p>Unless explicitly silenced.</p>\n<p>不要包庇错误，除非你有意为之</p>\n<p>In the face of ambiguity, refuse the temptation to guess.</p>\n<p>模棱两可时，不要尝试猜测</p>\n<p>There should be one– and preferably only one –obvious way to do it.</p>\n<p>而应该去找一种，最好是唯一一种明显的方案</p>\n<p>Although that way may not be obvious at first unless you’re Dutch.</p>\n<p>这显然不容易，除非你是Python之父</p>\n<p>Now is better than never.</p>\n<p>现在做总好于不做</p>\n<p>Although never is often better than <em>right</em> now.</p>\n<p>但不假思索就动手还不如不做</p>\n<p>If the implementation is hard to explain, it’s a bad idea.</p>\n<p>If the implementation is easy to explain, it may be a good idea.</p>\n<p>如果一个方案难以解释，这一定不是个好方案，反之亦然</p>\n<p>Namespaces are one honking great idea – let’s do more of those!</p>\n<p>命名空间是一个绝妙的主意，我们应多加利用。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-20/91655427.jpg\" alt></p>\n<p>最近在找python相关学习资料的时候，发现了一个好玩的东西。</p>\n<p>进入 Python 安装目录:<code>Python/Lib/idlelib/</code>，运行 <code>idle.bat</code>，然后输入 <code>import this</code>，你会看到下面的一段话,也尝试着翻译了一下：<br></p>","more":"<p></p>\n<h3 id=\"The-Zen-of-Python-by-Tim-Peters\"><a href=\"#The-Zen-of-Python-by-Tim-Peters\" class=\"headerlink\" title=\"The Zen of Python, by Tim Peters\"></a>The Zen of Python, by Tim Peters</h3><h4 id=\"python-哲学之道-Tim-Peters\"><a href=\"#python-哲学之道-Tim-Peters\" class=\"headerlink\" title=\"python  哲学之道    Tim Peters\"></a>python  哲学之道    Tim Peters</h4><hr>\n<p>Beautiful is better than ugly.</p>\n<p>美丽胜于丑陋</p>\n<p>Explicit is better than implicit.</p>\n<p>明示胜于暗喻</p>\n<p>Simple is better than complex.</p>\n<p>简明胜于复杂</p>\n<p>Complex is better than complicated.</p>\n<p>复杂胜于混乱</p>\n<p>Flat is better than nested.</p>\n<p>扁平胜于嵌套</p>\n<p>Sparse is better than dense.</p>\n<p>间隔胜于紧凑</p>\n<p>Readability counts.</p>\n<p>可读性极为重要</p>\n<p>Special cases aren’t special enough to break the rules.</p>\n<p>Although practicality beats purity.</p>\n<p>尽管实用性出发，特例也必须遵守规则</p>\n<p>Errors should never pass silently.</p>\n<p>Unless explicitly silenced.</p>\n<p>不要包庇错误，除非你有意为之</p>\n<p>In the face of ambiguity, refuse the temptation to guess.</p>\n<p>模棱两可时，不要尝试猜测</p>\n<p>There should be one– and preferably only one –obvious way to do it.</p>\n<p>而应该去找一种，最好是唯一一种明显的方案</p>\n<p>Although that way may not be obvious at first unless you’re Dutch.</p>\n<p>这显然不容易，除非你是Python之父</p>\n<p>Now is better than never.</p>\n<p>现在做总好于不做</p>\n<p>Although never is often better than <em>right</em> now.</p>\n<p>但不假思索就动手还不如不做</p>\n<p>If the implementation is hard to explain, it’s a bad idea.</p>\n<p>If the implementation is easy to explain, it may be a good idea.</p>\n<p>如果一个方案难以解释，这一定不是个好方案，反之亦然</p>\n<p>Namespaces are one honking great idea – let’s do more of those!</p>\n<p>命名空间是一个绝妙的主意，我们应多加利用。</p>"},{"title":"python大闯关(5-6)","date":"2017-11-29T12:51:02.000Z","_content":"继一年前闯到第4关之后就没有动静了,现在重新开始新的征途.\n<!--more-->\n\n## 第5关\n![第5关](http://www.pythonchallenge.com/pc/def/peakhell.jpg)\n第5关之有一张图,下面写着一句 \"pronounce it\",然而,英语极差的我并不知道小山丘怎么发音,hill?\n于是就看起了网页的源码:\n\n```\n<html>\n<head>\n  <title>peak hell</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../style.css\">\n</head>\n<body>\n<center>\n<img src=\"peakhell.jpg\"/>\n<br><font color=\"#c0c0ff\">\npronounce it\n<br>\n<peakhell src=\"banner.p\"/>\n</body>\n</html>\n\n<!-- peak hell sounds familiar ? -->\n\n```\n`peak hell sounds familiar ? `便是切入点了.于是我百度了一下,查到了`pickle`,读音很相似,也是python必不可少的模块之一,\n用于将对象持久化.那么何为持久化?指的便是保持对象，甚至在多次执行同一程序之间也保持对象。\n\n看样子这次是需要我们来将banner.p进行序列化处理.pickle主要有两个函数,dump和load,用于序列化和反序列化.\n```\n__author__ = 'zjbao123'\nimport pickle,re\n\nwith open('banner.p','r') as f:\n    data = pickle.load(f)\n\nprint data\n```\n序列化完毕之后,可以看到输出了一串由元组列表组成的列表:\n```\n[[(' ', 95)], [(' ', 14), ('#', 5), (' ', 70), ('#', 5), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 6), ('#', 3), (' ', 6), ('#', 4), (' ', 3), ('#', 3), (' ', 9), ('#', 3), (' ', 7), ('#', 5), (' ', 3), ('#', 3), (' ', 4), ('#', 5), (' ', 3), ('#', 3), (' ', 10), ('#', 3), (' ', 7), ('#', 4), (' ', 1)], [(' ', 3), ('#', 3), (' ', 3), ('#', 2), (' ', 4), ('#', 4), (' ', 1), ('#', 7), (' ', 5), ('#', 2), (' ', 2), ('#', 3), (' ', 6), ('#', 4), (' ', 1), ('#', 7), (' ', 3), ('#', 4), (' ', 1), ('#', 7), (' ', 5), ('#', 3), (' ', 2), ('#', 3), (' ', 5), ('#', 4), (' ', 1)], [(' ', 2), ('#', 3), (' ', 5), ('#', 3), (' ', 2), ('#', 5), (' ', 4), ('#', 4), (' ', 3), ('#', 3), (' ', 3), ('#', 4), (' ', 4), ('#', 5), (' ', 4), ('#', 4), (' ', 2), ('#', 5), (' ', 4), ('#', 4), (' ', 3), ('#', 3), (' ', 5), ('#', 3), (' ', 3), ('#', 4), (' ', 1)], [(' ', 1), ('#', 3), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 3), ('#', 3), (' ', 4), ('#', 3), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 3), (' ', 6), ('#', 4), (' ', 2), ('#', 4), (' ', 1)], [(' ', 1), ('#', 3), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 10), ('#', 3), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 3), (' ', 7), ('#', 3), (' ', 2), ('#', 4), (' ', 1)], [('#', 4), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 5), ('#', 2), (' ', 3), ('#', 3), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 4), (' ', 7), ('#', 3), (' ', 2), ('#', 4), (' ', 1)], [('#', 4), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 3), ('#', 10), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 14), (' ', 2), ('#', 4), (' ', 1)], [('#', 4), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 3), (' ', 4), ('#', 4), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 4), (' ', 12), ('#', 4), (' ', 1)], [('#', 4), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 4), (' ', 5), ('#', 3), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 4), (' ', 12), ('#', 4), (' ', 1)], [(' ', 1), ('#', 3), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 4), (' ', 5), ('#', 3), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 3), (' ', 12), ('#', 4), (' ', 1)], [(' ', 2), ('#', 3), (' ', 6), ('#', 2), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 3), (' ', 4), ('#', 4), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 3), ('#', 3), (' ', 6), ('#', 2), (' ', 3), ('#', 4), (' ', 1)], [(' ', 3), ('#', 3), (' ', 4), ('#', 2), (' ', 3), ('#', 4), (' ', 5), ('#', 4), (' ', 3), ('#', 11), (' ', 3), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 4), ('#', 3), (' ', 4), ('#', 2), (' ', 4), ('#', 4), (' ', 1)], [(' ', 6), ('#', 3), (' ', 5), ('#', 6), (' ', 4), ('#', 5), (' ', 4), ('#', 2), (' ', 4), ('#', 4), (' ', 1), ('#', 6), (' ', 4), ('#', 11), (' ', 4), ('#', 5), (' ', 6), ('#', 3), (' ', 6), ('#', 6)], [(' ', 95)]]\n\n```\n似乎在告诉你每一个符号所占位的空间,像是一种拼串类的游戏\n```\nfor list in data:\n    print ''.join(tuple[0]*tuple[1] for tuple in list)\n```\n将其占位相乘,即表示重复个数.此时,输出了`channel`,就过关啦!","source":"_posts/python/python大闯关(5-6).md","raw":"---\ntitle: python大闯关(5-6)\ndate: 2017-11-29 20:51:02\ntags:\n- python\ncategories: 总结\n---\n继一年前闯到第4关之后就没有动静了,现在重新开始新的征途.\n<!--more-->\n\n## 第5关\n![第5关](http://www.pythonchallenge.com/pc/def/peakhell.jpg)\n第5关之有一张图,下面写着一句 \"pronounce it\",然而,英语极差的我并不知道小山丘怎么发音,hill?\n于是就看起了网页的源码:\n\n```\n<html>\n<head>\n  <title>peak hell</title>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"../style.css\">\n</head>\n<body>\n<center>\n<img src=\"peakhell.jpg\"/>\n<br><font color=\"#c0c0ff\">\npronounce it\n<br>\n<peakhell src=\"banner.p\"/>\n</body>\n</html>\n\n<!-- peak hell sounds familiar ? -->\n\n```\n`peak hell sounds familiar ? `便是切入点了.于是我百度了一下,查到了`pickle`,读音很相似,也是python必不可少的模块之一,\n用于将对象持久化.那么何为持久化?指的便是保持对象，甚至在多次执行同一程序之间也保持对象。\n\n看样子这次是需要我们来将banner.p进行序列化处理.pickle主要有两个函数,dump和load,用于序列化和反序列化.\n```\n__author__ = 'zjbao123'\nimport pickle,re\n\nwith open('banner.p','r') as f:\n    data = pickle.load(f)\n\nprint data\n```\n序列化完毕之后,可以看到输出了一串由元组列表组成的列表:\n```\n[[(' ', 95)], [(' ', 14), ('#', 5), (' ', 70), ('#', 5), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 15), ('#', 4), (' ', 71), ('#', 4), (' ', 1)], [(' ', 6), ('#', 3), (' ', 6), ('#', 4), (' ', 3), ('#', 3), (' ', 9), ('#', 3), (' ', 7), ('#', 5), (' ', 3), ('#', 3), (' ', 4), ('#', 5), (' ', 3), ('#', 3), (' ', 10), ('#', 3), (' ', 7), ('#', 4), (' ', 1)], [(' ', 3), ('#', 3), (' ', 3), ('#', 2), (' ', 4), ('#', 4), (' ', 1), ('#', 7), (' ', 5), ('#', 2), (' ', 2), ('#', 3), (' ', 6), ('#', 4), (' ', 1), ('#', 7), (' ', 3), ('#', 4), (' ', 1), ('#', 7), (' ', 5), ('#', 3), (' ', 2), ('#', 3), (' ', 5), ('#', 4), (' ', 1)], [(' ', 2), ('#', 3), (' ', 5), ('#', 3), (' ', 2), ('#', 5), (' ', 4), ('#', 4), (' ', 3), ('#', 3), (' ', 3), ('#', 4), (' ', 4), ('#', 5), (' ', 4), ('#', 4), (' ', 2), ('#', 5), (' ', 4), ('#', 4), (' ', 3), ('#', 3), (' ', 5), ('#', 3), (' ', 3), ('#', 4), (' ', 1)], [(' ', 1), ('#', 3), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 3), ('#', 3), (' ', 4), ('#', 3), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 3), (' ', 6), ('#', 4), (' ', 2), ('#', 4), (' ', 1)], [(' ', 1), ('#', 3), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 10), ('#', 3), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 3), (' ', 7), ('#', 3), (' ', 2), ('#', 4), (' ', 1)], [('#', 4), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 5), ('#', 2), (' ', 3), ('#', 3), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 4), (' ', 7), ('#', 3), (' ', 2), ('#', 4), (' ', 1)], [('#', 4), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 3), ('#', 10), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 14), (' ', 2), ('#', 4), (' ', 1)], [('#', 4), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 3), (' ', 4), ('#', 4), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 4), (' ', 12), ('#', 4), (' ', 1)], [('#', 4), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 4), (' ', 5), ('#', 3), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 4), (' ', 12), ('#', 4), (' ', 1)], [(' ', 1), ('#', 3), (' ', 11), ('#', 4), (' ', 5), ('#', 4), (' ', 1), ('#', 4), (' ', 5), ('#', 3), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 3), (' ', 12), ('#', 4), (' ', 1)], [(' ', 2), ('#', 3), (' ', 6), ('#', 2), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 3), (' ', 4), ('#', 4), (' ', 4), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 3), ('#', 3), (' ', 6), ('#', 2), (' ', 3), ('#', 4), (' ', 1)], [(' ', 3), ('#', 3), (' ', 4), ('#', 2), (' ', 3), ('#', 4), (' ', 5), ('#', 4), (' ', 3), ('#', 11), (' ', 3), ('#', 4), (' ', 5), ('#', 4), (' ', 2), ('#', 4), (' ', 5), ('#', 4), (' ', 4), ('#', 3), (' ', 4), ('#', 2), (' ', 4), ('#', 4), (' ', 1)], [(' ', 6), ('#', 3), (' ', 5), ('#', 6), (' ', 4), ('#', 5), (' ', 4), ('#', 2), (' ', 4), ('#', 4), (' ', 1), ('#', 6), (' ', 4), ('#', 11), (' ', 4), ('#', 5), (' ', 6), ('#', 3), (' ', 6), ('#', 6)], [(' ', 95)]]\n\n```\n似乎在告诉你每一个符号所占位的空间,像是一种拼串类的游戏\n```\nfor list in data:\n    print ''.join(tuple[0]*tuple[1] for tuple in list)\n```\n将其占位相乘,即表示重复个数.此时,输出了`channel`,就过关啦!","slug":"python/python大闯关(5-6)","published":1,"updated":"2019-03-22T14:44:36.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwe001y4l3nd7mhk7rs","content":"<p>继一年前闯到第4关之后就没有动静了,现在重新开始新的征途.<br><a id=\"more\"></a></p>\n<h2 id=\"第5关\"><a href=\"#第5关\" class=\"headerlink\" title=\"第5关\"></a>第5关</h2><p><img src=\"http://www.pythonchallenge.com/pc/def/peakhell.jpg\" alt=\"第5关\"><br>第5关之有一张图,下面写着一句 “pronounce it”,然而,英语极差的我并不知道小山丘怎么发音,hill?<br>于是就看起了网页的源码:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>peak hell<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"../style.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">center</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"peakhell.jpg\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">color</span>=<span class=\"string\">\"#c0c0ff\"</span>&gt;</span></span><br><span class=\"line\">pronounce it</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">peakhell</span> <span class=\"attr\">src</span>=<span class=\"string\">\"banner.p\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- peak hell sounds familiar ? --&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>peak hell sounds familiar ?</code>便是切入点了.于是我百度了一下,查到了<code>pickle</code>,读音很相似,也是python必不可少的模块之一,<br>用于将对象持久化.那么何为持久化?指的便是保持对象，甚至在多次执行同一程序之间也保持对象。</p>\n<p>看样子这次是需要我们来将banner.p进行序列化处理.pickle主要有两个函数,dump和load,用于序列化和反序列化.<br><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pickle,re</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'banner.p'</span>,<span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    <span class=\"keyword\">data</span> = pickle.load(f)</span><br><span class=\"line\"></span><br><span class=\"line\">print <span class=\"keyword\">data</span></span><br></pre></td></tr></table></figure></p>\n<p>序列化完毕之后,可以看到输出了一串由元组列表组成的列表:<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[(' ', <span class=\"number\">95</span>)], [(' ', <span class=\"number\">14</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">70</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">9</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">7</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">10</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">7</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">7</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">7</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">7</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">10</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">7</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">7</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">10</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">14</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">12</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">12</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">12</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">11</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">6</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">6</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">11</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">6</span>)], [(' ', <span class=\"number\">95</span>)]]</span><br></pre></td></tr></table></figure></p>\n<p>似乎在告诉你每一个符号所占位的空间,像是一种拼串类的游戏<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">    print <span class=\"string\">''</span>.join(<span class=\"keyword\">tuple</span>[<span class=\"number\">0</span>]*<span class=\"keyword\">tuple</span>[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> <span class=\"keyword\">tuple</span> <span class=\"keyword\">in</span> list)</span><br></pre></td></tr></table></figure></p>\n<p>将其占位相乘,即表示重复个数.此时,输出了<code>channel</code>,就过关啦!</p>\n","site":{"data":{}},"excerpt":"<p>继一年前闯到第4关之后就没有动静了,现在重新开始新的征途.<br></p>","more":"<p></p>\n<h2 id=\"第5关\"><a href=\"#第5关\" class=\"headerlink\" title=\"第5关\"></a>第5关</h2><p><img src=\"http://www.pythonchallenge.com/pc/def/peakhell.jpg\" alt=\"第5关\"><br>第5关之有一张图,下面写着一句 “pronounce it”,然而,英语极差的我并不知道小山丘怎么发音,hill?<br>于是就看起了网页的源码:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">title</span>&gt;</span>peak hell<span class=\"tag\">&lt;/<span class=\"name\">title</span>&gt;</span></span><br><span class=\"line\">  <span class=\"tag\">&lt;<span class=\"name\">link</span> <span class=\"attr\">rel</span>=<span class=\"string\">\"stylesheet\"</span> <span class=\"attr\">type</span>=<span class=\"string\">\"text/css\"</span> <span class=\"attr\">href</span>=<span class=\"string\">\"../style.css\"</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">head</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">center</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">img</span> <span class=\"attr\">src</span>=<span class=\"string\">\"peakhell.jpg\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span><span class=\"tag\">&lt;<span class=\"name\">font</span> <span class=\"attr\">color</span>=<span class=\"string\">\"#c0c0ff\"</span>&gt;</span></span><br><span class=\"line\">pronounce it</span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">br</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">peakhell</span> <span class=\"attr\">src</span>=<span class=\"string\">\"banner.p\"</span>/&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">body</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">html</span>&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">&lt;!-- peak hell sounds familiar ? --&gt;</span></span><br></pre></td></tr></table></figure>\n<p><code>peak hell sounds familiar ?</code>便是切入点了.于是我百度了一下,查到了<code>pickle</code>,读音很相似,也是python必不可少的模块之一,<br>用于将对象持久化.那么何为持久化?指的便是保持对象，甚至在多次执行同一程序之间也保持对象。</p>\n<p>看样子这次是需要我们来将banner.p进行序列化处理.pickle主要有两个函数,dump和load,用于序列化和反序列化.<br><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> pickle,re</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'banner.p'</span>,<span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    <span class=\"keyword\">data</span> = pickle.load(f)</span><br><span class=\"line\"></span><br><span class=\"line\">print <span class=\"keyword\">data</span></span><br></pre></td></tr></table></figure></p>\n<p>序列化完毕之后,可以看到输出了一串由元组列表组成的列表:<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[(' ', <span class=\"number\">95</span>)], [(' ', <span class=\"number\">14</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">70</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">15</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">71</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">9</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">7</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">10</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">7</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">7</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">7</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">7</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">10</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">7</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">7</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">10</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">14</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">12</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">12</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">11</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">12</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">11</span>), (' ', <span class=\"number\">3</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">2</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>)], [(' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">5</span>), ('#', <span class=\"number\">6</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">2</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">4</span>), (' ', <span class=\"number\">1</span>), ('#', <span class=\"number\">6</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">11</span>), (' ', <span class=\"number\">4</span>), ('#', <span class=\"number\">5</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">3</span>), (' ', <span class=\"number\">6</span>), ('#', <span class=\"number\">6</span>)], [(' ', <span class=\"number\">95</span>)]]</span><br></pre></td></tr></table></figure></p>\n<p>似乎在告诉你每一个符号所占位的空间,像是一种拼串类的游戏<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> list <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">    print <span class=\"string\">''</span>.join(<span class=\"keyword\">tuple</span>[<span class=\"number\">0</span>]*<span class=\"keyword\">tuple</span>[<span class=\"number\">1</span>] <span class=\"keyword\">for</span> <span class=\"keyword\">tuple</span> <span class=\"keyword\">in</span> list)</span><br></pre></td></tr></table></figure></p>\n<p>将其占位相乘,即表示重复个数.此时,输出了<code>channel</code>,就过关啦!</p>"},{"title":"python爬虫入门（1）","date":"2016-10-16T07:51:02.000Z","_content":"## 前言\n\n之前只是在学习Python的基本语法，并没有实战。时间所迫，就业所需，兴趣所驱，一边学习一边总结吧。又是一条漫长的打怪(bug)升级之路。\n<!--more-->\n## 什么是爬虫\n\n### 爬虫的定义\n\n把互联网比喻成一个蜘蛛网，那么Spider就是在网上爬来爬去的蜘蛛。\n网络蜘蛛是通过网页的链接地址来寻找网页的。\n从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址，\n然后通过这些链接地址寻找下一个网页，每次看到一个可能需要爬的新链接，你就先查查你脑子里是不是已经去过这个页面地址。如果去过，那就别去了。这样一直循环下去，直到把这个网站所有的网页都抓取完为止。\n如果把整个互联网当成一个网站，那么网络蜘蛛就可以用这个原理把互联网上所有的网页都抓取下来。\n这样看来，网络爬虫就是一个爬行程序，一个抓取网页的程序。\n网络爬虫的基本操作是抓取网页。\n\n### 爬虫流程\n\n* “所有网站皆可爬”\n\n* 框架不变：**发送请求——获得页面——解析页面——下载内容——储存内容**\n\n### 认识URI和URL\n\nURI：Web上可用的每种资源 -HTML文档、图像、视频片段、程序等 - 由一个通用资源标识符（Uniform Resource Identifier, 简称\"URI\"）进行定位。\n\nURL是Uniform Resource Locator的缩写，译为“统一资源定位符”。\n\nURL是URI命名机制的一个子集。\n\nURL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，所以，是绝对的，而通常说的relative URL，则是针对另一个absolute URL，本质上还是绝对的。\n\n这里的相对绝对指的是是否有`协议:`这部分的内容，即访问该路径的方式。\n\n示例：`协议://域名/目录a/目录b/文件c`\n\n## Urllib库的使用\n\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\nimport urllib2\nimport urllib\n\nuser_agent = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36'\nheaders = {'User-Agent': user_agent, 'referer': 'https://www.zhihu.com/'}\nvalues = {\"username\": \"zjbao123\", \"password\": \"***\"}\ndata = urllib.urlencode(values)\nurl = 'http://passport.csdn.net/account/login'\n# 向服务器端发送请求\nrequest = urllib2.Request(url, data, headers)\n# 响应服务器的请求\nresponse = urllib2.urlopen(request)\nprint response.read()\n```\n首先导入urllib2库。\n\n* `urlopen(url, data, timeout)`\n第一个参数url即为URL\n第二个参数data是访问URL时要传送的数据,默认为None\n第三个timeout是设置超时时间。默认为`socket._GLOBAL_DEFAULT_TIMEOUT`\n\n* `urlencode(query, doseq=0)`\nEncode a sequence of two-element tuples or dictionary into a URL query string.\n将两个元素的元组或者是字典编码为URL查询字符串。\n\n我这边传入的是一个`request`请求，然后用`response`来响应请求。通过`request`来传入所需的url和data。这边所需的data要通过`urllib.urlencode`来进行编码，输出一个URL查询字符串才可以传入。\n这里使用的`POST`的方式进行传输。\n\n### `POST`和`GET`\n网页的数据传送分为`POST`和`GET`两种方式。\n\n`GET`方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。\n\n而`POST`则不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了，大家可以酌情选择。\n\n### 设置Headers\n\n有些网站不会同意程序直接用上面的方式进行访问，如果识别有问题，那么站点根本不会响应，所以为了完全模拟浏览器的工作，所以，我们需要设置一些`Headers`的属性。\n\n如果要查看你的`Headers`相应的属性，在浏览器界面按下`F12`-> `network` -> 选择一个文件 -> `Headers`\n\n`user_agent`就是请求的身份，如果没有写入请求身份，那么服务器不一定会响应，所以可以在`headers`中设置`agent`,另外，我们还有对付”反盗链”的方式，对付防盗链，服务器会识别`headers`中的`referer`是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在`headers`中加入`referer`。\n\n同上面的方法，在传送请求时把headers传入Request参数里，这样就能应付防盗链了。\n\n另外headers的一些属性，下面的需要特别注意一下：\n\n>User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求\n>Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。\n>application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用\n>application/json ： 在 JSON RPC 调用时使用\n>application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用\n>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务\n\n### Proxy（代理）的设置\n\nurllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。假如一个网站它会检测某一段时间某个IP 的访问次数，如果访问次数过多，它会禁止你的访问。所以你可以设置一些代理服务器来帮助你做工作，每隔一段时间换一个代理，网站君都不知道是谁在捣鬼了，这酸爽！\n\n代理的设置用法：\n```\nenable_proxy = True\nproxy_handler = urllib2.ProxyHandler({\"http\" : 'http://some-proxy.com:8080'})\nnull_proxy_handler = urllib2.ProxyHandler({})\nif enable_proxy:\n    opener = urllib2.build_opener(proxy_handler)\nelse:\n    opener = urllib2.build_opener(null_proxy_handler)\nurllib2.install_opener(opener)\n\n```\n\n### 使用 HTTP 的`PUT`和`DELETE`方法\n\nhttp协议有六种请求方法，get,head,put,delete,post,options，我们有时候需要用到PUT方式或者DELETE方式请求。\n\n>PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。\n>\n>DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。\n\n```\nimport urllib2\nrequest = urllib2.Request(uri, data=data)\nrequest.get_method = lambda: 'PUT' # or 'DELETE'\nresponse = urllib2.urlopen(request)\n```\n\n### 使用DebugLog\n\n可以通过下面的方法把 Debug Log 打开，这样收发包的内容就会在屏幕上打印出来，方便调试，这个也不太常用，仅提一下。\n```\nimport urllib2\nhttpHandler = urllib2.HTTPHandler(debuglevel=1)\nhttpsHandler = urllib2.HTTPSHandler(debuglevel=1)\nopener = urllib2.build_opener(httpHandler, httpsHandler)\nurllib2.install_opener(opener)\nresponse = urllib2.urlopen('http://www.baidu.com')\n```\n\n------------------------------------------------------------\n\n## 参考\n\n[如何入门 Python 爬虫？-知乎](https://www.zhihu.com/question/20899988)\n\n[Python爬虫学习系列教程](http://cuiqingcai.com/1052.html)\n\n\n","source":"_posts/python/python爬虫入门(1).md","raw":"---\ntitle: python爬虫入门（1）\ndate: 2016-10-16 15:51:02\ntags:\n- python\n- 爬虫\ncategories: 总结\n---\n## 前言\n\n之前只是在学习Python的基本语法，并没有实战。时间所迫，就业所需，兴趣所驱，一边学习一边总结吧。又是一条漫长的打怪(bug)升级之路。\n<!--more-->\n## 什么是爬虫\n\n### 爬虫的定义\n\n把互联网比喻成一个蜘蛛网，那么Spider就是在网上爬来爬去的蜘蛛。\n网络蜘蛛是通过网页的链接地址来寻找网页的。\n从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址，\n然后通过这些链接地址寻找下一个网页，每次看到一个可能需要爬的新链接，你就先查查你脑子里是不是已经去过这个页面地址。如果去过，那就别去了。这样一直循环下去，直到把这个网站所有的网页都抓取完为止。\n如果把整个互联网当成一个网站，那么网络蜘蛛就可以用这个原理把互联网上所有的网页都抓取下来。\n这样看来，网络爬虫就是一个爬行程序，一个抓取网页的程序。\n网络爬虫的基本操作是抓取网页。\n\n### 爬虫流程\n\n* “所有网站皆可爬”\n\n* 框架不变：**发送请求——获得页面——解析页面——下载内容——储存内容**\n\n### 认识URI和URL\n\nURI：Web上可用的每种资源 -HTML文档、图像、视频片段、程序等 - 由一个通用资源标识符（Uniform Resource Identifier, 简称\"URI\"）进行定位。\n\nURL是Uniform Resource Locator的缩写，译为“统一资源定位符”。\n\nURL是URI命名机制的一个子集。\n\nURL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，所以，是绝对的，而通常说的relative URL，则是针对另一个absolute URL，本质上还是绝对的。\n\n这里的相对绝对指的是是否有`协议:`这部分的内容，即访问该路径的方式。\n\n示例：`协议://域名/目录a/目录b/文件c`\n\n## Urllib库的使用\n\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\nimport urllib2\nimport urllib\n\nuser_agent = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36'\nheaders = {'User-Agent': user_agent, 'referer': 'https://www.zhihu.com/'}\nvalues = {\"username\": \"zjbao123\", \"password\": \"***\"}\ndata = urllib.urlencode(values)\nurl = 'http://passport.csdn.net/account/login'\n# 向服务器端发送请求\nrequest = urllib2.Request(url, data, headers)\n# 响应服务器的请求\nresponse = urllib2.urlopen(request)\nprint response.read()\n```\n首先导入urllib2库。\n\n* `urlopen(url, data, timeout)`\n第一个参数url即为URL\n第二个参数data是访问URL时要传送的数据,默认为None\n第三个timeout是设置超时时间。默认为`socket._GLOBAL_DEFAULT_TIMEOUT`\n\n* `urlencode(query, doseq=0)`\nEncode a sequence of two-element tuples or dictionary into a URL query string.\n将两个元素的元组或者是字典编码为URL查询字符串。\n\n我这边传入的是一个`request`请求，然后用`response`来响应请求。通过`request`来传入所需的url和data。这边所需的data要通过`urllib.urlencode`来进行编码，输出一个URL查询字符串才可以传入。\n这里使用的`POST`的方式进行传输。\n\n### `POST`和`GET`\n网页的数据传送分为`POST`和`GET`两种方式。\n\n`GET`方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。\n\n而`POST`则不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了，大家可以酌情选择。\n\n### 设置Headers\n\n有些网站不会同意程序直接用上面的方式进行访问，如果识别有问题，那么站点根本不会响应，所以为了完全模拟浏览器的工作，所以，我们需要设置一些`Headers`的属性。\n\n如果要查看你的`Headers`相应的属性，在浏览器界面按下`F12`-> `network` -> 选择一个文件 -> `Headers`\n\n`user_agent`就是请求的身份，如果没有写入请求身份，那么服务器不一定会响应，所以可以在`headers`中设置`agent`,另外，我们还有对付”反盗链”的方式，对付防盗链，服务器会识别`headers`中的`referer`是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在`headers`中加入`referer`。\n\n同上面的方法，在传送请求时把headers传入Request参数里，这样就能应付防盗链了。\n\n另外headers的一些属性，下面的需要特别注意一下：\n\n>User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求\n>Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。\n>application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用\n>application/json ： 在 JSON RPC 调用时使用\n>application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用\n>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务\n\n### Proxy（代理）的设置\n\nurllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。假如一个网站它会检测某一段时间某个IP 的访问次数，如果访问次数过多，它会禁止你的访问。所以你可以设置一些代理服务器来帮助你做工作，每隔一段时间换一个代理，网站君都不知道是谁在捣鬼了，这酸爽！\n\n代理的设置用法：\n```\nenable_proxy = True\nproxy_handler = urllib2.ProxyHandler({\"http\" : 'http://some-proxy.com:8080'})\nnull_proxy_handler = urllib2.ProxyHandler({})\nif enable_proxy:\n    opener = urllib2.build_opener(proxy_handler)\nelse:\n    opener = urllib2.build_opener(null_proxy_handler)\nurllib2.install_opener(opener)\n\n```\n\n### 使用 HTTP 的`PUT`和`DELETE`方法\n\nhttp协议有六种请求方法，get,head,put,delete,post,options，我们有时候需要用到PUT方式或者DELETE方式请求。\n\n>PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。\n>\n>DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。\n\n```\nimport urllib2\nrequest = urllib2.Request(uri, data=data)\nrequest.get_method = lambda: 'PUT' # or 'DELETE'\nresponse = urllib2.urlopen(request)\n```\n\n### 使用DebugLog\n\n可以通过下面的方法把 Debug Log 打开，这样收发包的内容就会在屏幕上打印出来，方便调试，这个也不太常用，仅提一下。\n```\nimport urllib2\nhttpHandler = urllib2.HTTPHandler(debuglevel=1)\nhttpsHandler = urllib2.HTTPSHandler(debuglevel=1)\nopener = urllib2.build_opener(httpHandler, httpsHandler)\nurllib2.install_opener(opener)\nresponse = urllib2.urlopen('http://www.baidu.com')\n```\n\n------------------------------------------------------------\n\n## 参考\n\n[如何入门 Python 爬虫？-知乎](https://www.zhihu.com/question/20899988)\n\n[Python爬虫学习系列教程](http://cuiqingcai.com/1052.html)\n\n\n","slug":"python/python爬虫入门(1)","published":1,"updated":"2019-03-22T14:44:36.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwf00224l3ne8ge9ogj","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前只是在学习Python的基本语法，并没有实战。时间所迫，就业所需，兴趣所驱，一边学习一边总结吧。又是一条漫长的打怪(bug)升级之路。<br><a id=\"more\"></a></p>\n<h2 id=\"什么是爬虫\"><a href=\"#什么是爬虫\" class=\"headerlink\" title=\"什么是爬虫\"></a>什么是爬虫</h2><h3 id=\"爬虫的定义\"><a href=\"#爬虫的定义\" class=\"headerlink\" title=\"爬虫的定义\"></a>爬虫的定义</h3><p>把互联网比喻成一个蜘蛛网，那么Spider就是在网上爬来爬去的蜘蛛。<br>网络蜘蛛是通过网页的链接地址来寻找网页的。<br>从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址，<br>然后通过这些链接地址寻找下一个网页，每次看到一个可能需要爬的新链接，你就先查查你脑子里是不是已经去过这个页面地址。如果去过，那就别去了。这样一直循环下去，直到把这个网站所有的网页都抓取完为止。<br>如果把整个互联网当成一个网站，那么网络蜘蛛就可以用这个原理把互联网上所有的网页都抓取下来。<br>这样看来，网络爬虫就是一个爬行程序，一个抓取网页的程序。<br>网络爬虫的基本操作是抓取网页。</p>\n<h3 id=\"爬虫流程\"><a href=\"#爬虫流程\" class=\"headerlink\" title=\"爬虫流程\"></a>爬虫流程</h3><ul>\n<li><p>“所有网站皆可爬”</p>\n</li>\n<li><p>框架不变：<strong>发送请求——获得页面——解析页面——下载内容——储存内容</strong></p>\n</li>\n</ul>\n<h3 id=\"认识URI和URL\"><a href=\"#认识URI和URL\" class=\"headerlink\" title=\"认识URI和URL\"></a>认识URI和URL</h3><p>URI：Web上可用的每种资源 -HTML文档、图像、视频片段、程序等 - 由一个通用资源标识符（Uniform Resource Identifier, 简称”URI”）进行定位。</p>\n<p>URL是Uniform Resource Locator的缩写，译为“统一资源定位符”。</p>\n<p>URL是URI命名机制的一个子集。</p>\n<p>URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，所以，是绝对的，而通常说的relative URL，则是针对另一个absolute URL，本质上还是绝对的。</p>\n<p>这里的相对绝对指的是是否有<code>协议:</code>这部分的内容，即访问该路径的方式。</p>\n<p>示例：<code>协议://域名/目录a/目录b/文件c</code></p>\n<h2 id=\"Urllib库的使用\"><a href=\"#Urllib库的使用\" class=\"headerlink\" title=\"Urllib库的使用\"></a>Urllib库的使用</h2><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = 'zjbao123'</span><br><span class=\"line\">import urllib2</span><br><span class=\"line\">import urllib</span><br><span class=\"line\"></span><br><span class=\"line\">user_agent = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36'</span><br><span class=\"line\">headers = &#123;'User-Agent': user_agent, 'referer': 'https://www.zhihu.com/'&#125;</span><br><span class=\"line\">values = &#123;<span class=\"string\">\"username\"</span>: <span class=\"string\">\"zjbao123\"</span>, <span class=\"string\">\"password\"</span>: <span class=\"string\">\"***\"</span>&#125;</span><br><span class=\"line\">data = urllib.urlencode(values)</span><br><span class=\"line\">url = 'http://passport.csdn.net/account/login'</span><br><span class=\"line\"><span class=\"comment\"># 向服务器端发送请求</span></span><br><span class=\"line\">request = urllib2.Request(url, data, headers)</span><br><span class=\"line\"><span class=\"comment\"># 响应服务器的请求</span></span><br><span class=\"line\">response = urllib2.urlopen(request)</span><br><span class=\"line\">print response.read()</span><br></pre></td></tr></table></figure>\n<p>首先导入urllib2库。</p>\n<ul>\n<li><p><code>urlopen(url, data, timeout)</code><br>第一个参数url即为URL<br>第二个参数data是访问URL时要传送的数据,默认为None<br>第三个timeout是设置超时时间。默认为<code>socket._GLOBAL_DEFAULT_TIMEOUT</code></p>\n</li>\n<li><p><code>urlencode(query, doseq=0)</code><br>Encode a sequence of two-element tuples or dictionary into a URL query string.<br>将两个元素的元组或者是字典编码为URL查询字符串。</p>\n</li>\n</ul>\n<p>我这边传入的是一个<code>request</code>请求，然后用<code>response</code>来响应请求。通过<code>request</code>来传入所需的url和data。这边所需的data要通过<code>urllib.urlencode</code>来进行编码，输出一个URL查询字符串才可以传入。<br>这里使用的<code>POST</code>的方式进行传输。</p>\n<h3 id=\"POST和GET\"><a href=\"#POST和GET\" class=\"headerlink\" title=\"POST和GET\"></a><code>POST</code>和<code>GET</code></h3><p>网页的数据传送分为<code>POST</code>和<code>GET</code>两种方式。</p>\n<p><code>GET</code>方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。</p>\n<p>而<code>POST</code>则不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了，大家可以酌情选择。</p>\n<h3 id=\"设置Headers\"><a href=\"#设置Headers\" class=\"headerlink\" title=\"设置Headers\"></a>设置Headers</h3><p>有些网站不会同意程序直接用上面的方式进行访问，如果识别有问题，那么站点根本不会响应，所以为了完全模拟浏览器的工作，所以，我们需要设置一些<code>Headers</code>的属性。</p>\n<p>如果要查看你的<code>Headers</code>相应的属性，在浏览器界面按下<code>F12</code>-&gt; <code>network</code> -&gt; 选择一个文件 -&gt; <code>Headers</code></p>\n<p><code>user_agent</code>就是请求的身份，如果没有写入请求身份，那么服务器不一定会响应，所以可以在<code>headers</code>中设置<code>agent</code>,另外，我们还有对付”反盗链”的方式，对付防盗链，服务器会识别<code>headers</code>中的<code>referer</code>是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在<code>headers</code>中加入<code>referer</code>。</p>\n<p>同上面的方法，在传送请求时把headers传入Request参数里，这样就能应付防盗链了。</p>\n<p>另外headers的一些属性，下面的需要特别注意一下：</p>\n<blockquote>\n<p>User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求<br>Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。<br>application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用<br>application/json ： 在 JSON RPC 调用时使用<br>application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用<br>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</p>\n</blockquote>\n<h3 id=\"Proxy（代理）的设置\"><a href=\"#Proxy（代理）的设置\" class=\"headerlink\" title=\"Proxy（代理）的设置\"></a>Proxy（代理）的设置</h3><p>urllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。假如一个网站它会检测某一段时间某个IP 的访问次数，如果访问次数过多，它会禁止你的访问。所以你可以设置一些代理服务器来帮助你做工作，每隔一段时间换一个代理，网站君都不知道是谁在捣鬼了，这酸爽！</p>\n<p>代理的设置用法：<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enable_proxy = True</span><br><span class=\"line\">proxy_handler = urllib2.ProxyHandler(&#123;<span class=\"string\">\"http\"</span> : 'http://some-proxy.com:8080'&#125;)</span><br><span class=\"line\">null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)</span><br><span class=\"line\">if enable_proxy:</span><br><span class=\"line\">    opener = urllib2.build_opener(proxy_handler)</span><br><span class=\"line\"><span class=\"section\">else:</span></span><br><span class=\"line\">    opener = urllib2.build_opener(null_proxy_handler)</span><br><span class=\"line\">urllib2.install_opener(opener)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-HTTP-的PUT和DELETE方法\"><a href=\"#使用-HTTP-的PUT和DELETE方法\" class=\"headerlink\" title=\"使用 HTTP 的PUT和DELETE方法\"></a>使用 HTTP 的<code>PUT</code>和<code>DELETE</code>方法</h3><p>http协议有六种请求方法，get,head,put,delete,post,options，我们有时候需要用到PUT方式或者DELETE方式请求。</p>\n<blockquote>\n<p>PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</p>\n<p>DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</p>\n</blockquote>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> urllib2</span><br><span class=\"line\">request = urllib2.Request(uri, <span class=\"keyword\">data</span>=<span class=\"keyword\">data</span>)</span><br><span class=\"line\">request.get_method = lambda: <span class=\"string\">'PUT'</span> # <span class=\"built_in\">or</span> <span class=\"string\">'DELETE'</span></span><br><span class=\"line\">response = urllib2.urlopen(request)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用DebugLog\"><a href=\"#使用DebugLog\" class=\"headerlink\" title=\"使用DebugLog\"></a>使用DebugLog</h3><p>可以通过下面的方法把 Debug Log 打开，这样收发包的内容就会在屏幕上打印出来，方便调试，这个也不太常用，仅提一下。<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib2</span><br><span class=\"line\">httpHandler = urllib2.HTTPHandler(debuglevel=1)</span><br><span class=\"line\">httpsHandler = urllib2.HTTPSHandler(debuglevel=1)</span><br><span class=\"line\">opener = urllib2.build_opener(httpHandler, httpsHandler)</span><br><span class=\"line\">urllib2.install_opener(opener)</span><br><span class=\"line\">response = urllib2.urlopen('http://www.baidu.com')</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.zhihu.com/question/20899988\" target=\"_blank\" rel=\"noopener\">如何入门 Python 爬虫？-知乎</a></p>\n<p><a href=\"http://cuiqingcai.com/1052.html\" target=\"_blank\" rel=\"noopener\">Python爬虫学习系列教程</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>之前只是在学习Python的基本语法，并没有实战。时间所迫，就业所需，兴趣所驱，一边学习一边总结吧。又是一条漫长的打怪(bug)升级之路。<br></p>","more":"<p></p>\n<h2 id=\"什么是爬虫\"><a href=\"#什么是爬虫\" class=\"headerlink\" title=\"什么是爬虫\"></a>什么是爬虫</h2><h3 id=\"爬虫的定义\"><a href=\"#爬虫的定义\" class=\"headerlink\" title=\"爬虫的定义\"></a>爬虫的定义</h3><p>把互联网比喻成一个蜘蛛网，那么Spider就是在网上爬来爬去的蜘蛛。<br>网络蜘蛛是通过网页的链接地址来寻找网页的。<br>从网站某一个页面（通常是首页）开始，读取网页的内容，找到在网页中的其它链接地址，<br>然后通过这些链接地址寻找下一个网页，每次看到一个可能需要爬的新链接，你就先查查你脑子里是不是已经去过这个页面地址。如果去过，那就别去了。这样一直循环下去，直到把这个网站所有的网页都抓取完为止。<br>如果把整个互联网当成一个网站，那么网络蜘蛛就可以用这个原理把互联网上所有的网页都抓取下来。<br>这样看来，网络爬虫就是一个爬行程序，一个抓取网页的程序。<br>网络爬虫的基本操作是抓取网页。</p>\n<h3 id=\"爬虫流程\"><a href=\"#爬虫流程\" class=\"headerlink\" title=\"爬虫流程\"></a>爬虫流程</h3><ul>\n<li><p>“所有网站皆可爬”</p>\n</li>\n<li><p>框架不变：<strong>发送请求——获得页面——解析页面——下载内容——储存内容</strong></p>\n</li>\n</ul>\n<h3 id=\"认识URI和URL\"><a href=\"#认识URI和URL\" class=\"headerlink\" title=\"认识URI和URL\"></a>认识URI和URL</h3><p>URI：Web上可用的每种资源 -HTML文档、图像、视频片段、程序等 - 由一个通用资源标识符（Uniform Resource Identifier, 简称”URI”）进行定位。</p>\n<p>URL是Uniform Resource Locator的缩写，译为“统一资源定位符”。</p>\n<p>URL是URI命名机制的一个子集。</p>\n<p>URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。URI是一种语义上的抽象概念，可以是绝对的，也可以是相对的，而URL则必须提供足够的信息来定位，所以，是绝对的，而通常说的relative URL，则是针对另一个absolute URL，本质上还是绝对的。</p>\n<p>这里的相对绝对指的是是否有<code>协议:</code>这部分的内容，即访问该路径的方式。</p>\n<p>示例：<code>协议://域名/目录a/目录b/文件c</code></p>\n<h2 id=\"Urllib库的使用\"><a href=\"#Urllib库的使用\" class=\"headerlink\" title=\"Urllib库的使用\"></a>Urllib库的使用</h2><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = 'zjbao123'</span><br><span class=\"line\">import urllib2</span><br><span class=\"line\">import urllib</span><br><span class=\"line\"></span><br><span class=\"line\">user_agent = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.110 Safari/537.36'</span><br><span class=\"line\">headers = &#123;'User-Agent': user_agent, 'referer': 'https://www.zhihu.com/'&#125;</span><br><span class=\"line\">values = &#123;<span class=\"string\">\"username\"</span>: <span class=\"string\">\"zjbao123\"</span>, <span class=\"string\">\"password\"</span>: <span class=\"string\">\"***\"</span>&#125;</span><br><span class=\"line\">data = urllib.urlencode(values)</span><br><span class=\"line\">url = 'http://passport.csdn.net/account/login'</span><br><span class=\"line\"><span class=\"comment\"># 向服务器端发送请求</span></span><br><span class=\"line\">request = urllib2.Request(url, data, headers)</span><br><span class=\"line\"><span class=\"comment\"># 响应服务器的请求</span></span><br><span class=\"line\">response = urllib2.urlopen(request)</span><br><span class=\"line\">print response.read()</span><br></pre></td></tr></table></figure>\n<p>首先导入urllib2库。</p>\n<ul>\n<li><p><code>urlopen(url, data, timeout)</code><br>第一个参数url即为URL<br>第二个参数data是访问URL时要传送的数据,默认为None<br>第三个timeout是设置超时时间。默认为<code>socket._GLOBAL_DEFAULT_TIMEOUT</code></p>\n</li>\n<li><p><code>urlencode(query, doseq=0)</code><br>Encode a sequence of two-element tuples or dictionary into a URL query string.<br>将两个元素的元组或者是字典编码为URL查询字符串。</p>\n</li>\n</ul>\n<p>我这边传入的是一个<code>request</code>请求，然后用<code>response</code>来响应请求。通过<code>request</code>来传入所需的url和data。这边所需的data要通过<code>urllib.urlencode</code>来进行编码，输出一个URL查询字符串才可以传入。<br>这里使用的<code>POST</code>的方式进行传输。</p>\n<h3 id=\"POST和GET\"><a href=\"#POST和GET\" class=\"headerlink\" title=\"POST和GET\"></a><code>POST</code>和<code>GET</code></h3><p>网页的数据传送分为<code>POST</code>和<code>GET</code>两种方式。</p>\n<p><code>GET</code>方式是直接以链接形式访问，链接中包含了所有的参数，当然如果包含了密码的话是一种不安全的选择，不过你可以直观地看到自己提交了什么内容。</p>\n<p>而<code>POST</code>则不会在网址上显示所有的参数，不过如果你想直接查看提交了什么就不太方便了，大家可以酌情选择。</p>\n<h3 id=\"设置Headers\"><a href=\"#设置Headers\" class=\"headerlink\" title=\"设置Headers\"></a>设置Headers</h3><p>有些网站不会同意程序直接用上面的方式进行访问，如果识别有问题，那么站点根本不会响应，所以为了完全模拟浏览器的工作，所以，我们需要设置一些<code>Headers</code>的属性。</p>\n<p>如果要查看你的<code>Headers</code>相应的属性，在浏览器界面按下<code>F12</code>-&gt; <code>network</code> -&gt; 选择一个文件 -&gt; <code>Headers</code></p>\n<p><code>user_agent</code>就是请求的身份，如果没有写入请求身份，那么服务器不一定会响应，所以可以在<code>headers</code>中设置<code>agent</code>,另外，我们还有对付”反盗链”的方式，对付防盗链，服务器会识别<code>headers</code>中的<code>referer</code>是不是它自己，如果不是，有的服务器不会响应，所以我们还可以在<code>headers</code>中加入<code>referer</code>。</p>\n<p>同上面的方法，在传送请求时把headers传入Request参数里，这样就能应付防盗链了。</p>\n<p>另外headers的一些属性，下面的需要特别注意一下：</p>\n<blockquote>\n<p>User-Agent : 有些服务器或 Proxy 会通过该值来判断是否是浏览器发出的请求<br>Content-Type : 在使用 REST 接口时，服务器会检查该值，用来确定 HTTP Body 中的内容该怎样解析。<br>application/xml ： 在 XML RPC，如 RESTful/SOAP 调用时使用<br>application/json ： 在 JSON RPC 调用时使用<br>application/x-www-form-urlencoded ： 浏览器提交 Web 表单时使用<br>在使用服务器提供的 RESTful 或 SOAP 服务时， Content-Type 设置错误会导致服务器拒绝服务</p>\n</blockquote>\n<h3 id=\"Proxy（代理）的设置\"><a href=\"#Proxy（代理）的设置\" class=\"headerlink\" title=\"Proxy（代理）的设置\"></a>Proxy（代理）的设置</h3><p>urllib2 默认会使用环境变量 http_proxy 来设置 HTTP Proxy。假如一个网站它会检测某一段时间某个IP 的访问次数，如果访问次数过多，它会禁止你的访问。所以你可以设置一些代理服务器来帮助你做工作，每隔一段时间换一个代理，网站君都不知道是谁在捣鬼了，这酸爽！</p>\n<p>代理的设置用法：<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">enable_proxy = True</span><br><span class=\"line\">proxy_handler = urllib2.ProxyHandler(&#123;<span class=\"string\">\"http\"</span> : 'http://some-proxy.com:8080'&#125;)</span><br><span class=\"line\">null_proxy_handler = urllib2.ProxyHandler(&#123;&#125;)</span><br><span class=\"line\">if enable_proxy:</span><br><span class=\"line\">    opener = urllib2.build_opener(proxy_handler)</span><br><span class=\"line\"><span class=\"section\">else:</span></span><br><span class=\"line\">    opener = urllib2.build_opener(null_proxy_handler)</span><br><span class=\"line\">urllib2.install_opener(opener)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"使用-HTTP-的PUT和DELETE方法\"><a href=\"#使用-HTTP-的PUT和DELETE方法\" class=\"headerlink\" title=\"使用 HTTP 的PUT和DELETE方法\"></a>使用 HTTP 的<code>PUT</code>和<code>DELETE</code>方法</h3><p>http协议有六种请求方法，get,head,put,delete,post,options，我们有时候需要用到PUT方式或者DELETE方式请求。</p>\n<blockquote>\n<p>PUT：这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。</p>\n<p>DELETE：删除某一个资源。基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。</p>\n</blockquote>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> urllib2</span><br><span class=\"line\">request = urllib2.Request(uri, <span class=\"keyword\">data</span>=<span class=\"keyword\">data</span>)</span><br><span class=\"line\">request.get_method = lambda: <span class=\"string\">'PUT'</span> # <span class=\"built_in\">or</span> <span class=\"string\">'DELETE'</span></span><br><span class=\"line\">response = urllib2.urlopen(request)</span><br></pre></td></tr></table></figure>\n<h3 id=\"使用DebugLog\"><a href=\"#使用DebugLog\" class=\"headerlink\" title=\"使用DebugLog\"></a>使用DebugLog</h3><p>可以通过下面的方法把 Debug Log 打开，这样收发包的内容就会在屏幕上打印出来，方便调试，这个也不太常用，仅提一下。<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib2</span><br><span class=\"line\">httpHandler = urllib2.HTTPHandler(debuglevel=1)</span><br><span class=\"line\">httpsHandler = urllib2.HTTPSHandler(debuglevel=1)</span><br><span class=\"line\">opener = urllib2.build_opener(httpHandler, httpsHandler)</span><br><span class=\"line\">urllib2.install_opener(opener)</span><br><span class=\"line\">response = urllib2.urlopen('http://www.baidu.com')</span><br></pre></td></tr></table></figure></p>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.zhihu.com/question/20899988\" target=\"_blank\" rel=\"noopener\">如何入门 Python 爬虫？-知乎</a></p>\n<p><a href=\"http://cuiqingcai.com/1052.html\" target=\"_blank\" rel=\"noopener\">Python爬虫学习系列教程</a></p>"},{"title":"【python】random模块小结","date":"2016-10-16T05:14:50.000Z","_content":"尽管`help（random）`一下就能出来模块内各个函数的用法，不过我也想深入一步看一下`random`的具体用法。\n<!-- more -->\n`random`是用于生成随机数的，我们可以利用它随机生成数字或者选择字符串。\n\n不过真的是一个很厉害的模块，里面有随机正太分布，帕累托分布，高斯分布，β分布，γ分布，三角分布，威布尔分布等等各种函数，这些就不细讲了，用到再去看就行，`门在哪知道就好`，不过我这边列出一些比较常用的。\n\n* `random.random()` \n\n用来随机生成一个0到1之间的浮点数，包括零。\n\n* `randint(a, b)`\n\n用来生成[a,b]之间的随意整数，包括两个边界值。\n\n* `random.uniform(a,b)`\n用来生成[a,b]之间的随意浮点数，包括两个边界值。\n\n* `choice(seq)` \n从一个非空序列选出随机一个元素。seq泛指list，tuple，字符串等\n\n* `randrange(start, stop[, step = 1])`\n这个就是random和range函数的合二为一了。但注意，range用法有变。\n\n\n以上是一些常规想得到的用法。一下介绍一些不是很想得到的用法。\n\n* `random.shuffle(x[,random]) `\n正如函数名所表示的意思，`shuffle`，洗牌，将一个列表中的元素打乱。\n\n* `random.sample(sequence,k) `\n\nsample，样品，从有序列表中选k个作为一个片段返回。\n\n\n* `random.seed ( [x] )`\n`x`:改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。\n\n一般计算机的随机数都是伪随机数，以一个真随机数（种子）作为初始条件，然后用一定的算法不停迭代产生随机数。\n\n","source":"_posts/python/【python】random模块.md","raw":"---\ntitle: 【python】random模块小结\ndate: 2016-10-16 13:14:50\ntags: \n- python\ncategories: 总结\n---\n尽管`help（random）`一下就能出来模块内各个函数的用法，不过我也想深入一步看一下`random`的具体用法。\n<!-- more -->\n`random`是用于生成随机数的，我们可以利用它随机生成数字或者选择字符串。\n\n不过真的是一个很厉害的模块，里面有随机正太分布，帕累托分布，高斯分布，β分布，γ分布，三角分布，威布尔分布等等各种函数，这些就不细讲了，用到再去看就行，`门在哪知道就好`，不过我这边列出一些比较常用的。\n\n* `random.random()` \n\n用来随机生成一个0到1之间的浮点数，包括零。\n\n* `randint(a, b)`\n\n用来生成[a,b]之间的随意整数，包括两个边界值。\n\n* `random.uniform(a,b)`\n用来生成[a,b]之间的随意浮点数，包括两个边界值。\n\n* `choice(seq)` \n从一个非空序列选出随机一个元素。seq泛指list，tuple，字符串等\n\n* `randrange(start, stop[, step = 1])`\n这个就是random和range函数的合二为一了。但注意，range用法有变。\n\n\n以上是一些常规想得到的用法。一下介绍一些不是很想得到的用法。\n\n* `random.shuffle(x[,random]) `\n正如函数名所表示的意思，`shuffle`，洗牌，将一个列表中的元素打乱。\n\n* `random.sample(sequence,k) `\n\nsample，样品，从有序列表中选k个作为一个片段返回。\n\n\n* `random.seed ( [x] )`\n`x`:改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。\n\n一般计算机的随机数都是伪随机数，以一个真随机数（种子）作为初始条件，然后用一定的算法不停迭代产生随机数。\n\n","slug":"python/【python】random模块","published":1,"updated":"2019-03-22T14:44:36.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwg00254l3nnnlpksyj","content":"<p>尽管<code>help（random）</code>一下就能出来模块内各个函数的用法，不过我也想深入一步看一下<code>random</code>的具体用法。<br><a id=\"more\"></a><br><code>random</code>是用于生成随机数的，我们可以利用它随机生成数字或者选择字符串。</p>\n<p>不过真的是一个很厉害的模块，里面有随机正太分布，帕累托分布，高斯分布，β分布，γ分布，三角分布，威布尔分布等等各种函数，这些就不细讲了，用到再去看就行，<code>门在哪知道就好</code>，不过我这边列出一些比较常用的。</p>\n<ul>\n<li><code>random.random()</code> </li>\n</ul>\n<p>用来随机生成一个0到1之间的浮点数，包括零。</p>\n<ul>\n<li><code>randint(a, b)</code></li>\n</ul>\n<p>用来生成[a,b]之间的随意整数，包括两个边界值。</p>\n<ul>\n<li><p><code>random.uniform(a,b)</code><br>用来生成[a,b]之间的随意浮点数，包括两个边界值。</p>\n</li>\n<li><p><code>choice(seq)</code><br>从一个非空序列选出随机一个元素。seq泛指list，tuple，字符串等</p>\n</li>\n<li><p><code>randrange(start, stop[, step = 1])</code><br>这个就是random和range函数的合二为一了。但注意，range用法有变。</p>\n</li>\n</ul>\n<p>以上是一些常规想得到的用法。一下介绍一些不是很想得到的用法。</p>\n<ul>\n<li><p><code>random.shuffle(x[,random])</code><br>正如函数名所表示的意思，<code>shuffle</code>，洗牌，将一个列表中的元素打乱。</p>\n</li>\n<li><p><code>random.sample(sequence,k)</code></p>\n</li>\n</ul>\n<p>sample，样品，从有序列表中选k个作为一个片段返回。</p>\n<ul>\n<li><code>random.seed ( [x] )</code><br><code>x</code>:改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</li>\n</ul>\n<p>一般计算机的随机数都是伪随机数，以一个真随机数（种子）作为初始条件，然后用一定的算法不停迭代产生随机数。</p>\n","site":{"data":{}},"excerpt":"<p>尽管<code>help（random）</code>一下就能出来模块内各个函数的用法，不过我也想深入一步看一下<code>random</code>的具体用法。<br></p>","more":"<br><code>random</code>是用于生成随机数的，我们可以利用它随机生成数字或者选择字符串。<p></p>\n<p>不过真的是一个很厉害的模块，里面有随机正太分布，帕累托分布，高斯分布，β分布，γ分布，三角分布，威布尔分布等等各种函数，这些就不细讲了，用到再去看就行，<code>门在哪知道就好</code>，不过我这边列出一些比较常用的。</p>\n<ul>\n<li><code>random.random()</code> </li>\n</ul>\n<p>用来随机生成一个0到1之间的浮点数，包括零。</p>\n<ul>\n<li><code>randint(a, b)</code></li>\n</ul>\n<p>用来生成[a,b]之间的随意整数，包括两个边界值。</p>\n<ul>\n<li><p><code>random.uniform(a,b)</code><br>用来生成[a,b]之间的随意浮点数，包括两个边界值。</p>\n</li>\n<li><p><code>choice(seq)</code><br>从一个非空序列选出随机一个元素。seq泛指list，tuple，字符串等</p>\n</li>\n<li><p><code>randrange(start, stop[, step = 1])</code><br>这个就是random和range函数的合二为一了。但注意，range用法有变。</p>\n</li>\n</ul>\n<p>以上是一些常规想得到的用法。一下介绍一些不是很想得到的用法。</p>\n<ul>\n<li><p><code>random.shuffle(x[,random])</code><br>正如函数名所表示的意思，<code>shuffle</code>，洗牌，将一个列表中的元素打乱。</p>\n</li>\n<li><p><code>random.sample(sequence,k)</code></p>\n</li>\n</ul>\n<p>sample，样品，从有序列表中选k个作为一个片段返回。</p>\n<ul>\n<li><code>random.seed ( [x] )</code><br><code>x</code>:改变随机数生成器的种子seed。如果你不了解其原理，你不必特别去设定seed，Python会帮你选择seed。</li>\n</ul>\n<p>一般计算机的随机数都是伪随机数，以一个真随机数（种子）作为初始条件，然后用一定的算法不停迭代产生随机数。</p>"},{"title":"python爬虫入门(3)","date":"2016-10-17T13:10:02.000Z","_content":"\n## 正则表达式\n\n这个在之前的博客有讲过，今天就当是复习吧。\n\n正则表达式可以把前面获得到的页面提取整理出来。\n\n>它是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。\n\n<!-- more -->\n\n正则表达式的大致匹配过程是：\n1.依次拿出表达式和文本中的字符比较，\n2.如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。\n3.如果表达式中有量词或边界，这个过程会稍微有一些不同。\n\n正则表达式的匹配规则：\n![匹配规则](http://images.cnblogs.com/cnblogs_com/huxi/Windows-Live-Writer/Python_10A67/pyre_ebb9ce1c-e5e8-4219-a8ae-7ee620d5f9f1.png)\n\n### re模块\nPython 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下：\n\n* `compile(pattern, flags=0)`\n\n 将正则表达式字符串形式编译为一个Pattern实例。\n ```\n pattern = re.compile(r'hello')\n ```\n\n 字符串前加r是为了防止字符串转义。 在参数中我们传入了原生字符串对象，通过compile方法编译生成一个pattern对象，然后我们利用这个对象来进行进一步的匹配。\n\n* `escape(pattern)`\n\n 避开所有非字母数字的字符模式，即虽然含有特殊字符，不需要用反斜杠注释。\n\n* `findall(pattern, string, flags=0)`\n\n 返回一个非重叠的字符串匹配列表。\n 列表中每个元素的值的类型，取决于你的正则表达式的写法:\n\t* 元组tuple：当你的正则表达式中有（带捕获的）分组（简单可理解为有括号）而tuple的值，是各个group的值所组合出来的\n\t* 字符串：当你的正则表达式中没有捕获的组（不分组，或非捕获分组）\n\t字符串的值，是你的正则表达式所匹配到的单个完整的字符串\n```\nimport re\n \npattern = re.compile(r'\\d+')\nprint re.findall(pattern,'one1two2three3four4')\n\n### 输出 \n# ['1', '2', '3', '4']\n```\n* `finditer(pattern, string, flags=0)`\n 返回一个顺序访问每一个匹配结果的迭代器，每个匹配结果返回一个`match`对象。\n 用一个`for`循环来接收，然后用`group`来接收。\n\n* `match(pattern, string, flags=0)`\n 这个方法将会从string（我们要匹配的字符串）的开头开始，尝试匹配pattern，一直向后匹配，当匹配pattern成功时，返回一个`match`对象，同时匹配终止，不再对string向后匹配。如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。两个结果均表示匹配失败。\n\n* `search(pattern, string, flags=0)`\n 在字符串中查找，是否能匹配正则表达式。返回`match`对象，如果不能匹配返回None。\n 和`match`区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。\n ```\n\timport re\n\t \n\t# 将正则表达式编译成Pattern对象\n\tpattern = re.compile(r'world')\n\t# 使用search()查找匹配的子串，不存在能匹配的子串时将返回None\n\t# 这个例子中使用match()无法成功匹配\n\tmatch = re.search(pattern,'hello world!')\n\tif match:\n\t    # 使用Match获得分组信息\n\t    print match.group()\n\t### 输出 ###\n\t# world\n ```\n* `purge()`\n 清除正则缓存。\n\n* `split(pattern, string, maxsplit=0, flags=0)`\n 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。\n\n* `sub(pattern, repl, string, count=0, flags=0)`\n 使用repl替换string中每一个匹配的子串后返回替换后的字符串。\n \n rep1有两种形式：\n 当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\n 当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。\n\n count用于指定最多替换次数，不指定时全部替换。\n ```\n\timport re\n\n\tpattern = re.compile(r'(\\w+) (\\w+)')\n\ts = 'i say, hello world!'\n\n\tprint re.sub(pattern,r'\\2 \\1', s)\n\n\tdef func(m):\n\t    return m.group(1).title() + ' ' + m.group(2).title()\n\n\tprint re.sub(pattern,func, s)\n\n\t### output ###\n\t# say i, world hello!\n\t# I Say, Hello World!\n ```\n\n* `subn(pattern, repl, string, count=0, flags=0)`\n 与re.sub方法作用一样，但返回的是包含新字符串和替换执行次数的两元组。\n\n\n另外，参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如`re.I | re.M`。\n\n可选值有：\n> • re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）\n • re.M(全拼：MULTILINE): 多行模式，改变'^'和'$'的行为（参见上图）\n • re.S(全拼：DOTALL): 点任意匹配模式，改变'.'的行为\n • re.L(全拼：LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定\n • re.U(全拼：UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性\n • re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。\n\n### match对象\n\n下面我们说一下关于match对象的的属性和方法。\n\n我们在调用re模块的方法时，得到了match对象result，之后我们输出结果用的是result.group()，这个是什么意思呢？\n\nMatch对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。\n\n#### 属性\n1.string: 匹配时使用的文本。\n\n2.re: 匹配时使用的Pattern对象。\n\n3.pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。\n\n4.endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。\n\n5.lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。\n\n6.lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。\n\n#### 方法\n1.group([group1, …]):\n获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。\n\n2.groups([default]):\n以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。\n\n3.groupdict([default]):\n返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。\n\n4.start([group]):\n返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。\n\n5.end([group]):\n返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。\n\n6.span([group]):\n返回(start(group), end(group))。\n\n7.expand(template):\n将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，只能使用\\g0。","source":"_posts/python/python爬虫入门(3).md","raw":"---\ntitle: python爬虫入门(3)\ndate: 2016-10-17 21:10:02\ntags:\n- python\n- 爬虫\ncategories: 总结\n---\n\n## 正则表达式\n\n这个在之前的博客有讲过，今天就当是复习吧。\n\n正则表达式可以把前面获得到的页面提取整理出来。\n\n>它是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。\n\n<!-- more -->\n\n正则表达式的大致匹配过程是：\n1.依次拿出表达式和文本中的字符比较，\n2.如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。\n3.如果表达式中有量词或边界，这个过程会稍微有一些不同。\n\n正则表达式的匹配规则：\n![匹配规则](http://images.cnblogs.com/cnblogs_com/huxi/Windows-Live-Writer/Python_10A67/pyre_ebb9ce1c-e5e8-4219-a8ae-7ee620d5f9f1.png)\n\n### re模块\nPython 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下：\n\n* `compile(pattern, flags=0)`\n\n 将正则表达式字符串形式编译为一个Pattern实例。\n ```\n pattern = re.compile(r'hello')\n ```\n\n 字符串前加r是为了防止字符串转义。 在参数中我们传入了原生字符串对象，通过compile方法编译生成一个pattern对象，然后我们利用这个对象来进行进一步的匹配。\n\n* `escape(pattern)`\n\n 避开所有非字母数字的字符模式，即虽然含有特殊字符，不需要用反斜杠注释。\n\n* `findall(pattern, string, flags=0)`\n\n 返回一个非重叠的字符串匹配列表。\n 列表中每个元素的值的类型，取决于你的正则表达式的写法:\n\t* 元组tuple：当你的正则表达式中有（带捕获的）分组（简单可理解为有括号）而tuple的值，是各个group的值所组合出来的\n\t* 字符串：当你的正则表达式中没有捕获的组（不分组，或非捕获分组）\n\t字符串的值，是你的正则表达式所匹配到的单个完整的字符串\n```\nimport re\n \npattern = re.compile(r'\\d+')\nprint re.findall(pattern,'one1two2three3four4')\n\n### 输出 \n# ['1', '2', '3', '4']\n```\n* `finditer(pattern, string, flags=0)`\n 返回一个顺序访问每一个匹配结果的迭代器，每个匹配结果返回一个`match`对象。\n 用一个`for`循环来接收，然后用`group`来接收。\n\n* `match(pattern, string, flags=0)`\n 这个方法将会从string（我们要匹配的字符串）的开头开始，尝试匹配pattern，一直向后匹配，当匹配pattern成功时，返回一个`match`对象，同时匹配终止，不再对string向后匹配。如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。两个结果均表示匹配失败。\n\n* `search(pattern, string, flags=0)`\n 在字符串中查找，是否能匹配正则表达式。返回`match`对象，如果不能匹配返回None。\n 和`match`区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。\n ```\n\timport re\n\t \n\t# 将正则表达式编译成Pattern对象\n\tpattern = re.compile(r'world')\n\t# 使用search()查找匹配的子串，不存在能匹配的子串时将返回None\n\t# 这个例子中使用match()无法成功匹配\n\tmatch = re.search(pattern,'hello world!')\n\tif match:\n\t    # 使用Match获得分组信息\n\t    print match.group()\n\t### 输出 ###\n\t# world\n ```\n* `purge()`\n 清除正则缓存。\n\n* `split(pattern, string, maxsplit=0, flags=0)`\n 按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。\n\n* `sub(pattern, repl, string, count=0, flags=0)`\n 使用repl替换string中每一个匹配的子串后返回替换后的字符串。\n \n rep1有两种形式：\n 当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\n 当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。\n\n count用于指定最多替换次数，不指定时全部替换。\n ```\n\timport re\n\n\tpattern = re.compile(r'(\\w+) (\\w+)')\n\ts = 'i say, hello world!'\n\n\tprint re.sub(pattern,r'\\2 \\1', s)\n\n\tdef func(m):\n\t    return m.group(1).title() + ' ' + m.group(2).title()\n\n\tprint re.sub(pattern,func, s)\n\n\t### output ###\n\t# say i, world hello!\n\t# I Say, Hello World!\n ```\n\n* `subn(pattern, repl, string, count=0, flags=0)`\n 与re.sub方法作用一样，但返回的是包含新字符串和替换执行次数的两元组。\n\n\n另外，参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如`re.I | re.M`。\n\n可选值有：\n> • re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）\n • re.M(全拼：MULTILINE): 多行模式，改变'^'和'$'的行为（参见上图）\n • re.S(全拼：DOTALL): 点任意匹配模式，改变'.'的行为\n • re.L(全拼：LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定\n • re.U(全拼：UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性\n • re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。\n\n### match对象\n\n下面我们说一下关于match对象的的属性和方法。\n\n我们在调用re模块的方法时，得到了match对象result，之后我们输出结果用的是result.group()，这个是什么意思呢？\n\nMatch对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。\n\n#### 属性\n1.string: 匹配时使用的文本。\n\n2.re: 匹配时使用的Pattern对象。\n\n3.pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。\n\n4.endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。\n\n5.lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。\n\n6.lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。\n\n#### 方法\n1.group([group1, …]):\n获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。\n\n2.groups([default]):\n以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。\n\n3.groupdict([default]):\n返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。\n\n4.start([group]):\n返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。\n\n5.end([group]):\n返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。\n\n6.span([group]):\n返回(start(group), end(group))。\n\n7.expand(template):\n将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，只能使用\\g0。","slug":"python/python爬虫入门(3)","published":1,"updated":"2019-03-22T14:44:36.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwi00294l3n7wbfks1o","content":"<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>这个在之前的博客有讲过，今天就当是复习吧。</p>\n<p>正则表达式可以把前面获得到的页面提取整理出来。</p>\n<blockquote>\n<p>它是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>正则表达式的大致匹配过程是：<br>1.依次拿出表达式和文本中的字符比较，<br>2.如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。<br>3.如果表达式中有量词或边界，这个过程会稍微有一些不同。</p>\n<p>正则表达式的匹配规则：<br><img src=\"http://images.cnblogs.com/cnblogs_com/huxi/Windows-Live-Writer/Python_10A67/pyre_ebb9ce1c-e5e8-4219-a8ae-7ee620d5f9f1.png\" alt=\"匹配规则\"></p>\n<h3 id=\"re模块\"><a href=\"#re模块\" class=\"headerlink\" title=\"re模块\"></a>re模块</h3><p>Python 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下：</p>\n<ul>\n<li><p><code>compile(pattern, flags=0)</code></p>\n<p>将正则表达式字符串形式编译为一个Pattern实例。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pattern = re.compile(<span class=\"string\">r'hello'</span>)</span><br></pre></td></tr></table></figure>\n<p>字符串前加r是为了防止字符串转义。 在参数中我们传入了原生字符串对象，通过compile方法编译生成一个pattern对象，然后我们利用这个对象来进行进一步的匹配。</p>\n</li>\n<li><p><code>escape(pattern)</code></p>\n<p>避开所有非字母数字的字符模式，即虽然含有特殊字符，不需要用反斜杠注释。</p>\n</li>\n<li><p><code>findall(pattern, string, flags=0)</code></p>\n<p>返回一个非重叠的字符串匹配列表。<br>列表中每个元素的值的类型，取决于你的正则表达式的写法:</p>\n<ul>\n<li>元组tuple：当你的正则表达式中有（带捕获的）分组（简单可理解为有括号）而tuple的值，是各个group的值所组合出来的</li>\n<li>字符串：当你的正则表达式中没有捕获的组（不分组，或非捕获分组）<br>字符串的值，是你的正则表达式所匹配到的单个完整的字符串<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">pattern = re.compile(<span class=\"string\">r'\\d+'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> re.findall(pattern,<span class=\"string\">'one1two2three3four4'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 输出 </span></span><br><span class=\"line\"><span class=\"comment\"># ['1', '2', '3', '4']</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><code>finditer(pattern, string, flags=0)</code><br>返回一个顺序访问每一个匹配结果的迭代器，每个匹配结果返回一个<code>match</code>对象。<br>用一个<code>for</code>循环来接收，然后用<code>group</code>来接收。</p>\n</li>\n<li><p><code>match(pattern, string, flags=0)</code><br>这个方法将会从string（我们要匹配的字符串）的开头开始，尝试匹配pattern，一直向后匹配，当匹配pattern成功时，返回一个<code>match</code>对象，同时匹配终止，不再对string向后匹配。如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。两个结果均表示匹配失败。</p>\n</li>\n<li><p><code>search(pattern, string, flags=0)</code><br>在字符串中查找，是否能匹配正则表达式。返回<code>match</code>对象，如果不能匹配返回None。<br>和<code>match</code>区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 将正则表达式编译成Pattern对象</span></span><br><span class=\"line\">pattern = re.compile(<span class=\"string\">r'world'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 使用search()查找匹配的子串，不存在能匹配的子串时将返回None</span></span><br><span class=\"line\"><span class=\"comment\"># 这个例子中使用match()无法成功匹配</span></span><br><span class=\"line\">match = re.search(pattern,<span class=\"string\">'hello world!'</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> match:</span><br><span class=\"line\">    <span class=\"comment\"># 使用Match获得分组信息</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> match.group()</span><br><span class=\"line\"><span class=\"comment\">### 输出 ###</span></span><br><span class=\"line\"><span class=\"comment\"># world</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>purge()</code><br>清除正则缓存。</p>\n</li>\n<li><p><code>split(pattern, string, maxsplit=0, flags=0)</code><br>按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。</p>\n</li>\n<li><p><code>sub(pattern, repl, string, count=0, flags=0)</code><br>使用repl替换string中每一个匹配的子串后返回替换后的字符串。</p>\n<p>rep1有两种形式：<br>当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。<br>当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。</p>\n<p>count用于指定最多替换次数，不指定时全部替换。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">pattern = re.compile(<span class=\"string\">r'(\\w+) (\\w+)'</span>)</span><br><span class=\"line\">s = <span class=\"string\">'i say, hello world!'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> re.sub(pattern,<span class=\"string\">r'\\2 \\1'</span>, s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(m)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.group(<span class=\"number\">1</span>).title() + <span class=\"string\">' '</span> + m.group(<span class=\"number\">2</span>).title()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> re.sub(pattern,func, s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### output ###</span></span><br><span class=\"line\"><span class=\"comment\"># say i, world hello!</span></span><br><span class=\"line\"><span class=\"comment\"># I Say, Hello World!</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>subn(pattern, repl, string, count=0, flags=0)</code><br>与re.sub方法作用一样，但返回的是包含新字符串和替换执行次数的两元组。</p>\n</li>\n</ul>\n<p>另外，参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如<code>re.I | re.M</code>。</p>\n<p>可选值有：</p>\n<blockquote>\n<p>• re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）<br> • re.M(全拼：MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）<br> • re.S(全拼：DOTALL): 点任意匹配模式，改变’.’的行为<br> • re.L(全拼：LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定<br> • re.U(全拼：UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性<br> • re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。</p>\n</blockquote>\n<h3 id=\"match对象\"><a href=\"#match对象\" class=\"headerlink\" title=\"match对象\"></a>match对象</h3><p>下面我们说一下关于match对象的的属性和方法。</p>\n<p>我们在调用re模块的方法时，得到了match对象result，之后我们输出结果用的是result.group()，这个是什么意思呢？</p>\n<p>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</p>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>1.string: 匹配时使用的文本。</p>\n<p>2.re: 匹配时使用的Pattern对象。</p>\n<p>3.pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</p>\n<p>4.endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</p>\n<p>5.lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。</p>\n<p>6.lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。</p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>1.group([group1, …]):<br>获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。</p>\n<p>2.groups([default]):<br>以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。</p>\n<p>3.groupdict([default]):<br>返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。</p>\n<p>4.start([group]):<br>返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。</p>\n<p>5.end([group]):<br>返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。</p>\n<p>6.span([group]):<br>返回(start(group), end(group))。</p>\n<p>7.expand(template):<br>将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，只能使用\\g0。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>这个在之前的博客有讲过，今天就当是复习吧。</p>\n<p>正则表达式可以把前面获得到的页面提取整理出来。</p>\n<blockquote>\n<p>它是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。</p>\n</blockquote>","more":"<p>正则表达式的大致匹配过程是：<br>1.依次拿出表达式和文本中的字符比较，<br>2.如果每一个字符都能匹配，则匹配成功；一旦有匹配不成功的字符则匹配失败。<br>3.如果表达式中有量词或边界，这个过程会稍微有一些不同。</p>\n<p>正则表达式的匹配规则：<br><img src=\"http://images.cnblogs.com/cnblogs_com/huxi/Windows-Live-Writer/Python_10A67/pyre_ebb9ce1c-e5e8-4219-a8ae-7ee620d5f9f1.png\" alt=\"匹配规则\"></p>\n<h3 id=\"re模块\"><a href=\"#re模块\" class=\"headerlink\" title=\"re模块\"></a>re模块</h3><p>Python 自带了re模块，它提供了对正则表达式的支持。主要用到的方法列举如下：</p>\n<ul>\n<li><p><code>compile(pattern, flags=0)</code></p>\n<p>将正则表达式字符串形式编译为一个Pattern实例。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pattern = re.compile(<span class=\"string\">r'hello'</span>)</span><br></pre></td></tr></table></figure>\n<p>字符串前加r是为了防止字符串转义。 在参数中我们传入了原生字符串对象，通过compile方法编译生成一个pattern对象，然后我们利用这个对象来进行进一步的匹配。</p>\n</li>\n<li><p><code>escape(pattern)</code></p>\n<p>避开所有非字母数字的字符模式，即虽然含有特殊字符，不需要用反斜杠注释。</p>\n</li>\n<li><p><code>findall(pattern, string, flags=0)</code></p>\n<p>返回一个非重叠的字符串匹配列表。<br>列表中每个元素的值的类型，取决于你的正则表达式的写法:</p>\n<ul>\n<li>元组tuple：当你的正则表达式中有（带捕获的）分组（简单可理解为有括号）而tuple的值，是各个group的值所组合出来的</li>\n<li>字符串：当你的正则表达式中没有捕获的组（不分组，或非捕获分组）<br>字符串的值，是你的正则表达式所匹配到的单个完整的字符串<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\">pattern = re.compile(<span class=\"string\">r'\\d+'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> re.findall(pattern,<span class=\"string\">'one1two2three3four4'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### 输出 </span></span><br><span class=\"line\"><span class=\"comment\"># ['1', '2', '3', '4']</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p><code>finditer(pattern, string, flags=0)</code><br>返回一个顺序访问每一个匹配结果的迭代器，每个匹配结果返回一个<code>match</code>对象。<br>用一个<code>for</code>循环来接收，然后用<code>group</code>来接收。</p>\n</li>\n<li><p><code>match(pattern, string, flags=0)</code><br>这个方法将会从string（我们要匹配的字符串）的开头开始，尝试匹配pattern，一直向后匹配，当匹配pattern成功时，返回一个<code>match</code>对象，同时匹配终止，不再对string向后匹配。如果遇到无法匹配的字符，立即返回None，如果匹配未结束已经到达string的末尾，也会返回None。两个结果均表示匹配失败。</p>\n</li>\n<li><p><code>search(pattern, string, flags=0)</code><br>在字符串中查找，是否能匹配正则表达式。返回<code>match</code>对象，如果不能匹配返回None。<br>和<code>match</code>区别在于match()函数只检测re是不是在string的开始位置匹配，search()会扫描整个string查找匹配，match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回None。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 将正则表达式编译成Pattern对象</span></span><br><span class=\"line\">pattern = re.compile(<span class=\"string\">r'world'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 使用search()查找匹配的子串，不存在能匹配的子串时将返回None</span></span><br><span class=\"line\"><span class=\"comment\"># 这个例子中使用match()无法成功匹配</span></span><br><span class=\"line\">match = re.search(pattern,<span class=\"string\">'hello world!'</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> match:</span><br><span class=\"line\">    <span class=\"comment\"># 使用Match获得分组信息</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> match.group()</span><br><span class=\"line\"><span class=\"comment\">### 输出 ###</span></span><br><span class=\"line\"><span class=\"comment\"># world</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>purge()</code><br>清除正则缓存。</p>\n</li>\n<li><p><code>split(pattern, string, maxsplit=0, flags=0)</code><br>按照能够匹配的子串将string分割后返回列表。maxsplit用于指定最大分割次数，不指定将全部分割。</p>\n</li>\n<li><p><code>sub(pattern, repl, string, count=0, flags=0)</code><br>使用repl替换string中每一个匹配的子串后返回替换后的字符串。</p>\n<p>rep1有两种形式：<br>当repl是一个字符串时，可以使用\\id或\\g、\\g引用分组，但不能使用编号0。<br>当repl是一个方法时，这个方法应当只接受一个参数（Match对象），并返回一个字符串用于替换（返回的字符串中不能再引用分组）。</p>\n<p>count用于指定最多替换次数，不指定时全部替换。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> re</span><br><span class=\"line\"></span><br><span class=\"line\">pattern = re.compile(<span class=\"string\">r'(\\w+) (\\w+)'</span>)</span><br><span class=\"line\">s = <span class=\"string\">'i say, hello world!'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> re.sub(pattern,<span class=\"string\">r'\\2 \\1'</span>, s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">func</span><span class=\"params\">(m)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> m.group(<span class=\"number\">1</span>).title() + <span class=\"string\">' '</span> + m.group(<span class=\"number\">2</span>).title()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> re.sub(pattern,func, s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">### output ###</span></span><br><span class=\"line\"><span class=\"comment\"># say i, world hello!</span></span><br><span class=\"line\"><span class=\"comment\"># I Say, Hello World!</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p><code>subn(pattern, repl, string, count=0, flags=0)</code><br>与re.sub方法作用一样，但返回的是包含新字符串和替换执行次数的两元组。</p>\n</li>\n</ul>\n<p>另外，参数flag是匹配模式，取值可以使用按位或运算符’|’表示同时生效，比如<code>re.I | re.M</code>。</p>\n<p>可选值有：</p>\n<blockquote>\n<p>• re.I(全拼：IGNORECASE): 忽略大小写（括号内是完整写法，下同）<br> • re.M(全拼：MULTILINE): 多行模式，改变’^’和’$’的行为（参见上图）<br> • re.S(全拼：DOTALL): 点任意匹配模式，改变’.’的行为<br> • re.L(全拼：LOCALE): 使预定字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定<br> • re.U(全拼：UNICODE): 使预定字符类 \\w \\W \\b \\B \\s \\S \\d \\D 取决于unicode定义的字符属性<br> • re.X(全拼：VERBOSE): 详细模式。这个模式下正则表达式可以是多行，忽略空白字符，并可以加入注释。</p>\n</blockquote>\n<h3 id=\"match对象\"><a href=\"#match对象\" class=\"headerlink\" title=\"match对象\"></a>match对象</h3><p>下面我们说一下关于match对象的的属性和方法。</p>\n<p>我们在调用re模块的方法时，得到了match对象result，之后我们输出结果用的是result.group()，这个是什么意思呢？</p>\n<p>Match对象是一次匹配的结果，包含了很多关于此次匹配的信息，可以使用Match提供的可读属性或方法来获取这些信息。</p>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>1.string: 匹配时使用的文本。</p>\n<p>2.re: 匹配时使用的Pattern对象。</p>\n<p>3.pos: 文本中正则表达式开始搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</p>\n<p>4.endpos: 文本中正则表达式结束搜索的索引。值与Pattern.match()和Pattern.seach()方法的同名参数相同。</p>\n<p>5.lastindex: 最后一个被捕获的分组在文本中的索引。如果没有被捕获的分组，将为None。</p>\n<p>6.lastgroup: 最后一个被捕获的分组的别名。如果这个分组没有别名或者没有被捕获的分组，将为None。</p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>1.group([group1, …]):<br>获得一个或多个分组截获的字符串；指定多个参数时将以元组形式返回。group1可以使用编号也可以使用别名；编号0代表整个匹配的子串；不填写参数时，返回group(0)；没有截获字符串的组返回None；截获了多次的组返回最后一次截获的子串。</p>\n<p>2.groups([default]):<br>以元组形式返回全部分组截获的字符串。相当于调用group(1,2,…last)。default表示没有截获字符串的组以这个值替代，默认为None。</p>\n<p>3.groupdict([default]):<br>返回以有别名的组的别名为键、以该组截获的子串为值的字典，没有别名的组不包含在内。default含义同上。</p>\n<p>4.start([group]):<br>返回指定的组截获的子串在string中的起始索引（子串第一个字符的索引）。group默认值为0。</p>\n<p>5.end([group]):<br>返回指定的组截获的子串在string中的结束索引（子串最后一个字符的索引+1）。group默认值为0。</p>\n<p>6.span([group]):<br>返回(start(group), end(group))。</p>\n<p>7.expand(template):<br>将匹配到的分组代入template中然后返回。template中可以使用\\id或\\g、\\g引用分组，但不能使用编号0。\\id与\\g是等价的；但\\10将被认为是第10个分组，如果你想表达\\1之后是字符’0’，只能使用\\g0。</p>"},{"title":"【python】用python自动发微博","date":"2016-10-23T09:14:50.000Z","_content":"\n首先声明一下，这只是一个小demo，用来作为我学习python的练习，一个除了学（zhuang）习（bi）并无大用的小脚本而已。\n\n咳咳，下面开始手把手教学，大家好好听啊【敲黑板】\n<!--more-->\n## 第一步：你应该要有自己的`app key `和 `app scret`\n[移动API申请](http://open.weibo.com/development/mobile)\n\n点击上面这个链接就可以进入开发者中心申请`app key `和 `app scret`啦，当然前提是你要完善一下个人信息，只要基本信息完善一下即可。然后激活邮箱，你申请一个就可以得到上面的所需信息啦。\n\n之后，在高级设置中将回调函数修改一下：`https://api.weibo.com/oauth2/default.html` ，这个需要和之后的python code里面的 `callback url`一致！！！\n\n## 第二步：安装所需插件\n这里要感谢一下`廖雪峰`大牛提供的SDK：`sinaweibopy`\n```\npip install sinaweibopy\npip install PIL\n```\n确认一下你的python版本，这里用的是`python 2.7`，会用2.7，3自然不是什么难事。\n\n## python Code\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\n\n\nfrom weibo import APIClient\nimport weather\n\ndef get_access_token(app_key, app_secret, callback_url):\n    client = APIClient(app_key=app_key, app_secret=app_secret, redirect_uri=callback_url)\n    # 获取授权页面网址\n    auth_url = client.get_authorize_url()\n    print auth_url\n\n    # 在浏览器中访问这个URL，会跳转到回调地址，回调地址后面跟着code，输入code\n    code = raw_input(\"Input code:\")\n    r = client.request_access_token(code)\n    access_token = r.access_token\n    # token过期的UNIX时间\n    expires_in = r.expires_in\n    print 'access_token:', access_token\n    print 'expires_in:', expires_in\n\n    return access_token, expires_in\ndef init_login():\n    app_key = 'xxxxxxx'\n    app_secret = 'xxxxxxxxxx'\n    callback_url = 'https://api.weibo.com/oauth2/default.html'\n\n    access_token, expires_in = get_access_token(app_key, app_secret, callback_url)\n    # 上面的语句运行一次后，可保存得到的access token，不必每次都申请\n    #print \"access_token = %s, expires_in = %s\" % (access_token, expires_in)\n    # access_token = 'xxxxxxxx'\n    # expires_in = 'xxxxxx'\n\n    client = APIClient(app_key=app_key, app_secret=app_secret, redirect_uri=callback_url)\n    client.set_access_token(access_token, expires_in)\n    return client\n\n\ndef send_pic(client,picpath,message):\n    # send a weibo with img\n    f = open(picpath, 'rb')\n    mes = message.decode('utf-8')\n    client.statuses.upload.post(status=mes, pic=f)\n    f.close()  # APIClient不会自动关闭文件，需要手动关闭\n    print u\"发送成功！\"\n\ndef send_mes(client,message):\n    utext = unicode(message,\"UTF-8\")\n    client.post.statuses__update(status=utext)\n    print u\"发送成功！\"\n\n\nif __name__ == '__main__':\n    client = init_login()\n    weather.draw_pic(weather.weather())\n    mes = \"鲍先森又被盗号啦哈哈哈，我特意来跟大家汇报杭州今日天气：\"\n    send_pic(client,'2.jpg',mes)\n\n```\n\n看完源码会发现，这个`weather`是什么东西？我看这个发微博单调无比，给他新增了一个功能，根据每日天气预报，绘制一张天气预报的图。\n![天气预报](http://i1.piimg.com/567571/437f626213a4472e.jpg)\n\nweather.py:\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\nimport json\nimport urllib2\nfrom PIL import Image,ImageDraw,ImageFont\n\ndef weather():\n    # 获取每日天气数据\n    try:\n        url = 'http://api.map.baidu.com/telematics/v3/weather?location=%E6%9D%AD%E5%B7%9E&output=json&ak=KPGX6sBfBZvz8NlDN5mXDNBF&callback='\n        s=json.loads(urllib2.urlopen(url).read())\n        s1 = s[\"results\"][0][\"weather_data\"][0][\"temperature\"]\n        s2 = s[\"results\"][0][\"weather_data\"][0][\"weather\"]\n        # print s[\"results\"][0][\"currentCity\"]\n        # print s[\"results\"][0][\"weather_data\"][0][\"temperature\"]\n        # print s[\"results\"][0][\"weather_data\"][0][\"weather\"]\n        return s1,s2\n    except :\n        print\"error\"\ndef draw_pic(l):\n    img = Image.open('test.jpg')\n    draw = ImageDraw.Draw(img)\n    myfont = ImageFont.truetype(u'C:/windows/fonts/逼格锐线体简4.0 (2).TTF', size=50) #字体自己改\n    draw.text((img.size[0]/6,img.size[1]/5),unicode(l[0]),font=myfont, fill = (0,177,106))\n    draw.text((img.size[0]/3,img.size[1]/5+150),unicode(l[1]),font=myfont, fill = (0,128,131))\n    img.save('2.jpg','jpeg')\n    print 'ok'\n```\n结果如图示：\n![微博截图](http://i1.piimg.com/567571/6ab683a65bd8d90d.jpg)\n\n最后贴上我的github链接吧：[repo](https://github.com/zjbao123/python_sinaWeiBo)\n\n\n-----\n参考：\nhttp://www.guokr.com/post/475564/\nhttps://www.zhihu.com/question/36960036","source":"_posts/python/【python】用python自动发微博.md","raw":"---\ntitle: 【python】用python自动发微博\ndate: 2016-10-23 17:14:50\ntags: \n- python\n- 趣玩\ncategories: 总结\n---\n\n首先声明一下，这只是一个小demo，用来作为我学习python的练习，一个除了学（zhuang）习（bi）并无大用的小脚本而已。\n\n咳咳，下面开始手把手教学，大家好好听啊【敲黑板】\n<!--more-->\n## 第一步：你应该要有自己的`app key `和 `app scret`\n[移动API申请](http://open.weibo.com/development/mobile)\n\n点击上面这个链接就可以进入开发者中心申请`app key `和 `app scret`啦，当然前提是你要完善一下个人信息，只要基本信息完善一下即可。然后激活邮箱，你申请一个就可以得到上面的所需信息啦。\n\n之后，在高级设置中将回调函数修改一下：`https://api.weibo.com/oauth2/default.html` ，这个需要和之后的python code里面的 `callback url`一致！！！\n\n## 第二步：安装所需插件\n这里要感谢一下`廖雪峰`大牛提供的SDK：`sinaweibopy`\n```\npip install sinaweibopy\npip install PIL\n```\n确认一下你的python版本，这里用的是`python 2.7`，会用2.7，3自然不是什么难事。\n\n## python Code\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\n\n\nfrom weibo import APIClient\nimport weather\n\ndef get_access_token(app_key, app_secret, callback_url):\n    client = APIClient(app_key=app_key, app_secret=app_secret, redirect_uri=callback_url)\n    # 获取授权页面网址\n    auth_url = client.get_authorize_url()\n    print auth_url\n\n    # 在浏览器中访问这个URL，会跳转到回调地址，回调地址后面跟着code，输入code\n    code = raw_input(\"Input code:\")\n    r = client.request_access_token(code)\n    access_token = r.access_token\n    # token过期的UNIX时间\n    expires_in = r.expires_in\n    print 'access_token:', access_token\n    print 'expires_in:', expires_in\n\n    return access_token, expires_in\ndef init_login():\n    app_key = 'xxxxxxx'\n    app_secret = 'xxxxxxxxxx'\n    callback_url = 'https://api.weibo.com/oauth2/default.html'\n\n    access_token, expires_in = get_access_token(app_key, app_secret, callback_url)\n    # 上面的语句运行一次后，可保存得到的access token，不必每次都申请\n    #print \"access_token = %s, expires_in = %s\" % (access_token, expires_in)\n    # access_token = 'xxxxxxxx'\n    # expires_in = 'xxxxxx'\n\n    client = APIClient(app_key=app_key, app_secret=app_secret, redirect_uri=callback_url)\n    client.set_access_token(access_token, expires_in)\n    return client\n\n\ndef send_pic(client,picpath,message):\n    # send a weibo with img\n    f = open(picpath, 'rb')\n    mes = message.decode('utf-8')\n    client.statuses.upload.post(status=mes, pic=f)\n    f.close()  # APIClient不会自动关闭文件，需要手动关闭\n    print u\"发送成功！\"\n\ndef send_mes(client,message):\n    utext = unicode(message,\"UTF-8\")\n    client.post.statuses__update(status=utext)\n    print u\"发送成功！\"\n\n\nif __name__ == '__main__':\n    client = init_login()\n    weather.draw_pic(weather.weather())\n    mes = \"鲍先森又被盗号啦哈哈哈，我特意来跟大家汇报杭州今日天气：\"\n    send_pic(client,'2.jpg',mes)\n\n```\n\n看完源码会发现，这个`weather`是什么东西？我看这个发微博单调无比，给他新增了一个功能，根据每日天气预报，绘制一张天气预报的图。\n![天气预报](http://i1.piimg.com/567571/437f626213a4472e.jpg)\n\nweather.py:\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\nimport json\nimport urllib2\nfrom PIL import Image,ImageDraw,ImageFont\n\ndef weather():\n    # 获取每日天气数据\n    try:\n        url = 'http://api.map.baidu.com/telematics/v3/weather?location=%E6%9D%AD%E5%B7%9E&output=json&ak=KPGX6sBfBZvz8NlDN5mXDNBF&callback='\n        s=json.loads(urllib2.urlopen(url).read())\n        s1 = s[\"results\"][0][\"weather_data\"][0][\"temperature\"]\n        s2 = s[\"results\"][0][\"weather_data\"][0][\"weather\"]\n        # print s[\"results\"][0][\"currentCity\"]\n        # print s[\"results\"][0][\"weather_data\"][0][\"temperature\"]\n        # print s[\"results\"][0][\"weather_data\"][0][\"weather\"]\n        return s1,s2\n    except :\n        print\"error\"\ndef draw_pic(l):\n    img = Image.open('test.jpg')\n    draw = ImageDraw.Draw(img)\n    myfont = ImageFont.truetype(u'C:/windows/fonts/逼格锐线体简4.0 (2).TTF', size=50) #字体自己改\n    draw.text((img.size[0]/6,img.size[1]/5),unicode(l[0]),font=myfont, fill = (0,177,106))\n    draw.text((img.size[0]/3,img.size[1]/5+150),unicode(l[1]),font=myfont, fill = (0,128,131))\n    img.save('2.jpg','jpeg')\n    print 'ok'\n```\n结果如图示：\n![微博截图](http://i1.piimg.com/567571/6ab683a65bd8d90d.jpg)\n\n最后贴上我的github链接吧：[repo](https://github.com/zjbao123/python_sinaWeiBo)\n\n\n-----\n参考：\nhttp://www.guokr.com/post/475564/\nhttps://www.zhihu.com/question/36960036","slug":"python/【python】用python自动发微博","published":1,"updated":"2019-03-22T14:44:36.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwj002c4l3nr4g6twxm","content":"<p>首先声明一下，这只是一个小demo，用来作为我学习python的练习，一个除了学（zhuang）习（bi）并无大用的小脚本而已。</p>\n<p>咳咳，下面开始手把手教学，大家好好听啊【敲黑板】<br><a id=\"more\"></a></p>\n<h2 id=\"第一步：你应该要有自己的app-key和-app-scret\"><a href=\"#第一步：你应该要有自己的app-key和-app-scret\" class=\"headerlink\" title=\"第一步：你应该要有自己的app key和 app scret\"></a>第一步：你应该要有自己的<code>app key</code>和 <code>app scret</code></h2><p><a href=\"http://open.weibo.com/development/mobile\" target=\"_blank\" rel=\"noopener\">移动API申请</a></p>\n<p>点击上面这个链接就可以进入开发者中心申请<code>app key</code>和 <code>app scret</code>啦，当然前提是你要完善一下个人信息，只要基本信息完善一下即可。然后激活邮箱，你申请一个就可以得到上面的所需信息啦。</p>\n<p>之后，在高级设置中将回调函数修改一下：<code>https://api.weibo.com/oauth2/default.html</code> ，这个需要和之后的python code里面的 <code>callback url</code>一致！！！</p>\n<h2 id=\"第二步：安装所需插件\"><a href=\"#第二步：安装所需插件\" class=\"headerlink\" title=\"第二步：安装所需插件\"></a>第二步：安装所需插件</h2><p>这里要感谢一下<code>廖雪峰</code>大牛提供的SDK：<code>sinaweibopy</code><br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip <span class=\"keyword\">install</span> sinaweibopy</span><br><span class=\"line\">pip <span class=\"keyword\">install</span> PIL</span><br></pre></td></tr></table></figure></p>\n<p>确认一下你的python版本，这里用的是<code>python 2.7</code>，会用2.7，3自然不是什么难事。</p>\n<h2 id=\"python-Code\"><a href=\"#python-Code\" class=\"headerlink\" title=\"python Code\"></a>python Code</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> weibo <span class=\"keyword\">import</span> APIClient</span><br><span class=\"line\"><span class=\"keyword\">import</span> weather</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_access_token</span><span class=\"params\">(app_key, app_secret, callback_url)</span>:</span></span><br><span class=\"line\">    client = APIClient(app_key=app_key, app_secret=app_secret, redirect_uri=callback_url)</span><br><span class=\"line\">    <span class=\"comment\"># 获取授权页面网址</span></span><br><span class=\"line\">    auth_url = client.get_authorize_url()</span><br><span class=\"line\">    <span class=\"keyword\">print</span> auth_url</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 在浏览器中访问这个URL，会跳转到回调地址，回调地址后面跟着code，输入code</span></span><br><span class=\"line\">    code = raw_input(<span class=\"string\">\"Input code:\"</span>)</span><br><span class=\"line\">    r = client.request_access_token(code)</span><br><span class=\"line\">    access_token = r.access_token</span><br><span class=\"line\">    <span class=\"comment\"># token过期的UNIX时间</span></span><br><span class=\"line\">    expires_in = r.expires_in</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'access_token:'</span>, access_token</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'expires_in:'</span>, expires_in</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> access_token, expires_in</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init_login</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    app_key = <span class=\"string\">'xxxxxxx'</span></span><br><span class=\"line\">    app_secret = <span class=\"string\">'xxxxxxxxxx'</span></span><br><span class=\"line\">    callback_url = <span class=\"string\">'https://api.weibo.com/oauth2/default.html'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    access_token, expires_in = get_access_token(app_key, app_secret, callback_url)</span><br><span class=\"line\">    <span class=\"comment\"># 上面的语句运行一次后，可保存得到的access token，不必每次都申请</span></span><br><span class=\"line\">    <span class=\"comment\">#print \"access_token = %s, expires_in = %s\" % (access_token, expires_in)</span></span><br><span class=\"line\">    <span class=\"comment\"># access_token = 'xxxxxxxx'</span></span><br><span class=\"line\">    <span class=\"comment\"># expires_in = 'xxxxxx'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    client = APIClient(app_key=app_key, app_secret=app_secret, redirect_uri=callback_url)</span><br><span class=\"line\">    client.set_access_token(access_token, expires_in)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> client</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">send_pic</span><span class=\"params\">(client,picpath,message)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># send a weibo with img</span></span><br><span class=\"line\">    f = open(picpath, <span class=\"string\">'rb'</span>)</span><br><span class=\"line\">    mes = message.decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    client.statuses.upload.post(status=mes, pic=f)</span><br><span class=\"line\">    f.close()  <span class=\"comment\"># APIClient不会自动关闭文件，需要手动关闭</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">u\"发送成功！\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">send_mes</span><span class=\"params\">(client,message)</span>:</span></span><br><span class=\"line\">    utext = unicode(message,<span class=\"string\">\"UTF-8\"</span>)</span><br><span class=\"line\">    client.post.statuses__update(status=utext)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">u\"发送成功！\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    client = init_login()</span><br><span class=\"line\">    weather.draw_pic(weather.weather())</span><br><span class=\"line\">    mes = <span class=\"string\">\"鲍先森又被盗号啦哈哈哈，我特意来跟大家汇报杭州今日天气：\"</span></span><br><span class=\"line\">    send_pic(client,<span class=\"string\">'2.jpg'</span>,mes)</span><br></pre></td></tr></table></figure>\n<p>看完源码会发现，这个<code>weather</code>是什么东西？我看这个发微博单调无比，给他新增了一个功能，根据每日天气预报，绘制一张天气预报的图。<br><img src=\"http://i1.piimg.com/567571/437f626213a4472e.jpg\" alt=\"天气预报\"></p>\n<p>weather.py:<br><figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># -*- coding: utf<span class=\"number\">-8</span> -*-</span><br><span class=\"line\"><span class=\"symbol\">__author__</span> = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\">import json</span><br><span class=\"line\">import urllib2</span><br><span class=\"line\">from <span class=\"symbol\">PIL</span> import <span class=\"symbol\">Image</span>,<span class=\"symbol\">ImageDraw</span>,<span class=\"symbol\">ImageFont</span></span><br><span class=\"line\"></span><br><span class=\"line\">def weather():</span><br><span class=\"line\">    # 获取每日天气数据</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        url = <span class=\"string\">'http://api.map.baidu.com/telematics/v3/weather?location=%E6%9D%AD%E5%B7%9E&amp;output=json&amp;ak=KPGX6sBfBZvz8NlDN5mXDNBF&amp;callback='</span></span><br><span class=\"line\">        s=json.loads(urllib2.urlopen(url).read())</span><br><span class=\"line\">        s1 = s[<span class=\"string\">\"results\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather_data\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"temperature\"</span>]</span><br><span class=\"line\">        s2 = s[<span class=\"string\">\"results\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather_data\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather\"</span>]</span><br><span class=\"line\">        # print s[<span class=\"string\">\"results\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"currentCity\"</span>]</span><br><span class=\"line\">        # print s[<span class=\"string\">\"results\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather_data\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"temperature\"</span>]</span><br><span class=\"line\">        # print s[<span class=\"string\">\"results\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather_data\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather\"</span>]</span><br><span class=\"line\">        return s1,s2</span><br><span class=\"line\">    except :</span><br><span class=\"line\">        print<span class=\"string\">\"error\"</span></span><br><span class=\"line\">def draw_pic(l):</span><br><span class=\"line\">    img = <span class=\"symbol\">Image</span>.open(<span class=\"string\">'test.jpg'</span>)</span><br><span class=\"line\">    draw = <span class=\"symbol\">ImageDraw</span>.<span class=\"symbol\">Draw</span>(img)</span><br><span class=\"line\">    myfont = <span class=\"symbol\">ImageFont</span>.truetype(u<span class=\"string\">'C:/windows/fonts/逼格锐线体简4.0 (2).TTF'</span>, size=<span class=\"number\">50</span>) #字体自己改</span><br><span class=\"line\">    draw.text((img.size[<span class=\"number\">0</span>]/<span class=\"number\">6</span>,img.size[<span class=\"number\">1</span>]/<span class=\"number\">5</span>),unicode(l[<span class=\"number\">0</span>]),font=myfont, fill = (<span class=\"number\">0</span>,<span class=\"number\">177</span>,<span class=\"number\">106</span>))</span><br><span class=\"line\">    draw.text((img.size[<span class=\"number\">0</span>]/<span class=\"number\">3</span>,img.size[<span class=\"number\">1</span>]/<span class=\"number\">5</span>+<span class=\"number\">150</span>),unicode(l[<span class=\"number\">1</span>]),font=myfont, fill = (<span class=\"number\">0</span>,<span class=\"number\">128</span>,<span class=\"number\">131</span>))</span><br><span class=\"line\">    img.save(<span class=\"string\">'2.jpg'</span>,<span class=\"string\">'jpeg'</span>)</span><br><span class=\"line\">    print <span class=\"string\">'ok'</span></span><br></pre></td></tr></table></figure></p>\n<p>结果如图示：<br><img src=\"http://i1.piimg.com/567571/6ab683a65bd8d90d.jpg\" alt=\"微博截图\"></p>\n<p>最后贴上我的github链接吧：<a href=\"https://github.com/zjbao123/python_sinaWeiBo\" target=\"_blank\" rel=\"noopener\">repo</a></p>\n<hr>\n<p>参考：<br><a href=\"http://www.guokr.com/post/475564/\" target=\"_blank\" rel=\"noopener\">http://www.guokr.com/post/475564/</a><br><a href=\"https://www.zhihu.com/question/36960036\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/36960036</a></p>\n","site":{"data":{}},"excerpt":"<p>首先声明一下，这只是一个小demo，用来作为我学习python的练习，一个除了学（zhuang）习（bi）并无大用的小脚本而已。</p>\n<p>咳咳，下面开始手把手教学，大家好好听啊【敲黑板】<br></p>","more":"<p></p>\n<h2 id=\"第一步：你应该要有自己的app-key和-app-scret\"><a href=\"#第一步：你应该要有自己的app-key和-app-scret\" class=\"headerlink\" title=\"第一步：你应该要有自己的app key和 app scret\"></a>第一步：你应该要有自己的<code>app key</code>和 <code>app scret</code></h2><p><a href=\"http://open.weibo.com/development/mobile\" target=\"_blank\" rel=\"noopener\">移动API申请</a></p>\n<p>点击上面这个链接就可以进入开发者中心申请<code>app key</code>和 <code>app scret</code>啦，当然前提是你要完善一下个人信息，只要基本信息完善一下即可。然后激活邮箱，你申请一个就可以得到上面的所需信息啦。</p>\n<p>之后，在高级设置中将回调函数修改一下：<code>https://api.weibo.com/oauth2/default.html</code> ，这个需要和之后的python code里面的 <code>callback url</code>一致！！！</p>\n<h2 id=\"第二步：安装所需插件\"><a href=\"#第二步：安装所需插件\" class=\"headerlink\" title=\"第二步：安装所需插件\"></a>第二步：安装所需插件</h2><p>这里要感谢一下<code>廖雪峰</code>大牛提供的SDK：<code>sinaweibopy</code><br><figure class=\"highlight cmake\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pip <span class=\"keyword\">install</span> sinaweibopy</span><br><span class=\"line\">pip <span class=\"keyword\">install</span> PIL</span><br></pre></td></tr></table></figure></p>\n<p>确认一下你的python版本，这里用的是<code>python 2.7</code>，会用2.7，3自然不是什么难事。</p>\n<h2 id=\"python-Code\"><a href=\"#python-Code\" class=\"headerlink\" title=\"python Code\"></a>python Code</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> weibo <span class=\"keyword\">import</span> APIClient</span><br><span class=\"line\"><span class=\"keyword\">import</span> weather</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_access_token</span><span class=\"params\">(app_key, app_secret, callback_url)</span>:</span></span><br><span class=\"line\">    client = APIClient(app_key=app_key, app_secret=app_secret, redirect_uri=callback_url)</span><br><span class=\"line\">    <span class=\"comment\"># 获取授权页面网址</span></span><br><span class=\"line\">    auth_url = client.get_authorize_url()</span><br><span class=\"line\">    <span class=\"keyword\">print</span> auth_url</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 在浏览器中访问这个URL，会跳转到回调地址，回调地址后面跟着code，输入code</span></span><br><span class=\"line\">    code = raw_input(<span class=\"string\">\"Input code:\"</span>)</span><br><span class=\"line\">    r = client.request_access_token(code)</span><br><span class=\"line\">    access_token = r.access_token</span><br><span class=\"line\">    <span class=\"comment\"># token过期的UNIX时间</span></span><br><span class=\"line\">    expires_in = r.expires_in</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'access_token:'</span>, access_token</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'expires_in:'</span>, expires_in</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> access_token, expires_in</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init_login</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    app_key = <span class=\"string\">'xxxxxxx'</span></span><br><span class=\"line\">    app_secret = <span class=\"string\">'xxxxxxxxxx'</span></span><br><span class=\"line\">    callback_url = <span class=\"string\">'https://api.weibo.com/oauth2/default.html'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    access_token, expires_in = get_access_token(app_key, app_secret, callback_url)</span><br><span class=\"line\">    <span class=\"comment\"># 上面的语句运行一次后，可保存得到的access token，不必每次都申请</span></span><br><span class=\"line\">    <span class=\"comment\">#print \"access_token = %s, expires_in = %s\" % (access_token, expires_in)</span></span><br><span class=\"line\">    <span class=\"comment\"># access_token = 'xxxxxxxx'</span></span><br><span class=\"line\">    <span class=\"comment\"># expires_in = 'xxxxxx'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    client = APIClient(app_key=app_key, app_secret=app_secret, redirect_uri=callback_url)</span><br><span class=\"line\">    client.set_access_token(access_token, expires_in)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> client</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">send_pic</span><span class=\"params\">(client,picpath,message)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># send a weibo with img</span></span><br><span class=\"line\">    f = open(picpath, <span class=\"string\">'rb'</span>)</span><br><span class=\"line\">    mes = message.decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">    client.statuses.upload.post(status=mes, pic=f)</span><br><span class=\"line\">    f.close()  <span class=\"comment\"># APIClient不会自动关闭文件，需要手动关闭</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">u\"发送成功！\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">send_mes</span><span class=\"params\">(client,message)</span>:</span></span><br><span class=\"line\">    utext = unicode(message,<span class=\"string\">\"UTF-8\"</span>)</span><br><span class=\"line\">    client.post.statuses__update(status=utext)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">u\"发送成功！\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    client = init_login()</span><br><span class=\"line\">    weather.draw_pic(weather.weather())</span><br><span class=\"line\">    mes = <span class=\"string\">\"鲍先森又被盗号啦哈哈哈，我特意来跟大家汇报杭州今日天气：\"</span></span><br><span class=\"line\">    send_pic(client,<span class=\"string\">'2.jpg'</span>,mes)</span><br></pre></td></tr></table></figure>\n<p>看完源码会发现，这个<code>weather</code>是什么东西？我看这个发微博单调无比，给他新增了一个功能，根据每日天气预报，绘制一张天气预报的图。<br><img src=\"http://i1.piimg.com/567571/437f626213a4472e.jpg\" alt=\"天气预报\"></p>\n<p>weather.py:<br><figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># -*- coding: utf<span class=\"number\">-8</span> -*-</span><br><span class=\"line\"><span class=\"symbol\">__author__</span> = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\">import json</span><br><span class=\"line\">import urllib2</span><br><span class=\"line\">from <span class=\"symbol\">PIL</span> import <span class=\"symbol\">Image</span>,<span class=\"symbol\">ImageDraw</span>,<span class=\"symbol\">ImageFont</span></span><br><span class=\"line\"></span><br><span class=\"line\">def weather():</span><br><span class=\"line\">    # 获取每日天气数据</span><br><span class=\"line\">    try:</span><br><span class=\"line\">        url = <span class=\"string\">'http://api.map.baidu.com/telematics/v3/weather?location=%E6%9D%AD%E5%B7%9E&amp;output=json&amp;ak=KPGX6sBfBZvz8NlDN5mXDNBF&amp;callback='</span></span><br><span class=\"line\">        s=json.loads(urllib2.urlopen(url).read())</span><br><span class=\"line\">        s1 = s[<span class=\"string\">\"results\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather_data\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"temperature\"</span>]</span><br><span class=\"line\">        s2 = s[<span class=\"string\">\"results\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather_data\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather\"</span>]</span><br><span class=\"line\">        # print s[<span class=\"string\">\"results\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"currentCity\"</span>]</span><br><span class=\"line\">        # print s[<span class=\"string\">\"results\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather_data\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"temperature\"</span>]</span><br><span class=\"line\">        # print s[<span class=\"string\">\"results\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather_data\"</span>][<span class=\"number\">0</span>][<span class=\"string\">\"weather\"</span>]</span><br><span class=\"line\">        return s1,s2</span><br><span class=\"line\">    except :</span><br><span class=\"line\">        print<span class=\"string\">\"error\"</span></span><br><span class=\"line\">def draw_pic(l):</span><br><span class=\"line\">    img = <span class=\"symbol\">Image</span>.open(<span class=\"string\">'test.jpg'</span>)</span><br><span class=\"line\">    draw = <span class=\"symbol\">ImageDraw</span>.<span class=\"symbol\">Draw</span>(img)</span><br><span class=\"line\">    myfont = <span class=\"symbol\">ImageFont</span>.truetype(u<span class=\"string\">'C:/windows/fonts/逼格锐线体简4.0 (2).TTF'</span>, size=<span class=\"number\">50</span>) #字体自己改</span><br><span class=\"line\">    draw.text((img.size[<span class=\"number\">0</span>]/<span class=\"number\">6</span>,img.size[<span class=\"number\">1</span>]/<span class=\"number\">5</span>),unicode(l[<span class=\"number\">0</span>]),font=myfont, fill = (<span class=\"number\">0</span>,<span class=\"number\">177</span>,<span class=\"number\">106</span>))</span><br><span class=\"line\">    draw.text((img.size[<span class=\"number\">0</span>]/<span class=\"number\">3</span>,img.size[<span class=\"number\">1</span>]/<span class=\"number\">5</span>+<span class=\"number\">150</span>),unicode(l[<span class=\"number\">1</span>]),font=myfont, fill = (<span class=\"number\">0</span>,<span class=\"number\">128</span>,<span class=\"number\">131</span>))</span><br><span class=\"line\">    img.save(<span class=\"string\">'2.jpg'</span>,<span class=\"string\">'jpeg'</span>)</span><br><span class=\"line\">    print <span class=\"string\">'ok'</span></span><br></pre></td></tr></table></figure></p>\n<p>结果如图示：<br><img src=\"http://i1.piimg.com/567571/6ab683a65bd8d90d.jpg\" alt=\"微博截图\"></p>\n<p>最后贴上我的github链接吧：<a href=\"https://github.com/zjbao123/python_sinaWeiBo\" target=\"_blank\" rel=\"noopener\">repo</a></p>\n<hr>\n<p>参考：<br><a href=\"http://www.guokr.com/post/475564/\" target=\"_blank\" rel=\"noopener\">http://www.guokr.com/post/475564/</a><br><a href=\"https://www.zhihu.com/question/36960036\" target=\"_blank\" rel=\"noopener\">https://www.zhihu.com/question/36960036</a></p>"},{"title":"初探python(3)高级特性","date":"2016-09-20T12:14:50.000Z","_content":"\n\n在Python中，并不是代码越多越好，而是越少越好。基于这个思想，我们来介绍一下Python的高级特性来精简我们的代码。\n\n## 切片\n取一个list或tuple的部分元素是非常常见的操作。对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。\n<!-- more -->\n```\nL = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']\n\n```\n\n```\nL[0:3]\nL[:3]\nL[1:3]\n L[-2:]\n```\n若要取前三个元素，不需要用循环.直接一行代码搞定。第一行\n表示从索引0开始取，直到索引3为止，但不包括索引3。也可以取负数，则表示从尾部开始取。\n\n如果从0开始取，0还可以省略。\n\n记住倒数第一个元素的索引是-1。\n```\nL = range(100)#0~99数列\nL[:10:2]#从第一个开始，0到10每两个取一个，就跳一个取\nL[::5]#所有数每5个取一个\nL[:]#复制一遍\n'ABCDEFG'[:3]#'ABC'\n'ABCDEFG'[::2]#'ACEG'\n```\ntuple也可以切，结果也是一个tuple\n\nPython没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。\n\n## 迭代\n如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。\n\n任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。\n```\nd = {'a': 1, 'b': 2, 'c': 3}\nfor key in d:\n    print key\n#a b c\n```\n由于字符串也是可迭代对象，因此，也可以作用于for循环。\n\n默认情况下，dict迭代的是key。如果要迭代value，可以用`for value in d.itervalues()`，如果要同时迭代key和value，可以用`for k, v in d.iteritems()`。\n\n那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断。\n```\nfrom collections import Iterable\nisinstance('abc', Iterable)\n```\n\n如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：\n```\nfor i, value in enumerate(['A', 'B', 'C']):\n    print i, value\n#0 A\n#1 B\n#2 C\n```\n\n## 列表生成式\n列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。\n\n```\n[x * x for x in range(1, 11)]\n[m + n for m in 'ABC' for n in 'XYZ']\n\n```\n但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成所需的list。\n也可以用双循环来生成全排列。\n\n运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：\n```\nimport os # 导入os模块，模块的概念后面讲到\n[d for d in os.listdir('.')] # os.listdir可以列出文件和目录\n```\n\n运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。\n\n如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法.\n```\nL = ['Hello','world',2016,0116]\n\nprint [s.lower() if isinstance(s, str) else s for s in L]\n```\n## 生成器\n\n通例如创建一个包含100万个元素的列表，且不说由于内存限制，不仅占用很大的存储空间，而且我们通常仅仅需要访问前面几个元素，因此，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。\n\n要创建一个generator，只需把列表生成式中的`[]`改成`（）`就行了，也就是元组。\n\n`generator`列出所有元素需要通过`generator`的`next()`方法，一个一个打印出来。\n\ngenerator保存的是算法，每次调用next()，就计算出下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。\n\n当然，上面这种不断调用next()方法实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象.\n\n所以基本上不会用`next()`方法，一般都用for循环。\n\ngenerator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。\n\n例如，打印斐波拉契数列，用列表上生成式很难写，不过generator就很方便\n```\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        print b\n        a, b = b, a + b\n        n = n + 1\n```\n\nfib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。\n\n上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print b改为yield b就可以了：\n```\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n```\n这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。\n```\nfor n in fib(6):\n    print n\n#######\n1\n1\n2\n3\n5\n8\n```\n### 生成器工作流程\n\n这里最难理解的就是generator和函数的执行流程不一样。\n\n函数是顺序执行，遇到return语句或者最后一行函数语句就返回。\n\n而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\n\n\n它的工作流程是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。\n\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。\n\n","source":"_posts/python/初探Python(3)高级特性.md","raw":"---\ntitle: 初探python(3)高级特性\ndate: 2016-09-20 20:14:50\ntags: \n- python\n- python教程\ncategories: 总结\n---\n\n\n在Python中，并不是代码越多越好，而是越少越好。基于这个思想，我们来介绍一下Python的高级特性来精简我们的代码。\n\n## 切片\n取一个list或tuple的部分元素是非常常见的操作。对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。\n<!-- more -->\n```\nL = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']\n\n```\n\n```\nL[0:3]\nL[:3]\nL[1:3]\n L[-2:]\n```\n若要取前三个元素，不需要用循环.直接一行代码搞定。第一行\n表示从索引0开始取，直到索引3为止，但不包括索引3。也可以取负数，则表示从尾部开始取。\n\n如果从0开始取，0还可以省略。\n\n记住倒数第一个元素的索引是-1。\n```\nL = range(100)#0~99数列\nL[:10:2]#从第一个开始，0到10每两个取一个，就跳一个取\nL[::5]#所有数每5个取一个\nL[:]#复制一遍\n'ABCDEFG'[:3]#'ABC'\n'ABCDEFG'[::2]#'ACEG'\n```\ntuple也可以切，结果也是一个tuple\n\nPython没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。\n\n## 迭代\n如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。\n\n任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。\n```\nd = {'a': 1, 'b': 2, 'c': 3}\nfor key in d:\n    print key\n#a b c\n```\n由于字符串也是可迭代对象，因此，也可以作用于for循环。\n\n默认情况下，dict迭代的是key。如果要迭代value，可以用`for value in d.itervalues()`，如果要同时迭代key和value，可以用`for k, v in d.iteritems()`。\n\n那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断。\n```\nfrom collections import Iterable\nisinstance('abc', Iterable)\n```\n\n如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：\n```\nfor i, value in enumerate(['A', 'B', 'C']):\n    print i, value\n#0 A\n#1 B\n#2 C\n```\n\n## 列表生成式\n列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。\n\n```\n[x * x for x in range(1, 11)]\n[m + n for m in 'ABC' for n in 'XYZ']\n\n```\n但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成所需的list。\n也可以用双循环来生成全排列。\n\n运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：\n```\nimport os # 导入os模块，模块的概念后面讲到\n[d for d in os.listdir('.')] # os.listdir可以列出文件和目录\n```\n\n运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。\n\n如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法.\n```\nL = ['Hello','world',2016,0116]\n\nprint [s.lower() if isinstance(s, str) else s for s in L]\n```\n## 生成器\n\n通例如创建一个包含100万个元素的列表，且不说由于内存限制，不仅占用很大的存储空间，而且我们通常仅仅需要访问前面几个元素，因此，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。\n\n要创建一个generator，只需把列表生成式中的`[]`改成`（）`就行了，也就是元组。\n\n`generator`列出所有元素需要通过`generator`的`next()`方法，一个一个打印出来。\n\ngenerator保存的是算法，每次调用next()，就计算出下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。\n\n当然，上面这种不断调用next()方法实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象.\n\n所以基本上不会用`next()`方法，一般都用for循环。\n\ngenerator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。\n\n例如，打印斐波拉契数列，用列表上生成式很难写，不过generator就很方便\n```\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        print b\n        a, b = b, a + b\n        n = n + 1\n```\n\nfib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。\n\n上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print b改为yield b就可以了：\n```\ndef fib(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        a, b = b, a + b\n        n = n + 1\n```\n这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。\n```\nfor n in fib(6):\n    print n\n#######\n1\n1\n2\n3\n5\n8\n```\n### 生成器工作流程\n\n这里最难理解的就是generator和函数的执行流程不一样。\n\n函数是顺序执行，遇到return语句或者最后一行函数语句就返回。\n\n而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。\n\n\n它的工作流程是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。\n\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。\n\n","slug":"python/初探Python(3)高级特性","published":1,"updated":"2019-03-22T14:44:36.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwk002f4l3num7g3zir","content":"<p>在Python中，并不是代码越多越好，而是越少越好。基于这个思想，我们来介绍一下Python的高级特性来精简我们的代码。</p>\n<h2 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h2><p>取一个list或tuple的部分元素是非常常见的操作。对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。<br><a id=\"more\"></a><br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">L</span> = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Sarah'</span>, <span class=\"string\">'Tracy'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Jack'</span>]</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L<span class=\"string\">[0:3]</span></span><br><span class=\"line\">L<span class=\"string\">[:3]</span></span><br><span class=\"line\">L<span class=\"string\">[1:3]</span></span><br><span class=\"line\"> L<span class=\"string\">[-2:]</span></span><br></pre></td></tr></table></figure>\n<p>若要取前三个元素，不需要用循环.直接一行代码搞定。第一行<br>表示从索引0开始取，直到索引3为止，但不包括索引3。也可以取负数，则表示从尾部开始取。</p>\n<p>如果从0开始取，0还可以省略。</p>\n<p>记住倒数第一个元素的索引是-1。<br><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L = range(<span class=\"number\">100</span>)<span class=\"meta\">#0~99数列</span></span><br><span class=\"line\">L[:<span class=\"number\">10</span>:<span class=\"number\">2</span>]<span class=\"meta\">#从第一个开始，0到10每两个取一个，就跳一个取</span></span><br><span class=\"line\">L[::<span class=\"number\">5</span>]<span class=\"meta\">#所有数每5个取一个</span></span><br><span class=\"line\">L[:]<span class=\"meta\">#复制一遍</span></span><br><span class=\"line\"><span class=\"string\">'ABCDEFG'</span>[:<span class=\"number\">3</span>]<span class=\"meta\">#<span class=\"string\">'ABC'</span></span></span><br><span class=\"line\"><span class=\"string\">'ABCDEFG'</span>[::<span class=\"number\">2</span>]<span class=\"meta\">#<span class=\"string\">'ACEG'</span></span></span><br></pre></td></tr></table></figure></p>\n<p>tuple也可以切，结果也是一个tuple</p>\n<p>Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p>\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p>\n<p>任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">    print key</span><br><span class=\"line\"><span class=\"selector-id\">#a</span> <span class=\"selector-tag\">b</span> c</span><br></pre></td></tr></table></figure></p>\n<p>由于字符串也是可迭代对象，因此，也可以作用于for循环。</p>\n<p>默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.itervalues()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.iteritems()</code>。</p>\n<p>那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断。<br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from collections <span class=\"keyword\">import</span> <span class=\"built_in\">Iterable</span></span><br><span class=\"line\">isinstance(<span class=\"string\">'abc'</span>, <span class=\"built_in\">Iterable</span>)</span><br></pre></td></tr></table></figure></p>\n<p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, <span class=\"built_in\">value</span> <span class=\"keyword\">in</span> enumerate([<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>]):</span><br><span class=\"line\">    print i, <span class=\"built_in\">value</span></span><br><span class=\"line\"><span class=\"comment\">#0 A</span></span><br><span class=\"line\"><span class=\"comment\">#1 B</span></span><br><span class=\"line\"><span class=\"comment\">#2 C</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"列表生成式\"><a href=\"#列表生成式\" class=\"headerlink\" title=\"列表生成式\"></a>列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">x</span> * x for x in range(<span class=\"name\">1</span>, <span class=\"number\">11</span>)]</span><br><span class=\"line\">[<span class=\"name\">m</span> + n for m in <span class=\"symbol\">'ABC</span>' for n in <span class=\"symbol\">'XYZ</span>']</span><br></pre></td></tr></table></figure>\n<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成所需的list。<br>也可以用双循环来生成全排列。</p>\n<p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：<br><figure class=\"highlight moonscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"built_in\">os</span> # 导入<span class=\"built_in\">os</span>模块，模块的概念后面讲到</span><br><span class=\"line\">[d <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> <span class=\"built_in\">os</span>.listdir(<span class=\"string\">'.'</span>)] # <span class=\"built_in\">os</span>.listdir可以列出文件和目录</span><br></pre></td></tr></table></figure></p>\n<p>运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。</p>\n<p>如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法.<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L = [<span class=\"string\">'Hello'</span>,<span class=\"string\">'world'</span>,<span class=\"number\">2016</span>,<span class=\"number\">0116</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> [s.<span class=\"built_in\">lower</span>() <span class=\"keyword\">if</span> isinstance(s, str) <span class=\"keyword\">else</span> s <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> L]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h2><p>通例如创建一个包含100万个元素的列表，且不说由于内存限制，不仅占用很大的存储空间，而且我们通常仅仅需要访问前面几个元素，因此，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。</p>\n<p>要创建一个generator，只需把列表生成式中的<code>[]</code>改成<code>（）</code>就行了，也就是元组。</p>\n<p><code>generator</code>列出所有元素需要通过<code>generator</code>的<code>next()</code>方法，一个一个打印出来。</p>\n<p>generator保存的是算法，每次调用next()，就计算出下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p>\n<p>当然，上面这种不断调用next()方法实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象.</p>\n<p>所以基本上不会用<code>next()</code>方法，一般都用for循环。</p>\n<p>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。</p>\n<p>例如，打印斐波拉契数列，用列表上生成式很难写，不过generator就很方便<br><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">def</span> fib(max):</span><br><span class=\"line\">    n, a, <span class=\"keyword\">b </span>= <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"meta\">while</span> n &lt; max:</span><br><span class=\"line\">        print <span class=\"keyword\">b</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>       a, <span class=\"keyword\">b </span>= <span class=\"keyword\">b, </span>a + <span class=\"keyword\">b</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>       n = n + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<p>fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。</p>\n<p>上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print b改为yield b就可以了：<br><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">def</span> fib(max):</span><br><span class=\"line\">    n, a, <span class=\"keyword\">b </span>= <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"meta\">while</span> n &lt; max:</span><br><span class=\"line\">        <span class=\"keyword\">yield </span><span class=\"keyword\">b</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>       a, <span class=\"keyword\">b </span>= <span class=\"keyword\">b, </span>a + <span class=\"keyword\">b</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>       n = n + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<p>这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for n <span class=\"keyword\">in</span> fib(<span class=\"number\">6</span>):</span><br><span class=\"line\">    print n</span><br><span class=\"line\">#######</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"生成器工作流程\"><a href=\"#生成器工作流程\" class=\"headerlink\" title=\"生成器工作流程\"></a>生成器工作流程</h3><p>这里最难理解的就是generator和函数的执行流程不一样。</p>\n<p>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。</p>\n<p>而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p>\n<p>它的工作流程是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>在Python中，并不是代码越多越好，而是越少越好。基于这个思想，我们来介绍一下Python的高级特性来精简我们的代码。</p>\n<h2 id=\"切片\"><a href=\"#切片\" class=\"headerlink\" title=\"切片\"></a>切片</h2><p>取一个list或tuple的部分元素是非常常见的操作。对这种经常取指定索引范围的操作，用循环十分繁琐，因此，Python提供了切片（Slice）操作符，能大大简化这种操作。<br></p>","more":"<br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">L</span> = [<span class=\"string\">'Michael'</span>, <span class=\"string\">'Sarah'</span>, <span class=\"string\">'Tracy'</span>, <span class=\"string\">'Bob'</span>, <span class=\"string\">'Jack'</span>]</span><br></pre></td></tr></table></figure><p></p>\n<figure class=\"highlight accesslog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L<span class=\"string\">[0:3]</span></span><br><span class=\"line\">L<span class=\"string\">[:3]</span></span><br><span class=\"line\">L<span class=\"string\">[1:3]</span></span><br><span class=\"line\"> L<span class=\"string\">[-2:]</span></span><br></pre></td></tr></table></figure>\n<p>若要取前三个元素，不需要用循环.直接一行代码搞定。第一行<br>表示从索引0开始取，直到索引3为止，但不包括索引3。也可以取负数，则表示从尾部开始取。</p>\n<p>如果从0开始取，0还可以省略。</p>\n<p>记住倒数第一个元素的索引是-1。<br><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L = range(<span class=\"number\">100</span>)<span class=\"meta\">#0~99数列</span></span><br><span class=\"line\">L[:<span class=\"number\">10</span>:<span class=\"number\">2</span>]<span class=\"meta\">#从第一个开始，0到10每两个取一个，就跳一个取</span></span><br><span class=\"line\">L[::<span class=\"number\">5</span>]<span class=\"meta\">#所有数每5个取一个</span></span><br><span class=\"line\">L[:]<span class=\"meta\">#复制一遍</span></span><br><span class=\"line\"><span class=\"string\">'ABCDEFG'</span>[:<span class=\"number\">3</span>]<span class=\"meta\">#<span class=\"string\">'ABC'</span></span></span><br><span class=\"line\"><span class=\"string\">'ABCDEFG'</span>[::<span class=\"number\">2</span>]<span class=\"meta\">#<span class=\"string\">'ACEG'</span></span></span><br></pre></td></tr></table></figure></p>\n<p>tuple也可以切，结果也是一个tuple</p>\n<p>Python没有针对字符串的截取函数，只需要切片一个操作就可以完成，非常简单。</p>\n<h2 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h2><p>如果给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，这种遍历我们称为迭代（Iteration）。</p>\n<p>任何可迭代对象都可以作用于for循环，包括我们自定义的数据类型，只要符合迭代条件，就可以使用for循环。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = &#123;<span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'b'</span>: <span class=\"number\">2</span>, <span class=\"string\">'c'</span>: <span class=\"number\">3</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> key <span class=\"keyword\">in</span> d:</span><br><span class=\"line\">    print key</span><br><span class=\"line\"><span class=\"selector-id\">#a</span> <span class=\"selector-tag\">b</span> c</span><br></pre></td></tr></table></figure></p>\n<p>由于字符串也是可迭代对象，因此，也可以作用于for循环。</p>\n<p>默认情况下，dict迭代的是key。如果要迭代value，可以用<code>for value in d.itervalues()</code>，如果要同时迭代key和value，可以用<code>for k, v in d.iteritems()</code>。</p>\n<p>那么，如何判断一个对象是可迭代对象呢？方法是通过collections模块的Iterable类型判断。<br><figure class=\"highlight dart\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from collections <span class=\"keyword\">import</span> <span class=\"built_in\">Iterable</span></span><br><span class=\"line\">isinstance(<span class=\"string\">'abc'</span>, <span class=\"built_in\">Iterable</span>)</span><br></pre></td></tr></table></figure></p>\n<p>如果要对list实现类似Java那样的下标循环怎么办？Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身：<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i, <span class=\"built_in\">value</span> <span class=\"keyword\">in</span> enumerate([<span class=\"string\">'A'</span>, <span class=\"string\">'B'</span>, <span class=\"string\">'C'</span>]):</span><br><span class=\"line\">    print i, <span class=\"built_in\">value</span></span><br><span class=\"line\"><span class=\"comment\">#0 A</span></span><br><span class=\"line\"><span class=\"comment\">#1 B</span></span><br><span class=\"line\"><span class=\"comment\">#2 C</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"列表生成式\"><a href=\"#列表生成式\" class=\"headerlink\" title=\"列表生成式\"></a>列表生成式</h2><p>列表生成式即List Comprehensions，是Python内置的非常简单却强大的可以用来创建list的生成式。</p>\n<figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"name\">x</span> * x for x in range(<span class=\"name\">1</span>, <span class=\"number\">11</span>)]</span><br><span class=\"line\">[<span class=\"name\">m</span> + n for m in <span class=\"symbol\">'ABC</span>' for n in <span class=\"symbol\">'XYZ</span>']</span><br></pre></td></tr></table></figure>\n<p>但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成所需的list。<br>也可以用双循环来生成全排列。</p>\n<p>运用列表生成式，可以写出非常简洁的代码。例如，列出当前目录下的所有文件和目录名，可以通过一行代码实现：<br><figure class=\"highlight moonscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"built_in\">os</span> # 导入<span class=\"built_in\">os</span>模块，模块的概念后面讲到</span><br><span class=\"line\">[d <span class=\"keyword\">for</span> d <span class=\"keyword\">in</span> <span class=\"built_in\">os</span>.listdir(<span class=\"string\">'.'</span>)] # <span class=\"built_in\">os</span>.listdir可以列出文件和目录</span><br></pre></td></tr></table></figure></p>\n<p>运用列表生成式，可以快速生成list，可以通过一个list推导出另一个list，而代码却十分简洁。</p>\n<p>如果list中既包含字符串，又包含整数，由于非字符串类型没有lower()方法.<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L = [<span class=\"string\">'Hello'</span>,<span class=\"string\">'world'</span>,<span class=\"number\">2016</span>,<span class=\"number\">0116</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> [s.<span class=\"built_in\">lower</span>() <span class=\"keyword\">if</span> isinstance(s, str) <span class=\"keyword\">else</span> s <span class=\"keyword\">for</span> s <span class=\"keyword\">in</span> L]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h2><p>通例如创建一个包含100万个元素的列表，且不说由于内存限制，不仅占用很大的存储空间，而且我们通常仅仅需要访问前面几个元素，因此，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器（Generator）。</p>\n<p>要创建一个generator，只需把列表生成式中的<code>[]</code>改成<code>（）</code>就行了，也就是元组。</p>\n<p><code>generator</code>列出所有元素需要通过<code>generator</code>的<code>next()</code>方法，一个一个打印出来。</p>\n<p>generator保存的是算法，每次调用next()，就计算出下一个元素的值，直到计算到最后一个元素，没有更多的元素时，抛出StopIteration的错误。</p>\n<p>当然，上面这种不断调用next()方法实在是太变态了，正确的方法是使用for循环，因为generator也是可迭代对象.</p>\n<p>所以基本上不会用<code>next()</code>方法，一般都用for循环。</p>\n<p>generator非常强大。如果推算的算法比较复杂，用类似列表生成式的for循环无法实现的时候，还可以用函数来实现。</p>\n<p>例如，打印斐波拉契数列，用列表上生成式很难写，不过generator就很方便<br><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">def</span> fib(max):</span><br><span class=\"line\">    n, a, <span class=\"keyword\">b </span>= <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"meta\">while</span> n &lt; max:</span><br><span class=\"line\">        print <span class=\"keyword\">b</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>       a, <span class=\"keyword\">b </span>= <span class=\"keyword\">b, </span>a + <span class=\"keyword\">b</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>       n = n + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<p>fib函数实际上是定义了斐波拉契数列的推算规则，可以从第一个元素开始，推算出后续任意的元素，这种逻辑其实非常类似generator。</p>\n<p>上面的函数和generator仅一步之遥。要把fib函数变成generator，只需要把print b改为yield b就可以了：<br><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">def</span> fib(max):</span><br><span class=\"line\">    n, a, <span class=\"keyword\">b </span>= <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"meta\">while</span> n &lt; max:</span><br><span class=\"line\">        <span class=\"keyword\">yield </span><span class=\"keyword\">b</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>       a, <span class=\"keyword\">b </span>= <span class=\"keyword\">b, </span>a + <span class=\"keyword\">b</span></span><br><span class=\"line\"><span class=\"keyword\"> </span>       n = n + <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<p>这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator。<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for n <span class=\"keyword\">in</span> fib(<span class=\"number\">6</span>):</span><br><span class=\"line\">    print n</span><br><span class=\"line\">#######</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">8</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"生成器工作流程\"><a href=\"#生成器工作流程\" class=\"headerlink\" title=\"生成器工作流程\"></a>生成器工作流程</h3><p>这里最难理解的就是generator和函数的执行流程不一样。</p>\n<p>函数是顺序执行，遇到return语句或者最后一行函数语句就返回。</p>\n<p>而变成generator的函数，在每次调用next()的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行。</p>\n<p>它的工作流程是在for循环的过程中不断计算出下一个元素，并在适当的条件结束for循环。对于函数改成的generator来说，遇到return语句或者执行到函数体最后一行语句，就是结束generator的指令，for循环随之结束。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"初探python(12)web开发","date":"2016-09-13T14:14:50.000Z","_content":"\n## WSGI接口\n在之前做的一些初步了解之后，我们明白，一个Web应用的本质就是：\n1.浏览器发送一个HTTP请求；\n2.服务器收到请求，生成一个HTML文档；\n3.服务器把HTML文档作为HTTP响应的Body发送给浏览器；\n4.浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。\n<!-- more -->\n所以，最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。Apache、Nginx、Lighttpd等这些常见的静态服务器就是干这件事情的。\n\n我们需要一个统一的接口，让我们专心用Python编写Web业务，而不是从底层开始一步步实现。当然，随着学习深入，自然需要这样走。目前我们所需的仅仅是一个接口。\n\n这个接口就是WSGI：Web Server Gateway Interface。\n\nWSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello, web!”：\n```\ndef application(environ, start_response):\n    start_response('200 OK', [('Content-Type', 'text/html')])\n    return '<h1>Hello, web!</h1>'\n```\n\n上面的`application()`函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：\n\n* environ：一个包含所有HTTP请求信息的dict对象；\n\n* start_response：一个发送HTTP响应的函数。\n\n在调用`start_response`时，就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次`start_response()`函数。`start_response()`函数接收两个参数，一个是HTTP响应码，一个是一组list表示的`HTTP Header`，每个Header用一个包含两个str的tuple表示。\n\n通常情况下，都应该把Content-Type头发送给浏览器。其他很多常用的HTTP Header也应该发送。\n\n然后，函数的返回值'<h1>Hello, web!</h1>'将作为HTTP响应的Body发送给浏览器。\n\n我们关心的就是如何从`environ`这个dict对象拿到HTTP请求信息，然后构造HTML，通过`start_response()`发送Header，最后返回Body。\n\n而`application()`函数的调用由WSGI服务器来实现。最简单的是Python内置了一个WSGI服务器，这个模块叫`wsgiref`，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。\n\n### demo\nhello.py,WSGI服务器：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\ndef application(environ, start_response):\n    start_response('200 OK', [('Content-Type', 'text/html')])\n    return '<h1>Hello, %s!</h1>' % (environ['PATH_INFO'][1:] or 'web') #返回URL的后一部分\n```\nserver.py，负责启动WSGI服务器，加载application()函数：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom wsgiref.simple_server import make_server\n\nfrom hello import application\n\nhttpd = make_server('', 8000, application)\nprint \"Serving HTTP on port 8000...\"\n\nhttpd.serve_forever()\n```\n无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过environ获得，HTTP响应的输出都可以通过start_response()加上函数返回值作为Body。\n\n复杂的Web应用程序，光靠一个WSGI函数来处理还是太底层了，我们需要在WSGI之上再抽象出Web框架，进一步简化Web开发。\n\n\n## 使用Web框架\n\n了解了WSGI框架，我们发现：其实一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。\n\n那如果有一百个网页需要响应呢？\n\n\n\n\n\n\n\n\n\n\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)和官方文档的一个学习内容的总结。以便于自己后的学习和整理。","source":"_posts/python/初探python(12)web开发.md","raw":"---\ntitle: 初探python(12)web开发\ndate: 2016-09-13 22:14:50\ntags: \n- python\n- python教程\ncategories: 总结\n---\n\n## WSGI接口\n在之前做的一些初步了解之后，我们明白，一个Web应用的本质就是：\n1.浏览器发送一个HTTP请求；\n2.服务器收到请求，生成一个HTML文档；\n3.服务器把HTML文档作为HTTP响应的Body发送给浏览器；\n4.浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。\n<!-- more -->\n所以，最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。Apache、Nginx、Lighttpd等这些常见的静态服务器就是干这件事情的。\n\n我们需要一个统一的接口，让我们专心用Python编写Web业务，而不是从底层开始一步步实现。当然，随着学习深入，自然需要这样走。目前我们所需的仅仅是一个接口。\n\n这个接口就是WSGI：Web Server Gateway Interface。\n\nWSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello, web!”：\n```\ndef application(environ, start_response):\n    start_response('200 OK', [('Content-Type', 'text/html')])\n    return '<h1>Hello, web!</h1>'\n```\n\n上面的`application()`函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：\n\n* environ：一个包含所有HTTP请求信息的dict对象；\n\n* start_response：一个发送HTTP响应的函数。\n\n在调用`start_response`时，就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次`start_response()`函数。`start_response()`函数接收两个参数，一个是HTTP响应码，一个是一组list表示的`HTTP Header`，每个Header用一个包含两个str的tuple表示。\n\n通常情况下，都应该把Content-Type头发送给浏览器。其他很多常用的HTTP Header也应该发送。\n\n然后，函数的返回值'<h1>Hello, web!</h1>'将作为HTTP响应的Body发送给浏览器。\n\n我们关心的就是如何从`environ`这个dict对象拿到HTTP请求信息，然后构造HTML，通过`start_response()`发送Header，最后返回Body。\n\n而`application()`函数的调用由WSGI服务器来实现。最简单的是Python内置了一个WSGI服务器，这个模块叫`wsgiref`，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。\n\n### demo\nhello.py,WSGI服务器：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\ndef application(environ, start_response):\n    start_response('200 OK', [('Content-Type', 'text/html')])\n    return '<h1>Hello, %s!</h1>' % (environ['PATH_INFO'][1:] or 'web') #返回URL的后一部分\n```\nserver.py，负责启动WSGI服务器，加载application()函数：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nfrom wsgiref.simple_server import make_server\n\nfrom hello import application\n\nhttpd = make_server('', 8000, application)\nprint \"Serving HTTP on port 8000...\"\n\nhttpd.serve_forever()\n```\n无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过environ获得，HTTP响应的输出都可以通过start_response()加上函数返回值作为Body。\n\n复杂的Web应用程序，光靠一个WSGI函数来处理还是太底层了，我们需要在WSGI之上再抽象出Web框架，进一步简化Web开发。\n\n\n## 使用Web框架\n\n了解了WSGI框架，我们发现：其实一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。\n\n那如果有一百个网页需要响应呢？\n\n\n\n\n\n\n\n\n\n\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)和官方文档的一个学习内容的总结。以便于自己后的学习和整理。","slug":"python/初探python(12)web开发","published":1,"updated":"2019-03-22T14:44:36.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwl002i4l3no2revc5v","content":"<h2 id=\"WSGI接口\"><a href=\"#WSGI接口\" class=\"headerlink\" title=\"WSGI接口\"></a>WSGI接口</h2><p>在之前做的一些初步了解之后，我们明白，一个Web应用的本质就是：<br>1.浏览器发送一个HTTP请求；<br>2.服务器收到请求，生成一个HTML文档；<br>3.服务器把HTML文档作为HTTP响应的Body发送给浏览器；<br>4.浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。<br><a id=\"more\"></a><br>所以，最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。Apache、Nginx、Lighttpd等这些常见的静态服务器就是干这件事情的。</p>\n<p>我们需要一个统一的接口，让我们专心用Python编写Web业务，而不是从底层开始一步步实现。当然，随着学习深入，自然需要这样走。目前我们所需的仅仅是一个接口。</p>\n<p>这个接口就是WSGI：Web Server Gateway Interface。</p>\n<p>WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello, web!”：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">application</span><span class=\"params\">(environ, start_response)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    start_response(<span class=\"string\">'200 OK'</span>, [(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'text/html'</span>)])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的<code>application()</code>函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：</p>\n<ul>\n<li><p>environ：一个包含所有HTTP请求信息的dict对象；</p>\n</li>\n<li><p>start_response：一个发送HTTP响应的函数。</p>\n</li>\n</ul>\n<p>在调用<code>start_response</code>时，就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次<code>start_response()</code>函数。<code>start_response()</code>函数接收两个参数，一个是HTTP响应码，一个是一组list表示的<code>HTTP Header</code>，每个Header用一个包含两个str的tuple表示。</p>\n<p>通常情况下，都应该把Content-Type头发送给浏览器。其他很多常用的HTTP Header也应该发送。</p>\n<p>然后，函数的返回值’</p><h1>Hello, web!</h1>‘将作为HTTP响应的Body发送给浏览器。<p></p>\n<p>我们关心的就是如何从<code>environ</code>这个dict对象拿到HTTP请求信息，然后构造HTML，通过<code>start_response()</code>发送Header，最后返回Body。</p>\n<p>而<code>application()</code>函数的调用由WSGI服务器来实现。最简单的是Python内置了一个WSGI服务器，这个模块叫<code>wsgiref</code>，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。</p>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><p>hello.py,WSGI服务器：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">application</span><span class=\"params\">(environ, start_response)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    start_response(<span class=\"string\">'200 OK'</span>, [(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'text/html'</span>)])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;h1&gt;Hello, %s!&lt;/h1&gt;'</span> % (environ[<span class=\"string\">'PATH_INFO'</span>][<span class=\"number\">1</span><span class=\"symbol\">:</span>] <span class=\"keyword\">or</span> <span class=\"string\">'web'</span>) <span class=\"comment\">#返回URL的后一部分</span></span><br></pre></td></tr></table></figure></p>\n<p>server.py，负责启动WSGI服务器，加载application()函数：<br><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> wsgiref.simple_server <span class=\"keyword\">import</span> make_server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> hello <span class=\"keyword\">import</span> application</span><br><span class=\"line\"></span><br><span class=\"line\">httpd = make_server(<span class=\"string\">''</span>, <span class=\"number\">8000</span>, application)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">\"Serving HTTP on port 8000...\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">httpd.serve_forever()</span><br></pre></td></tr></table></figure></p>\n<p>无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过environ获得，HTTP响应的输出都可以通过start_response()加上函数返回值作为Body。</p>\n<p>复杂的Web应用程序，光靠一个WSGI函数来处理还是太底层了，我们需要在WSGI之上再抽象出Web框架，进一步简化Web开发。</p>\n<h2 id=\"使用Web框架\"><a href=\"#使用Web框架\" class=\"headerlink\" title=\"使用Web框架\"></a>使用Web框架</h2><p>了解了WSGI框架，我们发现：其实一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。</p>\n<p>那如果有一百个网页需要响应呢？</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>和官方文档的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"WSGI接口\"><a href=\"#WSGI接口\" class=\"headerlink\" title=\"WSGI接口\"></a>WSGI接口</h2><p>在之前做的一些初步了解之后，我们明白，一个Web应用的本质就是：<br>1.浏览器发送一个HTTP请求；<br>2.服务器收到请求，生成一个HTML文档；<br>3.服务器把HTML文档作为HTTP响应的Body发送给浏览器；<br>4.浏览器收到HTTP响应，从HTTP Body取出HTML文档并显示。<br></p>","more":"<br>所以，最简单的Web应用就是先把HTML用文件保存好，用一个现成的HTTP服务器软件，接收用户请求，从文件中读取HTML，返回。Apache、Nginx、Lighttpd等这些常见的静态服务器就是干这件事情的。<p></p>\n<p>我们需要一个统一的接口，让我们专心用Python编写Web业务，而不是从底层开始一步步实现。当然，随着学习深入，自然需要这样走。目前我们所需的仅仅是一个接口。</p>\n<p>这个接口就是WSGI：Web Server Gateway Interface。</p>\n<p>WSGI接口定义非常简单，它只要求Web开发者实现一个函数，就可以响应HTTP请求。我们来看一个最简单的Web版本的“Hello, web!”：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">application</span><span class=\"params\">(environ, start_response)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    start_response(<span class=\"string\">'200 OK'</span>, [(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'text/html'</span>)])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;h1&gt;Hello, web!&lt;/h1&gt;'</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的<code>application()</code>函数就是符合WSGI标准的一个HTTP处理函数，它接收两个参数：</p>\n<ul>\n<li><p>environ：一个包含所有HTTP请求信息的dict对象；</p>\n</li>\n<li><p>start_response：一个发送HTTP响应的函数。</p>\n</li>\n</ul>\n<p>在调用<code>start_response</code>时，就发送了HTTP响应的Header，注意Header只能发送一次，也就是只能调用一次<code>start_response()</code>函数。<code>start_response()</code>函数接收两个参数，一个是HTTP响应码，一个是一组list表示的<code>HTTP Header</code>，每个Header用一个包含两个str的tuple表示。</p>\n<p>通常情况下，都应该把Content-Type头发送给浏览器。其他很多常用的HTTP Header也应该发送。</p>\n<p>然后，函数的返回值’</p><h1>Hello, web!</h1>‘将作为HTTP响应的Body发送给浏览器。<p></p>\n<p>我们关心的就是如何从<code>environ</code>这个dict对象拿到HTTP请求信息，然后构造HTML，通过<code>start_response()</code>发送Header，最后返回Body。</p>\n<p>而<code>application()</code>函数的调用由WSGI服务器来实现。最简单的是Python内置了一个WSGI服务器，这个模块叫<code>wsgiref</code>，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。</p>\n<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><p>hello.py,WSGI服务器：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">application</span><span class=\"params\">(environ, start_response)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    start_response(<span class=\"string\">'200 OK'</span>, [(<span class=\"string\">'Content-Type'</span>, <span class=\"string\">'text/html'</span>)])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'&lt;h1&gt;Hello, %s!&lt;/h1&gt;'</span> % (environ[<span class=\"string\">'PATH_INFO'</span>][<span class=\"number\">1</span><span class=\"symbol\">:</span>] <span class=\"keyword\">or</span> <span class=\"string\">'web'</span>) <span class=\"comment\">#返回URL的后一部分</span></span><br></pre></td></tr></table></figure></p>\n<p>server.py，负责启动WSGI服务器，加载application()函数：<br><figure class=\"highlight coffeescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> wsgiref.simple_server <span class=\"keyword\">import</span> make_server</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> hello <span class=\"keyword\">import</span> application</span><br><span class=\"line\"></span><br><span class=\"line\">httpd = make_server(<span class=\"string\">''</span>, <span class=\"number\">8000</span>, application)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">\"Serving HTTP on port 8000...\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">httpd.serve_forever()</span><br></pre></td></tr></table></figure></p>\n<p>无论多么复杂的Web应用程序，入口都是一个WSGI处理函数。HTTP请求的所有输入信息都可以通过environ获得，HTTP响应的输出都可以通过start_response()加上函数返回值作为Body。</p>\n<p>复杂的Web应用程序，光靠一个WSGI函数来处理还是太底层了，我们需要在WSGI之上再抽象出Web框架，进一步简化Web开发。</p>\n<h2 id=\"使用Web框架\"><a href=\"#使用Web框架\" class=\"headerlink\" title=\"使用Web框架\"></a>使用Web框架</h2><p>了解了WSGI框架，我们发现：其实一个Web App，就是写一个WSGI的处理函数，针对每个HTTP请求进行响应。</p>\n<p>那如果有一百个网页需要响应呢？</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>和官方文档的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"初探python(2)函数","date":"2016-09-19T14:14:50.000Z","_content":"\nPython内置了很多有用的函数，我们可以直接调用。\n\n如果要在函数内调用全局函数，应使用`global`。\n\n## 函数定义\n在Python中，函数的定义要用`def`，下面给一个示例。\n```\ndef my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n```\n<!-- more -->\n如果没有`return`语句，函数执行完毕后也会返回结果，只是结果为`None`。\n`return None`可以简写为`return`。\n\n## 空函数\n想定义一个空函数，可以用`pass`语句。`pass`可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个`pass`，让代码能运行起来。\n\n## 参数检查\n调用函数时，如果参数个数不对，`Python`解释器会自动检查出来，并抛出`TypeError`。\n而参数类型的错误则无法检查，应该在定义函数时完善。让我们修改一下`my_abs`的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数`isinstance`实现(isinstance用来判断变量类型)：\n```\ndef my_abs(x):\n    if not isinstance(x, (int, float)):\n        raise TypeError('bad operand type')\n    if x >= 0:\n        return x\n    else:\n        return -x\n```\n##　返回多个值\npython可以返回多个值是以元组(tuple)来实现的。返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值。\n\n## 默认参数\n默认参数用法都与其他语言保持一致。用法如下：\n1.必选参数在前，默认参数在后，否则Python的解释器会报错\n2.二是如何设置默认参数。\n\n当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。\n使用默认参数有什么好处？最大的好处是能降低调用函数的难度。\n\n定义默认参数要牢记一点：默认参数必须指向不变对象！\n```\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n可以用上述说的None这个不可变对象来实现。\n\n为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。\n\n## 可变参数\n\n如果要定义不定数量的参数的话，我们首先想到可以把a，b，c……作为一个`list`或`tuple`传进来。也可以使用可变参数。\n```\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n```\n定义可变参数和定义`list`或`tuple`参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。\n\n如果要传入一个已经写好的`tuple`的话，Python允许你在`list`或`tuple`前面加一个*号，把`list`或`tuple`的元素变成可变参数传进去：\n```\nnums = [1, 2, 3]\ncalc(*nums)\n//14\n```\n\n## 关键字参数\n\n关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个`dict`。\n```\ndef person(name, age, **kw):\n    print 'name:', name, 'age:', age, 'other:', kw\n```\n\n在调用该函数时，可以只传入必选参数,不填关键字参数\n```\nperson('Bob', 35, city='Beijing')\nname: Bob age: 35 other: {'city': 'Beijing'}\nperson('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n```\n也可传入任意值。\n\n关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过*\\*kw传入：func(**{'a': 1, 'b': 2})。\n\n## 递归函数\n递归的使用方法与其他相同，即自身调用自身。\n```\ndef fact(n):\n    if n==1:\n        return 1\n    return n * fact(n - 1)\n```\n\n**使用递归函数需要注意防止栈溢出。**\n\n函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。\n\n解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。\n\n尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。\n\n上面的`fact(n)`函数由于`return n * fact(n - 1)`引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：\n```\ndef fact(n):\n    return fact_iter(n, 1)\n\ndef fact_iter(num, product):\n    if num == 1:\n        return product\n    return fact_iter(num - 1, num * product)\n```\n可是，Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","source":"_posts/python/初探python(2)函数.md","raw":"---\ntitle: 初探python(2)函数\ndate: 2016-09-19 22:14:50\ntags: \n- python\n- python教程\ncategories: 总结\n---\n\nPython内置了很多有用的函数，我们可以直接调用。\n\n如果要在函数内调用全局函数，应使用`global`。\n\n## 函数定义\n在Python中，函数的定义要用`def`，下面给一个示例。\n```\ndef my_abs(x):\n    if x >= 0:\n        return x\n    else:\n        return -x\n```\n<!-- more -->\n如果没有`return`语句，函数执行完毕后也会返回结果，只是结果为`None`。\n`return None`可以简写为`return`。\n\n## 空函数\n想定义一个空函数，可以用`pass`语句。`pass`可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个`pass`，让代码能运行起来。\n\n## 参数检查\n调用函数时，如果参数个数不对，`Python`解释器会自动检查出来，并抛出`TypeError`。\n而参数类型的错误则无法检查，应该在定义函数时完善。让我们修改一下`my_abs`的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数`isinstance`实现(isinstance用来判断变量类型)：\n```\ndef my_abs(x):\n    if not isinstance(x, (int, float)):\n        raise TypeError('bad operand type')\n    if x >= 0:\n        return x\n    else:\n        return -x\n```\n##　返回多个值\npython可以返回多个值是以元组(tuple)来实现的。返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值。\n\n## 默认参数\n默认参数用法都与其他语言保持一致。用法如下：\n1.必选参数在前，默认参数在后，否则Python的解释器会报错\n2.二是如何设置默认参数。\n\n当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。\n使用默认参数有什么好处？最大的好处是能降低调用函数的难度。\n\n定义默认参数要牢记一点：默认参数必须指向不变对象！\n```\ndef add_end(L=None):\n    if L is None:\n        L = []\n    L.append('END')\n    return L\n```\n可以用上述说的None这个不可变对象来实现。\n\n为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。\n\n## 可变参数\n\n如果要定义不定数量的参数的话，我们首先想到可以把a，b，c……作为一个`list`或`tuple`传进来。也可以使用可变参数。\n```\ndef calc(*numbers):\n    sum = 0\n    for n in numbers:\n        sum = sum + n * n\n    return sum\n```\n定义可变参数和定义`list`或`tuple`参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。\n\n如果要传入一个已经写好的`tuple`的话，Python允许你在`list`或`tuple`前面加一个*号，把`list`或`tuple`的元素变成可变参数传进去：\n```\nnums = [1, 2, 3]\ncalc(*nums)\n//14\n```\n\n## 关键字参数\n\n关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个`dict`。\n```\ndef person(name, age, **kw):\n    print 'name:', name, 'age:', age, 'other:', kw\n```\n\n在调用该函数时，可以只传入必选参数,不填关键字参数\n```\nperson('Bob', 35, city='Beijing')\nname: Bob age: 35 other: {'city': 'Beijing'}\nperson('Adam', 45, gender='M', job='Engineer')\nname: Adam age: 45 other: {'gender': 'M', 'job': 'Engineer'}\n```\n也可传入任意值。\n\n关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过*\\*kw传入：func(**{'a': 1, 'b': 2})。\n\n## 递归函数\n递归的使用方法与其他相同，即自身调用自身。\n```\ndef fact(n):\n    if n==1:\n        return 1\n    return n * fact(n - 1)\n```\n\n**使用递归函数需要注意防止栈溢出。**\n\n函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。\n\n解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。\n\n尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。\n\n上面的`fact(n)`函数由于`return n * fact(n - 1)`引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：\n```\ndef fact(n):\n    return fact_iter(n, 1)\n\ndef fact_iter(num, product):\n    if num == 1:\n        return product\n    return fact_iter(num - 1, num * product)\n```\n可是，Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","slug":"python/初探python(2)函数","published":1,"updated":"2019-03-22T14:44:36.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwn002l4l3n4k011915","content":"<p>Python内置了很多有用的函数，我们可以直接调用。</p>\n<p>如果要在函数内调用全局函数，应使用<code>global</code>。</p>\n<h2 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h2><p>在Python中，函数的定义要用<code>def</code>，下面给一个示例。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_abs</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -x</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<br><code>return None</code>可以简写为<code>return</code>。</p>\n<h2 id=\"空函数\"><a href=\"#空函数\" class=\"headerlink\" title=\"空函数\"></a>空函数</h2><p>想定义一个空函数，可以用<code>pass</code>语句。<code>pass</code>可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。</p>\n<h2 id=\"参数检查\"><a href=\"#参数检查\" class=\"headerlink\" title=\"参数检查\"></a>参数检查</h2><p>调用函数时，如果参数个数不对，<code>Python</code>解释器会自动检查出来，并抛出<code>TypeError</code>。<br>而参数类型的错误则无法检查，应该在定义函数时完善。让我们修改一下<code>my_abs</code>的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数<code>isinstance</code>实现(isinstance用来判断变量类型)：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_abs</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(x, (int, float)):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">'bad operand type'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -x</span><br></pre></td></tr></table></figure></p>\n<p>##　返回多个值<br>python可以返回多个值是以元组(tuple)来实现的。返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值。</p>\n<h2 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h2><p>默认参数用法都与其他语言保持一致。用法如下：<br>1.必选参数在前，默认参数在后，否则Python的解释器会报错<br>2.二是如何设置默认参数。</p>\n<p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。<br>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</p>\n<p>定义默认参数要牢记一点：默认参数必须指向不变对象！<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> L <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        L = []</span><br><span class=\"line\">    L.append(<span class=\"string\">'END'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L</span><br></pre></td></tr></table></figure></p>\n<p>可以用上述说的None这个不可变对象来实现。</p>\n<p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>\n<h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><p>如果要定义不定数量的参数的话，我们首先想到可以把a，b，c……作为一个<code>list</code>或<code>tuple</code>传进来。也可以使用可变参数。<br><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def calc(*numbers)<span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    for <span class=\"built_in\">n</span> in numbe<span class=\"symbol\">rs:</span></span><br><span class=\"line\">        <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span> + <span class=\"built_in\">n</span> * <span class=\"built_in\">n</span></span><br><span class=\"line\">    return <span class=\"built_in\">sum</span></span><br></pre></td></tr></table></figure></p>\n<p>定义可变参数和定义<code>list</code>或<code>tuple</code>参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。</p>\n<p>如果要传入一个已经写好的<code>tuple</code>的话，Python允许你在<code>list</code>或<code>tuple</code>前面加一个*号，把<code>list</code>或<code>tuple</code>的元素变成可变参数传进去：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">calc(*nums)</span><br><span class=\"line\"><span class=\"comment\">//14</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h2><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code>。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">person</span><span class=\"params\">(name, age, **kw)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'other:'</span>, kw</span><br></pre></td></tr></table></figure></p>\n<p>在调用该函数时，可以只传入必选参数,不填关键字参数<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person(<span class=\"string\">'Bob'</span>, <span class=\"number\">35</span>, city=<span class=\"string\">'Beijing'</span>)</span><br><span class=\"line\"><span class=\"string\">name:</span> Bob <span class=\"string\">age:</span> <span class=\"number\">35</span> <span class=\"string\">other:</span> &#123;<span class=\"string\">'city'</span>: <span class=\"string\">'Beijing'</span>&#125;</span><br><span class=\"line\">person(<span class=\"string\">'Adam'</span>, <span class=\"number\">45</span>, gender=<span class=\"string\">'M'</span>, job=<span class=\"string\">'Engineer'</span>)</span><br><span class=\"line\"><span class=\"string\">name:</span> Adam <span class=\"string\">age:</span> <span class=\"number\">45</span> <span class=\"string\">other:</span> &#123;<span class=\"string\">'gender'</span>: <span class=\"string\">'M'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可传入任意值。</p>\n<p>关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过<em>\\</em>kw传入：func(**{‘a’: 1, ‘b’: 2})。</p>\n<h2 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h2><p>递归的使用方法与其他相同，即自身调用自身。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fact</span><span class=\"params\">(n)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n==<span class=\"number\">1</span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n * fact(n - <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<p><strong>使用递归函数需要注意防止栈溢出。</strong></p>\n<p>函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>\n<p>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>\n<p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>\n<p>上面的<code>fact(n)</code>函数由于<code>return n * fact(n - 1)</code>引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：<br><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fact(n):</span><br><span class=\"line\">    <span class=\"built_in\">return</span> fact_iter(n, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">def fact_iter(<span class=\"built_in\">num</span>, <span class=\"built_in\">product</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">num</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"built_in\">product</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> fact_iter(<span class=\"built_in\">num</span> - <span class=\"number\">1</span>, <span class=\"built_in\">num</span> * <span class=\"built_in\">product</span>)</span><br></pre></td></tr></table></figure></p>\n<p>可是，Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Python内置了很多有用的函数，我们可以直接调用。</p>\n<p>如果要在函数内调用全局函数，应使用<code>global</code>。</p>\n<h2 id=\"函数定义\"><a href=\"#函数定义\" class=\"headerlink\" title=\"函数定义\"></a>函数定义</h2><p>在Python中，函数的定义要用<code>def</code>，下面给一个示例。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_abs</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -x</span><br></pre></td></tr></table></figure></p>","more":"<p>如果没有<code>return</code>语句，函数执行完毕后也会返回结果，只是结果为<code>None</code>。<br><code>return None</code>可以简写为<code>return</code>。</p>\n<h2 id=\"空函数\"><a href=\"#空函数\" class=\"headerlink\" title=\"空函数\"></a>空函数</h2><p>想定义一个空函数，可以用<code>pass</code>语句。<code>pass</code>可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个<code>pass</code>，让代码能运行起来。</p>\n<h2 id=\"参数检查\"><a href=\"#参数检查\" class=\"headerlink\" title=\"参数检查\"></a>参数检查</h2><p>调用函数时，如果参数个数不对，<code>Python</code>解释器会自动检查出来，并抛出<code>TypeError</code>。<br>而参数类型的错误则无法检查，应该在定义函数时完善。让我们修改一下<code>my_abs</code>的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数<code>isinstance</code>实现(isinstance用来判断变量类型)：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">my_abs</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(x, (int, float)):</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">'bad operand type'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> x</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> -x</span><br></pre></td></tr></table></figure></p>\n<p>##　返回多个值<br>python可以返回多个值是以元组(tuple)来实现的。返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值。</p>\n<h2 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h2><p>默认参数用法都与其他语言保持一致。用法如下：<br>1.必选参数在前，默认参数在后，否则Python的解释器会报错<br>2.二是如何设置默认参数。</p>\n<p>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。<br>使用默认参数有什么好处？最大的好处是能降低调用函数的难度。</p>\n<p>定义默认参数要牢记一点：默认参数必须指向不变对象！<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add_end</span><span class=\"params\">(L=None)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> L <span class=\"keyword\">is</span> <span class=\"keyword\">None</span>:</span><br><span class=\"line\">        L = []</span><br><span class=\"line\">    L.append(<span class=\"string\">'END'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> L</span><br></pre></td></tr></table></figure></p>\n<p>可以用上述说的None这个不可变对象来实现。</p>\n<p>为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。</p>\n<h2 id=\"可变参数\"><a href=\"#可变参数\" class=\"headerlink\" title=\"可变参数\"></a>可变参数</h2><p>如果要定义不定数量的参数的话，我们首先想到可以把a，b，c……作为一个<code>list</code>或<code>tuple</code>传进来。也可以使用可变参数。<br><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def calc(*numbers)<span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"built_in\">sum</span> = <span class=\"number\">0</span></span><br><span class=\"line\">    for <span class=\"built_in\">n</span> in numbe<span class=\"symbol\">rs:</span></span><br><span class=\"line\">        <span class=\"built_in\">sum</span> = <span class=\"built_in\">sum</span> + <span class=\"built_in\">n</span> * <span class=\"built_in\">n</span></span><br><span class=\"line\">    return <span class=\"built_in\">sum</span></span><br></pre></td></tr></table></figure></p>\n<p>定义可变参数和定义<code>list</code>或<code>tuple</code>参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数。</p>\n<p>如果要传入一个已经写好的<code>tuple</code>的话，Python允许你在<code>list</code>或<code>tuple</code>前面加一个*号，把<code>list</code>或<code>tuple</code>的元素变成可变参数传进去：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>]</span><br><span class=\"line\">calc(*nums)</span><br><span class=\"line\"><span class=\"comment\">//14</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关键字参数\"><a href=\"#关键字参数\" class=\"headerlink\" title=\"关键字参数\"></a>关键字参数</h2><p>关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code>。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">person</span><span class=\"params\">(name, age, **kw)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'name:'</span>, name, <span class=\"string\">'age:'</span>, age, <span class=\"string\">'other:'</span>, kw</span><br></pre></td></tr></table></figure></p>\n<p>在调用该函数时，可以只传入必选参数,不填关键字参数<br><figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">person(<span class=\"string\">'Bob'</span>, <span class=\"number\">35</span>, city=<span class=\"string\">'Beijing'</span>)</span><br><span class=\"line\"><span class=\"string\">name:</span> Bob <span class=\"string\">age:</span> <span class=\"number\">35</span> <span class=\"string\">other:</span> &#123;<span class=\"string\">'city'</span>: <span class=\"string\">'Beijing'</span>&#125;</span><br><span class=\"line\">person(<span class=\"string\">'Adam'</span>, <span class=\"number\">45</span>, gender=<span class=\"string\">'M'</span>, job=<span class=\"string\">'Engineer'</span>)</span><br><span class=\"line\"><span class=\"string\">name:</span> Adam <span class=\"string\">age:</span> <span class=\"number\">45</span> <span class=\"string\">other:</span> &#123;<span class=\"string\">'gender'</span>: <span class=\"string\">'M'</span>, <span class=\"string\">'job'</span>: <span class=\"string\">'Engineer'</span>&#125;</span><br></pre></td></tr></table></figure></p>\n<p>也可传入任意值。</p>\n<p>关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过<em>\\</em>kw传入：func(**{‘a’: 1, ‘b’: 2})。</p>\n<h2 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h2><p>递归的使用方法与其他相同，即自身调用自身。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fact</span><span class=\"params\">(n)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> n==<span class=\"number\">1</span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> n * fact(n - <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<p><strong>使用递归函数需要注意防止栈溢出。</strong></p>\n<p>函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。</p>\n<p>解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。</p>\n<p>尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。</p>\n<p>上面的<code>fact(n)</code>函数由于<code>return n * fact(n - 1)</code>引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：<br><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fact(n):</span><br><span class=\"line\">    <span class=\"built_in\">return</span> fact_iter(n, <span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">def fact_iter(<span class=\"built_in\">num</span>, <span class=\"built_in\">product</span>):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"built_in\">num</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"built_in\">return</span> <span class=\"built_in\">product</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> fact_iter(<span class=\"built_in\">num</span> - <span class=\"number\">1</span>, <span class=\"built_in\">num</span> * <span class=\"built_in\">product</span>)</span><br></pre></td></tr></table></figure></p>\n<p>可是，Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"初探python(5)模块","date":"2016-09-26T12:14:50.000Z","_content":"\n\n随着代码越写越长，越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样件，每个文包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。\n<!-- more -->\n## 模块的好处\n1.大大提高了代码的可维护性。\n2.编写代码不必从零开始。\n3.使用模块还可以避免函数名和变量名冲突。即使变量名相同只要模块不同也没关系。\n\n## 包\n那如果有同名的模块怎么办？Python又引入了按目录来组织模块的方法，称为包（Package）。\n\n可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。假设包名为mycompany，那其中的abc.py模块的名字就变成了mycompany.abc。\n\n请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。\n\n## 使用模块\n\nPython本身就内置了很多非常有用的模块，我们可以立刻使用。\n\n使用模块的第一步，就是`import`对应的模块。\n```\nimport sys\n\n```\n这样就可以有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。\n\nsys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：\n\n运行python hello.py获得的sys.argv就是['hello.py']；\n\n运行python hello.py Michael获得的sys.argv就是['hello.py', 'Michael]\n```\nif __name__=='__main__':\n    test()\n```\nPython解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。\n\n## 别名\n导入模块时，还可以使用别名，这样，可以在运行时根据当前环境选择最合适的模块。也可以方便调用。\n比如Python标准库一般会提供StringIO和cStringIO两个库，这两个库的接口和功能是一样的，但是cStringIO是C写的，速度更快，所以，你会经常看到这样的写法：\n```\ntry:\n    import cStringIO as StringIO\nexcept ImportError: # 导入失败会捕获到ImportError\n    import StringIO\n```\n即优先导入`cStringIO`。如果有些平台不提供`cStringIO`，还可以降级使用`StringIO`。\n\n## 作用域\n当然，我们也可以通过不同的命名方式来设置作用域来作用变量的使用范围。\n\n正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；\n\n类似`__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途，但是有特殊用途，比如上面的`__author__`，`__name__`就是特殊变量，文档注释也可以用特殊变量`__doc__`访问，我们自己的变量一般不要用这种变量名。\n\n类似`_xxx`和`__xxx`这样的函数或变量就是非公开的（private），不应该被直接引用，比如`_abc`，`__abc`等；\n\n之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。\n\n## 安装第三方模块\n在Python中，安装第三方模块，是通过setuptools这个工具完成的。Python有两个封装了setuptools的包管理工具：easy_install和pip。目前官方推荐使用pip。\n\n要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow，因此，安装Pillow的命令就是：\n\npip install Pillow\n耐心等待下载并安装后，就可以使用Pillow了。\n\n## 模块搜索路径\n当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。\n\n默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。\n\n如果我们要添加自己的搜索目录，有两种方法：\n\n1.直接修改`sys.path`。添加要搜索的目录:\n```\nimport sys\nsys.path.append('/Users/michael/my_py_scripts')\n```\n\n这种方法是在运行时修改，运行结束后失效。\n\n2.设置环境变量`PYTHONPATH`，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。\n\n## 使用`__future__`\nPython的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。\n要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。\n\nPython提供了`__future__`模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。\n```\nfrom __future__ import unicode_literals\n```\n\n由于Python是由社区推动的开源并且免费的开发语言，不受商业公司控制，因此，Python的改进往往比较激进，不兼容的情况时有发生。Python为了确保你能顺利过渡到新版本，特别提供了`__future__`模块，让你在旧的版本中试验新版本的一些特性。\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","source":"_posts/python/初探python(5)模块.md","raw":"---\ntitle: 初探python(5)模块\ndate: 2016-09-26 20:14:50\ntags: \n- python\n- python教程\ncategories: 总结\n---\n\n\n随着代码越写越长，越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样件，每个文包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。\n<!-- more -->\n## 模块的好处\n1.大大提高了代码的可维护性。\n2.编写代码不必从零开始。\n3.使用模块还可以避免函数名和变量名冲突。即使变量名相同只要模块不同也没关系。\n\n## 包\n那如果有同名的模块怎么办？Python又引入了按目录来组织模块的方法，称为包（Package）。\n\n可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。假设包名为mycompany，那其中的abc.py模块的名字就变成了mycompany.abc。\n\n请注意，每一个包目录下面都会有一个__init__.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。__init__.py可以是空文件，也可以有Python代码，因为__init__.py本身就是一个模块，而它的模块名就是mycompany。\n\n## 使用模块\n\nPython本身就内置了很多非常有用的模块，我们可以立刻使用。\n\n使用模块的第一步，就是`import`对应的模块。\n```\nimport sys\n\n```\n这样就可以有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。\n\nsys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：\n\n运行python hello.py获得的sys.argv就是['hello.py']；\n\n运行python hello.py Michael获得的sys.argv就是['hello.py', 'Michael]\n```\nif __name__=='__main__':\n    test()\n```\nPython解释器把一个特殊变量__name__置为__main__，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。\n\n## 别名\n导入模块时，还可以使用别名，这样，可以在运行时根据当前环境选择最合适的模块。也可以方便调用。\n比如Python标准库一般会提供StringIO和cStringIO两个库，这两个库的接口和功能是一样的，但是cStringIO是C写的，速度更快，所以，你会经常看到这样的写法：\n```\ntry:\n    import cStringIO as StringIO\nexcept ImportError: # 导入失败会捕获到ImportError\n    import StringIO\n```\n即优先导入`cStringIO`。如果有些平台不提供`cStringIO`，还可以降级使用`StringIO`。\n\n## 作用域\n当然，我们也可以通过不同的命名方式来设置作用域来作用变量的使用范围。\n\n正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；\n\n类似`__xxx__`这样的变量是特殊变量，可以被直接引用，但是有特殊用途，但是有特殊用途，比如上面的`__author__`，`__name__`就是特殊变量，文档注释也可以用特殊变量`__doc__`访问，我们自己的变量一般不要用这种变量名。\n\n类似`_xxx`和`__xxx`这样的函数或变量就是非公开的（private），不应该被直接引用，比如`_abc`，`__abc`等；\n\n之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。\n\n## 安装第三方模块\n在Python中，安装第三方模块，是通过setuptools这个工具完成的。Python有两个封装了setuptools的包管理工具：easy_install和pip。目前官方推荐使用pip。\n\n要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow，因此，安装Pillow的命令就是：\n\npip install Pillow\n耐心等待下载并安装后，就可以使用Pillow了。\n\n## 模块搜索路径\n当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。\n\n默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。\n\n如果我们要添加自己的搜索目录，有两种方法：\n\n1.直接修改`sys.path`。添加要搜索的目录:\n```\nimport sys\nsys.path.append('/Users/michael/my_py_scripts')\n```\n\n这种方法是在运行时修改，运行结束后失效。\n\n2.设置环境变量`PYTHONPATH`，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。\n\n## 使用`__future__`\nPython的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。\n要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。\n\nPython提供了`__future__`模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。\n```\nfrom __future__ import unicode_literals\n```\n\n由于Python是由社区推动的开源并且免费的开发语言，不受商业公司控制，因此，Python的改进往往比较激进，不兼容的情况时有发生。Python为了确保你能顺利过渡到新版本，特别提供了`__future__`模块，让你在旧的版本中试验新版本的一些特性。\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","slug":"python/初探python(5)模块","published":1,"updated":"2019-03-22T14:44:36.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwo002o4l3n7ocyxggo","content":"<p>随着代码越写越长，越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样件，每个文包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。<br><a id=\"more\"></a></p>\n<h2 id=\"模块的好处\"><a href=\"#模块的好处\" class=\"headerlink\" title=\"模块的好处\"></a>模块的好处</h2><p>1.大大提高了代码的可维护性。<br>2.编写代码不必从零开始。<br>3.使用模块还可以避免函数名和变量名冲突。即使变量名相同只要模块不同也没关系。</p>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>那如果有同名的模块怎么办？Python又引入了按目录来组织模块的方法，称为包（Package）。</p>\n<p>可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。假设包名为mycompany，那其中的abc.py模块的名字就变成了mycompany.abc。</p>\n<p>请注意，每一个包目录下面都会有一个<strong>init</strong>.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<strong>init</strong>.py可以是空文件，也可以有Python代码，因为<strong>init</strong>.py本身就是一个模块，而它的模块名就是mycompany。</p>\n<h2 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h2><p>Python本身就内置了很多非常有用的模块，我们可以立刻使用。</p>\n<p>使用模块的第一步，就是<code>import</code>对应的模块。<br><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。</p>\n<p>sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：</p>\n<p>运行python hello.py获得的sys.argv就是[‘hello.py’]；</p>\n<p>运行python hello.py Michael获得的sys.argv就是[‘hello.py’, ‘Michael]<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"built_in\">test</span>()</span><br></pre></td></tr></table></figure></p>\n<p>Python解释器把一个特殊变量<strong>name</strong>置为<strong>main</strong>，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>\n<h2 id=\"别名\"><a href=\"#别名\" class=\"headerlink\" title=\"别名\"></a>别名</h2><p>导入模块时，还可以使用别名，这样，可以在运行时根据当前环境选择最合适的模块。也可以方便调用。<br>比如Python标准库一般会提供StringIO和cStringIO两个库，这两个库的接口和功能是一样的，但是cStringIO是C写的，速度更快，所以，你会经常看到这样的写法：<br><figure class=\"highlight nimrod\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> cStringIO <span class=\"keyword\">as</span> <span class=\"type\">StringIO</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> <span class=\"type\">ImportError</span>: <span class=\"comment\"># 导入失败会捕获到ImportError</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> <span class=\"type\">StringIO</span></span><br></pre></td></tr></table></figure></p>\n<p>即优先导入<code>cStringIO</code>。如果有些平台不提供<code>cStringIO</code>，还可以降级使用<code>StringIO</code>。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>当然，我们也可以通过不同的命名方式来设置作用域来作用变量的使用范围。</p>\n<p>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；</p>\n<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名。</p>\n<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p>\n<p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>\n<h2 id=\"安装第三方模块\"><a href=\"#安装第三方模块\" class=\"headerlink\" title=\"安装第三方模块\"></a>安装第三方模块</h2><p>在Python中，安装第三方模块，是通过setuptools这个工具完成的。Python有两个封装了setuptools的包管理工具：easy_install和pip。目前官方推荐使用pip。</p>\n<p>要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow，因此，安装Pillow的命令就是：</p>\n<p>pip install Pillow<br>耐心等待下载并安装后，就可以使用Pillow了。</p>\n<h2 id=\"模块搜索路径\"><a href=\"#模块搜索路径\" class=\"headerlink\" title=\"模块搜索路径\"></a>模块搜索路径</h2><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。</p>\n<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。</p>\n<p>如果我们要添加自己的搜索目录，有两种方法：</p>\n<p>1.直接修改<code>sys.path</code>。添加要搜索的目录:<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sys</span><br><span class=\"line\">sys<span class=\"selector-class\">.path</span><span class=\"selector-class\">.append</span>(<span class=\"string\">'/Users/michael/my_py_scripts'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这种方法是在运行时修改，运行结束后失效。</p>\n<p>2.设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>\n<h2 id=\"使用-future\"><a href=\"#使用-future\" class=\"headerlink\" title=\"使用__future__\"></a>使用<code>__future__</code></h2><p>Python的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。<br>要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。</p>\n<p>Python提供了<code>__future__</code>模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。<br><figure class=\"highlight capnproto\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> unicode_literals</span><br></pre></td></tr></table></figure></p>\n<p>由于Python是由社区推动的开源并且免费的开发语言，不受商业公司控制，因此，Python的改进往往比较激进，不兼容的情况时有发生。Python为了确保你能顺利过渡到新版本，特别提供了<code>__future__</code>模块，让你在旧的版本中试验新版本的一些特性。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>随着代码越写越长，越不容易维护。为了编写可维护的代码，我们把很多函数分组，分别放到不同的文件里，这样件，每个文包含的代码就相对较少，很多编程语言都采用这种组织代码的方式。在Python中，一个.py文件就称之为一个模块（Module）。<br></p>","more":"<p></p>\n<h2 id=\"模块的好处\"><a href=\"#模块的好处\" class=\"headerlink\" title=\"模块的好处\"></a>模块的好处</h2><p>1.大大提高了代码的可维护性。<br>2.编写代码不必从零开始。<br>3.使用模块还可以避免函数名和变量名冲突。即使变量名相同只要模块不同也没关系。</p>\n<h2 id=\"包\"><a href=\"#包\" class=\"headerlink\" title=\"包\"></a>包</h2><p>那如果有同名的模块怎么办？Python又引入了按目录来组织模块的方法，称为包（Package）。</p>\n<p>可以通过包来组织模块，避免冲突。方法是选择一个顶层包名，引入了包以后，只要顶层的包名不与别人冲突，那所有模块都不会与别人冲突。假设包名为mycompany，那其中的abc.py模块的名字就变成了mycompany.abc。</p>\n<p>请注意，每一个包目录下面都会有一个<strong>init</strong>.py的文件，这个文件是必须存在的，否则，Python就把这个目录当成普通目录，而不是一个包。<strong>init</strong>.py可以是空文件，也可以有Python代码，因为<strong>init</strong>.py本身就是一个模块，而它的模块名就是mycompany。</p>\n<h2 id=\"使用模块\"><a href=\"#使用模块\" class=\"headerlink\" title=\"使用模块\"></a>使用模块</h2><p>Python本身就内置了很多非常有用的模块，我们可以立刻使用。</p>\n<p>使用模块的第一步，就是<code>import</code>对应的模块。<br><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能。</p>\n<p>sys模块有一个argv变量，用list存储了命令行的所有参数。argv至少有一个元素，因为第一个参数永远是该.py文件的名称，例如：</p>\n<p>运行python hello.py获得的sys.argv就是[‘hello.py’]；</p>\n<p>运行python hello.py Michael获得的sys.argv就是[‘hello.py’, ‘Michael]<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"built_in\">test</span>()</span><br></pre></td></tr></table></figure></p>\n<p>Python解释器把一个特殊变量<strong>name</strong>置为<strong>main</strong>，而如果在其他地方导入该hello模块时，if判断将失败，因此，这种if测试可以让一个模块通过命令行运行时执行一些额外的代码，最常见的就是运行测试。</p>\n<h2 id=\"别名\"><a href=\"#别名\" class=\"headerlink\" title=\"别名\"></a>别名</h2><p>导入模块时，还可以使用别名，这样，可以在运行时根据当前环境选择最合适的模块。也可以方便调用。<br>比如Python标准库一般会提供StringIO和cStringIO两个库，这两个库的接口和功能是一样的，但是cStringIO是C写的，速度更快，所以，你会经常看到这样的写法：<br><figure class=\"highlight nimrod\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> cStringIO <span class=\"keyword\">as</span> <span class=\"type\">StringIO</span></span><br><span class=\"line\"><span class=\"keyword\">except</span> <span class=\"type\">ImportError</span>: <span class=\"comment\"># 导入失败会捕获到ImportError</span></span><br><span class=\"line\">    <span class=\"keyword\">import</span> <span class=\"type\">StringIO</span></span><br></pre></td></tr></table></figure></p>\n<p>即优先导入<code>cStringIO</code>。如果有些平台不提供<code>cStringIO</code>，还可以降级使用<code>StringIO</code>。</p>\n<h2 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h2><p>当然，我们也可以通过不同的命名方式来设置作用域来作用变量的使用范围。</p>\n<p>正常的函数和变量名是公开的（public），可以被直接引用，比如：abc，x123，PI等；</p>\n<p>类似<code>__xxx__</code>这样的变量是特殊变量，可以被直接引用，但是有特殊用途，但是有特殊用途，比如上面的<code>__author__</code>，<code>__name__</code>就是特殊变量，文档注释也可以用特殊变量<code>__doc__</code>访问，我们自己的变量一般不要用这种变量名。</p>\n<p>类似<code>_xxx</code>和<code>__xxx</code>这样的函数或变量就是非公开的（private），不应该被直接引用，比如<code>_abc</code>，<code>__abc</code>等；</p>\n<p>之所以我们说，private函数和变量“不应该”被直接引用，而不是“不能”被直接引用，是因为Python并没有一种方法可以完全限制访问private函数或变量，但是，从编程习惯上不应该引用private函数或变量。</p>\n<h2 id=\"安装第三方模块\"><a href=\"#安装第三方模块\" class=\"headerlink\" title=\"安装第三方模块\"></a>安装第三方模块</h2><p>在Python中，安装第三方模块，是通过setuptools这个工具完成的。Python有两个封装了setuptools的包管理工具：easy_install和pip。目前官方推荐使用pip。</p>\n<p>要安装一个第三方库，必须先知道该库的名称，可以在官网或者pypi上搜索，比如Pillow，因此，安装Pillow的命令就是：</p>\n<p>pip install Pillow<br>耐心等待下载并安装后，就可以使用Pillow了。</p>\n<h2 id=\"模块搜索路径\"><a href=\"#模块搜索路径\" class=\"headerlink\" title=\"模块搜索路径\"></a>模块搜索路径</h2><p>当我们试图加载一个模块时，Python会在指定的路径下搜索对应的.py文件，如果找不到，就会报错。</p>\n<p>默认情况下，Python解释器会搜索当前目录、所有已安装的内置模块和第三方模块，搜索路径存放在sys模块的path变量中。</p>\n<p>如果我们要添加自己的搜索目录，有两种方法：</p>\n<p>1.直接修改<code>sys.path</code>。添加要搜索的目录:<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import sys</span><br><span class=\"line\">sys<span class=\"selector-class\">.path</span><span class=\"selector-class\">.append</span>(<span class=\"string\">'/Users/michael/my_py_scripts'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这种方法是在运行时修改，运行结束后失效。</p>\n<p>2.设置环境变量<code>PYTHONPATH</code>，该环境变量的内容会被自动添加到模块搜索路径中。设置方式与设置Path环境变量类似。注意只需要添加你自己的搜索路径，Python自己本身的搜索路径不受影响。</p>\n<h2 id=\"使用-future\"><a href=\"#使用-future\" class=\"headerlink\" title=\"使用__future__\"></a>使用<code>__future__</code></h2><p>Python的每个新版本都会增加一些新的功能，或者对原来的功能作一些改动。<br>要直接把代码升级到3.x是比较冒进的，因为有大量的改动需要测试。相反，可以在2.7版本中先在一部分代码中测试一些3.x的特性，如果没有问题，再移植到3.x不迟。</p>\n<p>Python提供了<code>__future__</code>模块，把下一个新版本的特性导入到当前版本，于是我们就可以在当前版本中测试一些新版本的特性。<br><figure class=\"highlight capnproto\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> __future__ <span class=\"keyword\">import</span> unicode_literals</span><br></pre></td></tr></table></figure></p>\n<p>由于Python是由社区推动的开源并且免费的开发语言，不受商业公司控制，因此，Python的改进往往比较激进，不兼容的情况时有发生。Python为了确保你能顺利过渡到新版本，特别提供了<code>__future__</code>模块，让你在旧的版本中试验新版本的一些特性。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"初探python(6)面向对象编程","date":"2016-10-06T12:26:30.000Z","_content":"\n\n面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。\n\n由于这一章在C++中学的不错，所以内容较少。\n<!-- more -->\n## 面向对象与面向过程的区别\n之前的面向过程的程序设计是把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。\n\n而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。\n\n在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。\n\n面向对象的设计思想更为自然，但其抽象程度要高于函数，另外，还有其三大特点：数据封装、继承和多态。\n\n## 类和实例\n\n类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。\n\n```\nclass student(object):\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n    def print_imformation(self):\n        print \"your name is %s,your number is %s\" % (self.name, self.number)\n\n```\n`class`后跟类名，`object`指的是继承的类，如果没有合适的类，就用object类，所有类都会最终继承它。\n`__init__` 方法第一个参数是`self`，表示创建的实例本身，并且调用的时候，不用传递该参数。其他和普通函数没有什么区别。从而实现了对数据的封装。\n\n好处其一：方便调用，不需要知道内部实现细节；\n其二：可以给类增加新的方法。\n\n## 访问限制\n\n如果要让内部属性不被外部访问，可以把属性的名称前面加两个下划线，在`Python`中，这样就成了私有变量，只有内部可以访问。\n\n如果希望在外部进行访问和修改，可以增加`get_name`和`set_name`这样的方法：\n```\n    def get_name(self):\n        return self.__name\n\n    def set_name(self):\n        self.__name = name\n\n```\n需要注意的是，变量名是以双下划线开头，并且双下划线结尾的是特殊变量，特殊变量是可以直接访问的。\n\n另外，变量名以一个下划线开头的，这样的实例变量其实可以外部访问，但按照约定俗称的规定，看到这样的变量时，应该讲他看做私有变量，不要随意访问。\n\n双划线开头的实例变量不是一定不能访问，不能直接访问·`__name`是因为Python解释器对外把`__name`变量改成了`_Student__name`，所以，仍然可以通过`_Student__name`来访问`__name`变量。\n\n但是强烈建议不能这么干，不同版本的Python解释器可能会把`__name`改为不同的变量名。\n\n## 继承和多态\n\n当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。\n\n继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写；\n\n有了继承，才能有多态。在调用类实例方法的时候，尽量把变量视作父类类型，这样，所有子类类型都可以正常被接收；\n\n## 获取对象信息\n\n当我们拿到一个对象的引用时，如道这个对象是什么类型？有什么方法呢？\n\n### type()\n基本类型都可以用type()函数来判断。\n另外，有一种类型就叫`TypeType`，所有类型本身的类型就是`TypeType`。\n\n```\ntype(123)\n```\n### isinstance()\n\n对于class的继承关系，使用`type()`就很不方便。我们要判断`class`的类型，可以使用`isinistance()`函数。\n\n### dir()\n使用dir()函数可以获得一个对象的所有属性和方法。类似`__xxx__`的属性和方法在Python中都是有特殊用途的,比如`__len__`方法返回长度。在Python中，如果你调用`len()`函数试图获取一个对象的长度，实际上，在`len()`函数内部，它自动去调用该对象的`__len__()`方法。\n\n因此，我们自己写的类，如果也想用`len(myObj)`的话，就自己写一个`__len__()`方法。\n\n## 操作对象的状态\n\n我们可以通过`getattr()`、`setattr()`以及`hasattr()`来操作对象的属性(attribute)。\n\n```\n#getattr() 得到属性值\n\n#setattr() 设置属性值\n\n#hasattr() 查看是否有该属性\n\n\n\nclass MyObject(object):\n    def __init__(self):\n        self.x = 9\n\n    def power(self):\n        return self.x * self.x\n\nobj = MyObject()\nprint hasattr(obj, 'x')\nprint hasattr(obj, 'y')\nsetattr(obj, 'y', 19)\nprint hasattr(obj, 'y')\nprint getattr(obj, 'y'，404)  #如果值不存在返回值404\nn = getattr(obj, 'power')\nprint n()\n\n# 输出结果：true，false，true，19，81\n\n```\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","source":"_posts/python/初探python(6)面向对象编程.md","raw":"---\ntitle: 初探python(6)面向对象编程\ndate: 2016-10-06 20:26:30\ntags: \n- python\n- python教程\ncategories: 总结\n---\n\n\n面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。\n\n由于这一章在C++中学的不错，所以内容较少。\n<!-- more -->\n## 面向对象与面向过程的区别\n之前的面向过程的程序设计是把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。\n\n而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。\n\n在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。\n\n面向对象的设计思想更为自然，但其抽象程度要高于函数，另外，还有其三大特点：数据封装、继承和多态。\n\n## 类和实例\n\n类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。\n\n```\nclass student(object):\n    def __init__(self, name, score):\n        self.name = name\n        self.score = score\n    def print_imformation(self):\n        print \"your name is %s,your number is %s\" % (self.name, self.number)\n\n```\n`class`后跟类名，`object`指的是继承的类，如果没有合适的类，就用object类，所有类都会最终继承它。\n`__init__` 方法第一个参数是`self`，表示创建的实例本身，并且调用的时候，不用传递该参数。其他和普通函数没有什么区别。从而实现了对数据的封装。\n\n好处其一：方便调用，不需要知道内部实现细节；\n其二：可以给类增加新的方法。\n\n## 访问限制\n\n如果要让内部属性不被外部访问，可以把属性的名称前面加两个下划线，在`Python`中，这样就成了私有变量，只有内部可以访问。\n\n如果希望在外部进行访问和修改，可以增加`get_name`和`set_name`这样的方法：\n```\n    def get_name(self):\n        return self.__name\n\n    def set_name(self):\n        self.__name = name\n\n```\n需要注意的是，变量名是以双下划线开头，并且双下划线结尾的是特殊变量，特殊变量是可以直接访问的。\n\n另外，变量名以一个下划线开头的，这样的实例变量其实可以外部访问，但按照约定俗称的规定，看到这样的变量时，应该讲他看做私有变量，不要随意访问。\n\n双划线开头的实例变量不是一定不能访问，不能直接访问·`__name`是因为Python解释器对外把`__name`变量改成了`_Student__name`，所以，仍然可以通过`_Student__name`来访问`__name`变量。\n\n但是强烈建议不能这么干，不同版本的Python解释器可能会把`__name`改为不同的变量名。\n\n## 继承和多态\n\n当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。\n\n继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写；\n\n有了继承，才能有多态。在调用类实例方法的时候，尽量把变量视作父类类型，这样，所有子类类型都可以正常被接收；\n\n## 获取对象信息\n\n当我们拿到一个对象的引用时，如道这个对象是什么类型？有什么方法呢？\n\n### type()\n基本类型都可以用type()函数来判断。\n另外，有一种类型就叫`TypeType`，所有类型本身的类型就是`TypeType`。\n\n```\ntype(123)\n```\n### isinstance()\n\n对于class的继承关系，使用`type()`就很不方便。我们要判断`class`的类型，可以使用`isinistance()`函数。\n\n### dir()\n使用dir()函数可以获得一个对象的所有属性和方法。类似`__xxx__`的属性和方法在Python中都是有特殊用途的,比如`__len__`方法返回长度。在Python中，如果你调用`len()`函数试图获取一个对象的长度，实际上，在`len()`函数内部，它自动去调用该对象的`__len__()`方法。\n\n因此，我们自己写的类，如果也想用`len(myObj)`的话，就自己写一个`__len__()`方法。\n\n## 操作对象的状态\n\n我们可以通过`getattr()`、`setattr()`以及`hasattr()`来操作对象的属性(attribute)。\n\n```\n#getattr() 得到属性值\n\n#setattr() 设置属性值\n\n#hasattr() 查看是否有该属性\n\n\n\nclass MyObject(object):\n    def __init__(self):\n        self.x = 9\n\n    def power(self):\n        return self.x * self.x\n\nobj = MyObject()\nprint hasattr(obj, 'x')\nprint hasattr(obj, 'y')\nsetattr(obj, 'y', 19)\nprint hasattr(obj, 'y')\nprint getattr(obj, 'y'，404)  #如果值不存在返回值404\nn = getattr(obj, 'power')\nprint n()\n\n# 输出结果：true，false，true，19，81\n\n```\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","slug":"python/初探python(6)面向对象编程","published":1,"updated":"2019-03-22T14:44:36.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwr002r4l3nxhloh25h","content":"<p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>\n<p>由于这一章在C++中学的不错，所以内容较少。<br><a id=\"more\"></a></p>\n<h2 id=\"面向对象与面向过程的区别\"><a href=\"#面向对象与面向过程的区别\" class=\"headerlink\" title=\"面向对象与面向过程的区别\"></a>面向对象与面向过程的区别</h2><p>之前的面向过程的程序设计是把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>\n<p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>\n<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p>\n<p>面向对象的设计思想更为自然，但其抽象程度要高于函数，另外，还有其三大特点：数据封装、继承和多态。</p>\n<h2 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h2><p>类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, name, score)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.score = score</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_imformation</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        print <span class=\"string\">\"your name is %s,your number is %s\"</span> % (<span class=\"keyword\">self</span>.name, <span class=\"keyword\">self</span>.number)</span><br></pre></td></tr></table></figure>\n<p><code>class</code>后跟类名，<code>object</code>指的是继承的类，如果没有合适的类，就用object类，所有类都会最终继承它。<br><code>__init__</code> 方法第一个参数是<code>self</code>，表示创建的实例本身，并且调用的时候，不用传递该参数。其他和普通函数没有什么区别。从而实现了对数据的封装。</p>\n<p>好处其一：方便调用，不需要知道内部实现细节；<br>其二：可以给类增加新的方法。</p>\n<h2 id=\"访问限制\"><a href=\"#访问限制\" class=\"headerlink\" title=\"访问限制\"></a>访问限制</h2><p>如果要让内部属性不被外部访问，可以把属性的名称前面加两个下划线，在<code>Python</code>中，这样就成了私有变量，只有内部可以访问。</p>\n<p>如果希望在外部进行访问和修改，可以增加<code>get_name</code>和<code>set_name</code>这样的方法：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_name</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.__name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_name</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.__name = name</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，变量名是以双下划线开头，并且双下划线结尾的是特殊变量，特殊变量是可以直接访问的。</p>\n<p>另外，变量名以一个下划线开头的，这样的实例变量其实可以外部访问，但按照约定俗称的规定，看到这样的变量时，应该讲他看做私有变量，不要随意访问。</p>\n<p>双划线开头的实例变量不是一定不能访问，不能直接访问·<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量。</p>\n<p>但是强烈建议不能这么干，不同版本的Python解释器可能会把<code>__name</code>改为不同的变量名。</p>\n<h2 id=\"继承和多态\"><a href=\"#继承和多态\" class=\"headerlink\" title=\"继承和多态\"></a>继承和多态</h2><p>当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>\n<p>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写；</p>\n<p>有了继承，才能有多态。在调用类实例方法的时候，尽量把变量视作父类类型，这样，所有子类类型都可以正常被接收；</p>\n<h2 id=\"获取对象信息\"><a href=\"#获取对象信息\" class=\"headerlink\" title=\"获取对象信息\"></a>获取对象信息</h2><p>当我们拿到一个对象的引用时，如道这个对象是什么类型？有什么方法呢？</p>\n<h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type()\"></a>type()</h3><p>基本类型都可以用type()函数来判断。<br>另外，有一种类型就叫<code>TypeType</code>，所有类型本身的类型就是<code>TypeType</code>。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span>(123)</span><br></pre></td></tr></table></figure>\n<h3 id=\"isinstance\"><a href=\"#isinstance\" class=\"headerlink\" title=\"isinstance()\"></a>isinstance()</h3><p>对于class的继承关系，使用<code>type()</code>就很不方便。我们要判断<code>class</code>的类型，可以使用<code>isinistance()</code>函数。</p>\n<h3 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir()\"></a>dir()</h3><p>使用dir()函数可以获得一个对象的所有属性和方法。类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的,比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法。</p>\n<p>因此，我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法。</p>\n<h2 id=\"操作对象的状态\"><a href=\"#操作对象的状态\" class=\"headerlink\" title=\"操作对象的状态\"></a>操作对象的状态</h2><p>我们可以通过<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>来操作对象的属性(attribute)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#getattr() 得到属性值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#setattr() 设置属性值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#hasattr() 查看是否有该属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.x = <span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.x * self.x</span><br><span class=\"line\"></span><br><span class=\"line\">obj = MyObject()</span><br><span class=\"line\"><span class=\"keyword\">print</span> hasattr(obj, <span class=\"string\">'x'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> hasattr(obj, <span class=\"string\">'y'</span>)</span><br><span class=\"line\">setattr(obj, <span class=\"string\">'y'</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> hasattr(obj, <span class=\"string\">'y'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> getattr(obj, <span class=\"string\">'y'</span>，<span class=\"number\">404</span>)  <span class=\"comment\">#如果值不存在返回值404</span></span><br><span class=\"line\">n = getattr(obj, <span class=\"string\">'power'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> n()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果：true，false，true，19，81</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>面向对象编程——Object Oriented Programming，简称OOP，是一种程序设计思想。OOP把对象作为程序的基本单元，一个对象包含了数据和操作数据的函数。</p>\n<p>由于这一章在C++中学的不错，所以内容较少。<br></p>","more":"<p></p>\n<h2 id=\"面向对象与面向过程的区别\"><a href=\"#面向对象与面向过程的区别\" class=\"headerlink\" title=\"面向对象与面向过程的区别\"></a>面向对象与面向过程的区别</h2><p>之前的面向过程的程序设计是把计算机程序视为一系列的命令集合，即一组函数的顺序执行。为了简化程序设计，面向过程把函数继续切分为子函数，即把大块函数通过切割成小块函数来降低系统的复杂度。</p>\n<p>而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>\n<p>在Python中，所有数据类型都可以视为对象，当然也可以自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p>\n<p>面向对象的设计思想更为自然，但其抽象程度要高于函数，另外，还有其三大特点：数据封装、继承和多态。</p>\n<h2 id=\"类和实例\"><a href=\"#类和实例\" class=\"headerlink\" title=\"类和实例\"></a>类和实例</h2><p>类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, name, score)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.score = score</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">print_imformation</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        print <span class=\"string\">\"your name is %s,your number is %s\"</span> % (<span class=\"keyword\">self</span>.name, <span class=\"keyword\">self</span>.number)</span><br></pre></td></tr></table></figure>\n<p><code>class</code>后跟类名，<code>object</code>指的是继承的类，如果没有合适的类，就用object类，所有类都会最终继承它。<br><code>__init__</code> 方法第一个参数是<code>self</code>，表示创建的实例本身，并且调用的时候，不用传递该参数。其他和普通函数没有什么区别。从而实现了对数据的封装。</p>\n<p>好处其一：方便调用，不需要知道内部实现细节；<br>其二：可以给类增加新的方法。</p>\n<h2 id=\"访问限制\"><a href=\"#访问限制\" class=\"headerlink\" title=\"访问限制\"></a>访问限制</h2><p>如果要让内部属性不被外部访问，可以把属性的名称前面加两个下划线，在<code>Python</code>中，这样就成了私有变量，只有内部可以访问。</p>\n<p>如果希望在外部进行访问和修改，可以增加<code>get_name</code>和<code>set_name</code>这样的方法：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_name</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.__name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_name</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">self</span>.__name = name</span><br></pre></td></tr></table></figure></p>\n<p>需要注意的是，变量名是以双下划线开头，并且双下划线结尾的是特殊变量，特殊变量是可以直接访问的。</p>\n<p>另外，变量名以一个下划线开头的，这样的实例变量其实可以外部访问，但按照约定俗称的规定，看到这样的变量时，应该讲他看做私有变量，不要随意访问。</p>\n<p>双划线开头的实例变量不是一定不能访问，不能直接访问·<code>__name</code>是因为Python解释器对外把<code>__name</code>变量改成了<code>_Student__name</code>，所以，仍然可以通过<code>_Student__name</code>来访问<code>__name</code>变量。</p>\n<p>但是强烈建议不能这么干，不同版本的Python解释器可能会把<code>__name</code>改为不同的变量名。</p>\n<h2 id=\"继承和多态\"><a href=\"#继承和多态\" class=\"headerlink\" title=\"继承和多态\"></a>继承和多态</h2><p>当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p>\n<p>继承可以把父类的所有功能都直接拿过来，这样就不必重零做起，子类只需要新增自己特有的方法，也可以把父类不适合的方法覆盖重写；</p>\n<p>有了继承，才能有多态。在调用类实例方法的时候，尽量把变量视作父类类型，这样，所有子类类型都可以正常被接收；</p>\n<h2 id=\"获取对象信息\"><a href=\"#获取对象信息\" class=\"headerlink\" title=\"获取对象信息\"></a>获取对象信息</h2><p>当我们拿到一个对象的引用时，如道这个对象是什么类型？有什么方法呢？</p>\n<h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type()\"></a>type()</h3><p>基本类型都可以用type()函数来判断。<br>另外，有一种类型就叫<code>TypeType</code>，所有类型本身的类型就是<code>TypeType</code>。</p>\n<figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">type</span>(123)</span><br></pre></td></tr></table></figure>\n<h3 id=\"isinstance\"><a href=\"#isinstance\" class=\"headerlink\" title=\"isinstance()\"></a>isinstance()</h3><p>对于class的继承关系，使用<code>type()</code>就很不方便。我们要判断<code>class</code>的类型，可以使用<code>isinistance()</code>函数。</p>\n<h3 id=\"dir\"><a href=\"#dir\" class=\"headerlink\" title=\"dir()\"></a>dir()</h3><p>使用dir()函数可以获得一个对象的所有属性和方法。类似<code>__xxx__</code>的属性和方法在Python中都是有特殊用途的,比如<code>__len__</code>方法返回长度。在Python中，如果你调用<code>len()</code>函数试图获取一个对象的长度，实际上，在<code>len()</code>函数内部，它自动去调用该对象的<code>__len__()</code>方法。</p>\n<p>因此，我们自己写的类，如果也想用<code>len(myObj)</code>的话，就自己写一个<code>__len__()</code>方法。</p>\n<h2 id=\"操作对象的状态\"><a href=\"#操作对象的状态\" class=\"headerlink\" title=\"操作对象的状态\"></a>操作对象的状态</h2><p>我们可以通过<code>getattr()</code>、<code>setattr()</code>以及<code>hasattr()</code>来操作对象的属性(attribute)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#getattr() 得到属性值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#setattr() 设置属性值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#hasattr() 查看是否有该属性</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyObject</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        self.x = <span class=\"number\">9</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">power</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self.x * self.x</span><br><span class=\"line\"></span><br><span class=\"line\">obj = MyObject()</span><br><span class=\"line\"><span class=\"keyword\">print</span> hasattr(obj, <span class=\"string\">'x'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> hasattr(obj, <span class=\"string\">'y'</span>)</span><br><span class=\"line\">setattr(obj, <span class=\"string\">'y'</span>, <span class=\"number\">19</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> hasattr(obj, <span class=\"string\">'y'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> getattr(obj, <span class=\"string\">'y'</span>，<span class=\"number\">404</span>)  <span class=\"comment\">#如果值不存在返回值404</span></span><br><span class=\"line\">n = getattr(obj, <span class=\"string\">'power'</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> n()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 输出结果：true，false，true，19，81</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"项目管理实战","date":"2016-04-20T14:49:22.000Z","_content":"\n### 项目的分类\n项目管理实战分为五个部分,项目准备,项目计划,项目沟通, 项目过程管理, 项目验收与总结.\n 很多人在项目准备和项目总结上都没有做好工作,实际这个是项目经验累积的关键点所在.\n 首先,一个步要明确的是: 这个项目是属于什么类的?\n 研发类的项目一般分为:研发项目, 售前项目和售后项目;\n研发项目主要针对功能实现;\n售前项目主要面向客户打单,目的是为了销售,想要拿下客户,研发这个部分不一定参与\n售后项目主要目的是为了让别人用起来,跟点上线。\n<!-- more -->\n### 项目准备的关键项\n1. 项目目标：挖掘项目需求,指定方向\n2. 项目要求: 需要你进行识别并界定范围,范围是指更加细化的内容,需要每个人都知道的线\n3. 项目干系人: 包括项目内外部甚至双方可能用到的人力资源\n4. 项目资源: 包括人和人以外的资源\n5. 项目路径: 包括目标达成的方式,执行所需的策略;\n6. 项目关键点: 路径上必须经过的关键点以及关键要素\n\n### **忠告**\n1. 项目的起点在哪?\n2. 拿到项目先别急着动手.做好前期深入的项目分析思考,好的准备才会水到渠成.\n\n### 项目案例\n案例一: 草船借箭\n三天得到十万支箭\n1. 项目目标: 三天,十万支箭\n2. 项目要求: 不要让周瑜知道;三天内得到十万支箭;\n3. 项目干系人: 诸葛亮;周瑜;鲁肃;曹操;\n4. 项目资源: 船;人;兵;稻草;\n5. 项目路径: a. 拉鲁肃入伙; b.准备稻草人和船; c.借箭时间出发准备; d.借箭归时路径;\n6. 项目关键点: 1.搞定鲁肃; 2.天气; 3.时间的把握;\n\n案例二: 空城计\n\n\n### 项目计划\n项目计划需要包括的内容有:\n1. 项目时间计划\n2. 项目成本计划\n3. 项目人力资源计划\n4. 项目风险识别\n5. 项目管理计划","source":"_posts/todo/项目管理实战.md","raw":"---\ntitle: 项目管理实战\ndate: 2016-04-20 22:49:22\ntags:\n- 项目管理\ncategories: 管理\n---\n\n### 项目的分类\n项目管理实战分为五个部分,项目准备,项目计划,项目沟通, 项目过程管理, 项目验收与总结.\n 很多人在项目准备和项目总结上都没有做好工作,实际这个是项目经验累积的关键点所在.\n 首先,一个步要明确的是: 这个项目是属于什么类的?\n 研发类的项目一般分为:研发项目, 售前项目和售后项目;\n研发项目主要针对功能实现;\n售前项目主要面向客户打单,目的是为了销售,想要拿下客户,研发这个部分不一定参与\n售后项目主要目的是为了让别人用起来,跟点上线。\n<!-- more -->\n### 项目准备的关键项\n1. 项目目标：挖掘项目需求,指定方向\n2. 项目要求: 需要你进行识别并界定范围,范围是指更加细化的内容,需要每个人都知道的线\n3. 项目干系人: 包括项目内外部甚至双方可能用到的人力资源\n4. 项目资源: 包括人和人以外的资源\n5. 项目路径: 包括目标达成的方式,执行所需的策略;\n6. 项目关键点: 路径上必须经过的关键点以及关键要素\n\n### **忠告**\n1. 项目的起点在哪?\n2. 拿到项目先别急着动手.做好前期深入的项目分析思考,好的准备才会水到渠成.\n\n### 项目案例\n案例一: 草船借箭\n三天得到十万支箭\n1. 项目目标: 三天,十万支箭\n2. 项目要求: 不要让周瑜知道;三天内得到十万支箭;\n3. 项目干系人: 诸葛亮;周瑜;鲁肃;曹操;\n4. 项目资源: 船;人;兵;稻草;\n5. 项目路径: a. 拉鲁肃入伙; b.准备稻草人和船; c.借箭时间出发准备; d.借箭归时路径;\n6. 项目关键点: 1.搞定鲁肃; 2.天气; 3.时间的把握;\n\n案例二: 空城计\n\n\n### 项目计划\n项目计划需要包括的内容有:\n1. 项目时间计划\n2. 项目成本计划\n3. 项目人力资源计划\n4. 项目风险识别\n5. 项目管理计划","slug":"todo/项目管理实战","published":1,"updated":"2019-05-04T15:44:28.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmws002u4l3n7x6nxqok","content":"<h3 id=\"项目的分类\"><a href=\"#项目的分类\" class=\"headerlink\" title=\"项目的分类\"></a>项目的分类</h3><p>项目管理实战分为五个部分,项目准备,项目计划,项目沟通, 项目过程管理, 项目验收与总结.<br> 很多人在项目准备和项目总结上都没有做好工作,实际这个是项目经验累积的关键点所在.<br> 首先,一个步要明确的是: 这个项目是属于什么类的?<br> 研发类的项目一般分为:研发项目, 售前项目和售后项目;<br>研发项目主要针对功能实现;<br>售前项目主要面向客户打单,目的是为了销售,想要拿下客户,研发这个部分不一定参与<br>售后项目主要目的是为了让别人用起来,跟点上线。<br><a id=\"more\"></a></p>\n<h3 id=\"项目准备的关键项\"><a href=\"#项目准备的关键项\" class=\"headerlink\" title=\"项目准备的关键项\"></a>项目准备的关键项</h3><ol>\n<li>项目目标：挖掘项目需求,指定方向</li>\n<li>项目要求: 需要你进行识别并界定范围,范围是指更加细化的内容,需要每个人都知道的线</li>\n<li>项目干系人: 包括项目内外部甚至双方可能用到的人力资源</li>\n<li>项目资源: 包括人和人以外的资源</li>\n<li>项目路径: 包括目标达成的方式,执行所需的策略;</li>\n<li>项目关键点: 路径上必须经过的关键点以及关键要素</li>\n</ol>\n<h3 id=\"忠告\"><a href=\"#忠告\" class=\"headerlink\" title=\"忠告\"></a><strong>忠告</strong></h3><ol>\n<li>项目的起点在哪?</li>\n<li>拿到项目先别急着动手.做好前期深入的项目分析思考,好的准备才会水到渠成.</li>\n</ol>\n<h3 id=\"项目案例\"><a href=\"#项目案例\" class=\"headerlink\" title=\"项目案例\"></a>项目案例</h3><p>案例一: 草船借箭<br>三天得到十万支箭</p>\n<ol>\n<li>项目目标: 三天,十万支箭</li>\n<li>项目要求: 不要让周瑜知道;三天内得到十万支箭;</li>\n<li>项目干系人: 诸葛亮;周瑜;鲁肃;曹操;</li>\n<li>项目资源: 船;人;兵;稻草;</li>\n<li>项目路径: a. 拉鲁肃入伙; b.准备稻草人和船; c.借箭时间出发准备; d.借箭归时路径;</li>\n<li>项目关键点: 1.搞定鲁肃; 2.天气; 3.时间的把握;</li>\n</ol>\n<p>案例二: 空城计</p>\n<h3 id=\"项目计划\"><a href=\"#项目计划\" class=\"headerlink\" title=\"项目计划\"></a>项目计划</h3><p>项目计划需要包括的内容有:</p>\n<ol>\n<li>项目时间计划</li>\n<li>项目成本计划</li>\n<li>项目人力资源计划</li>\n<li>项目风险识别</li>\n<li>项目管理计划</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"项目的分类\"><a href=\"#项目的分类\" class=\"headerlink\" title=\"项目的分类\"></a>项目的分类</h3><p>项目管理实战分为五个部分,项目准备,项目计划,项目沟通, 项目过程管理, 项目验收与总结.<br> 很多人在项目准备和项目总结上都没有做好工作,实际这个是项目经验累积的关键点所在.<br> 首先,一个步要明确的是: 这个项目是属于什么类的?<br> 研发类的项目一般分为:研发项目, 售前项目和售后项目;<br>研发项目主要针对功能实现;<br>售前项目主要面向客户打单,目的是为了销售,想要拿下客户,研发这个部分不一定参与<br>售后项目主要目的是为了让别人用起来,跟点上线。<br></p>","more":"<p></p>\n<h3 id=\"项目准备的关键项\"><a href=\"#项目准备的关键项\" class=\"headerlink\" title=\"项目准备的关键项\"></a>项目准备的关键项</h3><ol>\n<li>项目目标：挖掘项目需求,指定方向</li>\n<li>项目要求: 需要你进行识别并界定范围,范围是指更加细化的内容,需要每个人都知道的线</li>\n<li>项目干系人: 包括项目内外部甚至双方可能用到的人力资源</li>\n<li>项目资源: 包括人和人以外的资源</li>\n<li>项目路径: 包括目标达成的方式,执行所需的策略;</li>\n<li>项目关键点: 路径上必须经过的关键点以及关键要素</li>\n</ol>\n<h3 id=\"忠告\"><a href=\"#忠告\" class=\"headerlink\" title=\"忠告\"></a><strong>忠告</strong></h3><ol>\n<li>项目的起点在哪?</li>\n<li>拿到项目先别急着动手.做好前期深入的项目分析思考,好的准备才会水到渠成.</li>\n</ol>\n<h3 id=\"项目案例\"><a href=\"#项目案例\" class=\"headerlink\" title=\"项目案例\"></a>项目案例</h3><p>案例一: 草船借箭<br>三天得到十万支箭</p>\n<ol>\n<li>项目目标: 三天,十万支箭</li>\n<li>项目要求: 不要让周瑜知道;三天内得到十万支箭;</li>\n<li>项目干系人: 诸葛亮;周瑜;鲁肃;曹操;</li>\n<li>项目资源: 船;人;兵;稻草;</li>\n<li>项目路径: a. 拉鲁肃入伙; b.准备稻草人和船; c.借箭时间出发准备; d.借箭归时路径;</li>\n<li>项目关键点: 1.搞定鲁肃; 2.天气; 3.时间的把握;</li>\n</ol>\n<p>案例二: 空城计</p>\n<h3 id=\"项目计划\"><a href=\"#项目计划\" class=\"headerlink\" title=\"项目计划\"></a>项目计划</h3><p>项目计划需要包括的内容有:</p>\n<ol>\n<li>项目时间计划</li>\n<li>项目成本计划</li>\n<li>项目人力资源计划</li>\n<li>项目风险识别</li>\n<li>项目管理计划</li>\n</ol>"},{"title":"计算机科学课","date":"2019-07-26T14:49:22.000Z","_content":"\n### 计算机早期历史\n\nAt each increase of knowledge,as well as on the contrivance of every new tool. --Charles Barbbage 计算之父\n<!-- more -->\n\n\n每当人类增长了新的知识，创造了新的工具，人类劳力将会降低。\n\n最早的计算设备是算盘。Computer从指代职业到变成指代机器。\nBarbbage发明步进计算器，第一个可以加减乘除的机器。从而取代了人工劳力。\n在战争中，为了计算精准炮弹轨迹，通过查表来做，但是每次改炮台设计，都要重新做表。\n此时，Barbbage提出了差分机。在构造差分机期间，想出了分析机，也为后续的通用计算机打下了基础。\n\nLovelace是给分析机写假想程序的，因此成为了第一位程序员。\n\n美国政府人口普查，10年一次，项目底下。\nHerman Hollerith 打孔卡片制表机，手工的十倍\n成立了制表机器公司，也就是后续的IBM。\n\n### 电子计算机\n\n哈佛马克一号，最大的机电计算机之一，IBM制造，给二战使用。\n给曼哈顿计划跑模拟。\n\n机械继电器 1秒50次开关，慢，磨损，会出bug。\n\n在哈佛马克二号故障的继电器中发现一只死虫。\nGrace Hopper曾说：每当电脑出现故障，我们就说他除了bug(虫子)。这也正是bug的来源。\n\n因此需要寻找替代品。\n1904年，英国物理学家 约翰·安布罗斯·佛莱明发明了热电子管。\n三级真空管，玻璃制，真空管，编程麻烦，需要配置。\n1946年，ENIAC第一个通用可编程计算机。\n1947年，贝尔实验室做出了晶体管，1秒10000次开关。由于很多晶体管和半导体都在一个地方开发，而生产半导体最常见的材料就是因此命名为硅谷。\n肖克力半导体 -> 仙童半导体 -> 英特尔\n\n\n\n\n\n\n\n\n","source":"_posts/todo/计算机科学课.md","raw":"---\ntitle: 计算机科学课\ndate: 2019-07-26 22:49:22\ntags:\n- 计算机科学\ncategories: 学习\n---\n\n### 计算机早期历史\n\nAt each increase of knowledge,as well as on the contrivance of every new tool. --Charles Barbbage 计算之父\n<!-- more -->\n\n\n每当人类增长了新的知识，创造了新的工具，人类劳力将会降低。\n\n最早的计算设备是算盘。Computer从指代职业到变成指代机器。\nBarbbage发明步进计算器，第一个可以加减乘除的机器。从而取代了人工劳力。\n在战争中，为了计算精准炮弹轨迹，通过查表来做，但是每次改炮台设计，都要重新做表。\n此时，Barbbage提出了差分机。在构造差分机期间，想出了分析机，也为后续的通用计算机打下了基础。\n\nLovelace是给分析机写假想程序的，因此成为了第一位程序员。\n\n美国政府人口普查，10年一次，项目底下。\nHerman Hollerith 打孔卡片制表机，手工的十倍\n成立了制表机器公司，也就是后续的IBM。\n\n### 电子计算机\n\n哈佛马克一号，最大的机电计算机之一，IBM制造，给二战使用。\n给曼哈顿计划跑模拟。\n\n机械继电器 1秒50次开关，慢，磨损，会出bug。\n\n在哈佛马克二号故障的继电器中发现一只死虫。\nGrace Hopper曾说：每当电脑出现故障，我们就说他除了bug(虫子)。这也正是bug的来源。\n\n因此需要寻找替代品。\n1904年，英国物理学家 约翰·安布罗斯·佛莱明发明了热电子管。\n三级真空管，玻璃制，真空管，编程麻烦，需要配置。\n1946年，ENIAC第一个通用可编程计算机。\n1947年，贝尔实验室做出了晶体管，1秒10000次开关。由于很多晶体管和半导体都在一个地方开发，而生产半导体最常见的材料就是因此命名为硅谷。\n肖克力半导体 -> 仙童半导体 -> 英特尔\n\n\n\n\n\n\n\n\n","slug":"todo/计算机科学课","published":1,"updated":"2019-07-26T15:24:54.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwu002x4l3n5ewve0s8","content":"<h3 id=\"计算机早期历史\"><a href=\"#计算机早期历史\" class=\"headerlink\" title=\"计算机早期历史\"></a>计算机早期历史</h3><p>At each increase of knowledge,as well as on the contrivance of every new tool. –Charles Barbbage 计算之父<br><a id=\"more\"></a></p>\n<p>每当人类增长了新的知识，创造了新的工具，人类劳力将会降低。</p>\n<p>最早的计算设备是算盘。Computer从指代职业到变成指代机器。<br>Barbbage发明步进计算器，第一个可以加减乘除的机器。从而取代了人工劳力。<br>在战争中，为了计算精准炮弹轨迹，通过查表来做，但是每次改炮台设计，都要重新做表。<br>此时，Barbbage提出了差分机。在构造差分机期间，想出了分析机，也为后续的通用计算机打下了基础。</p>\n<p>Lovelace是给分析机写假想程序的，因此成为了第一位程序员。</p>\n<p>美国政府人口普查，10年一次，项目底下。<br>Herman Hollerith 打孔卡片制表机，手工的十倍<br>成立了制表机器公司，也就是后续的IBM。</p>\n<h3 id=\"电子计算机\"><a href=\"#电子计算机\" class=\"headerlink\" title=\"电子计算机\"></a>电子计算机</h3><p>哈佛马克一号，最大的机电计算机之一，IBM制造，给二战使用。<br>给曼哈顿计划跑模拟。</p>\n<p>机械继电器 1秒50次开关，慢，磨损，会出bug。</p>\n<p>在哈佛马克二号故障的继电器中发现一只死虫。<br>Grace Hopper曾说：每当电脑出现故障，我们就说他除了bug(虫子)。这也正是bug的来源。</p>\n<p>因此需要寻找替代品。<br>1904年，英国物理学家 约翰·安布罗斯·佛莱明发明了热电子管。<br>三级真空管，玻璃制，真空管，编程麻烦，需要配置。<br>1946年，ENIAC第一个通用可编程计算机。<br>1947年，贝尔实验室做出了晶体管，1秒10000次开关。由于很多晶体管和半导体都在一个地方开发，而生产半导体最常见的材料就是因此命名为硅谷。<br>肖克力半导体 -&gt; 仙童半导体 -&gt; 英特尔</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"计算机早期历史\"><a href=\"#计算机早期历史\" class=\"headerlink\" title=\"计算机早期历史\"></a>计算机早期历史</h3><p>At each increase of knowledge,as well as on the contrivance of every new tool. –Charles Barbbage 计算之父<br></p>","more":"<p></p>\n<p>每当人类增长了新的知识，创造了新的工具，人类劳力将会降低。</p>\n<p>最早的计算设备是算盘。Computer从指代职业到变成指代机器。<br>Barbbage发明步进计算器，第一个可以加减乘除的机器。从而取代了人工劳力。<br>在战争中，为了计算精准炮弹轨迹，通过查表来做，但是每次改炮台设计，都要重新做表。<br>此时，Barbbage提出了差分机。在构造差分机期间，想出了分析机，也为后续的通用计算机打下了基础。</p>\n<p>Lovelace是给分析机写假想程序的，因此成为了第一位程序员。</p>\n<p>美国政府人口普查，10年一次，项目底下。<br>Herman Hollerith 打孔卡片制表机，手工的十倍<br>成立了制表机器公司，也就是后续的IBM。</p>\n<h3 id=\"电子计算机\"><a href=\"#电子计算机\" class=\"headerlink\" title=\"电子计算机\"></a>电子计算机</h3><p>哈佛马克一号，最大的机电计算机之一，IBM制造，给二战使用。<br>给曼哈顿计划跑模拟。</p>\n<p>机械继电器 1秒50次开关，慢，磨损，会出bug。</p>\n<p>在哈佛马克二号故障的继电器中发现一只死虫。<br>Grace Hopper曾说：每当电脑出现故障，我们就说他除了bug(虫子)。这也正是bug的来源。</p>\n<p>因此需要寻找替代品。<br>1904年，英国物理学家 约翰·安布罗斯·佛莱明发明了热电子管。<br>三级真空管，玻璃制，真空管，编程麻烦，需要配置。<br>1946年，ENIAC第一个通用可编程计算机。<br>1947年，贝尔实验室做出了晶体管，1秒10000次开关。由于很多晶体管和半导体都在一个地方开发，而生产半导体最常见的材料就是因此命名为硅谷。<br>肖克力半导体 -&gt; 仙童半导体 -&gt; 英特尔</p>"},{"title":"财务报表学习","date":"2007-04-06T12:22:00.000Z","_content":"\n企业主要的三项活动\n\n经营活动-> 融资活动 -> 投资活动\n\n1. 资产负债表: 描述企业财务状况,投融资情况,是家底，心脏。\n2. 利润表: 描述企业经营情况,是面子，四肢。\n3. 现金流量表:描述现金变化的来龙去脉,以及持续经营的风险，是日子，血液。\n\n\n\n\n从资产负债表看资源，从利润表看效益，从现金流量表看效益的质量.\n\n看定义，百度百科是这么解释资产的：资产是指企业过去的交易或事项形成的，由企业拥有或控制的，预期会给企业带来经济利益的资源。资产具有四个特征：资产预期会给企业带来经济效益、资产应为企业控制或者拥有的资源、资产由企业过去的交易或者事项形成、资产必须能够用货币计量。\n\n但是那些不能用货币表现的资产未予显示，他们甚至更加重要。\n\n1. 资本资源。首先是指股权结构或者股东带来的资源，它决定了企业发展的根本方向。资本结构与公司治理、组织行为、公司战略、税务筹划等密切相关。在企业的经营管理中，股东的资源——不仅包括资本资源，还包括许多社会资源——都在企业经营中起着重要作用。许多企业赖以发展的根本资源就是资本资源。\n2. 市场资源。与企业密切相关的市场主要有两个：证券市场和产品市场。对于特定的企业来讲，一定是先有企业的产品市场，才有企业可以去的资本市场。证券市场则能让企业“飞”起来，实现跨越式发展\n3. 人力资源,表外其他资源,如品牌力量等\n\n某种程度上说，企业的表内资源是为表外资源的运转服务的，甚至只是表外资源运行的结果。\n\n在这样的理解下，企业全部资源的经济表现在哪里呢？净资产收益率和商誉。我特别指出，商誉是企业特殊的资产，它没有明确的量的大小，更应该是一种增值的能力，是企业现有状态下全部资源带来的增值能力。\n\n\n\n\n在现行的会计制度下，我们可以用合并报表的净利润分析整个企业集团的盈利能力，但是母公司分红只能使用母公司的净利润为基础\n\n\n\n1.资产负债表需要注意的几个科目\n\n\n\n\n参考：\n[手把手教你分析财报](https://xueqiu.com/7318086163/113922972)","source":"_posts/业务知识总结/业务报表学习1.md","raw":"---\ntitle: 财务报表学习\ndate: 2007-04-06 20:22:00\ntags: \n- 财务报表\ncategories: 总结\n---\n\n企业主要的三项活动\n\n经营活动-> 融资活动 -> 投资活动\n\n1. 资产负债表: 描述企业财务状况,投融资情况,是家底，心脏。\n2. 利润表: 描述企业经营情况,是面子，四肢。\n3. 现金流量表:描述现金变化的来龙去脉,以及持续经营的风险，是日子，血液。\n\n\n\n\n从资产负债表看资源，从利润表看效益，从现金流量表看效益的质量.\n\n看定义，百度百科是这么解释资产的：资产是指企业过去的交易或事项形成的，由企业拥有或控制的，预期会给企业带来经济利益的资源。资产具有四个特征：资产预期会给企业带来经济效益、资产应为企业控制或者拥有的资源、资产由企业过去的交易或者事项形成、资产必须能够用货币计量。\n\n但是那些不能用货币表现的资产未予显示，他们甚至更加重要。\n\n1. 资本资源。首先是指股权结构或者股东带来的资源，它决定了企业发展的根本方向。资本结构与公司治理、组织行为、公司战略、税务筹划等密切相关。在企业的经营管理中，股东的资源——不仅包括资本资源，还包括许多社会资源——都在企业经营中起着重要作用。许多企业赖以发展的根本资源就是资本资源。\n2. 市场资源。与企业密切相关的市场主要有两个：证券市场和产品市场。对于特定的企业来讲，一定是先有企业的产品市场，才有企业可以去的资本市场。证券市场则能让企业“飞”起来，实现跨越式发展\n3. 人力资源,表外其他资源,如品牌力量等\n\n某种程度上说，企业的表内资源是为表外资源的运转服务的，甚至只是表外资源运行的结果。\n\n在这样的理解下，企业全部资源的经济表现在哪里呢？净资产收益率和商誉。我特别指出，商誉是企业特殊的资产，它没有明确的量的大小，更应该是一种增值的能力，是企业现有状态下全部资源带来的增值能力。\n\n\n\n\n在现行的会计制度下，我们可以用合并报表的净利润分析整个企业集团的盈利能力，但是母公司分红只能使用母公司的净利润为基础\n\n\n\n1.资产负债表需要注意的几个科目\n\n\n\n\n参考：\n[手把手教你分析财报](https://xueqiu.com/7318086163/113922972)","slug":"业务知识总结/业务报表学习1","published":1,"updated":"2019-03-22T14:44:36.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwx00314l3nx295dkgt","content":"<p>企业主要的三项活动</p>\n<p>经营活动-&gt; 融资活动 -&gt; 投资活动</p>\n<ol>\n<li>资产负债表: 描述企业财务状况,投融资情况,是家底，心脏。</li>\n<li>利润表: 描述企业经营情况,是面子，四肢。</li>\n<li>现金流量表:描述现金变化的来龙去脉,以及持续经营的风险，是日子，血液。</li>\n</ol>\n<p>从资产负债表看资源，从利润表看效益，从现金流量表看效益的质量.</p>\n<p>看定义，百度百科是这么解释资产的：资产是指企业过去的交易或事项形成的，由企业拥有或控制的，预期会给企业带来经济利益的资源。资产具有四个特征：资产预期会给企业带来经济效益、资产应为企业控制或者拥有的资源、资产由企业过去的交易或者事项形成、资产必须能够用货币计量。</p>\n<p>但是那些不能用货币表现的资产未予显示，他们甚至更加重要。</p>\n<ol>\n<li>资本资源。首先是指股权结构或者股东带来的资源，它决定了企业发展的根本方向。资本结构与公司治理、组织行为、公司战略、税务筹划等密切相关。在企业的经营管理中，股东的资源——不仅包括资本资源，还包括许多社会资源——都在企业经营中起着重要作用。许多企业赖以发展的根本资源就是资本资源。</li>\n<li>市场资源。与企业密切相关的市场主要有两个：证券市场和产品市场。对于特定的企业来讲，一定是先有企业的产品市场，才有企业可以去的资本市场。证券市场则能让企业“飞”起来，实现跨越式发展</li>\n<li>人力资源,表外其他资源,如品牌力量等</li>\n</ol>\n<p>某种程度上说，企业的表内资源是为表外资源的运转服务的，甚至只是表外资源运行的结果。</p>\n<p>在这样的理解下，企业全部资源的经济表现在哪里呢？净资产收益率和商誉。我特别指出，商誉是企业特殊的资产，它没有明确的量的大小，更应该是一种增值的能力，是企业现有状态下全部资源带来的增值能力。</p>\n<p>在现行的会计制度下，我们可以用合并报表的净利润分析整个企业集团的盈利能力，但是母公司分红只能使用母公司的净利润为基础</p>\n<p>1.资产负债表需要注意的几个科目</p>\n<p>参考：<br><a href=\"https://xueqiu.com/7318086163/113922972\" target=\"_blank\" rel=\"noopener\">手把手教你分析财报</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>企业主要的三项活动</p>\n<p>经营活动-&gt; 融资活动 -&gt; 投资活动</p>\n<ol>\n<li>资产负债表: 描述企业财务状况,投融资情况,是家底，心脏。</li>\n<li>利润表: 描述企业经营情况,是面子，四肢。</li>\n<li>现金流量表:描述现金变化的来龙去脉,以及持续经营的风险，是日子，血液。</li>\n</ol>\n<p>从资产负债表看资源，从利润表看效益，从现金流量表看效益的质量.</p>\n<p>看定义，百度百科是这么解释资产的：资产是指企业过去的交易或事项形成的，由企业拥有或控制的，预期会给企业带来经济利益的资源。资产具有四个特征：资产预期会给企业带来经济效益、资产应为企业控制或者拥有的资源、资产由企业过去的交易或者事项形成、资产必须能够用货币计量。</p>\n<p>但是那些不能用货币表现的资产未予显示，他们甚至更加重要。</p>\n<ol>\n<li>资本资源。首先是指股权结构或者股东带来的资源，它决定了企业发展的根本方向。资本结构与公司治理、组织行为、公司战略、税务筹划等密切相关。在企业的经营管理中，股东的资源——不仅包括资本资源，还包括许多社会资源——都在企业经营中起着重要作用。许多企业赖以发展的根本资源就是资本资源。</li>\n<li>市场资源。与企业密切相关的市场主要有两个：证券市场和产品市场。对于特定的企业来讲，一定是先有企业的产品市场，才有企业可以去的资本市场。证券市场则能让企业“飞”起来，实现跨越式发展</li>\n<li>人力资源,表外其他资源,如品牌力量等</li>\n</ol>\n<p>某种程度上说，企业的表内资源是为表外资源的运转服务的，甚至只是表外资源运行的结果。</p>\n<p>在这样的理解下，企业全部资源的经济表现在哪里呢？净资产收益率和商誉。我特别指出，商誉是企业特殊的资产，它没有明确的量的大小，更应该是一种增值的能力，是企业现有状态下全部资源带来的增值能力。</p>\n<p>在现行的会计制度下，我们可以用合并报表的净利润分析整个企业集团的盈利能力，但是母公司分红只能使用母公司的净利润为基础</p>\n<p>1.资产负债表需要注意的几个科目</p>\n<p>参考：<br><a href=\"https://xueqiu.com/7318086163/113922972\" target=\"_blank\" rel=\"noopener\">手把手教你分析财报</a></p>\n"},{"title":"股票命名规则总结","date":"2017-12-18T09:22:50.000Z","_content":"\nX开头:是指还没有正式上市，还在申购招股时期;\n\n4开头:表示是进入三板市场的股票，即4开头的股票是退市股票;\n\nXR:某股票在除权日当天,在其证券名称前记上XR,表示该股已除权，购买这样的股票后将不再享有分红的权利；\n\nXD：证券代码前标上XD，表示股票除息，购买这样的股票后将不再享有派息的权利。 \n\n此外还有DR，证券代码前标上DR，表示除权除息，购买这样的股票不再享有送股派息的权利；","source":"_posts/业务知识总结/股票命名规则总结.md","raw":"---\ntitle: 股票命名规则总结\ndate: 2017-12-18 17:22:50\ntags: \n- 金融业务\ncategories: 总结\n---\n\nX开头:是指还没有正式上市，还在申购招股时期;\n\n4开头:表示是进入三板市场的股票，即4开头的股票是退市股票;\n\nXR:某股票在除权日当天,在其证券名称前记上XR,表示该股已除权，购买这样的股票后将不再享有分红的权利；\n\nXD：证券代码前标上XD，表示股票除息，购买这样的股票后将不再享有派息的权利。 \n\n此外还有DR，证券代码前标上DR，表示除权除息，购买这样的股票不再享有送股派息的权利；","slug":"业务知识总结/股票命名规则总结","published":1,"updated":"2019-03-22T14:44:36.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwy00344l3n67l2k5iv","content":"<p>X开头:是指还没有正式上市，还在申购招股时期;</p>\n<p>4开头:表示是进入三板市场的股票，即4开头的股票是退市股票;</p>\n<p>XR:某股票在除权日当天,在其证券名称前记上XR,表示该股已除权，购买这样的股票后将不再享有分红的权利；</p>\n<p>XD：证券代码前标上XD，表示股票除息，购买这样的股票后将不再享有派息的权利。 </p>\n<p>此外还有DR，证券代码前标上DR，表示除权除息，购买这样的股票不再享有送股派息的权利；</p>\n","site":{"data":{}},"excerpt":"","more":"<p>X开头:是指还没有正式上市，还在申购招股时期;</p>\n<p>4开头:表示是进入三板市场的股票，即4开头的股票是退市股票;</p>\n<p>XR:某股票在除权日当天,在其证券名称前记上XR,表示该股已除权，购买这样的股票后将不再享有分红的权利；</p>\n<p>XD：证券代码前标上XD，表示股票除息，购买这样的股票后将不再享有派息的权利。 </p>\n<p>此外还有DR，证券代码前标上DR，表示除权除息，购买这样的股票不再享有送股派息的权利；</p>\n"},{"title":"bootstrap学习小结","date":"2016-07-20T12:22:50.000Z","_content":"\n## bootstrap简介\n\n### 什么是bootstrap？\n\n2011年，twitter的“一小撮”工程师为了提高他们内部的分析和管理能力，用业余时间为他们的产品构建了一套易用、优雅、灵活、可扩展的前端工具集--BootStrap。在github上开源之后，迅速成为该站上最多人watch&fork的项目。大量工程师踊跃为该项目贡献代码，社区惊人地活跃，代码版本进化非常快速，官方文档质量极其高(可以说是优雅)，同时涌现了许多基于Bootstrap建设的网站：界面清新、简洁;要素排版利落大方。<!-- more -->\n\nGitHub上这样介绍 bootstrap：\n\n * 简单灵活可用于架构流行的用户界面和交互接口的html、css、javascript工具集。\n *  基于html5、css3的bootstrap，具有大量的诱人特性：友好的学习曲线，卓越的兼容性，响应式设计，12列格网，样式向导文档。\n *  自定义JQuery插件，完整的类库，基于Less等。\n\n\n### Bootstrap样式\n\nBootstrap框架在这一部分做了一定的变更，不再一味追求归零，而是更注重重置可能产生问题的样式（如，body,form的margin等），保留和坚持部分浏览器的基础样式，解决部分潜在的问题，提升一些细节的体验，具体说明如下：\n\n* 移除body的margin声明\n* 设置body的背景色为白色\n* 为排版设置了基本的字体、字号和行高\n* 设置全局链接颜色，且当链接处于悬浮“:hover”状态时才会显示下划线样式\n\n\n\n\n### 强调\n\n`b`,`strong`  让文本直接加粗\n\n`.lead`  让一个段落p突出显示\n\n`em`,`i` 还可以通过使用标签或将元素设置样式font-style值为italic实现斜体\n\n* .text-muted：提示，使用浅灰色（#999）\n\n* .text-primary：主要，使用蓝色（#428bca）\n\n* .text-success：成功，使用浅绿色(#3c763d)\n\n* .text-info：通知信息，使用浅蓝色（#31708f）\n\n* .text-warning：警告，使用黄色（#8a6d3b）\n\n* .text-danger：危险，使用褐色（#a94442）\n\n\n### 对齐风格\n\n\n*  .text-left：左对齐\n\n*  .text-center：居中对齐\n\n*  .text-right：右对齐\n\n*  .text-justify：两端对齐\n\n### 列表\n\n.list-unstyled  给无序列表添去除默认的列表样式的风格。\n\n.dl-horizontal  给定义列表设置为水平（即将dt设置为浮动）\n\n### 代码风格\n\n1、`code`：一般是针对于单个单词或单个句子的代码，淡粉底\n2、`pre`：一般是针对于多行代码（也就是成块的代码），灰底\n3、`kbd`:一般是表示用户要通过键盘输入的内容,黑底\n\n在pre标签上添加类名“.pre-scrollable”，就可以控制代码块区域最大高度为340px，一旦超出这个高度，就会在Y轴出现滚动条。\n\n### 表格\n\nBootstrap为表格提供了1种基础样式和4种附加样式以及1个支持响应式的表格。\n1. `.table`：基础表格\n\n 1. 给表格设置了margin-bottom:20px以及设置单元内距\n\n 2. 在thead底部设置了一个2px的浅灰实线\n\n 3. 每个单元格顶部设置了一个1px的浅灰实线\n\n\n2. .table-striped：斑马线表格(隔行有一个浅灰色的背景色)\n\n3. .table-bordered：带边框的表格(中规中矩)\n\n4. .table-hover：鼠标悬停高亮的表格(当你鼠标悬浮在某一单元格上时，单元格所在行的背景色都会变成浅灰色。)\n\n5. .table-condensed：紧凑型表格(变挤而已)\n\n6. .table-responsive：响应式表格就是当屏幕小于768px时，表格下方会出现滚轮效果等）\n\n表格行的对应类：\n\n![表格图](http://7xsp7y.com1.z0.glb.clouddn.com/53ad213f0001b08807340508.jpg)\n\n### 表单\n\n表单中常见的元素主要包括：文本输入框、下拉选择框、单选按钮、复选按钮、文本域和按钮等。\n\n表单内容用for和id进行元素绑定\n\n`form-horizontal`　水平表单，标签居左，表单控件居右\n\n`sr-only`　将标签隐藏\n\n为了让控件在各种表单风格中样式不出错，需要添加类名“form-control”\n\n控件`input`必须添加type类型来定义样式\n\n控件`select`增加multiple多行显示\n\n`textarea`设置rows可定义其高度，在`from-control`中无序设置cols(宽度)属性\n\n`input-sm`让控件比正常大小更小\n\n`input-lg`让控件比正常大小更大\n\n\n\n### 图像和图标\n\n#### 图像\n\n可通过`src=\"http://placehold.it/140x140\"`获取图像样式\n\n1. img-responsive：响应式图片，主要针对于响应式设计\n\n2. img-rounded：圆角图片\n\n3. img-circle：圆形图片\n\n4. img-thumbnail：缩略图片\n\n#### 图标\n\n通过添加类，如搜索图标，即`glyphicon glyphicon-search`\n\n","source":"_posts/前端相关学习/bootstrap学习小结.md","raw":"---\ntitle: bootstrap学习小结\ndate: 2016-07-20 20:22:50\ntags: \n- html\n- bootstrap\ncategories: 总结\n---\n\n## bootstrap简介\n\n### 什么是bootstrap？\n\n2011年，twitter的“一小撮”工程师为了提高他们内部的分析和管理能力，用业余时间为他们的产品构建了一套易用、优雅、灵活、可扩展的前端工具集--BootStrap。在github上开源之后，迅速成为该站上最多人watch&fork的项目。大量工程师踊跃为该项目贡献代码，社区惊人地活跃，代码版本进化非常快速，官方文档质量极其高(可以说是优雅)，同时涌现了许多基于Bootstrap建设的网站：界面清新、简洁;要素排版利落大方。<!-- more -->\n\nGitHub上这样介绍 bootstrap：\n\n * 简单灵活可用于架构流行的用户界面和交互接口的html、css、javascript工具集。\n *  基于html5、css3的bootstrap，具有大量的诱人特性：友好的学习曲线，卓越的兼容性，响应式设计，12列格网，样式向导文档。\n *  自定义JQuery插件，完整的类库，基于Less等。\n\n\n### Bootstrap样式\n\nBootstrap框架在这一部分做了一定的变更，不再一味追求归零，而是更注重重置可能产生问题的样式（如，body,form的margin等），保留和坚持部分浏览器的基础样式，解决部分潜在的问题，提升一些细节的体验，具体说明如下：\n\n* 移除body的margin声明\n* 设置body的背景色为白色\n* 为排版设置了基本的字体、字号和行高\n* 设置全局链接颜色，且当链接处于悬浮“:hover”状态时才会显示下划线样式\n\n\n\n\n### 强调\n\n`b`,`strong`  让文本直接加粗\n\n`.lead`  让一个段落p突出显示\n\n`em`,`i` 还可以通过使用标签或将元素设置样式font-style值为italic实现斜体\n\n* .text-muted：提示，使用浅灰色（#999）\n\n* .text-primary：主要，使用蓝色（#428bca）\n\n* .text-success：成功，使用浅绿色(#3c763d)\n\n* .text-info：通知信息，使用浅蓝色（#31708f）\n\n* .text-warning：警告，使用黄色（#8a6d3b）\n\n* .text-danger：危险，使用褐色（#a94442）\n\n\n### 对齐风格\n\n\n*  .text-left：左对齐\n\n*  .text-center：居中对齐\n\n*  .text-right：右对齐\n\n*  .text-justify：两端对齐\n\n### 列表\n\n.list-unstyled  给无序列表添去除默认的列表样式的风格。\n\n.dl-horizontal  给定义列表设置为水平（即将dt设置为浮动）\n\n### 代码风格\n\n1、`code`：一般是针对于单个单词或单个句子的代码，淡粉底\n2、`pre`：一般是针对于多行代码（也就是成块的代码），灰底\n3、`kbd`:一般是表示用户要通过键盘输入的内容,黑底\n\n在pre标签上添加类名“.pre-scrollable”，就可以控制代码块区域最大高度为340px，一旦超出这个高度，就会在Y轴出现滚动条。\n\n### 表格\n\nBootstrap为表格提供了1种基础样式和4种附加样式以及1个支持响应式的表格。\n1. `.table`：基础表格\n\n 1. 给表格设置了margin-bottom:20px以及设置单元内距\n\n 2. 在thead底部设置了一个2px的浅灰实线\n\n 3. 每个单元格顶部设置了一个1px的浅灰实线\n\n\n2. .table-striped：斑马线表格(隔行有一个浅灰色的背景色)\n\n3. .table-bordered：带边框的表格(中规中矩)\n\n4. .table-hover：鼠标悬停高亮的表格(当你鼠标悬浮在某一单元格上时，单元格所在行的背景色都会变成浅灰色。)\n\n5. .table-condensed：紧凑型表格(变挤而已)\n\n6. .table-responsive：响应式表格就是当屏幕小于768px时，表格下方会出现滚轮效果等）\n\n表格行的对应类：\n\n![表格图](http://7xsp7y.com1.z0.glb.clouddn.com/53ad213f0001b08807340508.jpg)\n\n### 表单\n\n表单中常见的元素主要包括：文本输入框、下拉选择框、单选按钮、复选按钮、文本域和按钮等。\n\n表单内容用for和id进行元素绑定\n\n`form-horizontal`　水平表单，标签居左，表单控件居右\n\n`sr-only`　将标签隐藏\n\n为了让控件在各种表单风格中样式不出错，需要添加类名“form-control”\n\n控件`input`必须添加type类型来定义样式\n\n控件`select`增加multiple多行显示\n\n`textarea`设置rows可定义其高度，在`from-control`中无序设置cols(宽度)属性\n\n`input-sm`让控件比正常大小更小\n\n`input-lg`让控件比正常大小更大\n\n\n\n### 图像和图标\n\n#### 图像\n\n可通过`src=\"http://placehold.it/140x140\"`获取图像样式\n\n1. img-responsive：响应式图片，主要针对于响应式设计\n\n2. img-rounded：圆角图片\n\n3. img-circle：圆形图片\n\n4. img-thumbnail：缩略图片\n\n#### 图标\n\n通过添加类，如搜索图标，即`glyphicon glyphicon-search`\n\n","slug":"前端相关学习/bootstrap学习小结","published":1,"updated":"2019-03-22T14:44:36.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmwz00374l3na0xswmga","content":"<h2 id=\"bootstrap简介\"><a href=\"#bootstrap简介\" class=\"headerlink\" title=\"bootstrap简介\"></a>bootstrap简介</h2><h3 id=\"什么是bootstrap？\"><a href=\"#什么是bootstrap？\" class=\"headerlink\" title=\"什么是bootstrap？\"></a>什么是bootstrap？</h3><p>2011年，twitter的“一小撮”工程师为了提高他们内部的分析和管理能力，用业余时间为他们的产品构建了一套易用、优雅、灵活、可扩展的前端工具集–BootStrap。在github上开源之后，迅速成为该站上最多人watch&amp;fork的项目。大量工程师踊跃为该项目贡献代码，社区惊人地活跃，代码版本进化非常快速，官方文档质量极其高(可以说是优雅)，同时涌现了许多基于Bootstrap建设的网站：界面清新、简洁;要素排版利落大方。<a id=\"more\"></a></p>\n<p>GitHub上这样介绍 bootstrap：</p>\n<ul>\n<li>简单灵活可用于架构流行的用户界面和交互接口的html、css、javascript工具集。</li>\n<li>基于html5、css3的bootstrap，具有大量的诱人特性：友好的学习曲线，卓越的兼容性，响应式设计，12列格网，样式向导文档。</li>\n<li>自定义JQuery插件，完整的类库，基于Less等。</li>\n</ul>\n<h3 id=\"Bootstrap样式\"><a href=\"#Bootstrap样式\" class=\"headerlink\" title=\"Bootstrap样式\"></a>Bootstrap样式</h3><p>Bootstrap框架在这一部分做了一定的变更，不再一味追求归零，而是更注重重置可能产生问题的样式（如，body,form的margin等），保留和坚持部分浏览器的基础样式，解决部分潜在的问题，提升一些细节的体验，具体说明如下：</p>\n<ul>\n<li>移除body的margin声明</li>\n<li>设置body的背景色为白色</li>\n<li>为排版设置了基本的字体、字号和行高</li>\n<li>设置全局链接颜色，且当链接处于悬浮“:hover”状态时才会显示下划线样式</li>\n</ul>\n<h3 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h3><p><code>b</code>,<code>strong</code>  让文本直接加粗</p>\n<p><code>.lead</code>  让一个段落p突出显示</p>\n<p><code>em</code>,<code>i</code> 还可以通过使用标签或将元素设置样式font-style值为italic实现斜体</p>\n<ul>\n<li><p>.text-muted：提示，使用浅灰色（#999）</p>\n</li>\n<li><p>.text-primary：主要，使用蓝色（#428bca）</p>\n</li>\n<li><p>.text-success：成功，使用浅绿色(#3c763d)</p>\n</li>\n<li><p>.text-info：通知信息，使用浅蓝色（#31708f）</p>\n</li>\n<li><p>.text-warning：警告，使用黄色（#8a6d3b）</p>\n</li>\n<li><p>.text-danger：危险，使用褐色（#a94442）</p>\n</li>\n</ul>\n<h3 id=\"对齐风格\"><a href=\"#对齐风格\" class=\"headerlink\" title=\"对齐风格\"></a>对齐风格</h3><ul>\n<li><p>.text-left：左对齐</p>\n</li>\n<li><p>.text-center：居中对齐</p>\n</li>\n<li><p>.text-right：右对齐</p>\n</li>\n<li><p>.text-justify：两端对齐</p>\n</li>\n</ul>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>.list-unstyled  给无序列表添去除默认的列表样式的风格。</p>\n<p>.dl-horizontal  给定义列表设置为水平（即将dt设置为浮动）</p>\n<h3 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h3><p>1、<code>code</code>：一般是针对于单个单词或单个句子的代码，淡粉底<br>2、<code>pre</code>：一般是针对于多行代码（也就是成块的代码），灰底<br>3、<code>kbd</code>:一般是表示用户要通过键盘输入的内容,黑底</p>\n<p>在pre标签上添加类名“.pre-scrollable”，就可以控制代码块区域最大高度为340px，一旦超出这个高度，就会在Y轴出现滚动条。</p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p>Bootstrap为表格提供了1种基础样式和4种附加样式以及1个支持响应式的表格。</p>\n<ol>\n<li><p><code>.table</code>：基础表格</p>\n<ol>\n<li><p>给表格设置了margin-bottom:20px以及设置单元内距</p>\n</li>\n<li><p>在thead底部设置了一个2px的浅灰实线</p>\n</li>\n<li><p>每个单元格顶部设置了一个1px的浅灰实线</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>.table-striped：斑马线表格(隔行有一个浅灰色的背景色)</p>\n</li>\n<li><p>.table-bordered：带边框的表格(中规中矩)</p>\n</li>\n<li><p>.table-hover：鼠标悬停高亮的表格(当你鼠标悬浮在某一单元格上时，单元格所在行的背景色都会变成浅灰色。)</p>\n</li>\n<li><p>.table-condensed：紧凑型表格(变挤而已)</p>\n</li>\n<li><p>.table-responsive：响应式表格就是当屏幕小于768px时，表格下方会出现滚轮效果等）</p>\n</li>\n</ol>\n<p>表格行的对应类：</p>\n<p><img src=\"http://7xsp7y.com1.z0.glb.clouddn.com/53ad213f0001b08807340508.jpg\" alt=\"表格图\"></p>\n<h3 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h3><p>表单中常见的元素主要包括：文本输入框、下拉选择框、单选按钮、复选按钮、文本域和按钮等。</p>\n<p>表单内容用for和id进行元素绑定</p>\n<p><code>form-horizontal</code>　水平表单，标签居左，表单控件居右</p>\n<p><code>sr-only</code>　将标签隐藏</p>\n<p>为了让控件在各种表单风格中样式不出错，需要添加类名“form-control”</p>\n<p>控件<code>input</code>必须添加type类型来定义样式</p>\n<p>控件<code>select</code>增加multiple多行显示</p>\n<p><code>textarea</code>设置rows可定义其高度，在<code>from-control</code>中无序设置cols(宽度)属性</p>\n<p><code>input-sm</code>让控件比正常大小更小</p>\n<p><code>input-lg</code>让控件比正常大小更大</p>\n<h3 id=\"图像和图标\"><a href=\"#图像和图标\" class=\"headerlink\" title=\"图像和图标\"></a>图像和图标</h3><h4 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h4><p>可通过<code>src=&quot;http://placehold.it/140x140&quot;</code>获取图像样式</p>\n<ol>\n<li><p>img-responsive：响应式图片，主要针对于响应式设计</p>\n</li>\n<li><p>img-rounded：圆角图片</p>\n</li>\n<li><p>img-circle：圆形图片</p>\n</li>\n<li><p>img-thumbnail：缩略图片</p>\n</li>\n</ol>\n<h4 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h4><p>通过添加类，如搜索图标，即<code>glyphicon glyphicon-search</code></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"bootstrap简介\"><a href=\"#bootstrap简介\" class=\"headerlink\" title=\"bootstrap简介\"></a>bootstrap简介</h2><h3 id=\"什么是bootstrap？\"><a href=\"#什么是bootstrap？\" class=\"headerlink\" title=\"什么是bootstrap？\"></a>什么是bootstrap？</h3><p>2011年，twitter的“一小撮”工程师为了提高他们内部的分析和管理能力，用业余时间为他们的产品构建了一套易用、优雅、灵活、可扩展的前端工具集–BootStrap。在github上开源之后，迅速成为该站上最多人watch&amp;fork的项目。大量工程师踊跃为该项目贡献代码，社区惊人地活跃，代码版本进化非常快速，官方文档质量极其高(可以说是优雅)，同时涌现了许多基于Bootstrap建设的网站：界面清新、简洁;要素排版利落大方。</p>","more":"<p></p>\n<p>GitHub上这样介绍 bootstrap：</p>\n<ul>\n<li>简单灵活可用于架构流行的用户界面和交互接口的html、css、javascript工具集。</li>\n<li>基于html5、css3的bootstrap，具有大量的诱人特性：友好的学习曲线，卓越的兼容性，响应式设计，12列格网，样式向导文档。</li>\n<li>自定义JQuery插件，完整的类库，基于Less等。</li>\n</ul>\n<h3 id=\"Bootstrap样式\"><a href=\"#Bootstrap样式\" class=\"headerlink\" title=\"Bootstrap样式\"></a>Bootstrap样式</h3><p>Bootstrap框架在这一部分做了一定的变更，不再一味追求归零，而是更注重重置可能产生问题的样式（如，body,form的margin等），保留和坚持部分浏览器的基础样式，解决部分潜在的问题，提升一些细节的体验，具体说明如下：</p>\n<ul>\n<li>移除body的margin声明</li>\n<li>设置body的背景色为白色</li>\n<li>为排版设置了基本的字体、字号和行高</li>\n<li>设置全局链接颜色，且当链接处于悬浮“:hover”状态时才会显示下划线样式</li>\n</ul>\n<h3 id=\"强调\"><a href=\"#强调\" class=\"headerlink\" title=\"强调\"></a>强调</h3><p><code>b</code>,<code>strong</code>  让文本直接加粗</p>\n<p><code>.lead</code>  让一个段落p突出显示</p>\n<p><code>em</code>,<code>i</code> 还可以通过使用标签或将元素设置样式font-style值为italic实现斜体</p>\n<ul>\n<li><p>.text-muted：提示，使用浅灰色（#999）</p>\n</li>\n<li><p>.text-primary：主要，使用蓝色（#428bca）</p>\n</li>\n<li><p>.text-success：成功，使用浅绿色(#3c763d)</p>\n</li>\n<li><p>.text-info：通知信息，使用浅蓝色（#31708f）</p>\n</li>\n<li><p>.text-warning：警告，使用黄色（#8a6d3b）</p>\n</li>\n<li><p>.text-danger：危险，使用褐色（#a94442）</p>\n</li>\n</ul>\n<h3 id=\"对齐风格\"><a href=\"#对齐风格\" class=\"headerlink\" title=\"对齐风格\"></a>对齐风格</h3><ul>\n<li><p>.text-left：左对齐</p>\n</li>\n<li><p>.text-center：居中对齐</p>\n</li>\n<li><p>.text-right：右对齐</p>\n</li>\n<li><p>.text-justify：两端对齐</p>\n</li>\n</ul>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><p>.list-unstyled  给无序列表添去除默认的列表样式的风格。</p>\n<p>.dl-horizontal  给定义列表设置为水平（即将dt设置为浮动）</p>\n<h3 id=\"代码风格\"><a href=\"#代码风格\" class=\"headerlink\" title=\"代码风格\"></a>代码风格</h3><p>1、<code>code</code>：一般是针对于单个单词或单个句子的代码，淡粉底<br>2、<code>pre</code>：一般是针对于多行代码（也就是成块的代码），灰底<br>3、<code>kbd</code>:一般是表示用户要通过键盘输入的内容,黑底</p>\n<p>在pre标签上添加类名“.pre-scrollable”，就可以控制代码块区域最大高度为340px，一旦超出这个高度，就会在Y轴出现滚动条。</p>\n<h3 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h3><p>Bootstrap为表格提供了1种基础样式和4种附加样式以及1个支持响应式的表格。</p>\n<ol>\n<li><p><code>.table</code>：基础表格</p>\n<ol>\n<li><p>给表格设置了margin-bottom:20px以及设置单元内距</p>\n</li>\n<li><p>在thead底部设置了一个2px的浅灰实线</p>\n</li>\n<li><p>每个单元格顶部设置了一个1px的浅灰实线</p>\n</li>\n</ol>\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>.table-striped：斑马线表格(隔行有一个浅灰色的背景色)</p>\n</li>\n<li><p>.table-bordered：带边框的表格(中规中矩)</p>\n</li>\n<li><p>.table-hover：鼠标悬停高亮的表格(当你鼠标悬浮在某一单元格上时，单元格所在行的背景色都会变成浅灰色。)</p>\n</li>\n<li><p>.table-condensed：紧凑型表格(变挤而已)</p>\n</li>\n<li><p>.table-responsive：响应式表格就是当屏幕小于768px时，表格下方会出现滚轮效果等）</p>\n</li>\n</ol>\n<p>表格行的对应类：</p>\n<p><img src=\"http://7xsp7y.com1.z0.glb.clouddn.com/53ad213f0001b08807340508.jpg\" alt=\"表格图\"></p>\n<h3 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h3><p>表单中常见的元素主要包括：文本输入框、下拉选择框、单选按钮、复选按钮、文本域和按钮等。</p>\n<p>表单内容用for和id进行元素绑定</p>\n<p><code>form-horizontal</code>　水平表单，标签居左，表单控件居右</p>\n<p><code>sr-only</code>　将标签隐藏</p>\n<p>为了让控件在各种表单风格中样式不出错，需要添加类名“form-control”</p>\n<p>控件<code>input</code>必须添加type类型来定义样式</p>\n<p>控件<code>select</code>增加multiple多行显示</p>\n<p><code>textarea</code>设置rows可定义其高度，在<code>from-control</code>中无序设置cols(宽度)属性</p>\n<p><code>input-sm</code>让控件比正常大小更小</p>\n<p><code>input-lg</code>让控件比正常大小更大</p>\n<h3 id=\"图像和图标\"><a href=\"#图像和图标\" class=\"headerlink\" title=\"图像和图标\"></a>图像和图标</h3><h4 id=\"图像\"><a href=\"#图像\" class=\"headerlink\" title=\"图像\"></a>图像</h4><p>可通过<code>src=&quot;http://placehold.it/140x140&quot;</code>获取图像样式</p>\n<ol>\n<li><p>img-responsive：响应式图片，主要针对于响应式设计</p>\n</li>\n<li><p>img-rounded：圆角图片</p>\n</li>\n<li><p>img-circle：圆形图片</p>\n</li>\n<li><p>img-thumbnail：缩略图片</p>\n</li>\n</ol>\n<h4 id=\"图标\"><a href=\"#图标\" class=\"headerlink\" title=\"图标\"></a>图标</h4><p>通过添加类，如搜索图标，即<code>glyphicon glyphicon-search</code></p>"},{"title":"hello blog","date":"2016-04-05T12:22:50.000Z","_content":"![photo](http://pic.yupoo.com/zjbao123/FskJJNom/medish.jpg)\n第一次尝试用github page写博客,是使用GitHub和Hexo搭建而成。感谢[Zippera](http://www.zipperary.com/)以及[HelloDog](http://wsgzao.github.io/post/hexo-guide/)提供的教程。\n\n**Doing is better than perfect**\n<!-- more -->\n这个想法很早就产生了，可一直迟迟没有动手。也尝试过很多的平台去写blog，但是结果都不如人意，最终还是选择了这个平台。希望可以一直陪伴着我，用来记录自学之路吧。","source":"_posts/博客相关/hello blog.md","raw":"---\ntitle: hello blog \ndate: 2016-04-05 20:22:50\ntags: \n- Hexo\ncategories: 测试\n---\n![photo](http://pic.yupoo.com/zjbao123/FskJJNom/medish.jpg)\n第一次尝试用github page写博客,是使用GitHub和Hexo搭建而成。感谢[Zippera](http://www.zipperary.com/)以及[HelloDog](http://wsgzao.github.io/post/hexo-guide/)提供的教程。\n\n**Doing is better than perfect**\n<!-- more -->\n这个想法很早就产生了，可一直迟迟没有动手。也尝试过很多的平台去写blog，但是结果都不如人意，最终还是选择了这个平台。希望可以一直陪伴着我，用来记录自学之路吧。","slug":"博客相关/hello blog","published":1,"updated":"2019-03-22T14:44:36.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmx0003b4l3nllmakys7","content":"<p><img src=\"http://pic.yupoo.com/zjbao123/FskJJNom/medish.jpg\" alt=\"photo\"><br>第一次尝试用github page写博客,是使用GitHub和Hexo搭建而成。感谢<a href=\"http://www.zipperary.com/\" target=\"_blank\" rel=\"noopener\">Zippera</a>以及<a href=\"http://wsgzao.github.io/post/hexo-guide/\" target=\"_blank\" rel=\"noopener\">HelloDog</a>提供的教程。</p>\n<p><strong>Doing is better than perfect</strong><br><a id=\"more\"></a><br>这个想法很早就产生了，可一直迟迟没有动手。也尝试过很多的平台去写blog，但是结果都不如人意，最终还是选择了这个平台。希望可以一直陪伴着我，用来记录自学之路吧。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://pic.yupoo.com/zjbao123/FskJJNom/medish.jpg\" alt=\"photo\"><br>第一次尝试用github page写博客,是使用GitHub和Hexo搭建而成。感谢<a href=\"http://www.zipperary.com/\" target=\"_blank\" rel=\"noopener\">Zippera</a>以及<a href=\"http://wsgzao.github.io/post/hexo-guide/\" target=\"_blank\" rel=\"noopener\">HelloDog</a>提供的教程。</p>\n<p><strong>Doing is better than perfect</strong><br></p>","more":"<br>这个想法很早就产生了，可一直迟迟没有动手。也尝试过很多的平台去写blog，但是结果都不如人意，最终还是选择了这个平台。希望可以一直陪伴着我，用来记录自学之路吧。<p></p>"},{"title":"同步博客coding和github并实现本地上传图片至博客","date":"2017-10-18T10:01:50.000Z","_content":"\n## 同步博客至coding和github\n\n由于有些时候github page 会被墙，需要翻墙才能浏览。所以找一个国内的博客也变得十分需要。在查找之后，发现[coding.net](http://coding.net)非常的不错。\n![coding](http://i2.buimg.com/567571/1f5ff62372ee57a0.png)\n查了些资料，成功实现在国内托管平台coding同步自己的博客。\n<!-- more -->\n### 一.创建秘钥\n\n1.安装`git`\n\n2.安装完成后运行`git shell`\n\n3.输入`cd ~/.ssh` ,跳转到你的.ssh目录\n\n4.将目录下生成的 `id_rsa.pub` 复制出来部署至`coding` 和 `github`.\n\n### 二.部署秘钥\n1.在coding中新建项目，项目名与Global Key，即用户名。\n\n2.在github和coding中部署ssh相同的密钥，添加后，在Git命令窗口输入如下命令进行测试：\n\n```\nssh -T git@git.coding.net\nssh -T git@github.com\n```\n出现下列提示则说明添加成功：\n```\nCoding.net Tips : [Hello ! You've conected to Coding.net by SSH successfully! ]\n```\n\n3.将博客根目录下的 `_config.yml` 的一致deploy修改成类似代码\n\n```\ndeploy:\n  type: git\n  repo:\n      github: git@github.com:username/username.github.io.git,master\n      coding: git@git.coding.net:username/username.git,master\n```\n\n4.之后使用部署命令来同步博客到coding和github\n```\nhexo cl\nhexo g\nhexo d\n```\n\n5.那直接访问 username.coding.me就能访问博客\n\n## 本地上传图片至博客\n\n之前在看博客的时候看到一个开源库觉得不错，可以实现使用本地图片。\n\n地址如下：[hexo-asset-image](https://github.com/CodeFalling/hexo-asset-image)\n\n1.修改配置文件_config.yml\n```\npost_asset_folder:true\n\n```\n\n2.在hexo的目录下执行\n```\nnpm install hexo-asset-image --save\n```\n\n3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。\n\n通过上述例子进行访问。\n","source":"_posts/博客相关/同步博客到coding.md","raw":"---\ntitle: 同步博客coding和github并实现本地上传图片至博客\ndate: 2017-10-18 18:01:50\ntags: \n- 博客优化\ncategories: 总结\n---\n\n## 同步博客至coding和github\n\n由于有些时候github page 会被墙，需要翻墙才能浏览。所以找一个国内的博客也变得十分需要。在查找之后，发现[coding.net](http://coding.net)非常的不错。\n![coding](http://i2.buimg.com/567571/1f5ff62372ee57a0.png)\n查了些资料，成功实现在国内托管平台coding同步自己的博客。\n<!-- more -->\n### 一.创建秘钥\n\n1.安装`git`\n\n2.安装完成后运行`git shell`\n\n3.输入`cd ~/.ssh` ,跳转到你的.ssh目录\n\n4.将目录下生成的 `id_rsa.pub` 复制出来部署至`coding` 和 `github`.\n\n### 二.部署秘钥\n1.在coding中新建项目，项目名与Global Key，即用户名。\n\n2.在github和coding中部署ssh相同的密钥，添加后，在Git命令窗口输入如下命令进行测试：\n\n```\nssh -T git@git.coding.net\nssh -T git@github.com\n```\n出现下列提示则说明添加成功：\n```\nCoding.net Tips : [Hello ! You've conected to Coding.net by SSH successfully! ]\n```\n\n3.将博客根目录下的 `_config.yml` 的一致deploy修改成类似代码\n\n```\ndeploy:\n  type: git\n  repo:\n      github: git@github.com:username/username.github.io.git,master\n      coding: git@git.coding.net:username/username.git,master\n```\n\n4.之后使用部署命令来同步博客到coding和github\n```\nhexo cl\nhexo g\nhexo d\n```\n\n5.那直接访问 username.coding.me就能访问博客\n\n## 本地上传图片至博客\n\n之前在看博客的时候看到一个开源库觉得不错，可以实现使用本地图片。\n\n地址如下：[hexo-asset-image](https://github.com/CodeFalling/hexo-asset-image)\n\n1.修改配置文件_config.yml\n```\npost_asset_folder:true\n\n```\n\n2.在hexo的目录下执行\n```\nnpm install hexo-asset-image --save\n```\n\n3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。\n\n通过上述例子进行访问。\n","slug":"博客相关/同步博客到coding","published":1,"updated":"2019-03-22T14:44:36.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmx1003e4l3nnnjo33p9","content":"<h2 id=\"同步博客至coding和github\"><a href=\"#同步博客至coding和github\" class=\"headerlink\" title=\"同步博客至coding和github\"></a>同步博客至coding和github</h2><p>由于有些时候github page 会被墙，需要翻墙才能浏览。所以找一个国内的博客也变得十分需要。在查找之后，发现<a href=\"http://coding.net\" target=\"_blank\" rel=\"noopener\">coding.net</a>非常的不错。<br><img src=\"http://i2.buimg.com/567571/1f5ff62372ee57a0.png\" alt=\"coding\"><br>查了些资料，成功实现在国内托管平台coding同步自己的博客。<br><a id=\"more\"></a></p>\n<h3 id=\"一-创建秘钥\"><a href=\"#一-创建秘钥\" class=\"headerlink\" title=\"一.创建秘钥\"></a>一.创建秘钥</h3><p>1.安装<code>git</code></p>\n<p>2.安装完成后运行<code>git shell</code></p>\n<p>3.输入<code>cd ~/.ssh</code> ,跳转到你的.ssh目录</p>\n<p>4.将目录下生成的 <code>id_rsa.pub</code> 复制出来部署至<code>coding</code> 和 <code>github</code>.</p>\n<h3 id=\"二-部署秘钥\"><a href=\"#二-部署秘钥\" class=\"headerlink\" title=\"二.部署秘钥\"></a>二.部署秘钥</h3><p>1.在coding中新建项目，项目名与Global Key，即用户名。</p>\n<p>2.在github和coding中部署ssh相同的密钥，添加后，在Git命令窗口输入如下命令进行测试：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ssh</span> <span class=\"selector-tag\">-T</span> <span class=\"selector-tag\">git</span>@<span class=\"keyword\">git</span>.<span class=\"keyword\">coding</span>.<span class=\"keyword\">net</span></span><br><span class=\"line\"><span class=\"keyword\">ssh</span> -T git@github.com</span><br></pre></td></tr></table></figure>\n<p>出现下列提示则说明添加成功：<br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Coding.<span class=\"keyword\">net</span> Tips : [Hello ! You've conected to Coding.<span class=\"keyword\">net</span> <span class=\"keyword\">by</span> SSH successfully! ]</span><br></pre></td></tr></table></figure></p>\n<p>3.将博客根目录下的 <code>_config.yml</code> 的一致deploy修改成类似代码</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attribute\">type</span>: git</span><br><span class=\"line\">  <span class=\"attribute\">repo</span>:</span><br><span class=\"line\">      <span class=\"attribute\">github</span>: git<span class=\"variable\">@github</span>.<span class=\"attribute\">com</span>:username/username.github.io.git,master</span><br><span class=\"line\">      <span class=\"attribute\">coding</span>: git<span class=\"variable\">@git</span>.coding.<span class=\"attribute\">net</span>:username/username.git,master</span><br></pre></td></tr></table></figure>\n<p>4.之后使用部署命令来同步博客到coding和github<br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">cl</span></span><br><span class=\"line\">hexo <span class=\"keyword\">g</span></span><br><span class=\"line\">hexo <span class=\"built_in\">d</span></span><br></pre></td></tr></table></figure></p>\n<p>5.那直接访问 username.coding.me就能访问博客</p>\n<h2 id=\"本地上传图片至博客\"><a href=\"#本地上传图片至博客\" class=\"headerlink\" title=\"本地上传图片至博客\"></a>本地上传图片至博客</h2><p>之前在看博客的时候看到一个开源库觉得不错，可以实现使用本地图片。</p>\n<p>地址如下：<a href=\"https://github.com/CodeFalling/hexo-asset-image\" target=\"_blank\" rel=\"noopener\">hexo-asset-image</a></p>\n<p>1.修改配置文件_config.yml<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">post_asset_folder:</span><span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<p>2.在hexo的目录下执行<br><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-asset-<span class=\"built_in\">image</span> --<span class=\"built_in\">save</span></span><br></pre></td></tr></table></figure></p>\n<p>3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。</p>\n<p>通过上述例子进行访问。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"同步博客至coding和github\"><a href=\"#同步博客至coding和github\" class=\"headerlink\" title=\"同步博客至coding和github\"></a>同步博客至coding和github</h2><p>由于有些时候github page 会被墙，需要翻墙才能浏览。所以找一个国内的博客也变得十分需要。在查找之后，发现<a href=\"http://coding.net\" target=\"_blank\" rel=\"noopener\">coding.net</a>非常的不错。<br><img src=\"http://i2.buimg.com/567571/1f5ff62372ee57a0.png\" alt=\"coding\"><br>查了些资料，成功实现在国内托管平台coding同步自己的博客。<br></p>","more":"<p></p>\n<h3 id=\"一-创建秘钥\"><a href=\"#一-创建秘钥\" class=\"headerlink\" title=\"一.创建秘钥\"></a>一.创建秘钥</h3><p>1.安装<code>git</code></p>\n<p>2.安装完成后运行<code>git shell</code></p>\n<p>3.输入<code>cd ~/.ssh</code> ,跳转到你的.ssh目录</p>\n<p>4.将目录下生成的 <code>id_rsa.pub</code> 复制出来部署至<code>coding</code> 和 <code>github</code>.</p>\n<h3 id=\"二-部署秘钥\"><a href=\"#二-部署秘钥\" class=\"headerlink\" title=\"二.部署秘钥\"></a>二.部署秘钥</h3><p>1.在coding中新建项目，项目名与Global Key，即用户名。</p>\n<p>2.在github和coding中部署ssh相同的密钥，添加后，在Git命令窗口输入如下命令进行测试：</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">ssh</span> <span class=\"selector-tag\">-T</span> <span class=\"selector-tag\">git</span>@<span class=\"keyword\">git</span>.<span class=\"keyword\">coding</span>.<span class=\"keyword\">net</span></span><br><span class=\"line\"><span class=\"keyword\">ssh</span> -T git@github.com</span><br></pre></td></tr></table></figure>\n<p>出现下列提示则说明添加成功：<br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Coding.<span class=\"keyword\">net</span> Tips : [Hello ! You've conected to Coding.<span class=\"keyword\">net</span> <span class=\"keyword\">by</span> SSH successfully! ]</span><br></pre></td></tr></table></figure></p>\n<p>3.将博客根目录下的 <code>_config.yml</code> 的一致deploy修改成类似代码</p>\n<figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">deploy</span>:</span><br><span class=\"line\">  <span class=\"attribute\">type</span>: git</span><br><span class=\"line\">  <span class=\"attribute\">repo</span>:</span><br><span class=\"line\">      <span class=\"attribute\">github</span>: git<span class=\"variable\">@github</span>.<span class=\"attribute\">com</span>:username/username.github.io.git,master</span><br><span class=\"line\">      <span class=\"attribute\">coding</span>: git<span class=\"variable\">@git</span>.coding.<span class=\"attribute\">net</span>:username/username.git,master</span><br></pre></td></tr></table></figure>\n<p>4.之后使用部署命令来同步博客到coding和github<br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo <span class=\"keyword\">cl</span></span><br><span class=\"line\">hexo <span class=\"keyword\">g</span></span><br><span class=\"line\">hexo <span class=\"built_in\">d</span></span><br></pre></td></tr></table></figure></p>\n<p>5.那直接访问 username.coding.me就能访问博客</p>\n<h2 id=\"本地上传图片至博客\"><a href=\"#本地上传图片至博客\" class=\"headerlink\" title=\"本地上传图片至博客\"></a>本地上传图片至博客</h2><p>之前在看博客的时候看到一个开源库觉得不错，可以实现使用本地图片。</p>\n<p>地址如下：<a href=\"https://github.com/CodeFalling/hexo-asset-image\" target=\"_blank\" rel=\"noopener\">hexo-asset-image</a></p>\n<p>1.修改配置文件_config.yml<br><figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">post_asset_folder:</span><span class=\"literal\">true</span></span><br></pre></td></tr></table></figure></p>\n<p>2.在hexo的目录下执行<br><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-asset-<span class=\"built_in\">image</span> --<span class=\"built_in\">save</span></span><br></pre></td></tr></table></figure></p>\n<p>3.完成安装后用hexo新建文章的时候会发现_posts目录下面会多出一个和文章名字一样的文件夹。图片就可以放在文件夹下面。</p>\n<p>通过上述例子进行访问。</p>"},{"title":"TED-雪莉·桑德伯格哈佛14毕业典礼演讲","date":"2016-09-17T13:51:23.000Z","_content":"\n最近自己开的栏目有点多，脑洞太大，总想都做一些，也算自己在学习之余听听TED作为放松吧。不过光听总觉得会不够，也做一个TED观看总结吧。就当学英语了。\n\n## 演讲嘉宾介绍\n\n雪莉·桑德伯格，谷歌全球在线销售和运营部门副总裁。现任Facebook首席运营官，被媒体称为\"Facebook的第一夫人\"，她也是第一位进入Facebook董事会的女性成员。同时，她还是福布斯上榜的前50名\"最有力量\" 的商业女精英之一。2013年，她登上《时代周刊》杂志封面，并被《时代》杂志评为全球最具影响力的人物。桑德伯格还曾是前美国财政部官员，此外她还曾以世界银行经济学家的身份在麦肯锡咨询公司担任过顾问一职。\n<!-- more -->\n马克·扎克伯格说：“没有了谢莉·桑德伯格的Facebook不是完整的。”\n\n《每日电讯报》的编辑阿曼达·安德鲁斯评价说：“她说得不多，但却很好很流利而且非常有魅力。”安德鲁斯甚至称她为“Facebook的第一夫人”。\n\n也是大牛一个。\n\n\n## 演讲内容\n\n**为人要真诚，敢于发声，勇于为平等而战，时刻记住反省自身。**\n\nDon't just move up and down. Don't just look up.your career and your life will have starts and stops and zigs and zags,we should open ourself up to honesty.\n\n不要仅仅是爬上爬下，不要只往上看，你的职业和生活中会有始终，会有曲折。你需要对自己真诚。\n\n起点到终点之间不可能是一条直线，也不要期待直线，找到自己立体方格铁架，慢慢的曲曲折折的爬过去。顺便欣赏一下沿途的风景。这一点讲的非常的好，几个例子也举的非常合适。包括雪莉的职业选择，甚至是她的婚姻。当然讲到婚姻是为了讲应该去主动的收集反馈，这在走出了学校，走出了考试体系之后尤为重要。\n\nSo often the truth is sacrificed to conflict avoidance,or by the time we speak the truth, we've used so many caveats and preambles that the message totally gets lost.So I ask you to ask each other for the truth and other people,can you list it in simple and clear language?\n\n真相往往成为了避免冲突的牺牲品，在我们讲真相的时候，我们通常用了非常多的修饰，很多委婉语而导致淹没了真正想要传达的消息。在向人询问真相的时候，请用简单明了的语言相互交流。\n\nI want to put some pressure on you to acknowledge the hard truths,not shy away from them,and when you see them to address them.\n\n我想给你们一些压力让你们认识到真相有时候很难接受，但很重要，不要逃避，碰到时就勇于面对。\n\nLeaning in does not mean your path will be straight or smooth。\n\n向前一步并不表示你的前路一帆风顺。\n\nFortune favors the bold. What would you do if you weren't afraid? \n\n财富偏爱勇者，不要害怕，勇往直前\n\nnothing at Facebook is someone else's problem \n\n在脸书上没有别人的问题\n\nnot only will you figure out what you want to do eventually,but once you do, you'll crush it.\n\n你最终会找到你想要做的事情，并最终获得成功。\n\nyou know that while you are extraordinary on your own,we are all stronger and can be louder together.\n\n你知道虽然你们都很出色，但是团结在一起会使我们变得更强，并能发出更大的声音。\n\nTomrrow you all become part of a lifelong community,which offers truly great opportunity and therefore comes with real obligation.\n\n明天你们都将步入社会，这将是一生的旅途，图中会遇到很好的机会也会有很重大的责任。\n\n## 单词杂记\n```\ndaunting　令人畏惧的;使人气馁的;令人怯步的\ncliff 悬崖\nfeedback 反馈\n//Asking for feedback is a really important habit to get into,as you leave the structure of the school calendar and exams and grades behind.\nblurt out 脱口而出 \n//'You're mad,' the driver blurted out.\ncaveat修饰\nI was kinda like a parrot with issues 我就像一只学舌的鹦鹉\nforth 向前\n//This went back and forth a couple of times 这样来回了几次 \ntyranny 暴政，残暴\nbut we suffer from the tyranny of low expectations 但我们还在低预期的践踏\negregious 过分的，惊人的，异乎寻常的\nhit me even more egregious 这就让我更不爽了\npassionate 热烈的，激情的\nI wrote a long and passionate email 我写了一长篇饱含激情的文章\nbias 偏见\njungle gym 立体方格铁架\nunknown and often ununderstood gender bias 未知也通常未被理解的性别偏见\nYou can challenge stereotypes that's subtle and obvious 你可以挑战老一套的做法\n```","source":"_posts/摘录/TED-雪莉·桑德伯格哈佛14毕业典礼演讲.md","raw":"---\ntitle: TED-雪莉·桑德伯格哈佛14毕业典礼演讲\ndate: 2016-09-17 21:51:23\ntags: \n- TED\ncategories: 总结\n---\n\n最近自己开的栏目有点多，脑洞太大，总想都做一些，也算自己在学习之余听听TED作为放松吧。不过光听总觉得会不够，也做一个TED观看总结吧。就当学英语了。\n\n## 演讲嘉宾介绍\n\n雪莉·桑德伯格，谷歌全球在线销售和运营部门副总裁。现任Facebook首席运营官，被媒体称为\"Facebook的第一夫人\"，她也是第一位进入Facebook董事会的女性成员。同时，她还是福布斯上榜的前50名\"最有力量\" 的商业女精英之一。2013年，她登上《时代周刊》杂志封面，并被《时代》杂志评为全球最具影响力的人物。桑德伯格还曾是前美国财政部官员，此外她还曾以世界银行经济学家的身份在麦肯锡咨询公司担任过顾问一职。\n<!-- more -->\n马克·扎克伯格说：“没有了谢莉·桑德伯格的Facebook不是完整的。”\n\n《每日电讯报》的编辑阿曼达·安德鲁斯评价说：“她说得不多，但却很好很流利而且非常有魅力。”安德鲁斯甚至称她为“Facebook的第一夫人”。\n\n也是大牛一个。\n\n\n## 演讲内容\n\n**为人要真诚，敢于发声，勇于为平等而战，时刻记住反省自身。**\n\nDon't just move up and down. Don't just look up.your career and your life will have starts and stops and zigs and zags,we should open ourself up to honesty.\n\n不要仅仅是爬上爬下，不要只往上看，你的职业和生活中会有始终，会有曲折。你需要对自己真诚。\n\n起点到终点之间不可能是一条直线，也不要期待直线，找到自己立体方格铁架，慢慢的曲曲折折的爬过去。顺便欣赏一下沿途的风景。这一点讲的非常的好，几个例子也举的非常合适。包括雪莉的职业选择，甚至是她的婚姻。当然讲到婚姻是为了讲应该去主动的收集反馈，这在走出了学校，走出了考试体系之后尤为重要。\n\nSo often the truth is sacrificed to conflict avoidance,or by the time we speak the truth, we've used so many caveats and preambles that the message totally gets lost.So I ask you to ask each other for the truth and other people,can you list it in simple and clear language?\n\n真相往往成为了避免冲突的牺牲品，在我们讲真相的时候，我们通常用了非常多的修饰，很多委婉语而导致淹没了真正想要传达的消息。在向人询问真相的时候，请用简单明了的语言相互交流。\n\nI want to put some pressure on you to acknowledge the hard truths,not shy away from them,and when you see them to address them.\n\n我想给你们一些压力让你们认识到真相有时候很难接受，但很重要，不要逃避，碰到时就勇于面对。\n\nLeaning in does not mean your path will be straight or smooth。\n\n向前一步并不表示你的前路一帆风顺。\n\nFortune favors the bold. What would you do if you weren't afraid? \n\n财富偏爱勇者，不要害怕，勇往直前\n\nnothing at Facebook is someone else's problem \n\n在脸书上没有别人的问题\n\nnot only will you figure out what you want to do eventually,but once you do, you'll crush it.\n\n你最终会找到你想要做的事情，并最终获得成功。\n\nyou know that while you are extraordinary on your own,we are all stronger and can be louder together.\n\n你知道虽然你们都很出色，但是团结在一起会使我们变得更强，并能发出更大的声音。\n\nTomrrow you all become part of a lifelong community,which offers truly great opportunity and therefore comes with real obligation.\n\n明天你们都将步入社会，这将是一生的旅途，图中会遇到很好的机会也会有很重大的责任。\n\n## 单词杂记\n```\ndaunting　令人畏惧的;使人气馁的;令人怯步的\ncliff 悬崖\nfeedback 反馈\n//Asking for feedback is a really important habit to get into,as you leave the structure of the school calendar and exams and grades behind.\nblurt out 脱口而出 \n//'You're mad,' the driver blurted out.\ncaveat修饰\nI was kinda like a parrot with issues 我就像一只学舌的鹦鹉\nforth 向前\n//This went back and forth a couple of times 这样来回了几次 \ntyranny 暴政，残暴\nbut we suffer from the tyranny of low expectations 但我们还在低预期的践踏\negregious 过分的，惊人的，异乎寻常的\nhit me even more egregious 这就让我更不爽了\npassionate 热烈的，激情的\nI wrote a long and passionate email 我写了一长篇饱含激情的文章\nbias 偏见\njungle gym 立体方格铁架\nunknown and often ununderstood gender bias 未知也通常未被理解的性别偏见\nYou can challenge stereotypes that's subtle and obvious 你可以挑战老一套的做法\n```","slug":"摘录/TED-雪莉·桑德伯格哈佛14毕业典礼演讲","published":1,"updated":"2019-03-22T14:44:36.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmx2003i4l3n5p5acp3c","content":"<p>最近自己开的栏目有点多，脑洞太大，总想都做一些，也算自己在学习之余听听TED作为放松吧。不过光听总觉得会不够，也做一个TED观看总结吧。就当学英语了。</p>\n<h2 id=\"演讲嘉宾介绍\"><a href=\"#演讲嘉宾介绍\" class=\"headerlink\" title=\"演讲嘉宾介绍\"></a>演讲嘉宾介绍</h2><p>雪莉·桑德伯格，谷歌全球在线销售和运营部门副总裁。现任Facebook首席运营官，被媒体称为”Facebook的第一夫人”，她也是第一位进入Facebook董事会的女性成员。同时，她还是福布斯上榜的前50名”最有力量” 的商业女精英之一。2013年，她登上《时代周刊》杂志封面，并被《时代》杂志评为全球最具影响力的人物。桑德伯格还曾是前美国财政部官员，此外她还曾以世界银行经济学家的身份在麦肯锡咨询公司担任过顾问一职。<br><a id=\"more\"></a><br>马克·扎克伯格说：“没有了谢莉·桑德伯格的Facebook不是完整的。”</p>\n<p>《每日电讯报》的编辑阿曼达·安德鲁斯评价说：“她说得不多，但却很好很流利而且非常有魅力。”安德鲁斯甚至称她为“Facebook的第一夫人”。</p>\n<p>也是大牛一个。</p>\n<h2 id=\"演讲内容\"><a href=\"#演讲内容\" class=\"headerlink\" title=\"演讲内容\"></a>演讲内容</h2><p><strong>为人要真诚，敢于发声，勇于为平等而战，时刻记住反省自身。</strong></p>\n<p>Don’t just move up and down. Don’t just look up.your career and your life will have starts and stops and zigs and zags,we should open ourself up to honesty.</p>\n<p>不要仅仅是爬上爬下，不要只往上看，你的职业和生活中会有始终，会有曲折。你需要对自己真诚。</p>\n<p>起点到终点之间不可能是一条直线，也不要期待直线，找到自己立体方格铁架，慢慢的曲曲折折的爬过去。顺便欣赏一下沿途的风景。这一点讲的非常的好，几个例子也举的非常合适。包括雪莉的职业选择，甚至是她的婚姻。当然讲到婚姻是为了讲应该去主动的收集反馈，这在走出了学校，走出了考试体系之后尤为重要。</p>\n<p>So often the truth is sacrificed to conflict avoidance,or by the time we speak the truth, we’ve used so many caveats and preambles that the message totally gets lost.So I ask you to ask each other for the truth and other people,can you list it in simple and clear language?</p>\n<p>真相往往成为了避免冲突的牺牲品，在我们讲真相的时候，我们通常用了非常多的修饰，很多委婉语而导致淹没了真正想要传达的消息。在向人询问真相的时候，请用简单明了的语言相互交流。</p>\n<p>I want to put some pressure on you to acknowledge the hard truths,not shy away from them,and when you see them to address them.</p>\n<p>我想给你们一些压力让你们认识到真相有时候很难接受，但很重要，不要逃避，碰到时就勇于面对。</p>\n<p>Leaning in does not mean your path will be straight or smooth。</p>\n<p>向前一步并不表示你的前路一帆风顺。</p>\n<p>Fortune favors the bold. What would you do if you weren’t afraid? </p>\n<p>财富偏爱勇者，不要害怕，勇往直前</p>\n<p>nothing at Facebook is someone else’s problem </p>\n<p>在脸书上没有别人的问题</p>\n<p>not only will you figure out what you want to do eventually,but once you do, you’ll crush it.</p>\n<p>你最终会找到你想要做的事情，并最终获得成功。</p>\n<p>you know that while you are extraordinary on your own,we are all stronger and can be louder together.</p>\n<p>你知道虽然你们都很出色，但是团结在一起会使我们变得更强，并能发出更大的声音。</p>\n<p>Tomrrow you all become part of a lifelong community,which offers truly great opportunity and therefore comes with real obligation.</p>\n<p>明天你们都将步入社会，这将是一生的旅途，图中会遇到很好的机会也会有很重大的责任。</p>\n<h2 id=\"单词杂记\"><a href=\"#单词杂记\" class=\"headerlink\" title=\"单词杂记\"></a>单词杂记</h2><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">daunting　令人畏惧的;使人气馁的;令人怯步的</span><br><span class=\"line\">cliff 悬崖</span><br><span class=\"line\">feedback 反馈</span><br><span class=\"line\">//Asking <span class=\"keyword\">for</span> feedback is <span class=\"keyword\">a</span> really important habit <span class=\"built_in\">to</span> <span class=\"built_in\">get</span> <span class=\"keyword\">into</span>,<span class=\"keyword\">as</span> you leave <span class=\"keyword\">the</span> structure <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> school calendar <span class=\"keyword\">and</span> exams <span class=\"keyword\">and</span> grades behind.</span><br><span class=\"line\">blurt out 脱口而出 </span><br><span class=\"line\">//<span class=\"string\">'You'</span>re mad,<span class=\"string\">' the driver blurted out.</span></span><br><span class=\"line\"><span class=\"string\">caveat修饰</span></span><br><span class=\"line\"><span class=\"string\">I was kinda like a parrot with issues 我就像一只学舌的鹦鹉</span></span><br><span class=\"line\"><span class=\"string\">forth 向前</span></span><br><span class=\"line\"><span class=\"string\">//This went back and forth a couple of times 这样来回了几次 </span></span><br><span class=\"line\"><span class=\"string\">tyranny 暴政，残暴</span></span><br><span class=\"line\"><span class=\"string\">but we suffer from the tyranny of low expectations 但我们还在低预期的践踏</span></span><br><span class=\"line\"><span class=\"string\">egregious 过分的，惊人的，异乎寻常的</span></span><br><span class=\"line\"><span class=\"string\">hit me even more egregious 这就让我更不爽了</span></span><br><span class=\"line\"><span class=\"string\">passionate 热烈的，激情的</span></span><br><span class=\"line\"><span class=\"string\">I wrote a long and passionate email 我写了一长篇饱含激情的文章</span></span><br><span class=\"line\"><span class=\"string\">bias 偏见</span></span><br><span class=\"line\"><span class=\"string\">jungle gym 立体方格铁架</span></span><br><span class=\"line\"><span class=\"string\">unknown and often ununderstood gender bias 未知也通常未被理解的性别偏见</span></span><br><span class=\"line\"><span class=\"string\">You can challenge stereotypes that'</span>s subtle <span class=\"keyword\">and</span> obvious 你可以挑战老一套的做法</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>最近自己开的栏目有点多，脑洞太大，总想都做一些，也算自己在学习之余听听TED作为放松吧。不过光听总觉得会不够，也做一个TED观看总结吧。就当学英语了。</p>\n<h2 id=\"演讲嘉宾介绍\"><a href=\"#演讲嘉宾介绍\" class=\"headerlink\" title=\"演讲嘉宾介绍\"></a>演讲嘉宾介绍</h2><p>雪莉·桑德伯格，谷歌全球在线销售和运营部门副总裁。现任Facebook首席运营官，被媒体称为”Facebook的第一夫人”，她也是第一位进入Facebook董事会的女性成员。同时，她还是福布斯上榜的前50名”最有力量” 的商业女精英之一。2013年，她登上《时代周刊》杂志封面，并被《时代》杂志评为全球最具影响力的人物。桑德伯格还曾是前美国财政部官员，此外她还曾以世界银行经济学家的身份在麦肯锡咨询公司担任过顾问一职。<br></p>","more":"<br>马克·扎克伯格说：“没有了谢莉·桑德伯格的Facebook不是完整的。”<p></p>\n<p>《每日电讯报》的编辑阿曼达·安德鲁斯评价说：“她说得不多，但却很好很流利而且非常有魅力。”安德鲁斯甚至称她为“Facebook的第一夫人”。</p>\n<p>也是大牛一个。</p>\n<h2 id=\"演讲内容\"><a href=\"#演讲内容\" class=\"headerlink\" title=\"演讲内容\"></a>演讲内容</h2><p><strong>为人要真诚，敢于发声，勇于为平等而战，时刻记住反省自身。</strong></p>\n<p>Don’t just move up and down. Don’t just look up.your career and your life will have starts and stops and zigs and zags,we should open ourself up to honesty.</p>\n<p>不要仅仅是爬上爬下，不要只往上看，你的职业和生活中会有始终，会有曲折。你需要对自己真诚。</p>\n<p>起点到终点之间不可能是一条直线，也不要期待直线，找到自己立体方格铁架，慢慢的曲曲折折的爬过去。顺便欣赏一下沿途的风景。这一点讲的非常的好，几个例子也举的非常合适。包括雪莉的职业选择，甚至是她的婚姻。当然讲到婚姻是为了讲应该去主动的收集反馈，这在走出了学校，走出了考试体系之后尤为重要。</p>\n<p>So often the truth is sacrificed to conflict avoidance,or by the time we speak the truth, we’ve used so many caveats and preambles that the message totally gets lost.So I ask you to ask each other for the truth and other people,can you list it in simple and clear language?</p>\n<p>真相往往成为了避免冲突的牺牲品，在我们讲真相的时候，我们通常用了非常多的修饰，很多委婉语而导致淹没了真正想要传达的消息。在向人询问真相的时候，请用简单明了的语言相互交流。</p>\n<p>I want to put some pressure on you to acknowledge the hard truths,not shy away from them,and when you see them to address them.</p>\n<p>我想给你们一些压力让你们认识到真相有时候很难接受，但很重要，不要逃避，碰到时就勇于面对。</p>\n<p>Leaning in does not mean your path will be straight or smooth。</p>\n<p>向前一步并不表示你的前路一帆风顺。</p>\n<p>Fortune favors the bold. What would you do if you weren’t afraid? </p>\n<p>财富偏爱勇者，不要害怕，勇往直前</p>\n<p>nothing at Facebook is someone else’s problem </p>\n<p>在脸书上没有别人的问题</p>\n<p>not only will you figure out what you want to do eventually,but once you do, you’ll crush it.</p>\n<p>你最终会找到你想要做的事情，并最终获得成功。</p>\n<p>you know that while you are extraordinary on your own,we are all stronger and can be louder together.</p>\n<p>你知道虽然你们都很出色，但是团结在一起会使我们变得更强，并能发出更大的声音。</p>\n<p>Tomrrow you all become part of a lifelong community,which offers truly great opportunity and therefore comes with real obligation.</p>\n<p>明天你们都将步入社会，这将是一生的旅途，图中会遇到很好的机会也会有很重大的责任。</p>\n<h2 id=\"单词杂记\"><a href=\"#单词杂记\" class=\"headerlink\" title=\"单词杂记\"></a>单词杂记</h2><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">daunting　令人畏惧的;使人气馁的;令人怯步的</span><br><span class=\"line\">cliff 悬崖</span><br><span class=\"line\">feedback 反馈</span><br><span class=\"line\">//Asking <span class=\"keyword\">for</span> feedback is <span class=\"keyword\">a</span> really important habit <span class=\"built_in\">to</span> <span class=\"built_in\">get</span> <span class=\"keyword\">into</span>,<span class=\"keyword\">as</span> you leave <span class=\"keyword\">the</span> structure <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> school calendar <span class=\"keyword\">and</span> exams <span class=\"keyword\">and</span> grades behind.</span><br><span class=\"line\">blurt out 脱口而出 </span><br><span class=\"line\">//<span class=\"string\">'You'</span>re mad,<span class=\"string\">' the driver blurted out.</span></span><br><span class=\"line\"><span class=\"string\">caveat修饰</span></span><br><span class=\"line\"><span class=\"string\">I was kinda like a parrot with issues 我就像一只学舌的鹦鹉</span></span><br><span class=\"line\"><span class=\"string\">forth 向前</span></span><br><span class=\"line\"><span class=\"string\">//This went back and forth a couple of times 这样来回了几次 </span></span><br><span class=\"line\"><span class=\"string\">tyranny 暴政，残暴</span></span><br><span class=\"line\"><span class=\"string\">but we suffer from the tyranny of low expectations 但我们还在低预期的践踏</span></span><br><span class=\"line\"><span class=\"string\">egregious 过分的，惊人的，异乎寻常的</span></span><br><span class=\"line\"><span class=\"string\">hit me even more egregious 这就让我更不爽了</span></span><br><span class=\"line\"><span class=\"string\">passionate 热烈的，激情的</span></span><br><span class=\"line\"><span class=\"string\">I wrote a long and passionate email 我写了一长篇饱含激情的文章</span></span><br><span class=\"line\"><span class=\"string\">bias 偏见</span></span><br><span class=\"line\"><span class=\"string\">jungle gym 立体方格铁架</span></span><br><span class=\"line\"><span class=\"string\">unknown and often ununderstood gender bias 未知也通常未被理解的性别偏见</span></span><br><span class=\"line\"><span class=\"string\">You can challenge stereotypes that'</span>s subtle <span class=\"keyword\">and</span> obvious 你可以挑战老一套的做法</span><br></pre></td></tr></table></figure>"},{"title":"【TED】为掌握而学习而不是分数","date":"2016-09-29T15:14:50.000Z","_content":"\n今天要讲的是两个概念，也就是掌握概念和心智模式的概念。\n<!-- more -->\n\n当人们开始学习更高级的数学知识时，数学变得越来越难。当接触代数时，他们有太多没掌握的知识点(they had so many gaps in their knowledge they couldn't engage with it)。他们觉得自己根本是个数学笨蛋。当他们大一点的时候，他们去不可并决定好好努力。发现好的资源而且能够填补以前的知识差距并掌握他们。这会强化他们并未固化的心智模式(that reinforced their mindset that it wasn't fixed),然后他们发现自己是可以学好数学的。\n\n当然，生活中有很多方式，这只是展示了如何掌握很多事情的一例。如武术练习、学习乐器，需要不断基础功的积累。但我们要指出的是(but what we point out ),这不是传统学校的教学方式，在传统的教学方式中，我们不断上课，做作业如此重复，一周之后，进行一次小测验，可能在这个考试中我得了75分，你得了90分，虽然考试检验处我们的知识有差距(even though the test identified gaps in our knowledge)，可我还有25%的知识没掌握啊。即便我们知晓了差距，但整个班还是会进入下一个更高一级的知识讲解。更高一级的知识会继续累积我们的知识差距(probably a more advanced subject that's going to build on those gaps)。这个进程会继续，然后你马上回意识到这是多么的奇怪。我有25%的知识不动，现在又要学习更难的知识，这会持续好几个月，甚至好几年，直到有一天，我彻底蒙了(I hit a wall)，这不是因为代数本来就很难或者学生不聪明，这是因为我这解题时，但有30%我不懂的东西出现了。然后我就不想做了(I start to disengage)。\n\n为了更好地理解这有多荒谬，他举了一个造房子的例子，当造到第二层第三层的时候，楼彻底塌了。如果你的反应如在学习上碰到的那样，或者很多人都会这有，你可能会说，这是包工头的问题，可能我们需要更细致的检查或者更频繁的检查。但其实是过程出了问题(But what was really broken was the process)。我们认为地限制了做某件事的时间，保证了一个变动的结果，然后我们不厌其烦地一边又一遍地检查和确认差距，但我们依然在它上面继续造房子。\n\n所以掌握学习的精髓在于做相反的事。与其自我限制，不如另行其道。变动的是一个学生什么时候用多长时间学习一个概念，固定的是他们实实在在地掌握了知识。重要的是不仅这些学生会学得更好，而且还会强化他们正确的心智模式。\n\n也就是说，你得到75分，并不代表你很差，这表示你要努力学习，你要有勇气(grit)，要坚持(perseverance)。\n\n可能会有很多批评都会说，哇，真不错，理想真丰满(philosophically哲学的),以掌握为导向的学习机器与心智模式的关联。这都很有道理，可是现实是骨感的(impractical不切实际的)。要真正做到，那要每个学生都有自己的学习路径(every student would be on their own track)。\n\n不过现在可以通过网络课程来实现。我们有充分的适应性练习(there's adaptive exercises readily available for students)。当那些都成真了，有意思的事情就发生了(When that happens,all sorts of neat things happen)。\n\n>the student can actually master the concepts,but they're also building their growth mindset,they're building grit,perseverance,they're taking agency over their learning.\n\n\n如果当以掌握为导向时，而不是基于你的个人经历和周围亲友，那么当你出错了，拥抱它，将失败看做一次学习的契机。那分数会无限接近100分，这不仅仅是“不错”，这是社会的必然(social imperative)。社会的金字塔在改变，不再是以前那种底层是劳动力，中层是信息处理的官僚机构在顶端是资本家，企业家和有创造力的人群的结构，信息化的社会将是新的金字塔。在金字塔底层，自动化将替代人力，在中间那层甚至也将被计算机取代，而更多的人在金字塔的顶端，这将是一个颠倒的金字塔。\n\n如果我们让每个人都发挥他们的潜能去掌握概念，能够借助第三方来帮助他们学习，那就不是触不可及的。当你把它想象成一个公民社会的话，这就非常振奋人心。想想我们能够拥有的那种公平，还有我们的社会能达到的文明程度。我们会生活在一个很美好的时代。\n```\nthe key leverage points for learning\n学习的重要杠杆支点\npyramid 金字塔\ntake the trouble of doing sth.\n不厌其烦的\n\n\n```\n尽管演讲者这么说，但个人认为那种公民社会还是任重道远的。不过前半段很是赞同，不是么？","source":"_posts/摘录/【TED】为掌握而学习而不是分数.md","raw":"---\ntitle: 【TED】为掌握而学习而不是分数\ndate: 2016-09-29 23:14:50\ntags: \n- TED\ncategories: 总结\n---\n\n今天要讲的是两个概念，也就是掌握概念和心智模式的概念。\n<!-- more -->\n\n当人们开始学习更高级的数学知识时，数学变得越来越难。当接触代数时，他们有太多没掌握的知识点(they had so many gaps in their knowledge they couldn't engage with it)。他们觉得自己根本是个数学笨蛋。当他们大一点的时候，他们去不可并决定好好努力。发现好的资源而且能够填补以前的知识差距并掌握他们。这会强化他们并未固化的心智模式(that reinforced their mindset that it wasn't fixed),然后他们发现自己是可以学好数学的。\n\n当然，生活中有很多方式，这只是展示了如何掌握很多事情的一例。如武术练习、学习乐器，需要不断基础功的积累。但我们要指出的是(but what we point out ),这不是传统学校的教学方式，在传统的教学方式中，我们不断上课，做作业如此重复，一周之后，进行一次小测验，可能在这个考试中我得了75分，你得了90分，虽然考试检验处我们的知识有差距(even though the test identified gaps in our knowledge)，可我还有25%的知识没掌握啊。即便我们知晓了差距，但整个班还是会进入下一个更高一级的知识讲解。更高一级的知识会继续累积我们的知识差距(probably a more advanced subject that's going to build on those gaps)。这个进程会继续，然后你马上回意识到这是多么的奇怪。我有25%的知识不动，现在又要学习更难的知识，这会持续好几个月，甚至好几年，直到有一天，我彻底蒙了(I hit a wall)，这不是因为代数本来就很难或者学生不聪明，这是因为我这解题时，但有30%我不懂的东西出现了。然后我就不想做了(I start to disengage)。\n\n为了更好地理解这有多荒谬，他举了一个造房子的例子，当造到第二层第三层的时候，楼彻底塌了。如果你的反应如在学习上碰到的那样，或者很多人都会这有，你可能会说，这是包工头的问题，可能我们需要更细致的检查或者更频繁的检查。但其实是过程出了问题(But what was really broken was the process)。我们认为地限制了做某件事的时间，保证了一个变动的结果，然后我们不厌其烦地一边又一遍地检查和确认差距，但我们依然在它上面继续造房子。\n\n所以掌握学习的精髓在于做相反的事。与其自我限制，不如另行其道。变动的是一个学生什么时候用多长时间学习一个概念，固定的是他们实实在在地掌握了知识。重要的是不仅这些学生会学得更好，而且还会强化他们正确的心智模式。\n\n也就是说，你得到75分，并不代表你很差，这表示你要努力学习，你要有勇气(grit)，要坚持(perseverance)。\n\n可能会有很多批评都会说，哇，真不错，理想真丰满(philosophically哲学的),以掌握为导向的学习机器与心智模式的关联。这都很有道理，可是现实是骨感的(impractical不切实际的)。要真正做到，那要每个学生都有自己的学习路径(every student would be on their own track)。\n\n不过现在可以通过网络课程来实现。我们有充分的适应性练习(there's adaptive exercises readily available for students)。当那些都成真了，有意思的事情就发生了(When that happens,all sorts of neat things happen)。\n\n>the student can actually master the concepts,but they're also building their growth mindset,they're building grit,perseverance,they're taking agency over their learning.\n\n\n如果当以掌握为导向时，而不是基于你的个人经历和周围亲友，那么当你出错了，拥抱它，将失败看做一次学习的契机。那分数会无限接近100分，这不仅仅是“不错”，这是社会的必然(social imperative)。社会的金字塔在改变，不再是以前那种底层是劳动力，中层是信息处理的官僚机构在顶端是资本家，企业家和有创造力的人群的结构，信息化的社会将是新的金字塔。在金字塔底层，自动化将替代人力，在中间那层甚至也将被计算机取代，而更多的人在金字塔的顶端，这将是一个颠倒的金字塔。\n\n如果我们让每个人都发挥他们的潜能去掌握概念，能够借助第三方来帮助他们学习，那就不是触不可及的。当你把它想象成一个公民社会的话，这就非常振奋人心。想想我们能够拥有的那种公平，还有我们的社会能达到的文明程度。我们会生活在一个很美好的时代。\n```\nthe key leverage points for learning\n学习的重要杠杆支点\npyramid 金字塔\ntake the trouble of doing sth.\n不厌其烦的\n\n\n```\n尽管演讲者这么说，但个人认为那种公民社会还是任重道远的。不过前半段很是赞同，不是么？","slug":"摘录/【TED】为掌握而学习而不是分数","published":1,"updated":"2019-03-22T14:44:36.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmx3003k4l3n76uw9odp","content":"<p>今天要讲的是两个概念，也就是掌握概念和心智模式的概念。<br><a id=\"more\"></a></p>\n<p>当人们开始学习更高级的数学知识时，数学变得越来越难。当接触代数时，他们有太多没掌握的知识点(they had so many gaps in their knowledge they couldn’t engage with it)。他们觉得自己根本是个数学笨蛋。当他们大一点的时候，他们去不可并决定好好努力。发现好的资源而且能够填补以前的知识差距并掌握他们。这会强化他们并未固化的心智模式(that reinforced their mindset that it wasn’t fixed),然后他们发现自己是可以学好数学的。</p>\n<p>当然，生活中有很多方式，这只是展示了如何掌握很多事情的一例。如武术练习、学习乐器，需要不断基础功的积累。但我们要指出的是(but what we point out ),这不是传统学校的教学方式，在传统的教学方式中，我们不断上课，做作业如此重复，一周之后，进行一次小测验，可能在这个考试中我得了75分，你得了90分，虽然考试检验处我们的知识有差距(even though the test identified gaps in our knowledge)，可我还有25%的知识没掌握啊。即便我们知晓了差距，但整个班还是会进入下一个更高一级的知识讲解。更高一级的知识会继续累积我们的知识差距(probably a more advanced subject that’s going to build on those gaps)。这个进程会继续，然后你马上回意识到这是多么的奇怪。我有25%的知识不动，现在又要学习更难的知识，这会持续好几个月，甚至好几年，直到有一天，我彻底蒙了(I hit a wall)，这不是因为代数本来就很难或者学生不聪明，这是因为我这解题时，但有30%我不懂的东西出现了。然后我就不想做了(I start to disengage)。</p>\n<p>为了更好地理解这有多荒谬，他举了一个造房子的例子，当造到第二层第三层的时候，楼彻底塌了。如果你的反应如在学习上碰到的那样，或者很多人都会这有，你可能会说，这是包工头的问题，可能我们需要更细致的检查或者更频繁的检查。但其实是过程出了问题(But what was really broken was the process)。我们认为地限制了做某件事的时间，保证了一个变动的结果，然后我们不厌其烦地一边又一遍地检查和确认差距，但我们依然在它上面继续造房子。</p>\n<p>所以掌握学习的精髓在于做相反的事。与其自我限制，不如另行其道。变动的是一个学生什么时候用多长时间学习一个概念，固定的是他们实实在在地掌握了知识。重要的是不仅这些学生会学得更好，而且还会强化他们正确的心智模式。</p>\n<p>也就是说，你得到75分，并不代表你很差，这表示你要努力学习，你要有勇气(grit)，要坚持(perseverance)。</p>\n<p>可能会有很多批评都会说，哇，真不错，理想真丰满(philosophically哲学的),以掌握为导向的学习机器与心智模式的关联。这都很有道理，可是现实是骨感的(impractical不切实际的)。要真正做到，那要每个学生都有自己的学习路径(every student would be on their own track)。</p>\n<p>不过现在可以通过网络课程来实现。我们有充分的适应性练习(there’s adaptive exercises readily available for students)。当那些都成真了，有意思的事情就发生了(When that happens,all sorts of neat things happen)。</p>\n<blockquote>\n<p>the student can actually master the concepts,but they’re also building their growth mindset,they’re building grit,perseverance,they’re taking agency over their learning.</p>\n</blockquote>\n<p>如果当以掌握为导向时，而不是基于你的个人经历和周围亲友，那么当你出错了，拥抱它，将失败看做一次学习的契机。那分数会无限接近100分，这不仅仅是“不错”，这是社会的必然(social imperative)。社会的金字塔在改变，不再是以前那种底层是劳动力，中层是信息处理的官僚机构在顶端是资本家，企业家和有创造力的人群的结构，信息化的社会将是新的金字塔。在金字塔底层，自动化将替代人力，在中间那层甚至也将被计算机取代，而更多的人在金字塔的顶端，这将是一个颠倒的金字塔。</p>\n<p>如果我们让每个人都发挥他们的潜能去掌握概念，能够借助第三方来帮助他们学习，那就不是触不可及的。当你把它想象成一个公民社会的话，这就非常振奋人心。想想我们能够拥有的那种公平，还有我们的社会能达到的文明程度。我们会生活在一个很美好的时代。<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">the</span> key leverage points <span class=\"keyword\">for</span> learning</span><br><span class=\"line\">学习的重要杠杆支点</span><br><span class=\"line\">pyramid 金字塔</span><br><span class=\"line\">take <span class=\"keyword\">the</span> trouble <span class=\"keyword\">of</span> doing sth.</span><br><span class=\"line\">不厌其烦的</span><br></pre></td></tr></table></figure></p>\n<p>尽管演讲者这么说，但个人认为那种公民社会还是任重道远的。不过前半段很是赞同，不是么？</p>\n","site":{"data":{}},"excerpt":"<p>今天要讲的是两个概念，也就是掌握概念和心智模式的概念。<br></p>","more":"<p></p>\n<p>当人们开始学习更高级的数学知识时，数学变得越来越难。当接触代数时，他们有太多没掌握的知识点(they had so many gaps in their knowledge they couldn’t engage with it)。他们觉得自己根本是个数学笨蛋。当他们大一点的时候，他们去不可并决定好好努力。发现好的资源而且能够填补以前的知识差距并掌握他们。这会强化他们并未固化的心智模式(that reinforced their mindset that it wasn’t fixed),然后他们发现自己是可以学好数学的。</p>\n<p>当然，生活中有很多方式，这只是展示了如何掌握很多事情的一例。如武术练习、学习乐器，需要不断基础功的积累。但我们要指出的是(but what we point out ),这不是传统学校的教学方式，在传统的教学方式中，我们不断上课，做作业如此重复，一周之后，进行一次小测验，可能在这个考试中我得了75分，你得了90分，虽然考试检验处我们的知识有差距(even though the test identified gaps in our knowledge)，可我还有25%的知识没掌握啊。即便我们知晓了差距，但整个班还是会进入下一个更高一级的知识讲解。更高一级的知识会继续累积我们的知识差距(probably a more advanced subject that’s going to build on those gaps)。这个进程会继续，然后你马上回意识到这是多么的奇怪。我有25%的知识不动，现在又要学习更难的知识，这会持续好几个月，甚至好几年，直到有一天，我彻底蒙了(I hit a wall)，这不是因为代数本来就很难或者学生不聪明，这是因为我这解题时，但有30%我不懂的东西出现了。然后我就不想做了(I start to disengage)。</p>\n<p>为了更好地理解这有多荒谬，他举了一个造房子的例子，当造到第二层第三层的时候，楼彻底塌了。如果你的反应如在学习上碰到的那样，或者很多人都会这有，你可能会说，这是包工头的问题，可能我们需要更细致的检查或者更频繁的检查。但其实是过程出了问题(But what was really broken was the process)。我们认为地限制了做某件事的时间，保证了一个变动的结果，然后我们不厌其烦地一边又一遍地检查和确认差距，但我们依然在它上面继续造房子。</p>\n<p>所以掌握学习的精髓在于做相反的事。与其自我限制，不如另行其道。变动的是一个学生什么时候用多长时间学习一个概念，固定的是他们实实在在地掌握了知识。重要的是不仅这些学生会学得更好，而且还会强化他们正确的心智模式。</p>\n<p>也就是说，你得到75分，并不代表你很差，这表示你要努力学习，你要有勇气(grit)，要坚持(perseverance)。</p>\n<p>可能会有很多批评都会说，哇，真不错，理想真丰满(philosophically哲学的),以掌握为导向的学习机器与心智模式的关联。这都很有道理，可是现实是骨感的(impractical不切实际的)。要真正做到，那要每个学生都有自己的学习路径(every student would be on their own track)。</p>\n<p>不过现在可以通过网络课程来实现。我们有充分的适应性练习(there’s adaptive exercises readily available for students)。当那些都成真了，有意思的事情就发生了(When that happens,all sorts of neat things happen)。</p>\n<blockquote>\n<p>the student can actually master the concepts,but they’re also building their growth mindset,they’re building grit,perseverance,they’re taking agency over their learning.</p>\n</blockquote>\n<p>如果当以掌握为导向时，而不是基于你的个人经历和周围亲友，那么当你出错了，拥抱它，将失败看做一次学习的契机。那分数会无限接近100分，这不仅仅是“不错”，这是社会的必然(social imperative)。社会的金字塔在改变，不再是以前那种底层是劳动力，中层是信息处理的官僚机构在顶端是资本家，企业家和有创造力的人群的结构，信息化的社会将是新的金字塔。在金字塔底层，自动化将替代人力，在中间那层甚至也将被计算机取代，而更多的人在金字塔的顶端，这将是一个颠倒的金字塔。</p>\n<p>如果我们让每个人都发挥他们的潜能去掌握概念，能够借助第三方来帮助他们学习，那就不是触不可及的。当你把它想象成一个公民社会的话，这就非常振奋人心。想想我们能够拥有的那种公平，还有我们的社会能达到的文明程度。我们会生活在一个很美好的时代。<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">the</span> key leverage points <span class=\"keyword\">for</span> learning</span><br><span class=\"line\">学习的重要杠杆支点</span><br><span class=\"line\">pyramid 金字塔</span><br><span class=\"line\">take <span class=\"keyword\">the</span> trouble <span class=\"keyword\">of</span> doing sth.</span><br><span class=\"line\">不厌其烦的</span><br></pre></td></tr></table></figure></p>\n<p>尽管演讲者这么说，但个人认为那种公民社会还是任重道远的。不过前半段很是赞同，不是么？</p>"},{"title":"刘备为什么三顾茅庐","date":"2016-08-30T11:22:50.000Z","_content":"\n刘备三顾茅庐真的只是为了爱才么？诸葛亮曾经在《出师表》中说过这么一句话，\n<!-- more -->\n>臣本布衣，躬耕于南阳。\n\n诸葛亮自称是平民布衣，可是事实并非如此。他的祖上是汉朝司隶校尉诸葛丰，父亲是青州泰山郡丞，也是不小的官，所以说诸葛亮也是世家子弟。\n\n那为什么自称为布衣呢？一方面是自谦，另一方面，和他早年的经历有关。\n\n祖上虽然是高官，性情刚正不阿，对贪官污吏、专事阿谀奉承之小人恨之入骨。后因弹劾权臣，皇帝不允，被降为城门校尉。不久被免官，贬为庶人，后老死家中。父亲又早年去世，被叔叔养大。他的叔叔也不是一般的人，不过官运也不佳，之后投奔荆州大佬刘表。在叔父死后，诸葛亮就迁移到了隆中耕田，开始在荆州经营自己的关系网。\n\n那诸葛亮是怎么做的呢？\n\n在诸葛亮的时代，当时是以门阀政治为主。所谓门阀政治，势力以几个大家族为主，这几个大家族甚至超过了皇族。有一句话说：\n>旧时王谢堂前燕，飞入寻常百姓家。\n\n说的就是这样的情况。其中的王谢，则是王羲之和谢安家族。这样的门阀，一方面一个个眼睛都长在头顶上，爱看不起人。另一方面，现实利益分配的原因，对于外来的世家子弟，都予以排斥。\n\n我们都知道，诸葛亮有个特别丑的老婆，据记载，诸葛亮老婆身材壮硕，黄头发黑皮肤，脸上还有雀斑。相貌堂堂的诸葛亮为什么要取这么丑的老婆呢？原来，他老婆黄氏是在荆州当地非常有名望的家族。所以说，诸葛亮要融入当地的人际关系网，娶一个当地世俗都不愿意取的但是又出身名门大家的丑老婆，是一个很明智的选择。而在此之前，诸葛亮的叔父也没闲着，将诸葛亮的几个姐姐也都嫁到了另外的几个名门望族。现在我们再来梳理一下诸葛亮的荆州关系网。\n\n1.叔叔是当时荆州刘表的老朋友。\n2.岳父是名门大族。\n3.两个姐姐的婆家是刘表所依靠的两个家族。\n4.掌管军权的蔡瑁则是诸葛亮岳父的舅哥。刘表和蔡瑁也有姻亲。\n5.诸葛亮的大哥诸葛瑾当时是东吴冉冉升起的政治新星了。\n\n一句话就是，诸葛亮是当时荆州打通所有名门家族的人。而刘备呢？当时在荆州过得相当苦闷。刘表对刘备不信任，还处处提防。就在刘备去拜访诸葛亮的那年，曹操已经是挟天子以令诸侯了，而孙权年纪轻轻就已经当上了一方霸主，这对于一直图谋天下霸业的刘备来说，是一个极大的刺激。更重要的是，在那一年，荆州的一把手刘表病重，眼看就要不行了。这是刘备在荆州打开局面的一个重大机会。而要在荆州打开局面，就不得不得到当地名门望族的支持。而要得到他们的支持，就需要一个能够联络并调动起那些家族的人选，而恰恰又是那么巧，有人向刘备推荐了诸葛亮。这也就解释了为什么见多了名臣谋士的刘备会对诸葛亮那么重视，甚至在关羽和张飞这么不理解的情况下，还要坚持三顾茅庐。不仅如此，还要将其地位排在两位义弟之上。\n\n所以你看，不是说诸葛亮没有才华，但是诸葛亮联络调动荆州各方势力的能力才是刘备三顾茅庐的原因。\n\n这个故事告诉我们，**一个人进入一个系统的时机，决定了他的地位。而他利用自身资源给系统带来的助力有多大，他在系统当中的位置就有多重要。**\n\n----\n>以上摘自 公众号：“今日值得花时间”（诸葛亮的发迹之路）\n\n-----\n\n\n## 小小总结\n\n在我看来，上述故事不仅仅告诉了我们这些。诸葛亮之所以能值得刘备三顾茅庐，也正是因为自己明确自己的能力，尽管表面上看躬耕于南阳，却实则目光长远，都触及了那个时代社会的痛点。《隆中对》中就提到过诸葛亮当时庐中给刘备献策的场景，虽有艺术成分，不过那指点天下的才识和气魄，再加上上文所说诸葛在联络调动各方势力的能力，正是刘备此次就见的痛点所在。尽管诸葛亮当时还处在系统之外，就已经以系统人的身份在思考在准备，个人觉得在一开始诸葛亮就没有打算仅仅靠耕田过一辈子，早就计划好了自己的发展路线，明确而又清晰，才努力练就这一身的本领和气宇，也正是因为如此他一直在等伯乐前来，而那个伯乐恰巧就是刘备，三顾茅庐才终于出山，也正是天时地利人和综合所得。\n\n也希望自己能够在这网络大潮中，打好基石咬定青山，外修内练，静候伯乐。","source":"_posts/摘录/刘备为什么三顾茅庐.md","raw":"---\ntitle: 刘备为什么三顾茅庐\ndate: 2016-08-30 19:22:50\ntags: \n- 杂谈\ncategories: 反思\n---\n\n刘备三顾茅庐真的只是为了爱才么？诸葛亮曾经在《出师表》中说过这么一句话，\n<!-- more -->\n>臣本布衣，躬耕于南阳。\n\n诸葛亮自称是平民布衣，可是事实并非如此。他的祖上是汉朝司隶校尉诸葛丰，父亲是青州泰山郡丞，也是不小的官，所以说诸葛亮也是世家子弟。\n\n那为什么自称为布衣呢？一方面是自谦，另一方面，和他早年的经历有关。\n\n祖上虽然是高官，性情刚正不阿，对贪官污吏、专事阿谀奉承之小人恨之入骨。后因弹劾权臣，皇帝不允，被降为城门校尉。不久被免官，贬为庶人，后老死家中。父亲又早年去世，被叔叔养大。他的叔叔也不是一般的人，不过官运也不佳，之后投奔荆州大佬刘表。在叔父死后，诸葛亮就迁移到了隆中耕田，开始在荆州经营自己的关系网。\n\n那诸葛亮是怎么做的呢？\n\n在诸葛亮的时代，当时是以门阀政治为主。所谓门阀政治，势力以几个大家族为主，这几个大家族甚至超过了皇族。有一句话说：\n>旧时王谢堂前燕，飞入寻常百姓家。\n\n说的就是这样的情况。其中的王谢，则是王羲之和谢安家族。这样的门阀，一方面一个个眼睛都长在头顶上，爱看不起人。另一方面，现实利益分配的原因，对于外来的世家子弟，都予以排斥。\n\n我们都知道，诸葛亮有个特别丑的老婆，据记载，诸葛亮老婆身材壮硕，黄头发黑皮肤，脸上还有雀斑。相貌堂堂的诸葛亮为什么要取这么丑的老婆呢？原来，他老婆黄氏是在荆州当地非常有名望的家族。所以说，诸葛亮要融入当地的人际关系网，娶一个当地世俗都不愿意取的但是又出身名门大家的丑老婆，是一个很明智的选择。而在此之前，诸葛亮的叔父也没闲着，将诸葛亮的几个姐姐也都嫁到了另外的几个名门望族。现在我们再来梳理一下诸葛亮的荆州关系网。\n\n1.叔叔是当时荆州刘表的老朋友。\n2.岳父是名门大族。\n3.两个姐姐的婆家是刘表所依靠的两个家族。\n4.掌管军权的蔡瑁则是诸葛亮岳父的舅哥。刘表和蔡瑁也有姻亲。\n5.诸葛亮的大哥诸葛瑾当时是东吴冉冉升起的政治新星了。\n\n一句话就是，诸葛亮是当时荆州打通所有名门家族的人。而刘备呢？当时在荆州过得相当苦闷。刘表对刘备不信任，还处处提防。就在刘备去拜访诸葛亮的那年，曹操已经是挟天子以令诸侯了，而孙权年纪轻轻就已经当上了一方霸主，这对于一直图谋天下霸业的刘备来说，是一个极大的刺激。更重要的是，在那一年，荆州的一把手刘表病重，眼看就要不行了。这是刘备在荆州打开局面的一个重大机会。而要在荆州打开局面，就不得不得到当地名门望族的支持。而要得到他们的支持，就需要一个能够联络并调动起那些家族的人选，而恰恰又是那么巧，有人向刘备推荐了诸葛亮。这也就解释了为什么见多了名臣谋士的刘备会对诸葛亮那么重视，甚至在关羽和张飞这么不理解的情况下，还要坚持三顾茅庐。不仅如此，还要将其地位排在两位义弟之上。\n\n所以你看，不是说诸葛亮没有才华，但是诸葛亮联络调动荆州各方势力的能力才是刘备三顾茅庐的原因。\n\n这个故事告诉我们，**一个人进入一个系统的时机，决定了他的地位。而他利用自身资源给系统带来的助力有多大，他在系统当中的位置就有多重要。**\n\n----\n>以上摘自 公众号：“今日值得花时间”（诸葛亮的发迹之路）\n\n-----\n\n\n## 小小总结\n\n在我看来，上述故事不仅仅告诉了我们这些。诸葛亮之所以能值得刘备三顾茅庐，也正是因为自己明确自己的能力，尽管表面上看躬耕于南阳，却实则目光长远，都触及了那个时代社会的痛点。《隆中对》中就提到过诸葛亮当时庐中给刘备献策的场景，虽有艺术成分，不过那指点天下的才识和气魄，再加上上文所说诸葛在联络调动各方势力的能力，正是刘备此次就见的痛点所在。尽管诸葛亮当时还处在系统之外，就已经以系统人的身份在思考在准备，个人觉得在一开始诸葛亮就没有打算仅仅靠耕田过一辈子，早就计划好了自己的发展路线，明确而又清晰，才努力练就这一身的本领和气宇，也正是因为如此他一直在等伯乐前来，而那个伯乐恰巧就是刘备，三顾茅庐才终于出山，也正是天时地利人和综合所得。\n\n也希望自己能够在这网络大潮中，打好基石咬定青山，外修内练，静候伯乐。","slug":"摘录/刘备为什么三顾茅庐","published":1,"updated":"2019-03-22T14:44:36.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmx3003n4l3nh191so8h","content":"<p>刘备三顾茅庐真的只是为了爱才么？诸葛亮曾经在《出师表》中说过这么一句话，<br><a id=\"more\"></a></p>\n<blockquote>\n<p>臣本布衣，躬耕于南阳。</p>\n</blockquote>\n<p>诸葛亮自称是平民布衣，可是事实并非如此。他的祖上是汉朝司隶校尉诸葛丰，父亲是青州泰山郡丞，也是不小的官，所以说诸葛亮也是世家子弟。</p>\n<p>那为什么自称为布衣呢？一方面是自谦，另一方面，和他早年的经历有关。</p>\n<p>祖上虽然是高官，性情刚正不阿，对贪官污吏、专事阿谀奉承之小人恨之入骨。后因弹劾权臣，皇帝不允，被降为城门校尉。不久被免官，贬为庶人，后老死家中。父亲又早年去世，被叔叔养大。他的叔叔也不是一般的人，不过官运也不佳，之后投奔荆州大佬刘表。在叔父死后，诸葛亮就迁移到了隆中耕田，开始在荆州经营自己的关系网。</p>\n<p>那诸葛亮是怎么做的呢？</p>\n<p>在诸葛亮的时代，当时是以门阀政治为主。所谓门阀政治，势力以几个大家族为主，这几个大家族甚至超过了皇族。有一句话说：</p>\n<blockquote>\n<p>旧时王谢堂前燕，飞入寻常百姓家。</p>\n</blockquote>\n<p>说的就是这样的情况。其中的王谢，则是王羲之和谢安家族。这样的门阀，一方面一个个眼睛都长在头顶上，爱看不起人。另一方面，现实利益分配的原因，对于外来的世家子弟，都予以排斥。</p>\n<p>我们都知道，诸葛亮有个特别丑的老婆，据记载，诸葛亮老婆身材壮硕，黄头发黑皮肤，脸上还有雀斑。相貌堂堂的诸葛亮为什么要取这么丑的老婆呢？原来，他老婆黄氏是在荆州当地非常有名望的家族。所以说，诸葛亮要融入当地的人际关系网，娶一个当地世俗都不愿意取的但是又出身名门大家的丑老婆，是一个很明智的选择。而在此之前，诸葛亮的叔父也没闲着，将诸葛亮的几个姐姐也都嫁到了另外的几个名门望族。现在我们再来梳理一下诸葛亮的荆州关系网。</p>\n<p>1.叔叔是当时荆州刘表的老朋友。<br>2.岳父是名门大族。<br>3.两个姐姐的婆家是刘表所依靠的两个家族。<br>4.掌管军权的蔡瑁则是诸葛亮岳父的舅哥。刘表和蔡瑁也有姻亲。<br>5.诸葛亮的大哥诸葛瑾当时是东吴冉冉升起的政治新星了。</p>\n<p>一句话就是，诸葛亮是当时荆州打通所有名门家族的人。而刘备呢？当时在荆州过得相当苦闷。刘表对刘备不信任，还处处提防。就在刘备去拜访诸葛亮的那年，曹操已经是挟天子以令诸侯了，而孙权年纪轻轻就已经当上了一方霸主，这对于一直图谋天下霸业的刘备来说，是一个极大的刺激。更重要的是，在那一年，荆州的一把手刘表病重，眼看就要不行了。这是刘备在荆州打开局面的一个重大机会。而要在荆州打开局面，就不得不得到当地名门望族的支持。而要得到他们的支持，就需要一个能够联络并调动起那些家族的人选，而恰恰又是那么巧，有人向刘备推荐了诸葛亮。这也就解释了为什么见多了名臣谋士的刘备会对诸葛亮那么重视，甚至在关羽和张飞这么不理解的情况下，还要坚持三顾茅庐。不仅如此，还要将其地位排在两位义弟之上。</p>\n<p>所以你看，不是说诸葛亮没有才华，但是诸葛亮联络调动荆州各方势力的能力才是刘备三顾茅庐的原因。</p>\n<p>这个故事告诉我们，<strong>一个人进入一个系统的时机，决定了他的地位。而他利用自身资源给系统带来的助力有多大，他在系统当中的位置就有多重要。</strong></p>\n<hr>\n<blockquote>\n<p>以上摘自 公众号：“今日值得花时间”（诸葛亮的发迹之路）</p>\n</blockquote>\n<hr>\n<h2 id=\"小小总结\"><a href=\"#小小总结\" class=\"headerlink\" title=\"小小总结\"></a>小小总结</h2><p>在我看来，上述故事不仅仅告诉了我们这些。诸葛亮之所以能值得刘备三顾茅庐，也正是因为自己明确自己的能力，尽管表面上看躬耕于南阳，却实则目光长远，都触及了那个时代社会的痛点。《隆中对》中就提到过诸葛亮当时庐中给刘备献策的场景，虽有艺术成分，不过那指点天下的才识和气魄，再加上上文所说诸葛在联络调动各方势力的能力，正是刘备此次就见的痛点所在。尽管诸葛亮当时还处在系统之外，就已经以系统人的身份在思考在准备，个人觉得在一开始诸葛亮就没有打算仅仅靠耕田过一辈子，早就计划好了自己的发展路线，明确而又清晰，才努力练就这一身的本领和气宇，也正是因为如此他一直在等伯乐前来，而那个伯乐恰巧就是刘备，三顾茅庐才终于出山，也正是天时地利人和综合所得。</p>\n<p>也希望自己能够在这网络大潮中，打好基石咬定青山，外修内练，静候伯乐。</p>\n","site":{"data":{}},"excerpt":"<p>刘备三顾茅庐真的只是为了爱才么？诸葛亮曾经在《出师表》中说过这么一句话，<br></p>","more":"<p></p>\n<blockquote>\n<p>臣本布衣，躬耕于南阳。</p>\n</blockquote>\n<p>诸葛亮自称是平民布衣，可是事实并非如此。他的祖上是汉朝司隶校尉诸葛丰，父亲是青州泰山郡丞，也是不小的官，所以说诸葛亮也是世家子弟。</p>\n<p>那为什么自称为布衣呢？一方面是自谦，另一方面，和他早年的经历有关。</p>\n<p>祖上虽然是高官，性情刚正不阿，对贪官污吏、专事阿谀奉承之小人恨之入骨。后因弹劾权臣，皇帝不允，被降为城门校尉。不久被免官，贬为庶人，后老死家中。父亲又早年去世，被叔叔养大。他的叔叔也不是一般的人，不过官运也不佳，之后投奔荆州大佬刘表。在叔父死后，诸葛亮就迁移到了隆中耕田，开始在荆州经营自己的关系网。</p>\n<p>那诸葛亮是怎么做的呢？</p>\n<p>在诸葛亮的时代，当时是以门阀政治为主。所谓门阀政治，势力以几个大家族为主，这几个大家族甚至超过了皇族。有一句话说：</p>\n<blockquote>\n<p>旧时王谢堂前燕，飞入寻常百姓家。</p>\n</blockquote>\n<p>说的就是这样的情况。其中的王谢，则是王羲之和谢安家族。这样的门阀，一方面一个个眼睛都长在头顶上，爱看不起人。另一方面，现实利益分配的原因，对于外来的世家子弟，都予以排斥。</p>\n<p>我们都知道，诸葛亮有个特别丑的老婆，据记载，诸葛亮老婆身材壮硕，黄头发黑皮肤，脸上还有雀斑。相貌堂堂的诸葛亮为什么要取这么丑的老婆呢？原来，他老婆黄氏是在荆州当地非常有名望的家族。所以说，诸葛亮要融入当地的人际关系网，娶一个当地世俗都不愿意取的但是又出身名门大家的丑老婆，是一个很明智的选择。而在此之前，诸葛亮的叔父也没闲着，将诸葛亮的几个姐姐也都嫁到了另外的几个名门望族。现在我们再来梳理一下诸葛亮的荆州关系网。</p>\n<p>1.叔叔是当时荆州刘表的老朋友。<br>2.岳父是名门大族。<br>3.两个姐姐的婆家是刘表所依靠的两个家族。<br>4.掌管军权的蔡瑁则是诸葛亮岳父的舅哥。刘表和蔡瑁也有姻亲。<br>5.诸葛亮的大哥诸葛瑾当时是东吴冉冉升起的政治新星了。</p>\n<p>一句话就是，诸葛亮是当时荆州打通所有名门家族的人。而刘备呢？当时在荆州过得相当苦闷。刘表对刘备不信任，还处处提防。就在刘备去拜访诸葛亮的那年，曹操已经是挟天子以令诸侯了，而孙权年纪轻轻就已经当上了一方霸主，这对于一直图谋天下霸业的刘备来说，是一个极大的刺激。更重要的是，在那一年，荆州的一把手刘表病重，眼看就要不行了。这是刘备在荆州打开局面的一个重大机会。而要在荆州打开局面，就不得不得到当地名门望族的支持。而要得到他们的支持，就需要一个能够联络并调动起那些家族的人选，而恰恰又是那么巧，有人向刘备推荐了诸葛亮。这也就解释了为什么见多了名臣谋士的刘备会对诸葛亮那么重视，甚至在关羽和张飞这么不理解的情况下，还要坚持三顾茅庐。不仅如此，还要将其地位排在两位义弟之上。</p>\n<p>所以你看，不是说诸葛亮没有才华，但是诸葛亮联络调动荆州各方势力的能力才是刘备三顾茅庐的原因。</p>\n<p>这个故事告诉我们，<strong>一个人进入一个系统的时机，决定了他的地位。而他利用自身资源给系统带来的助力有多大，他在系统当中的位置就有多重要。</strong></p>\n<hr>\n<blockquote>\n<p>以上摘自 公众号：“今日值得花时间”（诸葛亮的发迹之路）</p>\n</blockquote>\n<hr>\n<h2 id=\"小小总结\"><a href=\"#小小总结\" class=\"headerlink\" title=\"小小总结\"></a>小小总结</h2><p>在我看来，上述故事不仅仅告诉了我们这些。诸葛亮之所以能值得刘备三顾茅庐，也正是因为自己明确自己的能力，尽管表面上看躬耕于南阳，却实则目光长远，都触及了那个时代社会的痛点。《隆中对》中就提到过诸葛亮当时庐中给刘备献策的场景，虽有艺术成分，不过那指点天下的才识和气魄，再加上上文所说诸葛在联络调动各方势力的能力，正是刘备此次就见的痛点所在。尽管诸葛亮当时还处在系统之外，就已经以系统人的身份在思考在准备，个人觉得在一开始诸葛亮就没有打算仅仅靠耕田过一辈子，早就计划好了自己的发展路线，明确而又清晰，才努力练就这一身的本领和气宇，也正是因为如此他一直在等伯乐前来，而那个伯乐恰巧就是刘备，三顾茅庐才终于出山，也正是天时地利人和综合所得。</p>\n<p>也希望自己能够在这网络大潮中，打好基石咬定青山，外修内练，静候伯乐。</p>"},{"title":"历史上的经济泡沫","date":"2020-02-07T15:22:50.000Z","_content":"\n## 历史上的经济泡沫\n\n参考自[李永乐老师讲经济泡沫](https://www.bilibili.com/video/av69184579)\n\n### 郁金香🌷狂热\n\n#### 背景\n1. 荷西战争获得胜利，政治独立。\n2. 开设东印度公司，经济富有，手工业者150盾/人年\n3. 中亚的郁金香，法国人佩戴郁金香作为身份的标志（精神需求）\n\n<!-- more -->\n\n>中亚的郁金香如何到的西欧？\n土耳其在中亚占了很多土地，后来又打下君士坦丁堡（1453年君士坦丁堡沦陷）。\n打下之后，和西欧接壤。所以逐渐传播到了西欧，\n\n#### 发生\n种子5-7年，而球茎只要1年，花期一周。\n当时数量少，培育时间长，人们有精神需求，于是炒作就开始了。\n\n1.1634年，成立行业协会，交易需要给佣金，由于在酒馆中交易，称之为酒钱。\n2.1636年12月，期货交易1647年4月的郁金香。\n3.1637年年初，郁金香品种“奥古斯都”买6290荷兰盾\n\n#### 结束\n1. 1637年2月，期货临近交割，着急出手，价格下跌\n2. 贷款者也急于追债，进一步促进下跌，最后下跌到0.1盾\n3. 1637年4月，无买主来购买，荷兰出台法律废止该合约。\n4. 一年后，改为3.5%的价格，可以作废合约。\n\n#### 郁金香🌷效应\n\n人们出于对财富的渴求，在炒作的开始，往往会出现羊群效应，缺失理智。从而称之为郁金香效应。\n\n#### 类似的长春君子兰事件\n\n1. 不是本土花，从非洲被殖民者引入日本，后在日本占领满洲时，日本皇室将该花送给伪满皇帝溥仪。后来伪满倒台之后，流落长春民间。\n2. 1982年，出台限价令，最高不能超过200元/盆。人均工资10+/人月\n3. 1982年，进行义展，展出钱将捐献给大熊猫，此次君子兰义展门票收入17000元。\n4. 1984年，政府推出窗台经济，倡议每人窗台上都种君子兰，放开限价令，还被定位长春市市花。\n5. 1985年，达到巅峰， 用皇冠车换君子兰。 一盆花卖了14万。\n6. 1985年，吉林省省报三篇文章，人民日报也发了，从而出台政策，跌到了1%\n\n\n\n\n\n","source":"_posts/摘录/历史上的经济泡沫.md","raw":"---\ntitle: 历史上的经济泡沫\ndate: 2020-02-07 23:22:50\ntags: \n- 杂谈\ncategories: 反思\n---\n\n## 历史上的经济泡沫\n\n参考自[李永乐老师讲经济泡沫](https://www.bilibili.com/video/av69184579)\n\n### 郁金香🌷狂热\n\n#### 背景\n1. 荷西战争获得胜利，政治独立。\n2. 开设东印度公司，经济富有，手工业者150盾/人年\n3. 中亚的郁金香，法国人佩戴郁金香作为身份的标志（精神需求）\n\n<!-- more -->\n\n>中亚的郁金香如何到的西欧？\n土耳其在中亚占了很多土地，后来又打下君士坦丁堡（1453年君士坦丁堡沦陷）。\n打下之后，和西欧接壤。所以逐渐传播到了西欧，\n\n#### 发生\n种子5-7年，而球茎只要1年，花期一周。\n当时数量少，培育时间长，人们有精神需求，于是炒作就开始了。\n\n1.1634年，成立行业协会，交易需要给佣金，由于在酒馆中交易，称之为酒钱。\n2.1636年12月，期货交易1647年4月的郁金香。\n3.1637年年初，郁金香品种“奥古斯都”买6290荷兰盾\n\n#### 结束\n1. 1637年2月，期货临近交割，着急出手，价格下跌\n2. 贷款者也急于追债，进一步促进下跌，最后下跌到0.1盾\n3. 1637年4月，无买主来购买，荷兰出台法律废止该合约。\n4. 一年后，改为3.5%的价格，可以作废合约。\n\n#### 郁金香🌷效应\n\n人们出于对财富的渴求，在炒作的开始，往往会出现羊群效应，缺失理智。从而称之为郁金香效应。\n\n#### 类似的长春君子兰事件\n\n1. 不是本土花，从非洲被殖民者引入日本，后在日本占领满洲时，日本皇室将该花送给伪满皇帝溥仪。后来伪满倒台之后，流落长春民间。\n2. 1982年，出台限价令，最高不能超过200元/盆。人均工资10+/人月\n3. 1982年，进行义展，展出钱将捐献给大熊猫，此次君子兰义展门票收入17000元。\n4. 1984年，政府推出窗台经济，倡议每人窗台上都种君子兰，放开限价令，还被定位长春市市花。\n5. 1985年，达到巅峰， 用皇冠车换君子兰。 一盆花卖了14万。\n6. 1985年，吉林省省报三篇文章，人民日报也发了，从而出台政策，跌到了1%\n\n\n\n\n\n","slug":"摘录/历史上的经济泡沫","published":1,"updated":"2020-02-07T15:31:58.713Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmx5003q4l3nbo2videt","content":"<h2 id=\"历史上的经济泡沫\"><a href=\"#历史上的经济泡沫\" class=\"headerlink\" title=\"历史上的经济泡沫\"></a>历史上的经济泡沫</h2><p>参考自<a href=\"https://www.bilibili.com/video/av69184579\" target=\"_blank\" rel=\"noopener\">李永乐老师讲经济泡沫</a></p>\n<h3 id=\"郁金香🌷狂热\"><a href=\"#郁金香🌷狂热\" class=\"headerlink\" title=\"郁金香🌷狂热\"></a>郁金香🌷狂热</h3><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><ol>\n<li>荷西战争获得胜利，政治独立。</li>\n<li>开设东印度公司，经济富有，手工业者150盾/人年</li>\n<li>中亚的郁金香，法国人佩戴郁金香作为身份的标志（精神需求）</li>\n</ol>\n<a id=\"more\"></a>\n<blockquote>\n<p>中亚的郁金香如何到的西欧？<br>土耳其在中亚占了很多土地，后来又打下君士坦丁堡（1453年君士坦丁堡沦陷）。<br>打下之后，和西欧接壤。所以逐渐传播到了西欧，</p>\n</blockquote>\n<h4 id=\"发生\"><a href=\"#发生\" class=\"headerlink\" title=\"发生\"></a>发生</h4><p>种子5-7年，而球茎只要1年，花期一周。<br>当时数量少，培育时间长，人们有精神需求，于是炒作就开始了。</p>\n<p>1.1634年，成立行业协会，交易需要给佣金，由于在酒馆中交易，称之为酒钱。<br>2.1636年12月，期货交易1647年4月的郁金香。<br>3.1637年年初，郁金香品种“奥古斯都”买6290荷兰盾</p>\n<h4 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h4><ol>\n<li>1637年2月，期货临近交割，着急出手，价格下跌</li>\n<li>贷款者也急于追债，进一步促进下跌，最后下跌到0.1盾</li>\n<li>1637年4月，无买主来购买，荷兰出台法律废止该合约。</li>\n<li>一年后，改为3.5%的价格，可以作废合约。</li>\n</ol>\n<h4 id=\"郁金香🌷效应\"><a href=\"#郁金香🌷效应\" class=\"headerlink\" title=\"郁金香🌷效应\"></a>郁金香🌷效应</h4><p>人们出于对财富的渴求，在炒作的开始，往往会出现羊群效应，缺失理智。从而称之为郁金香效应。</p>\n<h4 id=\"类似的长春君子兰事件\"><a href=\"#类似的长春君子兰事件\" class=\"headerlink\" title=\"类似的长春君子兰事件\"></a>类似的长春君子兰事件</h4><ol>\n<li>不是本土花，从非洲被殖民者引入日本，后在日本占领满洲时，日本皇室将该花送给伪满皇帝溥仪。后来伪满倒台之后，流落长春民间。</li>\n<li>1982年，出台限价令，最高不能超过200元/盆。人均工资10+/人月</li>\n<li>1982年，进行义展，展出钱将捐献给大熊猫，此次君子兰义展门票收入17000元。</li>\n<li>1984年，政府推出窗台经济，倡议每人窗台上都种君子兰，放开限价令，还被定位长春市市花。</li>\n<li>1985年，达到巅峰， 用皇冠车换君子兰。 一盆花卖了14万。</li>\n<li>1985年，吉林省省报三篇文章，人民日报也发了，从而出台政策，跌到了1%</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h2 id=\"历史上的经济泡沫\"><a href=\"#历史上的经济泡沫\" class=\"headerlink\" title=\"历史上的经济泡沫\"></a>历史上的经济泡沫</h2><p>参考自<a href=\"https://www.bilibili.com/video/av69184579\" target=\"_blank\" rel=\"noopener\">李永乐老师讲经济泡沫</a></p>\n<h3 id=\"郁金香🌷狂热\"><a href=\"#郁金香🌷狂热\" class=\"headerlink\" title=\"郁金香🌷狂热\"></a>郁金香🌷狂热</h3><h4 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h4><ol>\n<li>荷西战争获得胜利，政治独立。</li>\n<li>开设东印度公司，经济富有，手工业者150盾/人年</li>\n<li>中亚的郁金香，法国人佩戴郁金香作为身份的标志（精神需求）</li>\n</ol>","more":"<blockquote>\n<p>中亚的郁金香如何到的西欧？<br>土耳其在中亚占了很多土地，后来又打下君士坦丁堡（1453年君士坦丁堡沦陷）。<br>打下之后，和西欧接壤。所以逐渐传播到了西欧，</p>\n</blockquote>\n<h4 id=\"发生\"><a href=\"#发生\" class=\"headerlink\" title=\"发生\"></a>发生</h4><p>种子5-7年，而球茎只要1年，花期一周。<br>当时数量少，培育时间长，人们有精神需求，于是炒作就开始了。</p>\n<p>1.1634年，成立行业协会，交易需要给佣金，由于在酒馆中交易，称之为酒钱。<br>2.1636年12月，期货交易1647年4月的郁金香。<br>3.1637年年初，郁金香品种“奥古斯都”买6290荷兰盾</p>\n<h4 id=\"结束\"><a href=\"#结束\" class=\"headerlink\" title=\"结束\"></a>结束</h4><ol>\n<li>1637年2月，期货临近交割，着急出手，价格下跌</li>\n<li>贷款者也急于追债，进一步促进下跌，最后下跌到0.1盾</li>\n<li>1637年4月，无买主来购买，荷兰出台法律废止该合约。</li>\n<li>一年后，改为3.5%的价格，可以作废合约。</li>\n</ol>\n<h4 id=\"郁金香🌷效应\"><a href=\"#郁金香🌷效应\" class=\"headerlink\" title=\"郁金香🌷效应\"></a>郁金香🌷效应</h4><p>人们出于对财富的渴求，在炒作的开始，往往会出现羊群效应，缺失理智。从而称之为郁金香效应。</p>\n<h4 id=\"类似的长春君子兰事件\"><a href=\"#类似的长春君子兰事件\" class=\"headerlink\" title=\"类似的长春君子兰事件\"></a>类似的长春君子兰事件</h4><ol>\n<li>不是本土花，从非洲被殖民者引入日本，后在日本占领满洲时，日本皇室将该花送给伪满皇帝溥仪。后来伪满倒台之后，流落长春民间。</li>\n<li>1982年，出台限价令，最高不能超过200元/盆。人均工资10+/人月</li>\n<li>1982年，进行义展，展出钱将捐献给大熊猫，此次君子兰义展门票收入17000元。</li>\n<li>1984年，政府推出窗台经济，倡议每人窗台上都种君子兰，放开限价令，还被定位长春市市花。</li>\n<li>1985年，达到巅峰， 用皇冠车换君子兰。 一盆花卖了14万。</li>\n<li>1985年，吉林省省报三篇文章，人民日报也发了，从而出台政策，跌到了1%</li>\n</ol>"},{"title":"如何有效的报告bug","date":"2017-09-27T04:14:50.000Z","_content":"\n[原文章](https://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html)\n\n报告bug的目的是为了让程序员看到程序的错误。您可以亲自示范，也可以给出能导致程序出错的、详尽的操作步骤。如果程序出错了，程序员会收集额外的信息直到找到错误的原因；如果程序没有出错，那么他们会请您继续关注这个问题，收集相关的信息。\n<!-- more -->\n在bug报告里，要设法搞清什么是**事实**（例如：“我在电脑旁”和“XX出现了”）什么是**推测**（例如：“我想问题可能是出在……”）。如果愿意的话，您可以省去推测，但是千万别省略事实。\n\n当您报告bug的时候（既然您已经这么做了），一定是希望bug得到及时修正。所以此时针对程序员的任何过激或亵渎的言语（甚至谩骂）都是与事无补的——因为这可能是程序员的错误，也有可能是您的错误，也许您有权对他们发火，但是如果您能多提供一些有用的信息（而不是激愤之词）或许bug会被更快的修正。\n\n\n","source":"_posts/摘录/提问的智慧.md","raw":"---\ntitle: 如何有效的报告bug\ndate: 2017-09-27 12:14:50\ntags: \n- 摘录\ncategories: 方法学习\n---\n\n[原文章](https://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html)\n\n报告bug的目的是为了让程序员看到程序的错误。您可以亲自示范，也可以给出能导致程序出错的、详尽的操作步骤。如果程序出错了，程序员会收集额外的信息直到找到错误的原因；如果程序没有出错，那么他们会请您继续关注这个问题，收集相关的信息。\n<!-- more -->\n在bug报告里，要设法搞清什么是**事实**（例如：“我在电脑旁”和“XX出现了”）什么是**推测**（例如：“我想问题可能是出在……”）。如果愿意的话，您可以省去推测，但是千万别省略事实。\n\n当您报告bug的时候（既然您已经这么做了），一定是希望bug得到及时修正。所以此时针对程序员的任何过激或亵渎的言语（甚至谩骂）都是与事无补的——因为这可能是程序员的错误，也有可能是您的错误，也许您有权对他们发火，但是如果您能多提供一些有用的信息（而不是激愤之词）或许bug会被更快的修正。\n\n\n","slug":"摘录/提问的智慧","published":1,"updated":"2019-03-22T14:44:36.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmx7003u4l3nwcar9o6z","content":"<p><a href=\"https://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html\" target=\"_blank\" rel=\"noopener\">原文章</a></p>\n<p>报告bug的目的是为了让程序员看到程序的错误。您可以亲自示范，也可以给出能导致程序出错的、详尽的操作步骤。如果程序出错了，程序员会收集额外的信息直到找到错误的原因；如果程序没有出错，那么他们会请您继续关注这个问题，收集相关的信息。<br><a id=\"more\"></a><br>在bug报告里，要设法搞清什么是<strong>事实</strong>（例如：“我在电脑旁”和“XX出现了”）什么是<strong>推测</strong>（例如：“我想问题可能是出在……”）。如果愿意的话，您可以省去推测，但是千万别省略事实。</p>\n<p>当您报告bug的时候（既然您已经这么做了），一定是希望bug得到及时修正。所以此时针对程序员的任何过激或亵渎的言语（甚至谩骂）都是与事无补的——因为这可能是程序员的错误，也有可能是您的错误，也许您有权对他们发火，但是如果您能多提供一些有用的信息（而不是激愤之词）或许bug会被更快的修正。</p>\n","site":{"data":{}},"excerpt":"<p><a href=\"https://www.chiark.greenend.org.uk/~sgtatham/bugs-cn.html\" target=\"_blank\" rel=\"noopener\">原文章</a></p>\n<p>报告bug的目的是为了让程序员看到程序的错误。您可以亲自示范，也可以给出能导致程序出错的、详尽的操作步骤。如果程序出错了，程序员会收集额外的信息直到找到错误的原因；如果程序没有出错，那么他们会请您继续关注这个问题，收集相关的信息。<br></p>","more":"<br>在bug报告里，要设法搞清什么是<strong>事实</strong>（例如：“我在电脑旁”和“XX出现了”）什么是<strong>推测</strong>（例如：“我想问题可能是出在……”）。如果愿意的话，您可以省去推测，但是千万别省略事实。<p></p>\n<p>当您报告bug的时候（既然您已经这么做了），一定是希望bug得到及时修正。所以此时针对程序员的任何过激或亵渎的言语（甚至谩骂）都是与事无补的——因为这可能是程序员的错误，也有可能是您的错误，也许您有权对他们发火，但是如果您能多提供一些有用的信息（而不是激愤之词）或许bug会被更快的修正。</p>"},{"title":"技术管理课","date":"2019-03-25T12:22:00.000Z","_content":"\n### bug 引发事故，该不该究责？\n\n<!--more-->\n\n如果每个错误都会受到惩罚，会怎样;如果所有的错误都没有任何追究和跟进，又会怎样?\n假如每个错误都会受到惩罚，不难想象，以下情况一定难以避免。\n1. 大家都怕闯祸，所以风险高的事没人做，或者总是那几个靠谱的“老司机”做。没有机会处理这种复杂情况的人，永远得不到锻炼，也无法积累这样的经验。 \n\n2. 如果有人搞砸了什么事情，会因为担心承担后果而推卸责任，从而尽可能掩盖错误的坏影响，不让人知道。\n\n3. 如果别人犯了错，会觉得不关自己的事。\n\n4. 指出别人的错误就会导致别人被追究责任，因此看到有问题也会犹豫要不要指出。\n\n反之，如果无论发生什么错误，都不需要承担后果或进行反省，没有任何担当，那可能又会出现以下情况。\n\n1. 同样的错误可能会一再发生。\n\n2. 小错没有被及时制止，或者没有引起足够重视，最终导致酿成大错。\n\n3. 做事仔细的人会觉得不公平。自己为了安全起见，每次代码改动都写很多单元测试，每个项目都反复测试和预防问题;但是别人的草草而就导致错误百出，却因为显得进度更\n  快，反而被认为更有效率。\n\n那么，对于工作中的错误，尤其是 Bug 导致的错误，我们应该采取什么态度和措施呢?\n第一，解决问题。首先要考虑的是用户数据没有了怎么做补救。如果实在没有办法挽回数据了，考虑如何将损失降到最低。或者以某种方式补偿用户。用户的利益永远是第一位的。\n\n第二，追究责任，但不是惩罚。“知其然，并知其所以然”，搞清楚在什么场景下，什么样的 Bug 引发了什么样的错误。相关人员应该尽最大的可能去做好善后工作，并思考如何避免 下次犯同样的错误。\n\n第三，对事儿不对人。在这个追究的过程中，重点在于怎么改善流程、改进制度，来避免同样的错误，而不是指责员工不应该怎么样。如果相关人员已经那么做了，为什么这个错误仍 然没有及时被发现和制止?\n\n第四，反复问“为什么”，从根本上发现问题。错误为什么会发生?有些 Bug 可能只是显露出来的冰山一角。 ","source":"_posts/业务知识总结/技术管理.md","raw":"---\ntitle: 技术管理课\ndate: 2019-03-25 20:22:00\ntags: \n- 总结\ncategories: 总结\n---\n\n### bug 引发事故，该不该究责？\n\n<!--more-->\n\n如果每个错误都会受到惩罚，会怎样;如果所有的错误都没有任何追究和跟进，又会怎样?\n假如每个错误都会受到惩罚，不难想象，以下情况一定难以避免。\n1. 大家都怕闯祸，所以风险高的事没人做，或者总是那几个靠谱的“老司机”做。没有机会处理这种复杂情况的人，永远得不到锻炼，也无法积累这样的经验。 \n\n2. 如果有人搞砸了什么事情，会因为担心承担后果而推卸责任，从而尽可能掩盖错误的坏影响，不让人知道。\n\n3. 如果别人犯了错，会觉得不关自己的事。\n\n4. 指出别人的错误就会导致别人被追究责任，因此看到有问题也会犹豫要不要指出。\n\n反之，如果无论发生什么错误，都不需要承担后果或进行反省，没有任何担当，那可能又会出现以下情况。\n\n1. 同样的错误可能会一再发生。\n\n2. 小错没有被及时制止，或者没有引起足够重视，最终导致酿成大错。\n\n3. 做事仔细的人会觉得不公平。自己为了安全起见，每次代码改动都写很多单元测试，每个项目都反复测试和预防问题;但是别人的草草而就导致错误百出，却因为显得进度更\n  快，反而被认为更有效率。\n\n那么，对于工作中的错误，尤其是 Bug 导致的错误，我们应该采取什么态度和措施呢?\n第一，解决问题。首先要考虑的是用户数据没有了怎么做补救。如果实在没有办法挽回数据了，考虑如何将损失降到最低。或者以某种方式补偿用户。用户的利益永远是第一位的。\n\n第二，追究责任，但不是惩罚。“知其然，并知其所以然”，搞清楚在什么场景下，什么样的 Bug 引发了什么样的错误。相关人员应该尽最大的可能去做好善后工作，并思考如何避免 下次犯同样的错误。\n\n第三，对事儿不对人。在这个追究的过程中，重点在于怎么改善流程、改进制度，来避免同样的错误，而不是指责员工不应该怎么样。如果相关人员已经那么做了，为什么这个错误仍 然没有及时被发现和制止?\n\n第四，反复问“为什么”，从根本上发现问题。错误为什么会发生?有些 Bug 可能只是显露出来的冰山一角。 ","slug":"业务知识总结/技术管理","published":1,"updated":"2019-03-25T17:11:44.188Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmx9003x4l3nxectwfcg","content":"<h3 id=\"bug-引发事故，该不该究责？\"><a href=\"#bug-引发事故，该不该究责？\" class=\"headerlink\" title=\"bug 引发事故，该不该究责？\"></a>bug 引发事故，该不该究责？</h3><a id=\"more\"></a>\n<p>如果每个错误都会受到惩罚，会怎样;如果所有的错误都没有任何追究和跟进，又会怎样?<br>假如每个错误都会受到惩罚，不难想象，以下情况一定难以避免。</p>\n<ol>\n<li><p>大家都怕闯祸，所以风险高的事没人做，或者总是那几个靠谱的“老司机”做。没有机会处理这种复杂情况的人，永远得不到锻炼，也无法积累这样的经验。 </p>\n</li>\n<li><p>如果有人搞砸了什么事情，会因为担心承担后果而推卸责任，从而尽可能掩盖错误的坏影响，不让人知道。</p>\n</li>\n<li><p>如果别人犯了错，会觉得不关自己的事。</p>\n</li>\n<li><p>指出别人的错误就会导致别人被追究责任，因此看到有问题也会犹豫要不要指出。</p>\n</li>\n</ol>\n<p>反之，如果无论发生什么错误，都不需要承担后果或进行反省，没有任何担当，那可能又会出现以下情况。</p>\n<ol>\n<li><p>同样的错误可能会一再发生。</p>\n</li>\n<li><p>小错没有被及时制止，或者没有引起足够重视，最终导致酿成大错。</p>\n</li>\n<li><p>做事仔细的人会觉得不公平。自己为了安全起见，每次代码改动都写很多单元测试，每个项目都反复测试和预防问题;但是别人的草草而就导致错误百出，却因为显得进度更<br>快，反而被认为更有效率。</p>\n</li>\n</ol>\n<p>那么，对于工作中的错误，尤其是 Bug 导致的错误，我们应该采取什么态度和措施呢?<br>第一，解决问题。首先要考虑的是用户数据没有了怎么做补救。如果实在没有办法挽回数据了，考虑如何将损失降到最低。或者以某种方式补偿用户。用户的利益永远是第一位的。</p>\n<p>第二，追究责任，但不是惩罚。“知其然，并知其所以然”，搞清楚在什么场景下，什么样的 Bug 引发了什么样的错误。相关人员应该尽最大的可能去做好善后工作，并思考如何避免 下次犯同样的错误。</p>\n<p>第三，对事儿不对人。在这个追究的过程中，重点在于怎么改善流程、改进制度，来避免同样的错误，而不是指责员工不应该怎么样。如果相关人员已经那么做了，为什么这个错误仍 然没有及时被发现和制止?</p>\n<p>第四，反复问“为什么”，从根本上发现问题。错误为什么会发生?有些 Bug 可能只是显露出来的冰山一角。 </p>\n","site":{"data":{}},"excerpt":"<h3 id=\"bug-引发事故，该不该究责？\"><a href=\"#bug-引发事故，该不该究责？\" class=\"headerlink\" title=\"bug 引发事故，该不该究责？\"></a>bug 引发事故，该不该究责？</h3>","more":"<p>如果每个错误都会受到惩罚，会怎样;如果所有的错误都没有任何追究和跟进，又会怎样?<br>假如每个错误都会受到惩罚，不难想象，以下情况一定难以避免。</p>\n<ol>\n<li><p>大家都怕闯祸，所以风险高的事没人做，或者总是那几个靠谱的“老司机”做。没有机会处理这种复杂情况的人，永远得不到锻炼，也无法积累这样的经验。 </p>\n</li>\n<li><p>如果有人搞砸了什么事情，会因为担心承担后果而推卸责任，从而尽可能掩盖错误的坏影响，不让人知道。</p>\n</li>\n<li><p>如果别人犯了错，会觉得不关自己的事。</p>\n</li>\n<li><p>指出别人的错误就会导致别人被追究责任，因此看到有问题也会犹豫要不要指出。</p>\n</li>\n</ol>\n<p>反之，如果无论发生什么错误，都不需要承担后果或进行反省，没有任何担当，那可能又会出现以下情况。</p>\n<ol>\n<li><p>同样的错误可能会一再发生。</p>\n</li>\n<li><p>小错没有被及时制止，或者没有引起足够重视，最终导致酿成大错。</p>\n</li>\n<li><p>做事仔细的人会觉得不公平。自己为了安全起见，每次代码改动都写很多单元测试，每个项目都反复测试和预防问题;但是别人的草草而就导致错误百出，却因为显得进度更<br>快，反而被认为更有效率。</p>\n</li>\n</ol>\n<p>那么，对于工作中的错误，尤其是 Bug 导致的错误，我们应该采取什么态度和措施呢?<br>第一，解决问题。首先要考虑的是用户数据没有了怎么做补救。如果实在没有办法挽回数据了，考虑如何将损失降到最低。或者以某种方式补偿用户。用户的利益永远是第一位的。</p>\n<p>第二，追究责任，但不是惩罚。“知其然，并知其所以然”，搞清楚在什么场景下，什么样的 Bug 引发了什么样的错误。相关人员应该尽最大的可能去做好善后工作，并思考如何避免 下次犯同样的错误。</p>\n<p>第三，对事儿不对人。在这个追究的过程中，重点在于怎么改善流程、改进制度，来避免同样的错误，而不是指责员工不应该怎么样。如果相关人员已经那么做了，为什么这个错误仍 然没有及时被发现和制止?</p>\n<p>第四，反复问“为什么”，从根本上发现问题。错误为什么会发生?有些 Bug 可能只是显露出来的冰山一角。 </p>"},{"title":"HB10是啥玩意?","date":"2018-06-07T12:22:00.000Z","_content":"\n\n同样都是冲着数字货币去的，为啥大家买的都是主流币，我的币纹丝不动，而同事的翻了好几番？为啥我上的车都是儿童车，只会上下摇摆呢？上班一会不打开火币看行情，币却连连翻红？明明是大牛市，为啥我的资产却总是浮亏？别怕！我们还可以买HB10啊！等等，HB10是啥玩意儿？？？\n\n<!-- more -->\n\n\n### 什么是HB10?\n\n我们先来看看官方解答：\n\n```\n火币主力指数是由火币全球站上线币种中市值高、规模大、流通性好的10个币种组成，以综合反映火币全球站市场的整体表现。\n\n该指数样本空间为火币pro上线交易的全部USDT交易币种，根据区块链资产代表权益属性的不同，可以将其分为“币”、“平台”、“应用”和“实物资产代币化”四类。\n\n币指基于区块链技术开发的，不对应于特定的使用场景且主要功能仅为交易标的一类资产，其资产价值主要通过流动性体现；\n平台指与区块链底层技术开发相关联，且以该类平台使用权或参与权为支撑的一类资产；\n应用指与针对特定应用场景相关联，且以一定的使用权、参与权或分红权为支撑的一类资产；\n实物资产代币化指与实际资产如黄金、美元等挂钩的数字货币资产。\n\n在此基础上，火币主力指数以上一个季度的日均成交量作为选样的核心指标，采用派许加权综合价格指数公式进行计算。\n\n采用日均数据能降低单日价格波动性影响，更好地体现审核期内数字资产的流动性水平。此外本指数将根据各类区块链资产的上一季度日均成交额之和作为权重确定不同种类区块链资产的指数成份占比，以期全面反映火币上线区块链资产的综合表现，体现各类区块链技术应用的整体发展。\n```\n\n字太多根本不想看啊!来来来,划重点了!敲黑板!咳咳,是谁的小眼睛还没有看老师!\n\n简单的来说,只要看懂这一句就好了,HB10是火币选出了10个主流币种组成,反映了火币全球站市场的整体表现。\n\n整体表现什么意思? 也就是说主流币种涨了,你的资产涨了!\n\n### 优点一:\n\n不在乎你的钱多钱少,只要你买了HB10,就相当于你买下了整个市场！而且流通性够好,市值够高,规模够大!成功实现一个鸡蛋放在了多个篮子里的伟大目标,稳健!\n\n### 优点二:\n\n你再也不用担心某个币的大起大落落落落落落落而拉低你的资产,你也不用担心错过了EOS和HT的车了,因为买了HB就等于你已经买票上车了!跌的少,涨也不落下,稳健!\n\n### 优点三:\n\n再也不用担心每天从多个币之间倒来倒去,操碎了心肝,一顿操作,发现还不如躺着装死,只要市场势头旺,HB10就带着你飞,稳健!\n\n### 优点四:\n\nHB10每季度定期还会对超额收益进行分配。持有者还有糖果，分叉币等等的分红,稳健!\n\n\n\n最后剩下你需要做的,就是坚定的相信数字币的未来是足够光明的，火币的前景是一片大好的，还在等什么！HB10的出现正是解救我们于水深火热之中！话不多说，我已经梭哈了，你呢！","source":"_posts/数字货币/HB10是啥玩意.md","raw":"---\ntitle: HB10是啥玩意?\ndate: 2018-06-07 20:22:00\ntags: \n- 数字货币\ncategories: 数字货币\n---\n\n\n同样都是冲着数字货币去的，为啥大家买的都是主流币，我的币纹丝不动，而同事的翻了好几番？为啥我上的车都是儿童车，只会上下摇摆呢？上班一会不打开火币看行情，币却连连翻红？明明是大牛市，为啥我的资产却总是浮亏？别怕！我们还可以买HB10啊！等等，HB10是啥玩意儿？？？\n\n<!-- more -->\n\n\n### 什么是HB10?\n\n我们先来看看官方解答：\n\n```\n火币主力指数是由火币全球站上线币种中市值高、规模大、流通性好的10个币种组成，以综合反映火币全球站市场的整体表现。\n\n该指数样本空间为火币pro上线交易的全部USDT交易币种，根据区块链资产代表权益属性的不同，可以将其分为“币”、“平台”、“应用”和“实物资产代币化”四类。\n\n币指基于区块链技术开发的，不对应于特定的使用场景且主要功能仅为交易标的一类资产，其资产价值主要通过流动性体现；\n平台指与区块链底层技术开发相关联，且以该类平台使用权或参与权为支撑的一类资产；\n应用指与针对特定应用场景相关联，且以一定的使用权、参与权或分红权为支撑的一类资产；\n实物资产代币化指与实际资产如黄金、美元等挂钩的数字货币资产。\n\n在此基础上，火币主力指数以上一个季度的日均成交量作为选样的核心指标，采用派许加权综合价格指数公式进行计算。\n\n采用日均数据能降低单日价格波动性影响，更好地体现审核期内数字资产的流动性水平。此外本指数将根据各类区块链资产的上一季度日均成交额之和作为权重确定不同种类区块链资产的指数成份占比，以期全面反映火币上线区块链资产的综合表现，体现各类区块链技术应用的整体发展。\n```\n\n字太多根本不想看啊!来来来,划重点了!敲黑板!咳咳,是谁的小眼睛还没有看老师!\n\n简单的来说,只要看懂这一句就好了,HB10是火币选出了10个主流币种组成,反映了火币全球站市场的整体表现。\n\n整体表现什么意思? 也就是说主流币种涨了,你的资产涨了!\n\n### 优点一:\n\n不在乎你的钱多钱少,只要你买了HB10,就相当于你买下了整个市场！而且流通性够好,市值够高,规模够大!成功实现一个鸡蛋放在了多个篮子里的伟大目标,稳健!\n\n### 优点二:\n\n你再也不用担心某个币的大起大落落落落落落落而拉低你的资产,你也不用担心错过了EOS和HT的车了,因为买了HB就等于你已经买票上车了!跌的少,涨也不落下,稳健!\n\n### 优点三:\n\n再也不用担心每天从多个币之间倒来倒去,操碎了心肝,一顿操作,发现还不如躺着装死,只要市场势头旺,HB10就带着你飞,稳健!\n\n### 优点四:\n\nHB10每季度定期还会对超额收益进行分配。持有者还有糖果，分叉币等等的分红,稳健!\n\n\n\n最后剩下你需要做的,就是坚定的相信数字币的未来是足够光明的，火币的前景是一片大好的，还在等什么！HB10的出现正是解救我们于水深火热之中！话不多说，我已经梭哈了，你呢！","slug":"数字货币/HB10是啥玩意","published":1,"updated":"2019-03-22T14:44:36.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmx9003z4l3nl5cbfna2","content":"<p>同样都是冲着数字货币去的，为啥大家买的都是主流币，我的币纹丝不动，而同事的翻了好几番？为啥我上的车都是儿童车，只会上下摇摆呢？上班一会不打开火币看行情，币却连连翻红？明明是大牛市，为啥我的资产却总是浮亏？别怕！我们还可以买HB10啊！等等，HB10是啥玩意儿？？？</p>\n<a id=\"more\"></a>\n<h3 id=\"什么是HB10\"><a href=\"#什么是HB10\" class=\"headerlink\" title=\"什么是HB10?\"></a>什么是HB10?</h3><p>我们先来看看官方解答：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">火币主力指数是由火币全球站上线币种中市值高、规模大、流通性好的<span class=\"number\">10</span>个币种组成，以综合反映火币全球站市场的整体表现。</span><br><span class=\"line\"></span><br><span class=\"line\">该指数样本空间为火币pro上线交易的全部USDT交易币种，根据区块链资产代表权益属性的不同，可以将其分为“币”、“平台”、“应用”和“实物资产代币化”四类。</span><br><span class=\"line\"></span><br><span class=\"line\">币指基于区块链技术开发的，不对应于特定的使用场景且主要功能仅为交易标的一类资产，其资产价值主要通过流动性体现；</span><br><span class=\"line\">平台指与区块链底层技术开发相关联，且以该类平台使用权或参与权为支撑的一类资产；</span><br><span class=\"line\">应用指与针对特定应用场景相关联，且以一定的使用权、参与权或分红权为支撑的一类资产；</span><br><span class=\"line\">实物资产代币化指与实际资产如黄金、美元等挂钩的数字货币资产。</span><br><span class=\"line\"></span><br><span class=\"line\">在此基础上，火币主力指数以上一个季度的日均成交量作为选样的核心指标，采用派许加权综合价格指数公式进行计算。</span><br><span class=\"line\"></span><br><span class=\"line\">采用日均数据能降低单日价格波动性影响，更好地体现审核期内数字资产的流动性水平。此外本指数将根据各类区块链资产的上一季度日均成交额之和作为权重确定不同种类区块链资产的指数成份占比，以期全面反映火币上线区块链资产的综合表现，体现各类区块链技术应用的整体发展。</span><br></pre></td></tr></table></figure>\n<p>字太多根本不想看啊!来来来,划重点了!敲黑板!咳咳,是谁的小眼睛还没有看老师!</p>\n<p>简单的来说,只要看懂这一句就好了,HB10是火币选出了10个主流币种组成,反映了火币全球站市场的整体表现。</p>\n<p>整体表现什么意思? 也就是说主流币种涨了,你的资产涨了!</p>\n<h3 id=\"优点一\"><a href=\"#优点一\" class=\"headerlink\" title=\"优点一:\"></a>优点一:</h3><p>不在乎你的钱多钱少,只要你买了HB10,就相当于你买下了整个市场！而且流通性够好,市值够高,规模够大!成功实现一个鸡蛋放在了多个篮子里的伟大目标,稳健!</p>\n<h3 id=\"优点二\"><a href=\"#优点二\" class=\"headerlink\" title=\"优点二:\"></a>优点二:</h3><p>你再也不用担心某个币的大起大落落落落落落落而拉低你的资产,你也不用担心错过了EOS和HT的车了,因为买了HB就等于你已经买票上车了!跌的少,涨也不落下,稳健!</p>\n<h3 id=\"优点三\"><a href=\"#优点三\" class=\"headerlink\" title=\"优点三:\"></a>优点三:</h3><p>再也不用担心每天从多个币之间倒来倒去,操碎了心肝,一顿操作,发现还不如躺着装死,只要市场势头旺,HB10就带着你飞,稳健!</p>\n<h3 id=\"优点四\"><a href=\"#优点四\" class=\"headerlink\" title=\"优点四:\"></a>优点四:</h3><p>HB10每季度定期还会对超额收益进行分配。持有者还有糖果，分叉币等等的分红,稳健!</p>\n<p>最后剩下你需要做的,就是坚定的相信数字币的未来是足够光明的，火币的前景是一片大好的，还在等什么！HB10的出现正是解救我们于水深火热之中！话不多说，我已经梭哈了，你呢！</p>\n","site":{"data":{}},"excerpt":"<p>同样都是冲着数字货币去的，为啥大家买的都是主流币，我的币纹丝不动，而同事的翻了好几番？为啥我上的车都是儿童车，只会上下摇摆呢？上班一会不打开火币看行情，币却连连翻红？明明是大牛市，为啥我的资产却总是浮亏？别怕！我们还可以买HB10啊！等等，HB10是啥玩意儿？？？</p>","more":"<h3 id=\"什么是HB10\"><a href=\"#什么是HB10\" class=\"headerlink\" title=\"什么是HB10?\"></a>什么是HB10?</h3><p>我们先来看看官方解答：</p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">火币主力指数是由火币全球站上线币种中市值高、规模大、流通性好的<span class=\"number\">10</span>个币种组成，以综合反映火币全球站市场的整体表现。</span><br><span class=\"line\"></span><br><span class=\"line\">该指数样本空间为火币pro上线交易的全部USDT交易币种，根据区块链资产代表权益属性的不同，可以将其分为“币”、“平台”、“应用”和“实物资产代币化”四类。</span><br><span class=\"line\"></span><br><span class=\"line\">币指基于区块链技术开发的，不对应于特定的使用场景且主要功能仅为交易标的一类资产，其资产价值主要通过流动性体现；</span><br><span class=\"line\">平台指与区块链底层技术开发相关联，且以该类平台使用权或参与权为支撑的一类资产；</span><br><span class=\"line\">应用指与针对特定应用场景相关联，且以一定的使用权、参与权或分红权为支撑的一类资产；</span><br><span class=\"line\">实物资产代币化指与实际资产如黄金、美元等挂钩的数字货币资产。</span><br><span class=\"line\"></span><br><span class=\"line\">在此基础上，火币主力指数以上一个季度的日均成交量作为选样的核心指标，采用派许加权综合价格指数公式进行计算。</span><br><span class=\"line\"></span><br><span class=\"line\">采用日均数据能降低单日价格波动性影响，更好地体现审核期内数字资产的流动性水平。此外本指数将根据各类区块链资产的上一季度日均成交额之和作为权重确定不同种类区块链资产的指数成份占比，以期全面反映火币上线区块链资产的综合表现，体现各类区块链技术应用的整体发展。</span><br></pre></td></tr></table></figure>\n<p>字太多根本不想看啊!来来来,划重点了!敲黑板!咳咳,是谁的小眼睛还没有看老师!</p>\n<p>简单的来说,只要看懂这一句就好了,HB10是火币选出了10个主流币种组成,反映了火币全球站市场的整体表现。</p>\n<p>整体表现什么意思? 也就是说主流币种涨了,你的资产涨了!</p>\n<h3 id=\"优点一\"><a href=\"#优点一\" class=\"headerlink\" title=\"优点一:\"></a>优点一:</h3><p>不在乎你的钱多钱少,只要你买了HB10,就相当于你买下了整个市场！而且流通性够好,市值够高,规模够大!成功实现一个鸡蛋放在了多个篮子里的伟大目标,稳健!</p>\n<h3 id=\"优点二\"><a href=\"#优点二\" class=\"headerlink\" title=\"优点二:\"></a>优点二:</h3><p>你再也不用担心某个币的大起大落落落落落落落而拉低你的资产,你也不用担心错过了EOS和HT的车了,因为买了HB就等于你已经买票上车了!跌的少,涨也不落下,稳健!</p>\n<h3 id=\"优点三\"><a href=\"#优点三\" class=\"headerlink\" title=\"优点三:\"></a>优点三:</h3><p>再也不用担心每天从多个币之间倒来倒去,操碎了心肝,一顿操作,发现还不如躺着装死,只要市场势头旺,HB10就带着你飞,稳健!</p>\n<h3 id=\"优点四\"><a href=\"#优点四\" class=\"headerlink\" title=\"优点四:\"></a>优点四:</h3><p>HB10每季度定期还会对超额收益进行分配。持有者还有糖果，分叉币等等的分红,稳健!</p>\n<p>最后剩下你需要做的,就是坚定的相信数字币的未来是足够光明的，火币的前景是一片大好的，还在等什么！HB10的出现正是解救我们于水深火热之中！话不多说，我已经梭哈了，你呢！</p>"},{"title":"搬砖进阶","date":"2018-08-27T14:22:00.000Z","_content":"\n在数字货币行业当中，“搬砖”搬的不是砖头，是数字货币，并且是在不同交易所价格有差距的数字货币。由于搬运数字货币简单易操作，甚至可以用简单的电脑程序进行搬运的过程，因此被投资者们戏称为“搬砖”。\n\n<!-- more -->\n\n## 搬砖第一阶段\n假设有两个市场,存在较大价差,除去费用之后仍有盈余。大家都会想到的第一种方式便是搬，从价低市场搬到价高市场，赚取价差。\n\n实现方式为：\n\n```\n价低交易所买入BTC-> 转出至价高交易所 -> 价高交易所卖出\n\n```\n\n上述方式不可避免会导致由于转账时间长,导致价格波动， 导致亏损，因此引出了第二阶段的搬砖方法。\n\n\n## 搬砖第二阶段\n\n如何保证在价低交易所买入时即锁定了搬砖收益呢？\n\n我们同时在价高交易所A冲入币, 如`BTC`和价低交易所B冲入钱, 如`USDT`，在A市场卖出币的同时,在B市场买入币,及时锁定了实时的收益,避免了转账时的风险。\n\n实现方式为：\n\n```\n价低交易所冲入USDT，价高交易所冲入BTC -> 卖出USDT的同时买入BTC -> 两个交易所钱币互换 -> 循环\n\n```\n\n但是,这种方式还是存在一个问题，并不是所有的交易所都存在价格差适合搬砖的,搬得人多了利润差自然就被磨平。那么就引出了第三阶段的搬砖方式，我们称之为对冲。\n\n## 搬砖第三阶段\n当利润缩减到一定程度之后,手续费算上甚至会亏损的时候, 以上两种方式都不适合使用了。目前大部分交易所之间的价格差总会随着行情而上下波动，上一分钟还是A交易所价格高，下一分钟就是B交易所价格更高了。\n\n假设你在交易所A和交易所B都有USDT和BTC，当BTCA交易所价格高于B交易所的时候，在A交易所卖出BTC，同时在B交易所买入等量的BTC，这样你的总资产中，比特币总数没有变化，但USDT总数增加。由于各个市场的价格会有波动，过一段时间后，A交易所与B交易所的价格可能出现反转，这个时候，再在A交易所买入BTC，同时在B交易所卖出等量BTC。如此反复，USDT的数量一直呈现增长趋势。\n\n在实际交易中，我们可以拓展至三家以上交易所之间进行对冲，从而使得我们币的数量得到增长。","source":"_posts/数字货币/搬砖进阶.md","raw":"---\ntitle: 搬砖进阶\ndate: 2018-08-27 22:22:00\ntags: \n- 数字货币\ncategories: 数字货币\n---\n\n在数字货币行业当中，“搬砖”搬的不是砖头，是数字货币，并且是在不同交易所价格有差距的数字货币。由于搬运数字货币简单易操作，甚至可以用简单的电脑程序进行搬运的过程，因此被投资者们戏称为“搬砖”。\n\n<!-- more -->\n\n## 搬砖第一阶段\n假设有两个市场,存在较大价差,除去费用之后仍有盈余。大家都会想到的第一种方式便是搬，从价低市场搬到价高市场，赚取价差。\n\n实现方式为：\n\n```\n价低交易所买入BTC-> 转出至价高交易所 -> 价高交易所卖出\n\n```\n\n上述方式不可避免会导致由于转账时间长,导致价格波动， 导致亏损，因此引出了第二阶段的搬砖方法。\n\n\n## 搬砖第二阶段\n\n如何保证在价低交易所买入时即锁定了搬砖收益呢？\n\n我们同时在价高交易所A冲入币, 如`BTC`和价低交易所B冲入钱, 如`USDT`，在A市场卖出币的同时,在B市场买入币,及时锁定了实时的收益,避免了转账时的风险。\n\n实现方式为：\n\n```\n价低交易所冲入USDT，价高交易所冲入BTC -> 卖出USDT的同时买入BTC -> 两个交易所钱币互换 -> 循环\n\n```\n\n但是,这种方式还是存在一个问题，并不是所有的交易所都存在价格差适合搬砖的,搬得人多了利润差自然就被磨平。那么就引出了第三阶段的搬砖方式，我们称之为对冲。\n\n## 搬砖第三阶段\n当利润缩减到一定程度之后,手续费算上甚至会亏损的时候, 以上两种方式都不适合使用了。目前大部分交易所之间的价格差总会随着行情而上下波动，上一分钟还是A交易所价格高，下一分钟就是B交易所价格更高了。\n\n假设你在交易所A和交易所B都有USDT和BTC，当BTCA交易所价格高于B交易所的时候，在A交易所卖出BTC，同时在B交易所买入等量的BTC，这样你的总资产中，比特币总数没有变化，但USDT总数增加。由于各个市场的价格会有波动，过一段时间后，A交易所与B交易所的价格可能出现反转，这个时候，再在A交易所买入BTC，同时在B交易所卖出等量BTC。如此反复，USDT的数量一直呈现增长趋势。\n\n在实际交易中，我们可以拓展至三家以上交易所之间进行对冲，从而使得我们币的数量得到增长。","slug":"数字货币/搬砖进阶","published":1,"updated":"2019-03-22T14:44:36.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxb00444l3nucgj1h43","content":"<p>在数字货币行业当中，“搬砖”搬的不是砖头，是数字货币，并且是在不同交易所价格有差距的数字货币。由于搬运数字货币简单易操作，甚至可以用简单的电脑程序进行搬运的过程，因此被投资者们戏称为“搬砖”。</p>\n<a id=\"more\"></a>\n<h2 id=\"搬砖第一阶段\"><a href=\"#搬砖第一阶段\" class=\"headerlink\" title=\"搬砖第一阶段\"></a>搬砖第一阶段</h2><p>假设有两个市场,存在较大价差,除去费用之后仍有盈余。大家都会想到的第一种方式便是搬，从价低市场搬到价高市场，赚取价差。</p>\n<p>实现方式为：</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">价低交易所买入BTC-&gt; 转出至价高交易所 -&gt; 价高交易所卖出</span><br></pre></td></tr></table></figure>\n<p>上述方式不可避免会导致由于转账时间长,导致价格波动， 导致亏损，因此引出了第二阶段的搬砖方法。</p>\n<h2 id=\"搬砖第二阶段\"><a href=\"#搬砖第二阶段\" class=\"headerlink\" title=\"搬砖第二阶段\"></a>搬砖第二阶段</h2><p>如何保证在价低交易所买入时即锁定了搬砖收益呢？</p>\n<p>我们同时在价高交易所A冲入币, 如<code>BTC</code>和价低交易所B冲入钱, 如<code>USDT</code>，在A市场卖出币的同时,在B市场买入币,及时锁定了实时的收益,避免了转账时的风险。</p>\n<p>实现方式为：</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">价低交易所冲入USDT，价高交易所冲入BTC -&gt; 卖出USDT的同时买入BTC -&gt; 两个交易所钱币互换 -&gt; 循环</span><br></pre></td></tr></table></figure>\n<p>但是,这种方式还是存在一个问题，并不是所有的交易所都存在价格差适合搬砖的,搬得人多了利润差自然就被磨平。那么就引出了第三阶段的搬砖方式，我们称之为对冲。</p>\n<h2 id=\"搬砖第三阶段\"><a href=\"#搬砖第三阶段\" class=\"headerlink\" title=\"搬砖第三阶段\"></a>搬砖第三阶段</h2><p>当利润缩减到一定程度之后,手续费算上甚至会亏损的时候, 以上两种方式都不适合使用了。目前大部分交易所之间的价格差总会随着行情而上下波动，上一分钟还是A交易所价格高，下一分钟就是B交易所价格更高了。</p>\n<p>假设你在交易所A和交易所B都有USDT和BTC，当BTCA交易所价格高于B交易所的时候，在A交易所卖出BTC，同时在B交易所买入等量的BTC，这样你的总资产中，比特币总数没有变化，但USDT总数增加。由于各个市场的价格会有波动，过一段时间后，A交易所与B交易所的价格可能出现反转，这个时候，再在A交易所买入BTC，同时在B交易所卖出等量BTC。如此反复，USDT的数量一直呈现增长趋势。</p>\n<p>在实际交易中，我们可以拓展至三家以上交易所之间进行对冲，从而使得我们币的数量得到增长。</p>\n","site":{"data":{}},"excerpt":"<p>在数字货币行业当中，“搬砖”搬的不是砖头，是数字货币，并且是在不同交易所价格有差距的数字货币。由于搬运数字货币简单易操作，甚至可以用简单的电脑程序进行搬运的过程，因此被投资者们戏称为“搬砖”。</p>","more":"<h2 id=\"搬砖第一阶段\"><a href=\"#搬砖第一阶段\" class=\"headerlink\" title=\"搬砖第一阶段\"></a>搬砖第一阶段</h2><p>假设有两个市场,存在较大价差,除去费用之后仍有盈余。大家都会想到的第一种方式便是搬，从价低市场搬到价高市场，赚取价差。</p>\n<p>实现方式为：</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">价低交易所买入BTC-&gt; 转出至价高交易所 -&gt; 价高交易所卖出</span><br></pre></td></tr></table></figure>\n<p>上述方式不可避免会导致由于转账时间长,导致价格波动， 导致亏损，因此引出了第二阶段的搬砖方法。</p>\n<h2 id=\"搬砖第二阶段\"><a href=\"#搬砖第二阶段\" class=\"headerlink\" title=\"搬砖第二阶段\"></a>搬砖第二阶段</h2><p>如何保证在价低交易所买入时即锁定了搬砖收益呢？</p>\n<p>我们同时在价高交易所A冲入币, 如<code>BTC</code>和价低交易所B冲入钱, 如<code>USDT</code>，在A市场卖出币的同时,在B市场买入币,及时锁定了实时的收益,避免了转账时的风险。</p>\n<p>实现方式为：</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">价低交易所冲入USDT，价高交易所冲入BTC -&gt; 卖出USDT的同时买入BTC -&gt; 两个交易所钱币互换 -&gt; 循环</span><br></pre></td></tr></table></figure>\n<p>但是,这种方式还是存在一个问题，并不是所有的交易所都存在价格差适合搬砖的,搬得人多了利润差自然就被磨平。那么就引出了第三阶段的搬砖方式，我们称之为对冲。</p>\n<h2 id=\"搬砖第三阶段\"><a href=\"#搬砖第三阶段\" class=\"headerlink\" title=\"搬砖第三阶段\"></a>搬砖第三阶段</h2><p>当利润缩减到一定程度之后,手续费算上甚至会亏损的时候, 以上两种方式都不适合使用了。目前大部分交易所之间的价格差总会随着行情而上下波动，上一分钟还是A交易所价格高，下一分钟就是B交易所价格更高了。</p>\n<p>假设你在交易所A和交易所B都有USDT和BTC，当BTCA交易所价格高于B交易所的时候，在A交易所卖出BTC，同时在B交易所买入等量的BTC，这样你的总资产中，比特币总数没有变化，但USDT总数增加。由于各个市场的价格会有波动，过一段时间后，A交易所与B交易所的价格可能出现反转，这个时候，再在A交易所买入BTC，同时在B交易所卖出等量BTC。如此反复，USDT的数量一直呈现增长趋势。</p>\n<p>在实际交易中，我们可以拓展至三家以上交易所之间进行对冲，从而使得我们币的数量得到增长。</p>"},{"title":"何为框架","date":"2016-01-12T02:22:50.000Z","_content":"\n世上框架千千万万，五花八门，那设计其的初衷到底是什么？我们该不该学习框架？该如何学习框架？\n<!-- more -->\n## 一、什么是框架\n\n要回答这个问题要慢慢来。\n\n### DRY原则\nDRY：Don't Repeat Yourself，不要重复你的代码。\n\n很多人说编程是种机械性的工作，而有很多程序员也自嘲为码农，意为编程成了一种没有技术含量的体力性工作。如果不想沦为这个境界，首先需要的就是将DRY原则融入你的血液，在今后的编码工作中加以运用。\n\n从语法，再到方法，再到类型，再到多个类组合级别。基本上我们写代码只写有变化的代码，而尽量不写机械性重复性的代码，其实后面我们就会知道，这就叫专注于业务逻辑，所谓业务逻辑就是你这个项目中，与别的项目都不一样的地方，必须由你亲自去编写实现的部分。\n\n### DRY应用\n设计模式与之前原则里讲的几个层次不同，设计模式是经过长时间编码之后，经过系统性的总结所提出的针对某一类问题的最佳解决方案，又称之为最佳实践。\n而在小规模的编码工作中，其实并不需要什么设计模式，只有大型程序才有设计模式发挥的空间，所以我们需要借助一些特定领域有足够规模的问题来了解一下设计模式存在的必要性。\n\n\n\n\n\n\n\n\n\n\n\n\n\n-------\n整理自[知乎](https://www.zhihu.com/question/25654738)","source":"_posts/架构学习/何为框架.md","raw":"---\ntitle: 何为框架\ndate: 2016-01-12 10:22:50\ntags: \n- 框架\ncategories: 总结\n---\n\n世上框架千千万万，五花八门，那设计其的初衷到底是什么？我们该不该学习框架？该如何学习框架？\n<!-- more -->\n## 一、什么是框架\n\n要回答这个问题要慢慢来。\n\n### DRY原则\nDRY：Don't Repeat Yourself，不要重复你的代码。\n\n很多人说编程是种机械性的工作，而有很多程序员也自嘲为码农，意为编程成了一种没有技术含量的体力性工作。如果不想沦为这个境界，首先需要的就是将DRY原则融入你的血液，在今后的编码工作中加以运用。\n\n从语法，再到方法，再到类型，再到多个类组合级别。基本上我们写代码只写有变化的代码，而尽量不写机械性重复性的代码，其实后面我们就会知道，这就叫专注于业务逻辑，所谓业务逻辑就是你这个项目中，与别的项目都不一样的地方，必须由你亲自去编写实现的部分。\n\n### DRY应用\n设计模式与之前原则里讲的几个层次不同，设计模式是经过长时间编码之后，经过系统性的总结所提出的针对某一类问题的最佳解决方案，又称之为最佳实践。\n而在小规模的编码工作中，其实并不需要什么设计模式，只有大型程序才有设计模式发挥的空间，所以我们需要借助一些特定领域有足够规模的问题来了解一下设计模式存在的必要性。\n\n\n\n\n\n\n\n\n\n\n\n\n\n-------\n整理自[知乎](https://www.zhihu.com/question/25654738)","slug":"架构学习/何为框架","published":1,"updated":"2019-03-22T14:44:36.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxc00474l3neghwoe2t","content":"<p>世上框架千千万万，五花八门，那设计其的初衷到底是什么？我们该不该学习框架？该如何学习框架？<br><a id=\"more\"></a></p>\n<h2 id=\"一、什么是框架\"><a href=\"#一、什么是框架\" class=\"headerlink\" title=\"一、什么是框架\"></a>一、什么是框架</h2><p>要回答这个问题要慢慢来。</p>\n<h3 id=\"DRY原则\"><a href=\"#DRY原则\" class=\"headerlink\" title=\"DRY原则\"></a>DRY原则</h3><p>DRY：Don’t Repeat Yourself，不要重复你的代码。</p>\n<p>很多人说编程是种机械性的工作，而有很多程序员也自嘲为码农，意为编程成了一种没有技术含量的体力性工作。如果不想沦为这个境界，首先需要的就是将DRY原则融入你的血液，在今后的编码工作中加以运用。</p>\n<p>从语法，再到方法，再到类型，再到多个类组合级别。基本上我们写代码只写有变化的代码，而尽量不写机械性重复性的代码，其实后面我们就会知道，这就叫专注于业务逻辑，所谓业务逻辑就是你这个项目中，与别的项目都不一样的地方，必须由你亲自去编写实现的部分。</p>\n<h3 id=\"DRY应用\"><a href=\"#DRY应用\" class=\"headerlink\" title=\"DRY应用\"></a>DRY应用</h3><p>设计模式与之前原则里讲的几个层次不同，设计模式是经过长时间编码之后，经过系统性的总结所提出的针对某一类问题的最佳解决方案，又称之为最佳实践。<br>而在小规模的编码工作中，其实并不需要什么设计模式，只有大型程序才有设计模式发挥的空间，所以我们需要借助一些特定领域有足够规模的问题来了解一下设计模式存在的必要性。</p>\n<hr>\n<p>整理自<a href=\"https://www.zhihu.com/question/25654738\" target=\"_blank\" rel=\"noopener\">知乎</a></p>\n","site":{"data":{}},"excerpt":"<p>世上框架千千万万，五花八门，那设计其的初衷到底是什么？我们该不该学习框架？该如何学习框架？<br></p>","more":"<p></p>\n<h2 id=\"一、什么是框架\"><a href=\"#一、什么是框架\" class=\"headerlink\" title=\"一、什么是框架\"></a>一、什么是框架</h2><p>要回答这个问题要慢慢来。</p>\n<h3 id=\"DRY原则\"><a href=\"#DRY原则\" class=\"headerlink\" title=\"DRY原则\"></a>DRY原则</h3><p>DRY：Don’t Repeat Yourself，不要重复你的代码。</p>\n<p>很多人说编程是种机械性的工作，而有很多程序员也自嘲为码农，意为编程成了一种没有技术含量的体力性工作。如果不想沦为这个境界，首先需要的就是将DRY原则融入你的血液，在今后的编码工作中加以运用。</p>\n<p>从语法，再到方法，再到类型，再到多个类组合级别。基本上我们写代码只写有变化的代码，而尽量不写机械性重复性的代码，其实后面我们就会知道，这就叫专注于业务逻辑，所谓业务逻辑就是你这个项目中，与别的项目都不一样的地方，必须由你亲自去编写实现的部分。</p>\n<h3 id=\"DRY应用\"><a href=\"#DRY应用\" class=\"headerlink\" title=\"DRY应用\"></a>DRY应用</h3><p>设计模式与之前原则里讲的几个层次不同，设计模式是经过长时间编码之后，经过系统性的总结所提出的针对某一类问题的最佳解决方案，又称之为最佳实践。<br>而在小规模的编码工作中，其实并不需要什么设计模式，只有大型程序才有设计模式发挥的空间，所以我们需要借助一些特定领域有足够规模的问题来了解一下设计模式存在的必要性。</p>\n<hr>\n<p>整理自<a href=\"https://www.zhihu.com/question/25654738\" target=\"_blank\" rel=\"noopener\">知乎</a></p>"},{"title":"一年书单(未完)","date":"2016-10-14T13:54:52.000Z","_content":"![海浪](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-15/85925929.jpg)\n看完的书我将进行简评，来做个记录。\n<!-- more -->\n\n《新生 ——七年就是一辈子》 5-15 李笑来的一本开源书，更确切的说是众创书籍。看完收获还是挺大的。复利确实是一个神奇但又真切存在的事物，理财这种东西还是越早开始越好，开始滚自己的小雪球。不要抱怨自己的苦，就算没人害你，你也可能很倒霉，关键时候，还是要靠自己。收获最大的是类比这点。将每个人的大脑比作了操作系统，我们必须主动升级自己的操作系统，操作系统由概念和方法论组成。努力将自己进化成多任务，多模式的操作系统，在合适的情况下合理运用虚拟机与其他操作系统进行沟通。沟通的目的是为了分享，而分享最终会带来惊喜。通过概念去理解问题，通过方法论来解决问题。要学的东西还是很多，要走的路还很长。希望下次再读可以再升级自己的系统一次。\n\n\n《高效能人士的七个习惯》\n\n\n《金字塔原理》\n\n\n《编程之美》\n\n\n《奇特的一生》\n\n\n《暗时间》\n\n\n《向死而生 我修的死亡学分》 4-26 读完 不得不说，很多东西只有真正来不及了，走到绝路了，才会去后悔。李开复也正是借这一次的淋巴癌才真正的回头发现了人生中真正重要的东西，尽管还是开复式的鸡汤写作，但是对于最近一直不在状态的我来说是一剂良药。被乱花弄得头晕目眩，停滞不前的时候，也正需要干一碗鸡汤补补身子，继续上路。珍惜身边人，赶紧追自己的父母，而不是如龙应台所说的不必追。keep healthy，切忌眼高手低，未来一切都还是未知数，做好当下，提前成为未来的你。\n\n《月亮与六便士》\n\n\n《万万没想到：用理工科思维理解世界》\n\n\n《习惯的力量》\n\n\n《麦肯锡方法》\n\n\n《解忧杂货店》 10-14 在自己做不出决定的时候，即便是抛硬币，都已经是做出了决定。就像苦恼向别人咨询，其实手中已经揣着一个答案了。\n\n>我咨询多年，终于了解到一件事。通常咨询者心里已经有了答案，找人咨询的目的，只是为了确认这个答案是正确的。所以，有些咨询者在看了我的回信后，会再写信给我，可能是我的回答和他原本想的不一样。\n\n但是做不出决定又何妨？即便脑袋里一片空白，人生之路也是一片白纸，那绘出属于自己的地图何尝又不是一个选择呢？\n\n\n《精进：如何成为一个很厉害的人》\n一种全新的思维方式。\n\n\n《清单革命：如何持续、正确、安全地把事情做好》人类的错误分两类：无知之错，可以原谅；无能之错，不可饶恕。\n","source":"_posts/每日计划/一年书单.md","raw":"---\ntitle: 一年书单(未完)\ndate: 2016-10-14 21:54:52\ntags:\n- 目标\ncategories: 计划\n---\n![海浪](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-15/85925929.jpg)\n看完的书我将进行简评，来做个记录。\n<!-- more -->\n\n《新生 ——七年就是一辈子》 5-15 李笑来的一本开源书，更确切的说是众创书籍。看完收获还是挺大的。复利确实是一个神奇但又真切存在的事物，理财这种东西还是越早开始越好，开始滚自己的小雪球。不要抱怨自己的苦，就算没人害你，你也可能很倒霉，关键时候，还是要靠自己。收获最大的是类比这点。将每个人的大脑比作了操作系统，我们必须主动升级自己的操作系统，操作系统由概念和方法论组成。努力将自己进化成多任务，多模式的操作系统，在合适的情况下合理运用虚拟机与其他操作系统进行沟通。沟通的目的是为了分享，而分享最终会带来惊喜。通过概念去理解问题，通过方法论来解决问题。要学的东西还是很多，要走的路还很长。希望下次再读可以再升级自己的系统一次。\n\n\n《高效能人士的七个习惯》\n\n\n《金字塔原理》\n\n\n《编程之美》\n\n\n《奇特的一生》\n\n\n《暗时间》\n\n\n《向死而生 我修的死亡学分》 4-26 读完 不得不说，很多东西只有真正来不及了，走到绝路了，才会去后悔。李开复也正是借这一次的淋巴癌才真正的回头发现了人生中真正重要的东西，尽管还是开复式的鸡汤写作，但是对于最近一直不在状态的我来说是一剂良药。被乱花弄得头晕目眩，停滞不前的时候，也正需要干一碗鸡汤补补身子，继续上路。珍惜身边人，赶紧追自己的父母，而不是如龙应台所说的不必追。keep healthy，切忌眼高手低，未来一切都还是未知数，做好当下，提前成为未来的你。\n\n《月亮与六便士》\n\n\n《万万没想到：用理工科思维理解世界》\n\n\n《习惯的力量》\n\n\n《麦肯锡方法》\n\n\n《解忧杂货店》 10-14 在自己做不出决定的时候，即便是抛硬币，都已经是做出了决定。就像苦恼向别人咨询，其实手中已经揣着一个答案了。\n\n>我咨询多年，终于了解到一件事。通常咨询者心里已经有了答案，找人咨询的目的，只是为了确认这个答案是正确的。所以，有些咨询者在看了我的回信后，会再写信给我，可能是我的回答和他原本想的不一样。\n\n但是做不出决定又何妨？即便脑袋里一片空白，人生之路也是一片白纸，那绘出属于自己的地图何尝又不是一个选择呢？\n\n\n《精进：如何成为一个很厉害的人》\n一种全新的思维方式。\n\n\n《清单革命：如何持续、正确、安全地把事情做好》人类的错误分两类：无知之错，可以原谅；无能之错，不可饶恕。\n","slug":"每日计划/一年书单","published":1,"updated":"2019-03-22T14:44:36.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxd004c4l3n210ftg1t","content":"<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-15/85925929.jpg\" alt=\"海浪\"><br>看完的书我将进行简评，来做个记录。<br><a id=\"more\"></a></p>\n<p>《新生 ——七年就是一辈子》 5-15 李笑来的一本开源书，更确切的说是众创书籍。看完收获还是挺大的。复利确实是一个神奇但又真切存在的事物，理财这种东西还是越早开始越好，开始滚自己的小雪球。不要抱怨自己的苦，就算没人害你，你也可能很倒霉，关键时候，还是要靠自己。收获最大的是类比这点。将每个人的大脑比作了操作系统，我们必须主动升级自己的操作系统，操作系统由概念和方法论组成。努力将自己进化成多任务，多模式的操作系统，在合适的情况下合理运用虚拟机与其他操作系统进行沟通。沟通的目的是为了分享，而分享最终会带来惊喜。通过概念去理解问题，通过方法论来解决问题。要学的东西还是很多，要走的路还很长。希望下次再读可以再升级自己的系统一次。</p>\n<p>《高效能人士的七个习惯》</p>\n<p>《金字塔原理》</p>\n<p>《编程之美》</p>\n<p>《奇特的一生》</p>\n<p>《暗时间》</p>\n<p>《向死而生 我修的死亡学分》 4-26 读完 不得不说，很多东西只有真正来不及了，走到绝路了，才会去后悔。李开复也正是借这一次的淋巴癌才真正的回头发现了人生中真正重要的东西，尽管还是开复式的鸡汤写作，但是对于最近一直不在状态的我来说是一剂良药。被乱花弄得头晕目眩，停滞不前的时候，也正需要干一碗鸡汤补补身子，继续上路。珍惜身边人，赶紧追自己的父母，而不是如龙应台所说的不必追。keep healthy，切忌眼高手低，未来一切都还是未知数，做好当下，提前成为未来的你。</p>\n<p>《月亮与六便士》</p>\n<p>《万万没想到：用理工科思维理解世界》</p>\n<p>《习惯的力量》</p>\n<p>《麦肯锡方法》</p>\n<p>《解忧杂货店》 10-14 在自己做不出决定的时候，即便是抛硬币，都已经是做出了决定。就像苦恼向别人咨询，其实手中已经揣着一个答案了。</p>\n<blockquote>\n<p>我咨询多年，终于了解到一件事。通常咨询者心里已经有了答案，找人咨询的目的，只是为了确认这个答案是正确的。所以，有些咨询者在看了我的回信后，会再写信给我，可能是我的回答和他原本想的不一样。</p>\n</blockquote>\n<p>但是做不出决定又何妨？即便脑袋里一片空白，人生之路也是一片白纸，那绘出属于自己的地图何尝又不是一个选择呢？</p>\n<p>《精进：如何成为一个很厉害的人》<br>一种全新的思维方式。</p>\n<p>《清单革命：如何持续、正确、安全地把事情做好》人类的错误分两类：无知之错，可以原谅；无能之错，不可饶恕。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-15/85925929.jpg\" alt=\"海浪\"><br>看完的书我将进行简评，来做个记录。<br></p>","more":"<p></p>\n<p>《新生 ——七年就是一辈子》 5-15 李笑来的一本开源书，更确切的说是众创书籍。看完收获还是挺大的。复利确实是一个神奇但又真切存在的事物，理财这种东西还是越早开始越好，开始滚自己的小雪球。不要抱怨自己的苦，就算没人害你，你也可能很倒霉，关键时候，还是要靠自己。收获最大的是类比这点。将每个人的大脑比作了操作系统，我们必须主动升级自己的操作系统，操作系统由概念和方法论组成。努力将自己进化成多任务，多模式的操作系统，在合适的情况下合理运用虚拟机与其他操作系统进行沟通。沟通的目的是为了分享，而分享最终会带来惊喜。通过概念去理解问题，通过方法论来解决问题。要学的东西还是很多，要走的路还很长。希望下次再读可以再升级自己的系统一次。</p>\n<p>《高效能人士的七个习惯》</p>\n<p>《金字塔原理》</p>\n<p>《编程之美》</p>\n<p>《奇特的一生》</p>\n<p>《暗时间》</p>\n<p>《向死而生 我修的死亡学分》 4-26 读完 不得不说，很多东西只有真正来不及了，走到绝路了，才会去后悔。李开复也正是借这一次的淋巴癌才真正的回头发现了人生中真正重要的东西，尽管还是开复式的鸡汤写作，但是对于最近一直不在状态的我来说是一剂良药。被乱花弄得头晕目眩，停滞不前的时候，也正需要干一碗鸡汤补补身子，继续上路。珍惜身边人，赶紧追自己的父母，而不是如龙应台所说的不必追。keep healthy，切忌眼高手低，未来一切都还是未知数，做好当下，提前成为未来的你。</p>\n<p>《月亮与六便士》</p>\n<p>《万万没想到：用理工科思维理解世界》</p>\n<p>《习惯的力量》</p>\n<p>《麦肯锡方法》</p>\n<p>《解忧杂货店》 10-14 在自己做不出决定的时候，即便是抛硬币，都已经是做出了决定。就像苦恼向别人咨询，其实手中已经揣着一个答案了。</p>\n<blockquote>\n<p>我咨询多年，终于了解到一件事。通常咨询者心里已经有了答案，找人咨询的目的，只是为了确认这个答案是正确的。所以，有些咨询者在看了我的回信后，会再写信给我，可能是我的回答和他原本想的不一样。</p>\n</blockquote>\n<p>但是做不出决定又何妨？即便脑袋里一片空白，人生之路也是一片白纸，那绘出属于自己的地图何尝又不是一个选择呢？</p>\n<p>《精进：如何成为一个很厉害的人》<br>一种全新的思维方式。</p>\n<p>《清单革命：如何持续、正确、安全地把事情做好》人类的错误分两类：无知之错，可以原谅；无能之错，不可饶恕。</p>"},{"title":"每日计划","date":"2016-04-15T10:33:35.000Z","_content":"![雪山](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-15/45411719.jpg)\n**EveryDayPlan** 灵感来自[hoosin](https://github.com/hoosin)的[EveryDaySport](https://github.com/hoosin/EveryDaySport)\n<!-- more -->\n## 坚持背单词，坚持健身，坚持阅读 \n最近突然发现各种慢性病如胃病，颈椎病随着自己身体体质变差而到来，我现在才意识到拥有健康体质的重要性，也开始着手增加锻炼来加强自己的体质。作为一个苦逼码农，身魄强健更为重要。希望能有一个计划来逐步锻炼自己，并且对自己的弱项如英语和阅读量进行强化。希望大家可以加入，以此自勉。\n\n## 计划内容\n\n1. 每日进行背单词，20min以上\n2. 一周坚持3-4次健身，绕校健身跑 `or` 俯卧撑，引体向上练习\n3. 坚持每天看`kindle` 30min以上\n\n------------------------------\n\n**2016.4.29 更新内容 **\n\n从五月开始升级为每周定量完成\n\n1. 每周进行背单词，70个新老单词以上 7个钩，每次离开图书馆之前回顾\n2. 一周坚持3-4次健身，绕校健身跑 `or` 俯卧撑，引体向上练习\n3. 坚持每周看`kindle` 5小时，10个钩\n\n## 参与\n\n[入口](https://github.com/zjbao123/EveryDayPlan)\n\n\n如果你也想加入我的每日计划，可以`fork`[EveryDayPlan](https://github.com/zjbao123/EveryDayPlan/tree/master),由于我也是一个新手，希望大家能提更好的建议。\n\n## 目录\n\n.\n├── table                 … 锻炼签到表\n└── readme.md             … 说明文档\n\t\n","source":"_posts/每日计划/每日计划.md","raw":"---\ntitle: 每日计划\ndate: 2016-04-15 18:33:35\ntags:\n- 目标\ncategories: 计划\n---\n![雪山](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-15/45411719.jpg)\n**EveryDayPlan** 灵感来自[hoosin](https://github.com/hoosin)的[EveryDaySport](https://github.com/hoosin/EveryDaySport)\n<!-- more -->\n## 坚持背单词，坚持健身，坚持阅读 \n最近突然发现各种慢性病如胃病，颈椎病随着自己身体体质变差而到来，我现在才意识到拥有健康体质的重要性，也开始着手增加锻炼来加强自己的体质。作为一个苦逼码农，身魄强健更为重要。希望能有一个计划来逐步锻炼自己，并且对自己的弱项如英语和阅读量进行强化。希望大家可以加入，以此自勉。\n\n## 计划内容\n\n1. 每日进行背单词，20min以上\n2. 一周坚持3-4次健身，绕校健身跑 `or` 俯卧撑，引体向上练习\n3. 坚持每天看`kindle` 30min以上\n\n------------------------------\n\n**2016.4.29 更新内容 **\n\n从五月开始升级为每周定量完成\n\n1. 每周进行背单词，70个新老单词以上 7个钩，每次离开图书馆之前回顾\n2. 一周坚持3-4次健身，绕校健身跑 `or` 俯卧撑，引体向上练习\n3. 坚持每周看`kindle` 5小时，10个钩\n\n## 参与\n\n[入口](https://github.com/zjbao123/EveryDayPlan)\n\n\n如果你也想加入我的每日计划，可以`fork`[EveryDayPlan](https://github.com/zjbao123/EveryDayPlan/tree/master),由于我也是一个新手，希望大家能提更好的建议。\n\n## 目录\n\n.\n├── table                 … 锻炼签到表\n└── readme.md             … 说明文档\n\t\n","slug":"每日计划/每日计划","published":1,"updated":"2019-03-22T14:44:36.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxe004e4l3n8405a5w8","content":"<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-15/45411719.jpg\" alt=\"雪山\"><br><strong>EveryDayPlan</strong> 灵感来自<a href=\"https://github.com/hoosin\" target=\"_blank\" rel=\"noopener\">hoosin</a>的<a href=\"https://github.com/hoosin/EveryDaySport\" target=\"_blank\" rel=\"noopener\">EveryDaySport</a><br><a id=\"more\"></a></p>\n<h2 id=\"坚持背单词，坚持健身，坚持阅读\"><a href=\"#坚持背单词，坚持健身，坚持阅读\" class=\"headerlink\" title=\"坚持背单词，坚持健身，坚持阅读\"></a>坚持背单词，坚持健身，坚持阅读</h2><p>最近突然发现各种慢性病如胃病，颈椎病随着自己身体体质变差而到来，我现在才意识到拥有健康体质的重要性，也开始着手增加锻炼来加强自己的体质。作为一个苦逼码农，身魄强健更为重要。希望能有一个计划来逐步锻炼自己，并且对自己的弱项如英语和阅读量进行强化。希望大家可以加入，以此自勉。</p>\n<h2 id=\"计划内容\"><a href=\"#计划内容\" class=\"headerlink\" title=\"计划内容\"></a>计划内容</h2><ol>\n<li>每日进行背单词，20min以上</li>\n<li>一周坚持3-4次健身，绕校健身跑 <code>or</code> 俯卧撑，引体向上练习</li>\n<li>坚持每天看<code>kindle</code> 30min以上</li>\n</ol>\n<hr>\n<p><strong>2016.4.29 更新内容 </strong></p>\n<p>从五月开始升级为每周定量完成</p>\n<ol>\n<li>每周进行背单词，70个新老单词以上 7个钩，每次离开图书馆之前回顾</li>\n<li>一周坚持3-4次健身，绕校健身跑 <code>or</code> 俯卧撑，引体向上练习</li>\n<li>坚持每周看<code>kindle</code> 5小时，10个钩</li>\n</ol>\n<h2 id=\"参与\"><a href=\"#参与\" class=\"headerlink\" title=\"参与\"></a>参与</h2><p><a href=\"https://github.com/zjbao123/EveryDayPlan\" target=\"_blank\" rel=\"noopener\">入口</a></p>\n<p>如果你也想加入我的每日计划，可以<code>fork</code><a href=\"https://github.com/zjbao123/EveryDayPlan/tree/master\" target=\"_blank\" rel=\"noopener\">EveryDayPlan</a>,由于我也是一个新手，希望大家能提更好的建议。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>.<br>├── table                 … 锻炼签到表<br>└── readme.md             … 说明文档</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-15/45411719.jpg\" alt=\"雪山\"><br><strong>EveryDayPlan</strong> 灵感来自<a href=\"https://github.com/hoosin\" target=\"_blank\" rel=\"noopener\">hoosin</a>的<a href=\"https://github.com/hoosin/EveryDaySport\" target=\"_blank\" rel=\"noopener\">EveryDaySport</a><br></p>","more":"<p></p>\n<h2 id=\"坚持背单词，坚持健身，坚持阅读\"><a href=\"#坚持背单词，坚持健身，坚持阅读\" class=\"headerlink\" title=\"坚持背单词，坚持健身，坚持阅读\"></a>坚持背单词，坚持健身，坚持阅读</h2><p>最近突然发现各种慢性病如胃病，颈椎病随着自己身体体质变差而到来，我现在才意识到拥有健康体质的重要性，也开始着手增加锻炼来加强自己的体质。作为一个苦逼码农，身魄强健更为重要。希望能有一个计划来逐步锻炼自己，并且对自己的弱项如英语和阅读量进行强化。希望大家可以加入，以此自勉。</p>\n<h2 id=\"计划内容\"><a href=\"#计划内容\" class=\"headerlink\" title=\"计划内容\"></a>计划内容</h2><ol>\n<li>每日进行背单词，20min以上</li>\n<li>一周坚持3-4次健身，绕校健身跑 <code>or</code> 俯卧撑，引体向上练习</li>\n<li>坚持每天看<code>kindle</code> 30min以上</li>\n</ol>\n<hr>\n<p><strong>2016.4.29 更新内容 </strong></p>\n<p>从五月开始升级为每周定量完成</p>\n<ol>\n<li>每周进行背单词，70个新老单词以上 7个钩，每次离开图书馆之前回顾</li>\n<li>一周坚持3-4次健身，绕校健身跑 <code>or</code> 俯卧撑，引体向上练习</li>\n<li>坚持每周看<code>kindle</code> 5小时，10个钩</li>\n</ol>\n<h2 id=\"参与\"><a href=\"#参与\" class=\"headerlink\" title=\"参与\"></a>参与</h2><p><a href=\"https://github.com/zjbao123/EveryDayPlan\" target=\"_blank\" rel=\"noopener\">入口</a></p>\n<p>如果你也想加入我的每日计划，可以<code>fork</code><a href=\"https://github.com/zjbao123/EveryDayPlan/tree/master\" target=\"_blank\" rel=\"noopener\">EveryDayPlan</a>,由于我也是一个新手，希望大家能提更好的建议。</p>\n<h2 id=\"目录\"><a href=\"#目录\" class=\"headerlink\" title=\"目录\"></a>目录</h2><p>.<br>├── table                 … 锻炼签到表<br>└── readme.md             … 说明文档</p>"},{"title":"谈一谈消息队列","date":"2019-10-07T14:49:22.000Z","_content":"\n### 什么是消息队列？\n\n消息队列，也就是所谓的MQ（Message Queue）。消息队列可以简单理解为：把要传输的数据放在队列中。\n<!-- more -->\n### 使用消息队列可以解决什么问题？\n\n#### 1.解耦\n![原有系统架构](消息队列/system.png)\n如果在原有系统架构中，需要额外增加一个系统E或者删除一个系统C，也需要对A系统进行修改。A 系统跟其它各种乱七八糟的系统严重耦合，A系统产生一条比较关键的数据，很多系统都需要 A系统将这个数据发送过来。A 系统要时时刻刻考虑BCD三个系统如果挂了该咋办？要不要重发，要不要把消息存起来？\n\n而在增加MQ之后，我们将A系统与BCD系统进行了解耦，A系统只管往MQ中放消息，BCD从消息队列中取消息进行处理。这样下来，A 系统不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。\n![现有系统架构](消息队列/systemAfter.png)\n#### 2.异步\n![原有系统架构](消息队列/systemTiming.png)\n再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、150ms、200ms。最终请求总延时是 3 + 300 + 150 + 200 = 653ms，用户通过浏览器发起请求等待时间这几乎是不可接受的。\n\n再通过MQ之后，那么 A系统连续发送3条消息到 MQ 队列中，假如耗时15ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 15 = 8ms，对于用户而言，其实感觉上就是点个按钮，18ms 以后就直接返回了，用户体验就非常的好。\n![现有系统架构](消息队列/systemTimingAfter.png)\n\n#### 3.削峰\n用户请求量不是恒定的数值，总会有峰谷的变化。比如高峰期时，大量的请求直接到后台的话，可能直接就把系统给请求崩溃了，从而用户也没法继续使用这个系统。但是高峰期一过，又恢复如初。\n\n在有MQ的情况，短暂的高峰请求就会积压在MQ中，等到高峰期一过，请求也会依次得到处理。从而解决高峰期访问量飙升的问题。\n\n### MQ有哪些问题？\n\n- 系统可用性降低<br>\n系统引入的外部依赖越多，越容易挂掉。如果MQ挂掉，则会导致ABCD四个系统全部崩溃。那么就要需要保证MA的高可用。\n\n- 系统复杂度提高<br>\n增加MQ之后，如何保证消息没有重复消费？如何处理消息丢失呢？怎样保证消息传递的顺序？\n\n- 一致性问题<br>\nA系统处理完了直接返回了成功，都以为这个请求成功了。但是在BCD这边，如果BC处理成功了，D写库失败了，如何处理？\n\n- 消费者怎么从消息队列里边得到数据<br>\n生产者将数据放到消息队列中，消息队列有数据了，主动叫消费者去拿(俗称push)\n消费者不断去轮训消息队列，看看有没有新的数据，如果有就消费(俗称pull)\n\n所以，引入MQ有很多好处，也增加了系统的复杂性。\n\n### Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？\n\n| 特性 | ActiveMQ | RabbitMQ | RocketMQ | Kafka |\n|---|---|---|---|---|\n| 单机吞吐量 | 万级，比 RocketMQ、Kafka 低一个数量级 | 同 ActiveMQ | 10 万级，支撑高吞吐 | 10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |\n| topic 数量对吞吐量的影响 | | | topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic | topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源 |\n| 时效性 | ms 级 | 微秒级，这是 RabbitMQ 的一大特点，延迟最低 | ms 级 | 延迟在 ms 级以内 |\n| 可用性 | 高，基于主从架构实现高可用 | 同 ActiveMQ | 非常高，分布式架构 | 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |\n| 消息可靠性 | 有较低的概率丢失数据 | 基本不丢 | 经过参数优化配置，可以做到 0 丢失 | 同 RocketMQ |\n| 功能支持 | MQ 领域的功能极其完备 | 基于 erlang 开发，并发能力很强，性能极好，延时很低 | MQ 功能较为完善，还是分布式的，扩展性好 | 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 |\n\n\n综上，各种对比之后，有如下建议：\n\n一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；\n\n后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；\n\n不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 [Apache](https://github.com/apache/rocketmq)，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。\n\n所以**中小型公司**，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；**大型公司**，基础架构研发实力较强，用 RocketMQ 是很好的选择。\n\n如果是**大数据领域**的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。\n\n--------\n\n**参考资料**：\n[面试官问你什么是消息队列？把这篇甩给他！](http://developer.51cto.com/art/201904/595020.htm)\n[为什么使用消息队列？消息队列有什么优点和缺点？Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么优点和缺点？](https://doocs.github.io/advanced-java/#/docs/high-concurrency/why-mq)","source":"_posts/架构学习/消息队列.md","raw":"---\ntitle: 谈一谈消息队列\ndate: 2019-10-07 22:49:22\ntags:\n- Java进阶\ncategories: Java\n---\n\n### 什么是消息队列？\n\n消息队列，也就是所谓的MQ（Message Queue）。消息队列可以简单理解为：把要传输的数据放在队列中。\n<!-- more -->\n### 使用消息队列可以解决什么问题？\n\n#### 1.解耦\n![原有系统架构](消息队列/system.png)\n如果在原有系统架构中，需要额外增加一个系统E或者删除一个系统C，也需要对A系统进行修改。A 系统跟其它各种乱七八糟的系统严重耦合，A系统产生一条比较关键的数据，很多系统都需要 A系统将这个数据发送过来。A 系统要时时刻刻考虑BCD三个系统如果挂了该咋办？要不要重发，要不要把消息存起来？\n\n而在增加MQ之后，我们将A系统与BCD系统进行了解耦，A系统只管往MQ中放消息，BCD从消息队列中取消息进行处理。这样下来，A 系统不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。\n![现有系统架构](消息队列/systemAfter.png)\n#### 2.异步\n![原有系统架构](消息队列/systemTiming.png)\n再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、150ms、200ms。最终请求总延时是 3 + 300 + 150 + 200 = 653ms，用户通过浏览器发起请求等待时间这几乎是不可接受的。\n\n再通过MQ之后，那么 A系统连续发送3条消息到 MQ 队列中，假如耗时15ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 15 = 8ms，对于用户而言，其实感觉上就是点个按钮，18ms 以后就直接返回了，用户体验就非常的好。\n![现有系统架构](消息队列/systemTimingAfter.png)\n\n#### 3.削峰\n用户请求量不是恒定的数值，总会有峰谷的变化。比如高峰期时，大量的请求直接到后台的话，可能直接就把系统给请求崩溃了，从而用户也没法继续使用这个系统。但是高峰期一过，又恢复如初。\n\n在有MQ的情况，短暂的高峰请求就会积压在MQ中，等到高峰期一过，请求也会依次得到处理。从而解决高峰期访问量飙升的问题。\n\n### MQ有哪些问题？\n\n- 系统可用性降低<br>\n系统引入的外部依赖越多，越容易挂掉。如果MQ挂掉，则会导致ABCD四个系统全部崩溃。那么就要需要保证MA的高可用。\n\n- 系统复杂度提高<br>\n增加MQ之后，如何保证消息没有重复消费？如何处理消息丢失呢？怎样保证消息传递的顺序？\n\n- 一致性问题<br>\nA系统处理完了直接返回了成功，都以为这个请求成功了。但是在BCD这边，如果BC处理成功了，D写库失败了，如何处理？\n\n- 消费者怎么从消息队列里边得到数据<br>\n生产者将数据放到消息队列中，消息队列有数据了，主动叫消费者去拿(俗称push)\n消费者不断去轮训消息队列，看看有没有新的数据，如果有就消费(俗称pull)\n\n所以，引入MQ有很多好处，也增加了系统的复杂性。\n\n### Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？\n\n| 特性 | ActiveMQ | RabbitMQ | RocketMQ | Kafka |\n|---|---|---|---|---|\n| 单机吞吐量 | 万级，比 RocketMQ、Kafka 低一个数量级 | 同 ActiveMQ | 10 万级，支撑高吞吐 | 10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景 |\n| topic 数量对吞吐量的影响 | | | topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic | topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源 |\n| 时效性 | ms 级 | 微秒级，这是 RabbitMQ 的一大特点，延迟最低 | ms 级 | 延迟在 ms 级以内 |\n| 可用性 | 高，基于主从架构实现高可用 | 同 ActiveMQ | 非常高，分布式架构 | 非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用 |\n| 消息可靠性 | 有较低的概率丢失数据 | 基本不丢 | 经过参数优化配置，可以做到 0 丢失 | 同 RocketMQ |\n| 功能支持 | MQ 领域的功能极其完备 | 基于 erlang 开发，并发能力很强，性能极好，延时很低 | MQ 功能较为完善，还是分布式的，扩展性好 | 功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用 |\n\n\n综上，各种对比之后，有如下建议：\n\n一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；\n\n后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；\n\n不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 [Apache](https://github.com/apache/rocketmq)，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。\n\n所以**中小型公司**，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；**大型公司**，基础架构研发实力较强，用 RocketMQ 是很好的选择。\n\n如果是**大数据领域**的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。\n\n--------\n\n**参考资料**：\n[面试官问你什么是消息队列？把这篇甩给他！](http://developer.51cto.com/art/201904/595020.htm)\n[为什么使用消息队列？消息队列有什么优点和缺点？Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么优点和缺点？](https://doocs.github.io/advanced-java/#/docs/high-concurrency/why-mq)","slug":"架构学习/消息队列","published":1,"updated":"2019-10-21T16:31:41.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxg004i4l3nujsxdmqt","content":"<h3 id=\"什么是消息队列？\"><a href=\"#什么是消息队列？\" class=\"headerlink\" title=\"什么是消息队列？\"></a>什么是消息队列？</h3><p>消息队列，也就是所谓的MQ（Message Queue）。消息队列可以简单理解为：把要传输的数据放在队列中。<br><a id=\"more\"></a></p>\n<h3 id=\"使用消息队列可以解决什么问题？\"><a href=\"#使用消息队列可以解决什么问题？\" class=\"headerlink\" title=\"使用消息队列可以解决什么问题？\"></a>使用消息队列可以解决什么问题？</h3><h4 id=\"1-解耦\"><a href=\"#1-解耦\" class=\"headerlink\" title=\"1.解耦\"></a>1.解耦</h4><p><img src=\"/2019/10/07/架构学习/消息队列/system.png\" alt=\"原有系统架构\"><br>如果在原有系统架构中，需要额外增加一个系统E或者删除一个系统C，也需要对A系统进行修改。A 系统跟其它各种乱七八糟的系统严重耦合，A系统产生一条比较关键的数据，很多系统都需要 A系统将这个数据发送过来。A 系统要时时刻刻考虑BCD三个系统如果挂了该咋办？要不要重发，要不要把消息存起来？</p>\n<p>而在增加MQ之后，我们将A系统与BCD系统进行了解耦，A系统只管往MQ中放消息，BCD从消息队列中取消息进行处理。这样下来，A 系统不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。<br><img src=\"/2019/10/07/架构学习/消息队列/systemAfter.png\" alt=\"现有系统架构\"></p>\n<h4 id=\"2-异步\"><a href=\"#2-异步\" class=\"headerlink\" title=\"2.异步\"></a>2.异步</h4><p><img src=\"/2019/10/07/架构学习/消息队列/systemTiming.png\" alt=\"原有系统架构\"><br>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、150ms、200ms。最终请求总延时是 3 + 300 + 150 + 200 = 653ms，用户通过浏览器发起请求等待时间这几乎是不可接受的。</p>\n<p>再通过MQ之后，那么 A系统连续发送3条消息到 MQ 队列中，假如耗时15ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 15 = 8ms，对于用户而言，其实感觉上就是点个按钮，18ms 以后就直接返回了，用户体验就非常的好。<br><img src=\"/2019/10/07/架构学习/消息队列/systemTimingAfter.png\" alt=\"现有系统架构\"></p>\n<h4 id=\"3-削峰\"><a href=\"#3-削峰\" class=\"headerlink\" title=\"3.削峰\"></a>3.削峰</h4><p>用户请求量不是恒定的数值，总会有峰谷的变化。比如高峰期时，大量的请求直接到后台的话，可能直接就把系统给请求崩溃了，从而用户也没法继续使用这个系统。但是高峰期一过，又恢复如初。</p>\n<p>在有MQ的情况，短暂的高峰请求就会积压在MQ中，等到高峰期一过，请求也会依次得到处理。从而解决高峰期访问量飙升的问题。</p>\n<h3 id=\"MQ有哪些问题？\"><a href=\"#MQ有哪些问题？\" class=\"headerlink\" title=\"MQ有哪些问题？\"></a>MQ有哪些问题？</h3><ul>\n<li><p>系统可用性降低<br><br>系统引入的外部依赖越多，越容易挂掉。如果MQ挂掉，则会导致ABCD四个系统全部崩溃。那么就要需要保证MA的高可用。</p>\n</li>\n<li><p>系统复杂度提高<br><br>增加MQ之后，如何保证消息没有重复消费？如何处理消息丢失呢？怎样保证消息传递的顺序？</p>\n</li>\n<li><p>一致性问题<br><br>A系统处理完了直接返回了成功，都以为这个请求成功了。但是在BCD这边，如果BC处理成功了，D写库失败了，如何处理？</p>\n</li>\n<li><p>消费者怎么从消息队列里边得到数据<br><br>生产者将数据放到消息队列中，消息队列有数据了，主动叫消费者去拿(俗称push)<br>消费者不断去轮训消息队列，看看有没有新的数据，如果有就消费(俗称pull)</p>\n</li>\n</ul>\n<p>所以，引入MQ有很多好处，也增加了系统的复杂性。</p>\n<h3 id=\"Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？\"><a href=\"#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？\" class=\"headerlink\" title=\"Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？\"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ActiveMQ</th>\n<th>RabbitMQ</th>\n<th>RocketMQ</th>\n<th>Kafka</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单机吞吐量</td>\n<td>万级，比 RocketMQ、Kafka 低一个数量级</td>\n<td>同 ActiveMQ</td>\n<td>10 万级，支撑高吞吐</td>\n<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>\n</tr>\n<tr>\n<td>topic 数量对吞吐量的影响</td>\n<td></td>\n<td></td>\n<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>\n<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>ms 级</td>\n<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>\n<td>ms 级</td>\n<td>延迟在 ms 级以内</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>高，基于主从架构实现高可用</td>\n<td>同 ActiveMQ</td>\n<td>非常高，分布式架构</td>\n<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>\n</tr>\n<tr>\n<td>消息可靠性</td>\n<td>有较低的概率丢失数据</td>\n<td>基本不丢</td>\n<td>经过参数优化配置，可以做到 0 丢失</td>\n<td>同 RocketMQ</td>\n</tr>\n<tr>\n<td>功能支持</td>\n<td>MQ 领域的功能极其完备</td>\n<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>\n<td>MQ 功能较为完善，还是分布式的，扩展性好</td>\n<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>\n</tr>\n</tbody>\n</table>\n<p>综上，各种对比之后，有如下建议：</p>\n<p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p>\n<p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p>\n<p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href=\"https://github.com/apache/rocketmq\" target=\"_blank\" rel=\"noopener\">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p>\n<p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p>\n<p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>\n<hr>\n<p><strong>参考资料</strong>：<br><a href=\"http://developer.51cto.com/art/201904/595020.htm\" target=\"_blank\" rel=\"noopener\">面试官问你什么是消息队列？把这篇甩给他！</a><br><a href=\"https://doocs.github.io/advanced-java/#/docs/high-concurrency/why-mq\" target=\"_blank\" rel=\"noopener\">为什么使用消息队列？消息队列有什么优点和缺点？Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么优点和缺点？</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是消息队列？\"><a href=\"#什么是消息队列？\" class=\"headerlink\" title=\"什么是消息队列？\"></a>什么是消息队列？</h3><p>消息队列，也就是所谓的MQ（Message Queue）。消息队列可以简单理解为：把要传输的数据放在队列中。<br></p>","more":"<p></p>\n<h3 id=\"使用消息队列可以解决什么问题？\"><a href=\"#使用消息队列可以解决什么问题？\" class=\"headerlink\" title=\"使用消息队列可以解决什么问题？\"></a>使用消息队列可以解决什么问题？</h3><h4 id=\"1-解耦\"><a href=\"#1-解耦\" class=\"headerlink\" title=\"1.解耦\"></a>1.解耦</h4><p><img src=\"/2019/10/07/架构学习/消息队列/system.png\" alt=\"原有系统架构\"><br>如果在原有系统架构中，需要额外增加一个系统E或者删除一个系统C，也需要对A系统进行修改。A 系统跟其它各种乱七八糟的系统严重耦合，A系统产生一条比较关键的数据，很多系统都需要 A系统将这个数据发送过来。A 系统要时时刻刻考虑BCD三个系统如果挂了该咋办？要不要重发，要不要把消息存起来？</p>\n<p>而在增加MQ之后，我们将A系统与BCD系统进行了解耦，A系统只管往MQ中放消息，BCD从消息队列中取消息进行处理。这样下来，A 系统不需要去考虑要给谁发送数据，不需要维护这个代码，也不需要考虑人家是否调用成功、失败超时等情况。通过一个 MQ，Pub/Sub 发布订阅消息这么一个模型，A 系统就跟其它系统彻底解耦了。<br><img src=\"/2019/10/07/架构学习/消息队列/systemAfter.png\" alt=\"现有系统架构\"></p>\n<h4 id=\"2-异步\"><a href=\"#2-异步\" class=\"headerlink\" title=\"2.异步\"></a>2.异步</h4><p><img src=\"/2019/10/07/架构学习/消息队列/systemTiming.png\" alt=\"原有系统架构\"><br>再来看一个场景，A 系统接收一个请求，需要在自己本地写库，还需要在 BCD 三个系统写库，自己本地写库要 3ms，BCD 三个系统分别写库要 300ms、150ms、200ms。最终请求总延时是 3 + 300 + 150 + 200 = 653ms，用户通过浏览器发起请求等待时间这几乎是不可接受的。</p>\n<p>再通过MQ之后，那么 A系统连续发送3条消息到 MQ 队列中，假如耗时15ms，A 系统从接受一个请求到返回响应给用户，总时长是 3 + 15 = 8ms，对于用户而言，其实感觉上就是点个按钮，18ms 以后就直接返回了，用户体验就非常的好。<br><img src=\"/2019/10/07/架构学习/消息队列/systemTimingAfter.png\" alt=\"现有系统架构\"></p>\n<h4 id=\"3-削峰\"><a href=\"#3-削峰\" class=\"headerlink\" title=\"3.削峰\"></a>3.削峰</h4><p>用户请求量不是恒定的数值，总会有峰谷的变化。比如高峰期时，大量的请求直接到后台的话，可能直接就把系统给请求崩溃了，从而用户也没法继续使用这个系统。但是高峰期一过，又恢复如初。</p>\n<p>在有MQ的情况，短暂的高峰请求就会积压在MQ中，等到高峰期一过，请求也会依次得到处理。从而解决高峰期访问量飙升的问题。</p>\n<h3 id=\"MQ有哪些问题？\"><a href=\"#MQ有哪些问题？\" class=\"headerlink\" title=\"MQ有哪些问题？\"></a>MQ有哪些问题？</h3><ul>\n<li><p>系统可用性降低<br><br>系统引入的外部依赖越多，越容易挂掉。如果MQ挂掉，则会导致ABCD四个系统全部崩溃。那么就要需要保证MA的高可用。</p>\n</li>\n<li><p>系统复杂度提高<br><br>增加MQ之后，如何保证消息没有重复消费？如何处理消息丢失呢？怎样保证消息传递的顺序？</p>\n</li>\n<li><p>一致性问题<br><br>A系统处理完了直接返回了成功，都以为这个请求成功了。但是在BCD这边，如果BC处理成功了，D写库失败了，如何处理？</p>\n</li>\n<li><p>消费者怎么从消息队列里边得到数据<br><br>生产者将数据放到消息队列中，消息队列有数据了，主动叫消费者去拿(俗称push)<br>消费者不断去轮训消息队列，看看有没有新的数据，如果有就消费(俗称pull)</p>\n</li>\n</ul>\n<p>所以，引入MQ有很多好处，也增加了系统的复杂性。</p>\n<h3 id=\"Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？\"><a href=\"#Kafka、ActiveMQ、RabbitMQ、RocketMQ-有什么优缺点？\" class=\"headerlink\" title=\"Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？\"></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ActiveMQ</th>\n<th>RabbitMQ</th>\n<th>RocketMQ</th>\n<th>Kafka</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>单机吞吐量</td>\n<td>万级，比 RocketMQ、Kafka 低一个数量级</td>\n<td>同 ActiveMQ</td>\n<td>10 万级，支撑高吞吐</td>\n<td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td>\n</tr>\n<tr>\n<td>topic 数量对吞吐量的影响</td>\n<td></td>\n<td></td>\n<td>topic 可以达到几百/几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td>\n<td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td>\n</tr>\n<tr>\n<td>时效性</td>\n<td>ms 级</td>\n<td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td>\n<td>ms 级</td>\n<td>延迟在 ms 级以内</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>高，基于主从架构实现高可用</td>\n<td>同 ActiveMQ</td>\n<td>非常高，分布式架构</td>\n<td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td>\n</tr>\n<tr>\n<td>消息可靠性</td>\n<td>有较低的概率丢失数据</td>\n<td>基本不丢</td>\n<td>经过参数优化配置，可以做到 0 丢失</td>\n<td>同 RocketMQ</td>\n</tr>\n<tr>\n<td>功能支持</td>\n<td>MQ 领域的功能极其完备</td>\n<td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td>\n<td>MQ 功能较为完善，还是分布式的，扩展性好</td>\n<td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td>\n</tr>\n</tbody>\n</table>\n<p>综上，各种对比之后，有如下建议：</p>\n<p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了吧，我个人不推荐用这个了；</p>\n<p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高；</p>\n<p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href=\"https://github.com/apache/rocketmq\" target=\"_blank\" rel=\"noopener\">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p>\n<p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p>\n<p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p>\n<hr>\n<p><strong>参考资料</strong>：<br><a href=\"http://developer.51cto.com/art/201904/595020.htm\" target=\"_blank\" rel=\"noopener\">面试官问你什么是消息队列？把这篇甩给他！</a><br><a href=\"https://doocs.github.io/advanced-java/#/docs/high-concurrency/why-mq\" target=\"_blank\" rel=\"noopener\">为什么使用消息队列？消息队列有什么优点和缺点？Kafka、ActiveMQ、RabbitMQ、RocketMQ 都有什么优点和缺点？</a></p>"},{"title":"设计模式之美--鉴权功能实战","date":"2020-02-05T15:30:00.000Z","_content":"\n\n代码详见： [github.com/zjbao123/PatternDesign](https://github.com/zjbao123/PatternDesign/tree/master/ApiAuthenticator)\n\n## 需求来源\n\n为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。我希望由你来负责这个任务的开发，争取尽快上线。\n\n\n<!-- more -->\n\n## 需求分析\n\n* 阶段一：\n    > 通过 userId和password进行认证，如果不一致，则鉴权失败，如果一致则成功。\n    \n    > 缺点：密码明文存在安全问题\n* 阶段二：\n    > 将password进行加密后进行认证。\n    \n    > 缺点：将会导致重放攻击。\n* 阶段三：\n    > 增加随机数，例如时间戳来生成token进行认证，设定超时间隔（一分钟），超时则认为token过期。\n \n    > 缺点：一分钟内还是会有重放攻击。\n\n## 需求拆分\n\n1. 将URL，userId,password和时间戳拼接成字符串\n2. 通过加密算法将字符串生成token\n3. 将token和userId，时间戳拼在URL上发送至服务端\n4. 解析URL，拆分出token，userId，时间戳\n5. 比较时间戳，判断token是否超时\n6. 从数据库通过userId取得对应的password\n7. 生成token比较是否一致。\n\n## 设计\n\n* 划分职责进而识别出有哪些类\n* 定义类以及属性和方法\n* 定义类与类之间的交互关系\n* 将类组装起来并提供执行入口\n\n## 划分职责进而识别有哪些类\n\n1，2，5，7 与token的生成，验证，比较有关\n3，4与URL有关，负责处理URL的拼接和拆分\n6操作userId和password，从存储中读取userId和password\n\n因此，初步可以设置成三个类，分别为AuthToken，ApiRequest，CredentialStorage\n\n## 定义类以及属性和方法\n\n### AuthToken\n\n#### 属性\n\ntoken，createTime，expiredTimeInterval\n\n#### 构造函数\n\nAuthToken(String token, long createTime);\n\nAuthToken(String token, long createTime, long expiredTimeInterval);\n\n#### 方法\n\ncreateToken(String url, long createTime, Map<String,String> params);\n\ngetToken();\n\nisExpired();\n\nmatch(AuthToken authToken);\n\n### ApiRequest\n\n#### 属性\ntoken, baseUrl, userId，timestamp\n#### 构造方法\nApiRequest(String token, String baseUrl, String userId);\n#### 方法\n\nget；\n\nApiRequest getRequestFromURL(String url);\n\n\n### CredentialStorage\n\n#### 接口\nString getPasswordFromUserId(String userId);\n\n## 定义类与类之间的交互关系\nUML中主要分为 泛化，实现，组合，聚合， 关联， 依赖。\n\n泛化就是继承，实现就是接口和实现类之间的关系\n\n聚合是包含关系，A类对象包含B类对象，B的生命周期不依赖A的生命周期，类似课程和学生的关系\n\n组合也是包含关系，不同点在于B的生命周期依赖A的生命周期，类似翅膀和鸟类的关系。\n\n关联包含聚合和组合两种关系。\n\n依赖时一种比关联关系更加弱的关系，包含关联关系，只要B类对象时A类对象的参数，返回值，或者局部变量，任何使用关系，都称之为依赖。\n\n简化后，将组合关系替代UML中的组合，聚合，关联三个概念，都称之为组合，因此也就有了\n“多用组合少用继承”的设计原则。\n\n## 将类组装起来并提供执行入口\n\n### ApiAuthenticator接口\n\nvoid auth(String url);\n\nvoid auth(ApiRequest apiRequest);\n\n### ApiAuthenticator实现\n#### 属性\n\nprivate CredentialStorage credentialStorage;\n\n#### 构造函数\n\nApiAuthenticator();\n\nApiAuthenticator(ApiAuthenticator apiAuthenticator);\n\n#### 函数\n\nvoid auth(String url);\n\nvoid auth(ApiRequest apiRequest);\n\n","source":"_posts/设计模式/设计模式之实战.md","raw":"---\ntitle: 设计模式之美--鉴权功能实战\ndate: 2020-02-05 23:30:00\ntags:\n- 心法\ncategories: 设计模式\n---\n\n\n代码详见： [github.com/zjbao123/PatternDesign](https://github.com/zjbao123/PatternDesign/tree/master/ApiAuthenticator)\n\n## 需求来源\n\n为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。我希望由你来负责这个任务的开发，争取尽快上线。\n\n\n<!-- more -->\n\n## 需求分析\n\n* 阶段一：\n    > 通过 userId和password进行认证，如果不一致，则鉴权失败，如果一致则成功。\n    \n    > 缺点：密码明文存在安全问题\n* 阶段二：\n    > 将password进行加密后进行认证。\n    \n    > 缺点：将会导致重放攻击。\n* 阶段三：\n    > 增加随机数，例如时间戳来生成token进行认证，设定超时间隔（一分钟），超时则认为token过期。\n \n    > 缺点：一分钟内还是会有重放攻击。\n\n## 需求拆分\n\n1. 将URL，userId,password和时间戳拼接成字符串\n2. 通过加密算法将字符串生成token\n3. 将token和userId，时间戳拼在URL上发送至服务端\n4. 解析URL，拆分出token，userId，时间戳\n5. 比较时间戳，判断token是否超时\n6. 从数据库通过userId取得对应的password\n7. 生成token比较是否一致。\n\n## 设计\n\n* 划分职责进而识别出有哪些类\n* 定义类以及属性和方法\n* 定义类与类之间的交互关系\n* 将类组装起来并提供执行入口\n\n## 划分职责进而识别有哪些类\n\n1，2，5，7 与token的生成，验证，比较有关\n3，4与URL有关，负责处理URL的拼接和拆分\n6操作userId和password，从存储中读取userId和password\n\n因此，初步可以设置成三个类，分别为AuthToken，ApiRequest，CredentialStorage\n\n## 定义类以及属性和方法\n\n### AuthToken\n\n#### 属性\n\ntoken，createTime，expiredTimeInterval\n\n#### 构造函数\n\nAuthToken(String token, long createTime);\n\nAuthToken(String token, long createTime, long expiredTimeInterval);\n\n#### 方法\n\ncreateToken(String url, long createTime, Map<String,String> params);\n\ngetToken();\n\nisExpired();\n\nmatch(AuthToken authToken);\n\n### ApiRequest\n\n#### 属性\ntoken, baseUrl, userId，timestamp\n#### 构造方法\nApiRequest(String token, String baseUrl, String userId);\n#### 方法\n\nget；\n\nApiRequest getRequestFromURL(String url);\n\n\n### CredentialStorage\n\n#### 接口\nString getPasswordFromUserId(String userId);\n\n## 定义类与类之间的交互关系\nUML中主要分为 泛化，实现，组合，聚合， 关联， 依赖。\n\n泛化就是继承，实现就是接口和实现类之间的关系\n\n聚合是包含关系，A类对象包含B类对象，B的生命周期不依赖A的生命周期，类似课程和学生的关系\n\n组合也是包含关系，不同点在于B的生命周期依赖A的生命周期，类似翅膀和鸟类的关系。\n\n关联包含聚合和组合两种关系。\n\n依赖时一种比关联关系更加弱的关系，包含关联关系，只要B类对象时A类对象的参数，返回值，或者局部变量，任何使用关系，都称之为依赖。\n\n简化后，将组合关系替代UML中的组合，聚合，关联三个概念，都称之为组合，因此也就有了\n“多用组合少用继承”的设计原则。\n\n## 将类组装起来并提供执行入口\n\n### ApiAuthenticator接口\n\nvoid auth(String url);\n\nvoid auth(ApiRequest apiRequest);\n\n### ApiAuthenticator实现\n#### 属性\n\nprivate CredentialStorage credentialStorage;\n\n#### 构造函数\n\nApiAuthenticator();\n\nApiAuthenticator(ApiAuthenticator apiAuthenticator);\n\n#### 函数\n\nvoid auth(String url);\n\nvoid auth(ApiRequest apiRequest);\n\n","slug":"设计模式/设计模式之实战","published":1,"updated":"2020-02-05T15:32:07.870Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxh004l4l3n4c7doiql","content":"<p>代码详见： <a href=\"https://github.com/zjbao123/PatternDesign/tree/master/ApiAuthenticator\" target=\"_blank\" rel=\"noopener\">github.com/zjbao123/PatternDesign</a></p>\n<h2 id=\"需求来源\"><a href=\"#需求来源\" class=\"headerlink\" title=\"需求来源\"></a>需求来源</h2><p>为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。我希望由你来负责这个任务的开发，争取尽快上线。</p>\n<a id=\"more\"></a>\n<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><ul>\n<li><p>阶段一：</p>\n<blockquote>\n<p>通过 userId和password进行认证，如果不一致，则鉴权失败，如果一致则成功。</p>\n</blockquote>\n<blockquote>\n<p>缺点：密码明文存在安全问题</p>\n</blockquote>\n</li>\n<li><p>阶段二：</p>\n<blockquote>\n<p>将password进行加密后进行认证。</p>\n</blockquote>\n<blockquote>\n<p>缺点：将会导致重放攻击。</p>\n</blockquote>\n</li>\n<li><p>阶段三：</p>\n<blockquote>\n<p>增加随机数，例如时间戳来生成token进行认证，设定超时间隔（一分钟），超时则认为token过期。</p>\n</blockquote>\n<blockquote>\n<p>缺点：一分钟内还是会有重放攻击。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"需求拆分\"><a href=\"#需求拆分\" class=\"headerlink\" title=\"需求拆分\"></a>需求拆分</h2><ol>\n<li>将URL，userId,password和时间戳拼接成字符串</li>\n<li>通过加密算法将字符串生成token</li>\n<li>将token和userId，时间戳拼在URL上发送至服务端</li>\n<li>解析URL，拆分出token，userId，时间戳</li>\n<li>比较时间戳，判断token是否超时</li>\n<li>从数据库通过userId取得对应的password</li>\n<li>生成token比较是否一致。</li>\n</ol>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><ul>\n<li>划分职责进而识别出有哪些类</li>\n<li>定义类以及属性和方法</li>\n<li>定义类与类之间的交互关系</li>\n<li>将类组装起来并提供执行入口</li>\n</ul>\n<h2 id=\"划分职责进而识别有哪些类\"><a href=\"#划分职责进而识别有哪些类\" class=\"headerlink\" title=\"划分职责进而识别有哪些类\"></a>划分职责进而识别有哪些类</h2><p>1，2，5，7 与token的生成，验证，比较有关<br>3，4与URL有关，负责处理URL的拼接和拆分<br>6操作userId和password，从存储中读取userId和password</p>\n<p>因此，初步可以设置成三个类，分别为AuthToken，ApiRequest，CredentialStorage</p>\n<h2 id=\"定义类以及属性和方法\"><a href=\"#定义类以及属性和方法\" class=\"headerlink\" title=\"定义类以及属性和方法\"></a>定义类以及属性和方法</h2><h3 id=\"AuthToken\"><a href=\"#AuthToken\" class=\"headerlink\" title=\"AuthToken\"></a>AuthToken</h3><h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>token，createTime，expiredTimeInterval</p>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>AuthToken(String token, long createTime);</p>\n<p>AuthToken(String token, long createTime, long expiredTimeInterval);</p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>createToken(String url, long createTime, Map&lt;String,String&gt; params);</p>\n<p>getToken();</p>\n<p>isExpired();</p>\n<p>match(AuthToken authToken);</p>\n<h3 id=\"ApiRequest\"><a href=\"#ApiRequest\" class=\"headerlink\" title=\"ApiRequest\"></a>ApiRequest</h3><h4 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>token, baseUrl, userId，timestamp</p>\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p>ApiRequest(String token, String baseUrl, String userId);</p>\n<h4 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>get；</p>\n<p>ApiRequest getRequestFromURL(String url);</p>\n<h3 id=\"CredentialStorage\"><a href=\"#CredentialStorage\" class=\"headerlink\" title=\"CredentialStorage\"></a>CredentialStorage</h3><h4 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h4><p>String getPasswordFromUserId(String userId);</p>\n<h2 id=\"定义类与类之间的交互关系\"><a href=\"#定义类与类之间的交互关系\" class=\"headerlink\" title=\"定义类与类之间的交互关系\"></a>定义类与类之间的交互关系</h2><p>UML中主要分为 泛化，实现，组合，聚合， 关联， 依赖。</p>\n<p>泛化就是继承，实现就是接口和实现类之间的关系</p>\n<p>聚合是包含关系，A类对象包含B类对象，B的生命周期不依赖A的生命周期，类似课程和学生的关系</p>\n<p>组合也是包含关系，不同点在于B的生命周期依赖A的生命周期，类似翅膀和鸟类的关系。</p>\n<p>关联包含聚合和组合两种关系。</p>\n<p>依赖时一种比关联关系更加弱的关系，包含关联关系，只要B类对象时A类对象的参数，返回值，或者局部变量，任何使用关系，都称之为依赖。</p>\n<p>简化后，将组合关系替代UML中的组合，聚合，关联三个概念，都称之为组合，因此也就有了<br>“多用组合少用继承”的设计原则。</p>\n<h2 id=\"将类组装起来并提供执行入口\"><a href=\"#将类组装起来并提供执行入口\" class=\"headerlink\" title=\"将类组装起来并提供执行入口\"></a>将类组装起来并提供执行入口</h2><h3 id=\"ApiAuthenticator接口\"><a href=\"#ApiAuthenticator接口\" class=\"headerlink\" title=\"ApiAuthenticator接口\"></a>ApiAuthenticator接口</h3><p>void auth(String url);</p>\n<p>void auth(ApiRequest apiRequest);</p>\n<h3 id=\"ApiAuthenticator实现\"><a href=\"#ApiAuthenticator实现\" class=\"headerlink\" title=\"ApiAuthenticator实现\"></a>ApiAuthenticator实现</h3><h4 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>private CredentialStorage credentialStorage;</p>\n<h4 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>ApiAuthenticator();</p>\n<p>ApiAuthenticator(ApiAuthenticator apiAuthenticator);</p>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><p>void auth(String url);</p>\n<p>void auth(ApiRequest apiRequest);</p>\n","site":{"data":{}},"excerpt":"<p>代码详见： <a href=\"https://github.com/zjbao123/PatternDesign/tree/master/ApiAuthenticator\" target=\"_blank\" rel=\"noopener\">github.com/zjbao123/PatternDesign</a></p>\n<h2 id=\"需求来源\"><a href=\"#需求来源\" class=\"headerlink\" title=\"需求来源\"></a>需求来源</h2><p>为了保证接口调用的安全性，我们希望设计实现一个接口调用鉴权功能，只有经过认证之后的系统才能调用我们的接口，没有认证过的系统调用我们的接口会被拒绝。我希望由你来负责这个任务的开发，争取尽快上线。</p>","more":"<h2 id=\"需求分析\"><a href=\"#需求分析\" class=\"headerlink\" title=\"需求分析\"></a>需求分析</h2><ul>\n<li><p>阶段一：</p>\n<blockquote>\n<p>通过 userId和password进行认证，如果不一致，则鉴权失败，如果一致则成功。</p>\n</blockquote>\n<blockquote>\n<p>缺点：密码明文存在安全问题</p>\n</blockquote>\n</li>\n<li><p>阶段二：</p>\n<blockquote>\n<p>将password进行加密后进行认证。</p>\n</blockquote>\n<blockquote>\n<p>缺点：将会导致重放攻击。</p>\n</blockquote>\n</li>\n<li><p>阶段三：</p>\n<blockquote>\n<p>增加随机数，例如时间戳来生成token进行认证，设定超时间隔（一分钟），超时则认为token过期。</p>\n</blockquote>\n<blockquote>\n<p>缺点：一分钟内还是会有重放攻击。</p>\n</blockquote>\n</li>\n</ul>\n<h2 id=\"需求拆分\"><a href=\"#需求拆分\" class=\"headerlink\" title=\"需求拆分\"></a>需求拆分</h2><ol>\n<li>将URL，userId,password和时间戳拼接成字符串</li>\n<li>通过加密算法将字符串生成token</li>\n<li>将token和userId，时间戳拼在URL上发送至服务端</li>\n<li>解析URL，拆分出token，userId，时间戳</li>\n<li>比较时间戳，判断token是否超时</li>\n<li>从数据库通过userId取得对应的password</li>\n<li>生成token比较是否一致。</li>\n</ol>\n<h2 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h2><ul>\n<li>划分职责进而识别出有哪些类</li>\n<li>定义类以及属性和方法</li>\n<li>定义类与类之间的交互关系</li>\n<li>将类组装起来并提供执行入口</li>\n</ul>\n<h2 id=\"划分职责进而识别有哪些类\"><a href=\"#划分职责进而识别有哪些类\" class=\"headerlink\" title=\"划分职责进而识别有哪些类\"></a>划分职责进而识别有哪些类</h2><p>1，2，5，7 与token的生成，验证，比较有关<br>3，4与URL有关，负责处理URL的拼接和拆分<br>6操作userId和password，从存储中读取userId和password</p>\n<p>因此，初步可以设置成三个类，分别为AuthToken，ApiRequest，CredentialStorage</p>\n<h2 id=\"定义类以及属性和方法\"><a href=\"#定义类以及属性和方法\" class=\"headerlink\" title=\"定义类以及属性和方法\"></a>定义类以及属性和方法</h2><h3 id=\"AuthToken\"><a href=\"#AuthToken\" class=\"headerlink\" title=\"AuthToken\"></a>AuthToken</h3><h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>token，createTime，expiredTimeInterval</p>\n<h4 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>AuthToken(String token, long createTime);</p>\n<p>AuthToken(String token, long createTime, long expiredTimeInterval);</p>\n<h4 id=\"方法\"><a href=\"#方法\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>createToken(String url, long createTime, Map&lt;String,String&gt; params);</p>\n<p>getToken();</p>\n<p>isExpired();</p>\n<p>match(AuthToken authToken);</p>\n<h3 id=\"ApiRequest\"><a href=\"#ApiRequest\" class=\"headerlink\" title=\"ApiRequest\"></a>ApiRequest</h3><h4 id=\"属性-1\"><a href=\"#属性-1\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>token, baseUrl, userId，timestamp</p>\n<h4 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h4><p>ApiRequest(String token, String baseUrl, String userId);</p>\n<h4 id=\"方法-1\"><a href=\"#方法-1\" class=\"headerlink\" title=\"方法\"></a>方法</h4><p>get；</p>\n<p>ApiRequest getRequestFromURL(String url);</p>\n<h3 id=\"CredentialStorage\"><a href=\"#CredentialStorage\" class=\"headerlink\" title=\"CredentialStorage\"></a>CredentialStorage</h3><h4 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h4><p>String getPasswordFromUserId(String userId);</p>\n<h2 id=\"定义类与类之间的交互关系\"><a href=\"#定义类与类之间的交互关系\" class=\"headerlink\" title=\"定义类与类之间的交互关系\"></a>定义类与类之间的交互关系</h2><p>UML中主要分为 泛化，实现，组合，聚合， 关联， 依赖。</p>\n<p>泛化就是继承，实现就是接口和实现类之间的关系</p>\n<p>聚合是包含关系，A类对象包含B类对象，B的生命周期不依赖A的生命周期，类似课程和学生的关系</p>\n<p>组合也是包含关系，不同点在于B的生命周期依赖A的生命周期，类似翅膀和鸟类的关系。</p>\n<p>关联包含聚合和组合两种关系。</p>\n<p>依赖时一种比关联关系更加弱的关系，包含关联关系，只要B类对象时A类对象的参数，返回值，或者局部变量，任何使用关系，都称之为依赖。</p>\n<p>简化后，将组合关系替代UML中的组合，聚合，关联三个概念，都称之为组合，因此也就有了<br>“多用组合少用继承”的设计原则。</p>\n<h2 id=\"将类组装起来并提供执行入口\"><a href=\"#将类组装起来并提供执行入口\" class=\"headerlink\" title=\"将类组装起来并提供执行入口\"></a>将类组装起来并提供执行入口</h2><h3 id=\"ApiAuthenticator接口\"><a href=\"#ApiAuthenticator接口\" class=\"headerlink\" title=\"ApiAuthenticator接口\"></a>ApiAuthenticator接口</h3><p>void auth(String url);</p>\n<p>void auth(ApiRequest apiRequest);</p>\n<h3 id=\"ApiAuthenticator实现\"><a href=\"#ApiAuthenticator实现\" class=\"headerlink\" title=\"ApiAuthenticator实现\"></a>ApiAuthenticator实现</h3><h4 id=\"属性-2\"><a href=\"#属性-2\" class=\"headerlink\" title=\"属性\"></a>属性</h4><p>private CredentialStorage credentialStorage;</p>\n<h4 id=\"构造函数-1\"><a href=\"#构造函数-1\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h4><p>ApiAuthenticator();</p>\n<p>ApiAuthenticator(ApiAuthenticator apiAuthenticator);</p>\n<h4 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h4><p>void auth(String url);</p>\n<p>void auth(ApiRequest apiRequest);</p>"},{"title":"消息队列的高可用性","date":"2019-10-21T16:28:22.000Z","_content":"\n既然MQ会导致系统的可用性降低，那么如何保证MQ的高可用？\n\n首先来讲一讲各个MQ的高可用性。\n\n### RabbitMQ的高可用性\n\nRabbitMQ是比较有代表性的，基于主从来做高可用性。RabbitMQ有三种模式：单机模式、普通集群模式、镜像集群模式。\n\n单机模式就是最简单的模式，一般就是Demo级别，自己启动玩玩的。\n<!-- more -->\n#### 普通集群模式\n\n普通集群模式，意思是多台机器启动多个RabbitMQ实例，每个机器启动一个。你创建的queue，只会放在一个RabbitMQ实例上。但是每个实例会同步queue的元数据（可以理解queue的配置信息）。即使你消费的时候连接到了另一个实例，那么那个实例会从queue所在实例上拉取数据过来。\n![RabbitMQ普通集群](RabbitMQ的高可用性/RabbitMQ普通集群.png)\n\n其实并没有做到所谓的分布式，还是普通集群。因为会导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个queue所在实例消费数据。前者有数据拉取的开销，后者会导致单实例性能瓶颈。\n\n如果放queue的实例宕机了，则会导致其他实例都没有办法进行拉取。如果你开启了消息持久化，让RabbitMQ落地存储消息的话，消息不一定会丢。得等这个实例恢复了，然后才可以继续从这个queue拉取数据。\n\n这个方案主要是提高吞吐量。也就是说让多个节点来服务某个queue的读写操作。\n\n\n#### 镜像模式\n\n镜像集群模式，才是所谓的HA，跟普通集群不一样的是，在镜像集群模式下，你创造的元数据还是queue的消息都会存在多个实例上，也就是说，每个Rabbit节点都是一个完整的镜像，包含了所有queue的数据信息，当你写消息的时候，都会吧消息同步到多个实例的queue中。\n![RabbitMQ镜像集群模式](RabbitMQ的高可用性/RabbitMQ镜像模式.png)\n这种的好处就在于任何一个宕机，都可以从其他节点取消费数据。\n而他的坏处，也显而易见。第一，性能开销很大，消息需要同步到所有汲取，没有办法对你的queue进行线性拓展。如果数据量很大，大到你一个机器无法容纳了，该如何处理呢？\n\n### Kafka的高可用性\nkafka由多个broker组成，每个broker是一个节点；你创建的一个topic，可以划分为多个partition，每个partition存在不同的broker上，每个partition存放一部分的数据。也就是一个topic的数据，是分散在多个机器上的，每个机器就放一部分数据。\n\nKafka0.8以前，没有HA机制，任何一台broker宕机了，这个部分的数据就丢失了。\n在0.8版本之后，提供了HA机制，就是replica副本机制，每个partition数据都会同步到其他机器上，形成自己的多个副本，所有replica会选出一个leader来，来和生产者和消费者打交道，以保证数据一致性的问题。并且提高了容错率。\n\n![Kafka](RabbitMQ的高可用性/Kafka.png)\n\n写数据的时候，生产者就写leader，然后leader将数据落地写本地磁盘，接着其他follower自己从leader来pull数据，一旦所有follower同步好数据了，就会发送ack给leader，leader收到所有的follower的ack之后，就会返回写成功的消息给生产者。（这只是其中一种模式）\n\n消费的时候，只会从leader去读，但是只有当一个消息已经被所有follower都同步成功并且返回ack的时候，这个消息才会被消费者读到。\n","source":"_posts/架构学习/RabbitMQ的高可用性.md","raw":"---\ntitle: 消息队列的高可用性\ndate: 2019-10-22 0:28:22\ntags:\n- Java进阶\ncategories: Java\n---\n\n既然MQ会导致系统的可用性降低，那么如何保证MQ的高可用？\n\n首先来讲一讲各个MQ的高可用性。\n\n### RabbitMQ的高可用性\n\nRabbitMQ是比较有代表性的，基于主从来做高可用性。RabbitMQ有三种模式：单机模式、普通集群模式、镜像集群模式。\n\n单机模式就是最简单的模式，一般就是Demo级别，自己启动玩玩的。\n<!-- more -->\n#### 普通集群模式\n\n普通集群模式，意思是多台机器启动多个RabbitMQ实例，每个机器启动一个。你创建的queue，只会放在一个RabbitMQ实例上。但是每个实例会同步queue的元数据（可以理解queue的配置信息）。即使你消费的时候连接到了另一个实例，那么那个实例会从queue所在实例上拉取数据过来。\n![RabbitMQ普通集群](RabbitMQ的高可用性/RabbitMQ普通集群.png)\n\n其实并没有做到所谓的分布式，还是普通集群。因为会导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个queue所在实例消费数据。前者有数据拉取的开销，后者会导致单实例性能瓶颈。\n\n如果放queue的实例宕机了，则会导致其他实例都没有办法进行拉取。如果你开启了消息持久化，让RabbitMQ落地存储消息的话，消息不一定会丢。得等这个实例恢复了，然后才可以继续从这个queue拉取数据。\n\n这个方案主要是提高吞吐量。也就是说让多个节点来服务某个queue的读写操作。\n\n\n#### 镜像模式\n\n镜像集群模式，才是所谓的HA，跟普通集群不一样的是，在镜像集群模式下，你创造的元数据还是queue的消息都会存在多个实例上，也就是说，每个Rabbit节点都是一个完整的镜像，包含了所有queue的数据信息，当你写消息的时候，都会吧消息同步到多个实例的queue中。\n![RabbitMQ镜像集群模式](RabbitMQ的高可用性/RabbitMQ镜像模式.png)\n这种的好处就在于任何一个宕机，都可以从其他节点取消费数据。\n而他的坏处，也显而易见。第一，性能开销很大，消息需要同步到所有汲取，没有办法对你的queue进行线性拓展。如果数据量很大，大到你一个机器无法容纳了，该如何处理呢？\n\n### Kafka的高可用性\nkafka由多个broker组成，每个broker是一个节点；你创建的一个topic，可以划分为多个partition，每个partition存在不同的broker上，每个partition存放一部分的数据。也就是一个topic的数据，是分散在多个机器上的，每个机器就放一部分数据。\n\nKafka0.8以前，没有HA机制，任何一台broker宕机了，这个部分的数据就丢失了。\n在0.8版本之后，提供了HA机制，就是replica副本机制，每个partition数据都会同步到其他机器上，形成自己的多个副本，所有replica会选出一个leader来，来和生产者和消费者打交道，以保证数据一致性的问题。并且提高了容错率。\n\n![Kafka](RabbitMQ的高可用性/Kafka.png)\n\n写数据的时候，生产者就写leader，然后leader将数据落地写本地磁盘，接着其他follower自己从leader来pull数据，一旦所有follower同步好数据了，就会发送ack给leader，leader收到所有的follower的ack之后，就会返回写成功的消息给生产者。（这只是其中一种模式）\n\n消费的时候，只会从leader去读，但是只有当一个消息已经被所有follower都同步成功并且返回ack的时候，这个消息才会被消费者读到。\n","slug":"架构学习/RabbitMQ的高可用性","published":1,"updated":"2019-10-21T16:34:21.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxi004p4l3n9wuo2qya","content":"<p>既然MQ会导致系统的可用性降低，那么如何保证MQ的高可用？</p>\n<p>首先来讲一讲各个MQ的高可用性。</p>\n<h3 id=\"RabbitMQ的高可用性\"><a href=\"#RabbitMQ的高可用性\" class=\"headerlink\" title=\"RabbitMQ的高可用性\"></a>RabbitMQ的高可用性</h3><p>RabbitMQ是比较有代表性的，基于主从来做高可用性。RabbitMQ有三种模式：单机模式、普通集群模式、镜像集群模式。</p>\n<p>单机模式就是最简单的模式，一般就是Demo级别，自己启动玩玩的。<br><a id=\"more\"></a></p>\n<h4 id=\"普通集群模式\"><a href=\"#普通集群模式\" class=\"headerlink\" title=\"普通集群模式\"></a>普通集群模式</h4><p>普通集群模式，意思是多台机器启动多个RabbitMQ实例，每个机器启动一个。你创建的queue，只会放在一个RabbitMQ实例上。但是每个实例会同步queue的元数据（可以理解queue的配置信息）。即使你消费的时候连接到了另一个实例，那么那个实例会从queue所在实例上拉取数据过来。<br><img src=\"/2019/10/22/架构学习/RabbitMQ的高可用性/RabbitMQ普通集群.png\" alt=\"RabbitMQ普通集群\"></p>\n<p>其实并没有做到所谓的分布式，还是普通集群。因为会导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个queue所在实例消费数据。前者有数据拉取的开销，后者会导致单实例性能瓶颈。</p>\n<p>如果放queue的实例宕机了，则会导致其他实例都没有办法进行拉取。如果你开启了消息持久化，让RabbitMQ落地存储消息的话，消息不一定会丢。得等这个实例恢复了，然后才可以继续从这个queue拉取数据。</p>\n<p>这个方案主要是提高吞吐量。也就是说让多个节点来服务某个queue的读写操作。</p>\n<h4 id=\"镜像模式\"><a href=\"#镜像模式\" class=\"headerlink\" title=\"镜像模式\"></a>镜像模式</h4><p>镜像集群模式，才是所谓的HA，跟普通集群不一样的是，在镜像集群模式下，你创造的元数据还是queue的消息都会存在多个实例上，也就是说，每个Rabbit节点都是一个完整的镜像，包含了所有queue的数据信息，当你写消息的时候，都会吧消息同步到多个实例的queue中。<br><img src=\"/2019/10/22/架构学习/RabbitMQ的高可用性/RabbitMQ镜像模式.png\" alt=\"RabbitMQ镜像集群模式\"><br>这种的好处就在于任何一个宕机，都可以从其他节点取消费数据。<br>而他的坏处，也显而易见。第一，性能开销很大，消息需要同步到所有汲取，没有办法对你的queue进行线性拓展。如果数据量很大，大到你一个机器无法容纳了，该如何处理呢？</p>\n<h3 id=\"Kafka的高可用性\"><a href=\"#Kafka的高可用性\" class=\"headerlink\" title=\"Kafka的高可用性\"></a>Kafka的高可用性</h3><p>kafka由多个broker组成，每个broker是一个节点；你创建的一个topic，可以划分为多个partition，每个partition存在不同的broker上，每个partition存放一部分的数据。也就是一个topic的数据，是分散在多个机器上的，每个机器就放一部分数据。</p>\n<p>Kafka0.8以前，没有HA机制，任何一台broker宕机了，这个部分的数据就丢失了。<br>在0.8版本之后，提供了HA机制，就是replica副本机制，每个partition数据都会同步到其他机器上，形成自己的多个副本，所有replica会选出一个leader来，来和生产者和消费者打交道，以保证数据一致性的问题。并且提高了容错率。</p>\n<p><img src=\"/2019/10/22/架构学习/RabbitMQ的高可用性/Kafka.png\" alt=\"Kafka\"></p>\n<p>写数据的时候，生产者就写leader，然后leader将数据落地写本地磁盘，接着其他follower自己从leader来pull数据，一旦所有follower同步好数据了，就会发送ack给leader，leader收到所有的follower的ack之后，就会返回写成功的消息给生产者。（这只是其中一种模式）</p>\n<p>消费的时候，只会从leader去读，但是只有当一个消息已经被所有follower都同步成功并且返回ack的时候，这个消息才会被消费者读到。</p>\n","site":{"data":{}},"excerpt":"<p>既然MQ会导致系统的可用性降低，那么如何保证MQ的高可用？</p>\n<p>首先来讲一讲各个MQ的高可用性。</p>\n<h3 id=\"RabbitMQ的高可用性\"><a href=\"#RabbitMQ的高可用性\" class=\"headerlink\" title=\"RabbitMQ的高可用性\"></a>RabbitMQ的高可用性</h3><p>RabbitMQ是比较有代表性的，基于主从来做高可用性。RabbitMQ有三种模式：单机模式、普通集群模式、镜像集群模式。</p>\n<p>单机模式就是最简单的模式，一般就是Demo级别，自己启动玩玩的。<br></p>","more":"<p></p>\n<h4 id=\"普通集群模式\"><a href=\"#普通集群模式\" class=\"headerlink\" title=\"普通集群模式\"></a>普通集群模式</h4><p>普通集群模式，意思是多台机器启动多个RabbitMQ实例，每个机器启动一个。你创建的queue，只会放在一个RabbitMQ实例上。但是每个实例会同步queue的元数据（可以理解queue的配置信息）。即使你消费的时候连接到了另一个实例，那么那个实例会从queue所在实例上拉取数据过来。<br><img src=\"/2019/10/22/架构学习/RabbitMQ的高可用性/RabbitMQ普通集群.png\" alt=\"RabbitMQ普通集群\"></p>\n<p>其实并没有做到所谓的分布式，还是普通集群。因为会导致你要么消费者每次随机连接一个实例然后拉取数据，要么固定连接那个queue所在实例消费数据。前者有数据拉取的开销，后者会导致单实例性能瓶颈。</p>\n<p>如果放queue的实例宕机了，则会导致其他实例都没有办法进行拉取。如果你开启了消息持久化，让RabbitMQ落地存储消息的话，消息不一定会丢。得等这个实例恢复了，然后才可以继续从这个queue拉取数据。</p>\n<p>这个方案主要是提高吞吐量。也就是说让多个节点来服务某个queue的读写操作。</p>\n<h4 id=\"镜像模式\"><a href=\"#镜像模式\" class=\"headerlink\" title=\"镜像模式\"></a>镜像模式</h4><p>镜像集群模式，才是所谓的HA，跟普通集群不一样的是，在镜像集群模式下，你创造的元数据还是queue的消息都会存在多个实例上，也就是说，每个Rabbit节点都是一个完整的镜像，包含了所有queue的数据信息，当你写消息的时候，都会吧消息同步到多个实例的queue中。<br><img src=\"/2019/10/22/架构学习/RabbitMQ的高可用性/RabbitMQ镜像模式.png\" alt=\"RabbitMQ镜像集群模式\"><br>这种的好处就在于任何一个宕机，都可以从其他节点取消费数据。<br>而他的坏处，也显而易见。第一，性能开销很大，消息需要同步到所有汲取，没有办法对你的queue进行线性拓展。如果数据量很大，大到你一个机器无法容纳了，该如何处理呢？</p>\n<h3 id=\"Kafka的高可用性\"><a href=\"#Kafka的高可用性\" class=\"headerlink\" title=\"Kafka的高可用性\"></a>Kafka的高可用性</h3><p>kafka由多个broker组成，每个broker是一个节点；你创建的一个topic，可以划分为多个partition，每个partition存在不同的broker上，每个partition存放一部分的数据。也就是一个topic的数据，是分散在多个机器上的，每个机器就放一部分数据。</p>\n<p>Kafka0.8以前，没有HA机制，任何一台broker宕机了，这个部分的数据就丢失了。<br>在0.8版本之后，提供了HA机制，就是replica副本机制，每个partition数据都会同步到其他机器上，形成自己的多个副本，所有replica会选出一个leader来，来和生产者和消费者打交道，以保证数据一致性的问题。并且提高了容错率。</p>\n<p><img src=\"/2019/10/22/架构学习/RabbitMQ的高可用性/Kafka.png\" alt=\"Kafka\"></p>\n<p>写数据的时候，生产者就写leader，然后leader将数据落地写本地磁盘，接着其他follower自己从leader来pull数据，一旦所有follower同步好数据了，就会发送ack给leader，leader收到所有的follower的ack之后，就会返回写成功的消息给生产者。（这只是其中一种模式）</p>\n<p>消费的时候，只会从leader去读，但是只有当一个消息已经被所有follower都同步成功并且返回ack的时候，这个消息才会被消费者读到。</p>"},{"title":"设计模式之美--面向对象","date":"2019-11-20T14:49:22.000Z","_content":"\n### 从面向对象开始\n\n面向对象编程是一种编程范式或者编程风格。它以类或者对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为编程设计和实现的基石。\n\n面向对象编程语言，支持类或者对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程的四大特性的编程语言。\n\n<!-- more -->\n\n面向对象分析就是要清楚要做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产物是类的设计。包括程序被拆解为哪些类，每个类有哪些属性方法，类和类之间如何交互等等。\n\n#### 封装\nWHAT： 隐藏信息，保护数据访问。\nHOW：  通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。\nWHY：  一方面，保护数据不被随意修改，提高代码的可维护性；另一方面，仅仅暴露有限的必要接口，提高类的易用性。\n\n#### 抽象\nWHAT： 隐藏方法的具体实现，让使用者只需要关心提供了哪些功能，不需要知道实现。\nHOW：  通过接口类或者抽象类实现。特殊语法机制，非必须。\nWHY：  一方面，提高了代码的可拓展性、维护性，修改实现不需要改变定义，减少了代码的改动范围；另一方面。也是处理复杂系统的有效手段，能够有效的过滤掉不必要关注的信息。\n\n#### 继承\nWHAT： 继承用来表示 `is-a`关系。主要有单继承和多继承。（多继承会有菱形继承问题）\nHOW：  需要编程语言提供特殊的语法机制，比如Java的extends，C++的`：`\nWHY：  解决代码复用的问题。\n\n#### 多态\nWHAT：  子类可以替换父类，在实际代码运行中，调用子类的方法进行实现。\nHOW：   特殊机制，比如继承，接口类，duck-typing。 \nHWHY：  多态可以提高代码的可拓展性和复用性，遵循 `对修改关闭，对拓展开放`的设计原则。是很多设计模式，设计原则，编程技巧的代码实现基础。\n\n### 面向对象相比面向过程的优势\n\n1. 面向对象（OOP）能够应对大规模复杂程序的开发，可以在应对复杂程序开发的时候，思路更加清晰。\n程序处理流程并非单一的一条主线，而是错综复杂的网状结构。通过面相对象的方式，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系。有了类的设计之后，然后再像搭积木一样，按照处理流程，再进行组装。\n\n2. OOP风格的代码更易服用，易扩展，易维护。因为四大特性，可以极大的满足复杂的编程需求\n\n3. OOP语言更加人性化，更加高级，更加智能。面向过程是一种计算机思维模式，而面向对象是一种replied额思维模式。我们在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能够聚焦到业务本身，而不是思考如何跟机器打交道。 \n\n### 哪些代码看似面向对象，实际面向过程？\n\n1. 滥用getter，setter方法，破坏封装\n\n2. 滥用全局变量和全局方法,如Constants类、Utils类的设计问题。尽量细化成小类，如果能将这些类的属性和方法，划分到其他业务类中，能更好的提高类的内聚性和可复用性.\n\n3. 基于贫血模型的开发模式。数据和操作是分开定义在VO/BO/Entity 和 Controller/Service/Repository中的。\n\n\n\n\n\n\n","source":"_posts/设计模式/设计模式之美--面向对象.md","raw":"---\ntitle: 设计模式之美--面向对象\ndate: 2019-11-20 22:49:22\ntags:\n- 心法\ncategories: 设计模式\n---\n\n### 从面向对象开始\n\n面向对象编程是一种编程范式或者编程风格。它以类或者对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为编程设计和实现的基石。\n\n面向对象编程语言，支持类或者对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程的四大特性的编程语言。\n\n<!-- more -->\n\n面向对象分析就是要清楚要做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产物是类的设计。包括程序被拆解为哪些类，每个类有哪些属性方法，类和类之间如何交互等等。\n\n#### 封装\nWHAT： 隐藏信息，保护数据访问。\nHOW：  通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。\nWHY：  一方面，保护数据不被随意修改，提高代码的可维护性；另一方面，仅仅暴露有限的必要接口，提高类的易用性。\n\n#### 抽象\nWHAT： 隐藏方法的具体实现，让使用者只需要关心提供了哪些功能，不需要知道实现。\nHOW：  通过接口类或者抽象类实现。特殊语法机制，非必须。\nWHY：  一方面，提高了代码的可拓展性、维护性，修改实现不需要改变定义，减少了代码的改动范围；另一方面。也是处理复杂系统的有效手段，能够有效的过滤掉不必要关注的信息。\n\n#### 继承\nWHAT： 继承用来表示 `is-a`关系。主要有单继承和多继承。（多继承会有菱形继承问题）\nHOW：  需要编程语言提供特殊的语法机制，比如Java的extends，C++的`：`\nWHY：  解决代码复用的问题。\n\n#### 多态\nWHAT：  子类可以替换父类，在实际代码运行中，调用子类的方法进行实现。\nHOW：   特殊机制，比如继承，接口类，duck-typing。 \nHWHY：  多态可以提高代码的可拓展性和复用性，遵循 `对修改关闭，对拓展开放`的设计原则。是很多设计模式，设计原则，编程技巧的代码实现基础。\n\n### 面向对象相比面向过程的优势\n\n1. 面向对象（OOP）能够应对大规模复杂程序的开发，可以在应对复杂程序开发的时候，思路更加清晰。\n程序处理流程并非单一的一条主线，而是错综复杂的网状结构。通过面相对象的方式，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系。有了类的设计之后，然后再像搭积木一样，按照处理流程，再进行组装。\n\n2. OOP风格的代码更易服用，易扩展，易维护。因为四大特性，可以极大的满足复杂的编程需求\n\n3. OOP语言更加人性化，更加高级，更加智能。面向过程是一种计算机思维模式，而面向对象是一种replied额思维模式。我们在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能够聚焦到业务本身，而不是思考如何跟机器打交道。 \n\n### 哪些代码看似面向对象，实际面向过程？\n\n1. 滥用getter，setter方法，破坏封装\n\n2. 滥用全局变量和全局方法,如Constants类、Utils类的设计问题。尽量细化成小类，如果能将这些类的属性和方法，划分到其他业务类中，能更好的提高类的内聚性和可复用性.\n\n3. 基于贫血模型的开发模式。数据和操作是分开定义在VO/BO/Entity 和 Controller/Service/Repository中的。\n\n\n\n\n\n\n","slug":"设计模式/设计模式之美--面向对象","published":1,"updated":"2020-02-05T15:16:10.670Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxi004s4l3n6ejblz8k","content":"<h3 id=\"从面向对象开始\"><a href=\"#从面向对象开始\" class=\"headerlink\" title=\"从面向对象开始\"></a>从面向对象开始</h3><p>面向对象编程是一种编程范式或者编程风格。它以类或者对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为编程设计和实现的基石。</p>\n<p>面向对象编程语言，支持类或者对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程的四大特性的编程语言。</p>\n<a id=\"more\"></a>\n<p>面向对象分析就是要清楚要做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产物是类的设计。包括程序被拆解为哪些类，每个类有哪些属性方法，类和类之间如何交互等等。</p>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>WHAT： 隐藏信息，保护数据访问。<br>HOW：  通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。<br>WHY：  一方面，保护数据不被随意修改，提高代码的可维护性；另一方面，仅仅暴露有限的必要接口，提高类的易用性。</p>\n<h4 id=\"抽象\"><a href=\"#抽象\" class=\"headerlink\" title=\"抽象\"></a>抽象</h4><p>WHAT： 隐藏方法的具体实现，让使用者只需要关心提供了哪些功能，不需要知道实现。<br>HOW：  通过接口类或者抽象类实现。特殊语法机制，非必须。<br>WHY：  一方面，提高了代码的可拓展性、维护性，修改实现不需要改变定义，减少了代码的改动范围；另一方面。也是处理复杂系统的有效手段，能够有效的过滤掉不必要关注的信息。</p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>WHAT： 继承用来表示 <code>is-a</code>关系。主要有单继承和多继承。（多继承会有菱形继承问题）<br>HOW：  需要编程语言提供特殊的语法机制，比如Java的extends，C++的<code>：</code><br>WHY：  解决代码复用的问题。</p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>WHAT：  子类可以替换父类，在实际代码运行中，调用子类的方法进行实现。<br>HOW：   特殊机制，比如继承，接口类，duck-typing。<br>HWHY：  多态可以提高代码的可拓展性和复用性，遵循 <code>对修改关闭，对拓展开放</code>的设计原则。是很多设计模式，设计原则，编程技巧的代码实现基础。</p>\n<h3 id=\"面向对象相比面向过程的优势\"><a href=\"#面向对象相比面向过程的优势\" class=\"headerlink\" title=\"面向对象相比面向过程的优势\"></a>面向对象相比面向过程的优势</h3><ol>\n<li><p>面向对象（OOP）能够应对大规模复杂程序的开发，可以在应对复杂程序开发的时候，思路更加清晰。<br>程序处理流程并非单一的一条主线，而是错综复杂的网状结构。通过面相对象的方式，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系。有了类的设计之后，然后再像搭积木一样，按照处理流程，再进行组装。</p>\n</li>\n<li><p>OOP风格的代码更易服用，易扩展，易维护。因为四大特性，可以极大的满足复杂的编程需求</p>\n</li>\n<li><p>OOP语言更加人性化，更加高级，更加智能。面向过程是一种计算机思维模式，而面向对象是一种replied额思维模式。我们在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能够聚焦到业务本身，而不是思考如何跟机器打交道。 </p>\n</li>\n</ol>\n<h3 id=\"哪些代码看似面向对象，实际面向过程？\"><a href=\"#哪些代码看似面向对象，实际面向过程？\" class=\"headerlink\" title=\"哪些代码看似面向对象，实际面向过程？\"></a>哪些代码看似面向对象，实际面向过程？</h3><ol>\n<li><p>滥用getter，setter方法，破坏封装</p>\n</li>\n<li><p>滥用全局变量和全局方法,如Constants类、Utils类的设计问题。尽量细化成小类，如果能将这些类的属性和方法，划分到其他业务类中，能更好的提高类的内聚性和可复用性.</p>\n</li>\n<li><p>基于贫血模型的开发模式。数据和操作是分开定义在VO/BO/Entity 和 Controller/Service/Repository中的。</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"从面向对象开始\"><a href=\"#从面向对象开始\" class=\"headerlink\" title=\"从面向对象开始\"></a>从面向对象开始</h3><p>面向对象编程是一种编程范式或者编程风格。它以类或者对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性，作为编程设计和实现的基石。</p>\n<p>面向对象编程语言，支持类或者对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程的四大特性的编程语言。</p>","more":"<p>面向对象分析就是要清楚要做什么，面向对象设计就是要搞清楚怎么做。两个阶段最终的产物是类的设计。包括程序被拆解为哪些类，每个类有哪些属性方法，类和类之间如何交互等等。</p>\n<h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>WHAT： 隐藏信息，保护数据访问。<br>HOW：  通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部信息或者数据。<br>WHY：  一方面，保护数据不被随意修改，提高代码的可维护性；另一方面，仅仅暴露有限的必要接口，提高类的易用性。</p>\n<h4 id=\"抽象\"><a href=\"#抽象\" class=\"headerlink\" title=\"抽象\"></a>抽象</h4><p>WHAT： 隐藏方法的具体实现，让使用者只需要关心提供了哪些功能，不需要知道实现。<br>HOW：  通过接口类或者抽象类实现。特殊语法机制，非必须。<br>WHY：  一方面，提高了代码的可拓展性、维护性，修改实现不需要改变定义，减少了代码的改动范围；另一方面。也是处理复杂系统的有效手段，能够有效的过滤掉不必要关注的信息。</p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>WHAT： 继承用来表示 <code>is-a</code>关系。主要有单继承和多继承。（多继承会有菱形继承问题）<br>HOW：  需要编程语言提供特殊的语法机制，比如Java的extends，C++的<code>：</code><br>WHY：  解决代码复用的问题。</p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><p>WHAT：  子类可以替换父类，在实际代码运行中，调用子类的方法进行实现。<br>HOW：   特殊机制，比如继承，接口类，duck-typing。<br>HWHY：  多态可以提高代码的可拓展性和复用性，遵循 <code>对修改关闭，对拓展开放</code>的设计原则。是很多设计模式，设计原则，编程技巧的代码实现基础。</p>\n<h3 id=\"面向对象相比面向过程的优势\"><a href=\"#面向对象相比面向过程的优势\" class=\"headerlink\" title=\"面向对象相比面向过程的优势\"></a>面向对象相比面向过程的优势</h3><ol>\n<li><p>面向对象（OOP）能够应对大规模复杂程序的开发，可以在应对复杂程序开发的时候，思路更加清晰。<br>程序处理流程并非单一的一条主线，而是错综复杂的网状结构。通过面相对象的方式，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系。有了类的设计之后，然后再像搭积木一样，按照处理流程，再进行组装。</p>\n</li>\n<li><p>OOP风格的代码更易服用，易扩展，易维护。因为四大特性，可以极大的满足复杂的编程需求</p>\n</li>\n<li><p>OOP语言更加人性化，更加高级，更加智能。面向过程是一种计算机思维模式，而面向对象是一种replied额思维模式。我们在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能够聚焦到业务本身，而不是思考如何跟机器打交道。 </p>\n</li>\n</ol>\n<h3 id=\"哪些代码看似面向对象，实际面向过程？\"><a href=\"#哪些代码看似面向对象，实际面向过程？\" class=\"headerlink\" title=\"哪些代码看似面向对象，实际面向过程？\"></a>哪些代码看似面向对象，实际面向过程？</h3><ol>\n<li><p>滥用getter，setter方法，破坏封装</p>\n</li>\n<li><p>滥用全局变量和全局方法,如Constants类、Utils类的设计问题。尽量细化成小类，如果能将这些类的属性和方法，划分到其他业务类中，能更好的提高类的内聚性和可复用性.</p>\n</li>\n<li><p>基于贫血模型的开发模式。数据和操作是分开定义在VO/BO/Entity 和 Controller/Service/Repository中的。</p>\n</li>\n</ol>"},{"title":"设计模式之美--设计模式原则","date":"2020-02-06T14:49:22.000Z","_content":"\n### 单一职责原则（SRP）\n\n单一职责，全称为Single Responsibility Principle。单一职责，顾名思义，就是让一个类只负责一个职责或者功能。\n那么，如何判定是否职责单一呢？不同的业务场景下，对同一类的职责是否单一可能有不同的判定结果。可以从一下几个方面来判断。\n\n<!-- more -->\n\n1. 类中函数或者属性过多\n2. 类中依赖其他类过多，或者依赖类的其他类过多\n3. 私有方法过多\n4. 比较难给类起一个合适的名字\n5. 类中有大量方法都是集中在类的某几个属性\n\n### 开闭原则（OCP）\n\n开闭原则的英文全称是 Open Closed Principle，即对拓展开放，对修改关闭\n如何判定拓展还是修改？新增加一个功能，是在原有的代码基础上扩展代码，而非修改原有代码。\n这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。\n\n基于接口或抽象实现“封闭”，基于实现接口或继承实现“开放”。\n\n场景一：函数存在多个入参的时候，需要新增的入参需求。\n可以将其重构为单独类。那只需要新加属性而不用改动函数入参。\n场景二：对于其分支判断，另外拆分为各个hander。对抽象类进行继承重写。\n","source":"_posts/设计模式/设计模式之设计模式原则.md","raw":"---\ntitle: 设计模式之美--设计模式原则\ndate: 2020-02-06 22:49:22\ntags:\n- 心法\ncategories: 设计模式\n---\n\n### 单一职责原则（SRP）\n\n单一职责，全称为Single Responsibility Principle。单一职责，顾名思义，就是让一个类只负责一个职责或者功能。\n那么，如何判定是否职责单一呢？不同的业务场景下，对同一类的职责是否单一可能有不同的判定结果。可以从一下几个方面来判断。\n\n<!-- more -->\n\n1. 类中函数或者属性过多\n2. 类中依赖其他类过多，或者依赖类的其他类过多\n3. 私有方法过多\n4. 比较难给类起一个合适的名字\n5. 类中有大量方法都是集中在类的某几个属性\n\n### 开闭原则（OCP）\n\n开闭原则的英文全称是 Open Closed Principle，即对拓展开放，对修改关闭\n如何判定拓展还是修改？新增加一个功能，是在原有的代码基础上扩展代码，而非修改原有代码。\n这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。\n\n基于接口或抽象实现“封闭”，基于实现接口或继承实现“开放”。\n\n场景一：函数存在多个入参的时候，需要新增的入参需求。\n可以将其重构为单独类。那只需要新加属性而不用改动函数入参。\n场景二：对于其分支判断，另外拆分为各个hander。对抽象类进行继承重写。\n","slug":"设计模式/设计模式之设计模式原则","published":1,"updated":"2020-02-06T15:15:41.444Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxj004w4l3ngk2qfjjd","content":"<h3 id=\"单一职责原则（SRP）\"><a href=\"#单一职责原则（SRP）\" class=\"headerlink\" title=\"单一职责原则（SRP）\"></a>单一职责原则（SRP）</h3><p>单一职责，全称为Single Responsibility Principle。单一职责，顾名思义，就是让一个类只负责一个职责或者功能。<br>那么，如何判定是否职责单一呢？不同的业务场景下，对同一类的职责是否单一可能有不同的判定结果。可以从一下几个方面来判断。</p>\n<a id=\"more\"></a>\n<ol>\n<li>类中函数或者属性过多</li>\n<li>类中依赖其他类过多，或者依赖类的其他类过多</li>\n<li>私有方法过多</li>\n<li>比较难给类起一个合适的名字</li>\n<li>类中有大量方法都是集中在类的某几个属性</li>\n</ol>\n<h3 id=\"开闭原则（OCP）\"><a href=\"#开闭原则（OCP）\" class=\"headerlink\" title=\"开闭原则（OCP）\"></a>开闭原则（OCP）</h3><p>开闭原则的英文全称是 Open Closed Principle，即对拓展开放，对修改关闭<br>如何判定拓展还是修改？新增加一个功能，是在原有的代码基础上扩展代码，而非修改原有代码。<br>这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。</p>\n<p>基于接口或抽象实现“封闭”，基于实现接口或继承实现“开放”。</p>\n<p>场景一：函数存在多个入参的时候，需要新增的入参需求。<br>可以将其重构为单独类。那只需要新加属性而不用改动函数入参。<br>场景二：对于其分支判断，另外拆分为各个hander。对抽象类进行继承重写。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"单一职责原则（SRP）\"><a href=\"#单一职责原则（SRP）\" class=\"headerlink\" title=\"单一职责原则（SRP）\"></a>单一职责原则（SRP）</h3><p>单一职责，全称为Single Responsibility Principle。单一职责，顾名思义，就是让一个类只负责一个职责或者功能。<br>那么，如何判定是否职责单一呢？不同的业务场景下，对同一类的职责是否单一可能有不同的判定结果。可以从一下几个方面来判断。</p>","more":"<ol>\n<li>类中函数或者属性过多</li>\n<li>类中依赖其他类过多，或者依赖类的其他类过多</li>\n<li>私有方法过多</li>\n<li>比较难给类起一个合适的名字</li>\n<li>类中有大量方法都是集中在类的某几个属性</li>\n</ol>\n<h3 id=\"开闭原则（OCP）\"><a href=\"#开闭原则（OCP）\" class=\"headerlink\" title=\"开闭原则（OCP）\"></a>开闭原则（OCP）</h3><p>开闭原则的英文全称是 Open Closed Principle，即对拓展开放，对修改关闭<br>如何判定拓展还是修改？新增加一个功能，是在原有的代码基础上扩展代码，而非修改原有代码。<br>这条原则的设计初衷：只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。</p>\n<p>基于接口或抽象实现“封闭”，基于实现接口或继承实现“开放”。</p>\n<p>场景一：函数存在多个入参的时候，需要新增的入参需求。<br>可以将其重构为单独类。那只需要新加属性而不用改动函数入参。<br>场景二：对于其分支判断，另外拆分为各个hander。对抽象类进行继承重写。</p>"},{"title":"通向自由之路(1)起步篇","date":"2016-08-30T02:22:50.000Z","_content":"\n之所以取这个名字，是因为想写一个系列博客来记录一些技术之外的所学所得。\n<!-- more -->\n## 什么是自由\n\n以前傻乎乎的认为自由就是想做啥做啥，无拘无束。却发现这样做导致的结果却是懒散，是一种对以后的自己的不负责。尽管自由，可没有目标，盲目而又原始。\n\n最近一直在坚持做keep锻炼，看到一句话很受鼓舞，`自律给我自由`。才发现只有先实现自律才会有自由。当一个人缺乏自律的时候，他做的事总是在受习惯和即时诱惑所影响，要么就是被他人的思想观念所扰，几乎永远都在推迟去做内心真正所渴望的事。也正是自律，给了你心底的驱动力。\n\n## 我渴望的自由\n\n在我浅薄的认知下，我所渴望的自由有几个方面。\n\n一是实现财务自由，即收入能够抵过日常支出，且资产在一定安全界限内。\n\n二是实现深度践行。`古人学问无遗力，少壮工夫老始成。纸上得来终觉浅，绝知此事须躬行。`将所学的思想和道理应用到实际生活中，并升级自己的操作系统。尽管每天都在做这样的事，不过总觉得自己做的浅薄，总是在纸上谈兵，浅尝辄止。\n\n暂时想到这两点。\n\n## 通向自由之路\n\n最近花了一部分自己的闲钱订阅了李笑来老师在得到APP上的专栏：`通往财富自由之路`。说起李笑来老师，自从开始看他的作品，使我开始重新意识到自我这个层面了。以前很少去思考自我的认知，看完《把时间当做朋友》意识到升级自己的操作系统的重要性。一直觉得开源免费才是王道的我，也开始意识到我花钱买到的不仅仅是每次的订阅内容，还是一次对自己的提升，对知识的尊重，更是在帮你过滤掉无用信息，发现精华所在，也是免费这个鱼龙混杂所不能达到之处。我甚至成为了笑来老师的`迷弟`。这个专栏我开通主要是想记录这个订阅号里的内容。毕竟道理这种东西，说的再多也没有用，貌似理解了却实际上左耳进右耳出是最普遍的现象。践行，才是根本。\n\n## 一个更源头的问题\n\n在谈财富自由之前，谈一下一个更加源头的问题。\n\n有些目标，比如眼前这个金光闪闪的“财富自由”。我们明明感觉自己为之使出了浑身气力，但为什么这么多年过去，却没有以我们期望的速度向他靠近呢？\n\n笑来老师于是提到了一个这样的例子：\n>我要变得很牛逼。\n\n可至于怎么样才算牛逼，却卡壳了。\n\n正是因为这种尴尬，反映出绝大多数人在追求某个东西的时候，可能连那个东西的定义都不清楚。因为你一直在做无头苍蝇似的飞行，你连你要的究竟是什么都不知道。\n\n语言学家告诉我们，**如果我们的脑子里没有一个概念的话，我们的脑子就倾向于不去想那个事情；如果一个民族的语言里空缺某个概念，那么整个民族就倾向于从未想过那个事情。**也就是语言所存在的反向塑造。\n\n如果我们的脑子里一个概念不准确、或者没有准确、正确的定义，那么我们必然没有办法准确，正确的思考下去。\n\n## 找到它的定义\n\n所以，我们要先弄清楚这个定义到底是什么。在维基百科里提到财富自由：\n>财富自由是指你无须为了生活开销而努力为钱工作的状态。简单的说，你的资产产生的被动收入必须至少等于或超过你的日常开支，这是我们大多数人最渴望达到的状态，如果进入这种状态，我们就可以称之为退休或者其他各种名称。\n\n而在之上，笑来老师提到了更精炼的定义：\n\n**所谓的个人财富自由，指的是某个人再也不用为了满足生活必需而出售自己的时间了。**\n\n我们每个人做的所有奋斗的本质，都是让自己出售的时间单价更高。但是人群中的少部分人会对这个概念产生质的飞跃，就是把原来一份的时间，卖出多份。像畅销书作家，老干妈就是这样的人。\n\n## 财富自由不是终点\n\n这个论点又一次刷新了我的观念。笑来老师提到连死亡都不是绝对的终点，有些人死了但是他还活着，依旧在影响着一代代的人。那么，财富自由又怎么会是终点呢？事实上，当你这样想的时候，你基本就没希望获得财富自由了（汗 = =）。因为你的脑子里会产生别的乱七八糟的想法，你的价值观就会产生极大的扭曲。你的每一个选择，都因为错误地认为某个其实不太重要的东西更重要而扭曲。\n\n例如，大多数人常常这样想，**“如果我财富自由了，我就天天打游戏。”**反而会将自己的价值导向所歪曲。你会觉得手头的事情和天天打游戏相比变得不再那么重要。\n进而，厌恶自己手头做的事情。正是这种观念，在使你的生命变得令人生厌，散发恶臭。\n\n在获得财富自由之后，还是会不断做事，专注于成长而不是成功，不管你获得了怎么样的成功，你依旧需要成长。\n\n## 把大脑洗干净\n\n在自己找到一个定义的同时，也正是对自己的一次净化，剔除那些他人错误观念带来的污染，暂称之为洗脑。清晰且正确的概念是一切思考的及时。而衡量一个人是否聪明，几乎可以凝练为这两个条件。有没有足够多清晰、准确、正确的概念；概念之间有没有清晰、准确、正确的联系。\n\n总之，在踏上这条路之前，你要先想清楚，这件事真正的意义是什么。如果你暂时对它有错误的认识，尽早通过洗脑的方式来找到正确的方向。想清楚可以让你在正式跋涉之前事半功倍，不再盲目飞行。","source":"_posts/通向自由之路/通向自由之路(1)起步篇.md","raw":"---\ntitle: 通向自由之路(1)起步篇\ndate: 2016-08-30 10:22:50\ntags: \n- 通向自由之路\ncategories: 反思\n---\n\n之所以取这个名字，是因为想写一个系列博客来记录一些技术之外的所学所得。\n<!-- more -->\n## 什么是自由\n\n以前傻乎乎的认为自由就是想做啥做啥，无拘无束。却发现这样做导致的结果却是懒散，是一种对以后的自己的不负责。尽管自由，可没有目标，盲目而又原始。\n\n最近一直在坚持做keep锻炼，看到一句话很受鼓舞，`自律给我自由`。才发现只有先实现自律才会有自由。当一个人缺乏自律的时候，他做的事总是在受习惯和即时诱惑所影响，要么就是被他人的思想观念所扰，几乎永远都在推迟去做内心真正所渴望的事。也正是自律，给了你心底的驱动力。\n\n## 我渴望的自由\n\n在我浅薄的认知下，我所渴望的自由有几个方面。\n\n一是实现财务自由，即收入能够抵过日常支出，且资产在一定安全界限内。\n\n二是实现深度践行。`古人学问无遗力，少壮工夫老始成。纸上得来终觉浅，绝知此事须躬行。`将所学的思想和道理应用到实际生活中，并升级自己的操作系统。尽管每天都在做这样的事，不过总觉得自己做的浅薄，总是在纸上谈兵，浅尝辄止。\n\n暂时想到这两点。\n\n## 通向自由之路\n\n最近花了一部分自己的闲钱订阅了李笑来老师在得到APP上的专栏：`通往财富自由之路`。说起李笑来老师，自从开始看他的作品，使我开始重新意识到自我这个层面了。以前很少去思考自我的认知，看完《把时间当做朋友》意识到升级自己的操作系统的重要性。一直觉得开源免费才是王道的我，也开始意识到我花钱买到的不仅仅是每次的订阅内容，还是一次对自己的提升，对知识的尊重，更是在帮你过滤掉无用信息，发现精华所在，也是免费这个鱼龙混杂所不能达到之处。我甚至成为了笑来老师的`迷弟`。这个专栏我开通主要是想记录这个订阅号里的内容。毕竟道理这种东西，说的再多也没有用，貌似理解了却实际上左耳进右耳出是最普遍的现象。践行，才是根本。\n\n## 一个更源头的问题\n\n在谈财富自由之前，谈一下一个更加源头的问题。\n\n有些目标，比如眼前这个金光闪闪的“财富自由”。我们明明感觉自己为之使出了浑身气力，但为什么这么多年过去，却没有以我们期望的速度向他靠近呢？\n\n笑来老师于是提到了一个这样的例子：\n>我要变得很牛逼。\n\n可至于怎么样才算牛逼，却卡壳了。\n\n正是因为这种尴尬，反映出绝大多数人在追求某个东西的时候，可能连那个东西的定义都不清楚。因为你一直在做无头苍蝇似的飞行，你连你要的究竟是什么都不知道。\n\n语言学家告诉我们，**如果我们的脑子里没有一个概念的话，我们的脑子就倾向于不去想那个事情；如果一个民族的语言里空缺某个概念，那么整个民族就倾向于从未想过那个事情。**也就是语言所存在的反向塑造。\n\n如果我们的脑子里一个概念不准确、或者没有准确、正确的定义，那么我们必然没有办法准确，正确的思考下去。\n\n## 找到它的定义\n\n所以，我们要先弄清楚这个定义到底是什么。在维基百科里提到财富自由：\n>财富自由是指你无须为了生活开销而努力为钱工作的状态。简单的说，你的资产产生的被动收入必须至少等于或超过你的日常开支，这是我们大多数人最渴望达到的状态，如果进入这种状态，我们就可以称之为退休或者其他各种名称。\n\n而在之上，笑来老师提到了更精炼的定义：\n\n**所谓的个人财富自由，指的是某个人再也不用为了满足生活必需而出售自己的时间了。**\n\n我们每个人做的所有奋斗的本质，都是让自己出售的时间单价更高。但是人群中的少部分人会对这个概念产生质的飞跃，就是把原来一份的时间，卖出多份。像畅销书作家，老干妈就是这样的人。\n\n## 财富自由不是终点\n\n这个论点又一次刷新了我的观念。笑来老师提到连死亡都不是绝对的终点，有些人死了但是他还活着，依旧在影响着一代代的人。那么，财富自由又怎么会是终点呢？事实上，当你这样想的时候，你基本就没希望获得财富自由了（汗 = =）。因为你的脑子里会产生别的乱七八糟的想法，你的价值观就会产生极大的扭曲。你的每一个选择，都因为错误地认为某个其实不太重要的东西更重要而扭曲。\n\n例如，大多数人常常这样想，**“如果我财富自由了，我就天天打游戏。”**反而会将自己的价值导向所歪曲。你会觉得手头的事情和天天打游戏相比变得不再那么重要。\n进而，厌恶自己手头做的事情。正是这种观念，在使你的生命变得令人生厌，散发恶臭。\n\n在获得财富自由之后，还是会不断做事，专注于成长而不是成功，不管你获得了怎么样的成功，你依旧需要成长。\n\n## 把大脑洗干净\n\n在自己找到一个定义的同时，也正是对自己的一次净化，剔除那些他人错误观念带来的污染，暂称之为洗脑。清晰且正确的概念是一切思考的及时。而衡量一个人是否聪明，几乎可以凝练为这两个条件。有没有足够多清晰、准确、正确的概念；概念之间有没有清晰、准确、正确的联系。\n\n总之，在踏上这条路之前，你要先想清楚，这件事真正的意义是什么。如果你暂时对它有错误的认识，尽早通过洗脑的方式来找到正确的方向。想清楚可以让你在正式跋涉之前事半功倍，不再盲目飞行。","slug":"通向自由之路/通向自由之路(1)起步篇","published":1,"updated":"2019-03-22T14:44:36.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxk004y4l3ngvovwday","content":"<p>之所以取这个名字，是因为想写一个系列博客来记录一些技术之外的所学所得。<br><a id=\"more\"></a></p>\n<h2 id=\"什么是自由\"><a href=\"#什么是自由\" class=\"headerlink\" title=\"什么是自由\"></a>什么是自由</h2><p>以前傻乎乎的认为自由就是想做啥做啥，无拘无束。却发现这样做导致的结果却是懒散，是一种对以后的自己的不负责。尽管自由，可没有目标，盲目而又原始。</p>\n<p>最近一直在坚持做keep锻炼，看到一句话很受鼓舞，<code>自律给我自由</code>。才发现只有先实现自律才会有自由。当一个人缺乏自律的时候，他做的事总是在受习惯和即时诱惑所影响，要么就是被他人的思想观念所扰，几乎永远都在推迟去做内心真正所渴望的事。也正是自律，给了你心底的驱动力。</p>\n<h2 id=\"我渴望的自由\"><a href=\"#我渴望的自由\" class=\"headerlink\" title=\"我渴望的自由\"></a>我渴望的自由</h2><p>在我浅薄的认知下，我所渴望的自由有几个方面。</p>\n<p>一是实现财务自由，即收入能够抵过日常支出，且资产在一定安全界限内。</p>\n<p>二是实现深度践行。<code>古人学问无遗力，少壮工夫老始成。纸上得来终觉浅，绝知此事须躬行。</code>将所学的思想和道理应用到实际生活中，并升级自己的操作系统。尽管每天都在做这样的事，不过总觉得自己做的浅薄，总是在纸上谈兵，浅尝辄止。</p>\n<p>暂时想到这两点。</p>\n<h2 id=\"通向自由之路\"><a href=\"#通向自由之路\" class=\"headerlink\" title=\"通向自由之路\"></a>通向自由之路</h2><p>最近花了一部分自己的闲钱订阅了李笑来老师在得到APP上的专栏：<code>通往财富自由之路</code>。说起李笑来老师，自从开始看他的作品，使我开始重新意识到自我这个层面了。以前很少去思考自我的认知，看完《把时间当做朋友》意识到升级自己的操作系统的重要性。一直觉得开源免费才是王道的我，也开始意识到我花钱买到的不仅仅是每次的订阅内容，还是一次对自己的提升，对知识的尊重，更是在帮你过滤掉无用信息，发现精华所在，也是免费这个鱼龙混杂所不能达到之处。我甚至成为了笑来老师的<code>迷弟</code>。这个专栏我开通主要是想记录这个订阅号里的内容。毕竟道理这种东西，说的再多也没有用，貌似理解了却实际上左耳进右耳出是最普遍的现象。践行，才是根本。</p>\n<h2 id=\"一个更源头的问题\"><a href=\"#一个更源头的问题\" class=\"headerlink\" title=\"一个更源头的问题\"></a>一个更源头的问题</h2><p>在谈财富自由之前，谈一下一个更加源头的问题。</p>\n<p>有些目标，比如眼前这个金光闪闪的“财富自由”。我们明明感觉自己为之使出了浑身气力，但为什么这么多年过去，却没有以我们期望的速度向他靠近呢？</p>\n<p>笑来老师于是提到了一个这样的例子：</p>\n<blockquote>\n<p>我要变得很牛逼。</p>\n</blockquote>\n<p>可至于怎么样才算牛逼，却卡壳了。</p>\n<p>正是因为这种尴尬，反映出绝大多数人在追求某个东西的时候，可能连那个东西的定义都不清楚。因为你一直在做无头苍蝇似的飞行，你连你要的究竟是什么都不知道。</p>\n<p>语言学家告诉我们，<strong>如果我们的脑子里没有一个概念的话，我们的脑子就倾向于不去想那个事情；如果一个民族的语言里空缺某个概念，那么整个民族就倾向于从未想过那个事情。</strong>也就是语言所存在的反向塑造。</p>\n<p>如果我们的脑子里一个概念不准确、或者没有准确、正确的定义，那么我们必然没有办法准确，正确的思考下去。</p>\n<h2 id=\"找到它的定义\"><a href=\"#找到它的定义\" class=\"headerlink\" title=\"找到它的定义\"></a>找到它的定义</h2><p>所以，我们要先弄清楚这个定义到底是什么。在维基百科里提到财富自由：</p>\n<blockquote>\n<p>财富自由是指你无须为了生活开销而努力为钱工作的状态。简单的说，你的资产产生的被动收入必须至少等于或超过你的日常开支，这是我们大多数人最渴望达到的状态，如果进入这种状态，我们就可以称之为退休或者其他各种名称。</p>\n</blockquote>\n<p>而在之上，笑来老师提到了更精炼的定义：</p>\n<p><strong>所谓的个人财富自由，指的是某个人再也不用为了满足生活必需而出售自己的时间了。</strong></p>\n<p>我们每个人做的所有奋斗的本质，都是让自己出售的时间单价更高。但是人群中的少部分人会对这个概念产生质的飞跃，就是把原来一份的时间，卖出多份。像畅销书作家，老干妈就是这样的人。</p>\n<h2 id=\"财富自由不是终点\"><a href=\"#财富自由不是终点\" class=\"headerlink\" title=\"财富自由不是终点\"></a>财富自由不是终点</h2><p>这个论点又一次刷新了我的观念。笑来老师提到连死亡都不是绝对的终点，有些人死了但是他还活着，依旧在影响着一代代的人。那么，财富自由又怎么会是终点呢？事实上，当你这样想的时候，你基本就没希望获得财富自由了（汗 = =）。因为你的脑子里会产生别的乱七八糟的想法，你的价值观就会产生极大的扭曲。你的每一个选择，都因为错误地认为某个其实不太重要的东西更重要而扭曲。</p>\n<p>例如，大多数人常常这样想，<strong>“如果我财富自由了，我就天天打游戏。”</strong>反而会将自己的价值导向所歪曲。你会觉得手头的事情和天天打游戏相比变得不再那么重要。<br>进而，厌恶自己手头做的事情。正是这种观念，在使你的生命变得令人生厌，散发恶臭。</p>\n<p>在获得财富自由之后，还是会不断做事，专注于成长而不是成功，不管你获得了怎么样的成功，你依旧需要成长。</p>\n<h2 id=\"把大脑洗干净\"><a href=\"#把大脑洗干净\" class=\"headerlink\" title=\"把大脑洗干净\"></a>把大脑洗干净</h2><p>在自己找到一个定义的同时，也正是对自己的一次净化，剔除那些他人错误观念带来的污染，暂称之为洗脑。清晰且正确的概念是一切思考的及时。而衡量一个人是否聪明，几乎可以凝练为这两个条件。有没有足够多清晰、准确、正确的概念；概念之间有没有清晰、准确、正确的联系。</p>\n<p>总之，在踏上这条路之前，你要先想清楚，这件事真正的意义是什么。如果你暂时对它有错误的认识，尽早通过洗脑的方式来找到正确的方向。想清楚可以让你在正式跋涉之前事半功倍，不再盲目飞行。</p>\n","site":{"data":{}},"excerpt":"<p>之所以取这个名字，是因为想写一个系列博客来记录一些技术之外的所学所得。<br></p>","more":"<p></p>\n<h2 id=\"什么是自由\"><a href=\"#什么是自由\" class=\"headerlink\" title=\"什么是自由\"></a>什么是自由</h2><p>以前傻乎乎的认为自由就是想做啥做啥，无拘无束。却发现这样做导致的结果却是懒散，是一种对以后的自己的不负责。尽管自由，可没有目标，盲目而又原始。</p>\n<p>最近一直在坚持做keep锻炼，看到一句话很受鼓舞，<code>自律给我自由</code>。才发现只有先实现自律才会有自由。当一个人缺乏自律的时候，他做的事总是在受习惯和即时诱惑所影响，要么就是被他人的思想观念所扰，几乎永远都在推迟去做内心真正所渴望的事。也正是自律，给了你心底的驱动力。</p>\n<h2 id=\"我渴望的自由\"><a href=\"#我渴望的自由\" class=\"headerlink\" title=\"我渴望的自由\"></a>我渴望的自由</h2><p>在我浅薄的认知下，我所渴望的自由有几个方面。</p>\n<p>一是实现财务自由，即收入能够抵过日常支出，且资产在一定安全界限内。</p>\n<p>二是实现深度践行。<code>古人学问无遗力，少壮工夫老始成。纸上得来终觉浅，绝知此事须躬行。</code>将所学的思想和道理应用到实际生活中，并升级自己的操作系统。尽管每天都在做这样的事，不过总觉得自己做的浅薄，总是在纸上谈兵，浅尝辄止。</p>\n<p>暂时想到这两点。</p>\n<h2 id=\"通向自由之路\"><a href=\"#通向自由之路\" class=\"headerlink\" title=\"通向自由之路\"></a>通向自由之路</h2><p>最近花了一部分自己的闲钱订阅了李笑来老师在得到APP上的专栏：<code>通往财富自由之路</code>。说起李笑来老师，自从开始看他的作品，使我开始重新意识到自我这个层面了。以前很少去思考自我的认知，看完《把时间当做朋友》意识到升级自己的操作系统的重要性。一直觉得开源免费才是王道的我，也开始意识到我花钱买到的不仅仅是每次的订阅内容，还是一次对自己的提升，对知识的尊重，更是在帮你过滤掉无用信息，发现精华所在，也是免费这个鱼龙混杂所不能达到之处。我甚至成为了笑来老师的<code>迷弟</code>。这个专栏我开通主要是想记录这个订阅号里的内容。毕竟道理这种东西，说的再多也没有用，貌似理解了却实际上左耳进右耳出是最普遍的现象。践行，才是根本。</p>\n<h2 id=\"一个更源头的问题\"><a href=\"#一个更源头的问题\" class=\"headerlink\" title=\"一个更源头的问题\"></a>一个更源头的问题</h2><p>在谈财富自由之前，谈一下一个更加源头的问题。</p>\n<p>有些目标，比如眼前这个金光闪闪的“财富自由”。我们明明感觉自己为之使出了浑身气力，但为什么这么多年过去，却没有以我们期望的速度向他靠近呢？</p>\n<p>笑来老师于是提到了一个这样的例子：</p>\n<blockquote>\n<p>我要变得很牛逼。</p>\n</blockquote>\n<p>可至于怎么样才算牛逼，却卡壳了。</p>\n<p>正是因为这种尴尬，反映出绝大多数人在追求某个东西的时候，可能连那个东西的定义都不清楚。因为你一直在做无头苍蝇似的飞行，你连你要的究竟是什么都不知道。</p>\n<p>语言学家告诉我们，<strong>如果我们的脑子里没有一个概念的话，我们的脑子就倾向于不去想那个事情；如果一个民族的语言里空缺某个概念，那么整个民族就倾向于从未想过那个事情。</strong>也就是语言所存在的反向塑造。</p>\n<p>如果我们的脑子里一个概念不准确、或者没有准确、正确的定义，那么我们必然没有办法准确，正确的思考下去。</p>\n<h2 id=\"找到它的定义\"><a href=\"#找到它的定义\" class=\"headerlink\" title=\"找到它的定义\"></a>找到它的定义</h2><p>所以，我们要先弄清楚这个定义到底是什么。在维基百科里提到财富自由：</p>\n<blockquote>\n<p>财富自由是指你无须为了生活开销而努力为钱工作的状态。简单的说，你的资产产生的被动收入必须至少等于或超过你的日常开支，这是我们大多数人最渴望达到的状态，如果进入这种状态，我们就可以称之为退休或者其他各种名称。</p>\n</blockquote>\n<p>而在之上，笑来老师提到了更精炼的定义：</p>\n<p><strong>所谓的个人财富自由，指的是某个人再也不用为了满足生活必需而出售自己的时间了。</strong></p>\n<p>我们每个人做的所有奋斗的本质，都是让自己出售的时间单价更高。但是人群中的少部分人会对这个概念产生质的飞跃，就是把原来一份的时间，卖出多份。像畅销书作家，老干妈就是这样的人。</p>\n<h2 id=\"财富自由不是终点\"><a href=\"#财富自由不是终点\" class=\"headerlink\" title=\"财富自由不是终点\"></a>财富自由不是终点</h2><p>这个论点又一次刷新了我的观念。笑来老师提到连死亡都不是绝对的终点，有些人死了但是他还活着，依旧在影响着一代代的人。那么，财富自由又怎么会是终点呢？事实上，当你这样想的时候，你基本就没希望获得财富自由了（汗 = =）。因为你的脑子里会产生别的乱七八糟的想法，你的价值观就会产生极大的扭曲。你的每一个选择，都因为错误地认为某个其实不太重要的东西更重要而扭曲。</p>\n<p>例如，大多数人常常这样想，<strong>“如果我财富自由了，我就天天打游戏。”</strong>反而会将自己的价值导向所歪曲。你会觉得手头的事情和天天打游戏相比变得不再那么重要。<br>进而，厌恶自己手头做的事情。正是这种观念，在使你的生命变得令人生厌，散发恶臭。</p>\n<p>在获得财富自由之后，还是会不断做事，专注于成长而不是成功，不管你获得了怎么样的成功，你依旧需要成长。</p>\n<h2 id=\"把大脑洗干净\"><a href=\"#把大脑洗干净\" class=\"headerlink\" title=\"把大脑洗干净\"></a>把大脑洗干净</h2><p>在自己找到一个定义的同时，也正是对自己的一次净化，剔除那些他人错误观念带来的污染，暂称之为洗脑。清晰且正确的概念是一切思考的及时。而衡量一个人是否聪明，几乎可以凝练为这两个条件。有没有足够多清晰、准确、正确的概念；概念之间有没有清晰、准确、正确的联系。</p>\n<p>总之，在踏上这条路之前，你要先想清楚，这件事真正的意义是什么。如果你暂时对它有错误的认识，尽早通过洗脑的方式来找到正确的方向。想清楚可以让你在正式跋涉之前事半功倍，不再盲目飞行。</p>"},{"title":"通向自由之路(2)资本篇","date":"2016-09-06T08:06:50.000Z","_content":"\n继续来讲笑来老师的自由之路。这次先跳过前面没补上的，先跟上进度，看看这一个太重要的概念:资本。\n\n## 资本和资金的区别\n\n举个例子，房子确实使用砖头造的，但，仅仅一堆砖头摆在那里肯定算不上房子。同理，资本确实是由钱构成的，但一堆钱放在那里肯定算不上资本。\n\n那么，资本和资金的区别到底在哪呢？资金需要哪些要素才能配得上被称为资本呢？\n<!-- more -->\n1.资金的金额大小\n2.资金的使用时限\n3.资金背后的智慧\n\n同样的钱，在不同人手里，会发挥不同的威力。当然，有一个更加残酷的事实就是：\n\n>大多数人其实不配站在资本之后。\n\n尽管是笑来老师，也花了很大力气很长时间才勉强觉得自己可以站在资本之后。\n\n好消息是，那种站在资本之后的实力是可以习得的。习得的方法，是从各个维度逐步循环突破。\n## 真正在乎的应该是相对值\n第一个要突破的并不是金额——这也是绝大多数人止步不前的根本陷阱。\n\n其实，投资的重点并不在于盈亏绝对值的大小，而是在于盈亏比例的大小。\n**把焦点放在盈亏比例上（相对值），而不是在于本金上（绝对值）**，是90% 的投资者终生都没有学会的东西。\n\n很多人的成长都死在了相互比较上。不论起点的绝对值是多少，你相对于你自己的起点永远都是一样的。\n\n还记得复利公式么？\n```\n（1+r）^n\n```\n我们大家每天都是站在自己的起点上向前迈出一小步，不论这一小步有多小，只要他对于你是进步就足够了。\n\n在这方面使用“相对视角”，可以为自己屏蔽掉很多不必要的麻烦。因为别人已经领先了，而放弃自己的成长，相当愚蠢。\n\n## 给资产判一个“无期”\n第二个要突破的，也是最重要的：\n\n**能不能给自己的投资款“判上一个无期徒刑”。**\n\n心理学家研究表明，大约2/3以上的人在丢失了自己年收入百分之10的话，其实根本不会影响生活质量。\n\n**不能心平气和地被判上无期徒刑的资金，就别假装资本混迹江湖了......**\n\n投资知识、经验、智慧，几乎只能从实战中获得——书上所写的、牛人所讲的、都和你没关系，因为只有那些东西在你的骨子里生根之后再发芽且不夭折而后还要等上很久才会茁壮甚至茂盛，\n\n千万别不相信这个漫长的过程不可或缺，这不是聪明可以跨越的。就好像生孩子一样，没有什么东西可以帮你凭空跨越那段经历。\n\n获取财富的诀窍之一就是不冒险。\n\n如果投资的金额超过一定比例，绝大数人都没有办法做到彻底的淡定。如果这一部分是动辄要去救急的资金，你是没有办法给它判上无期徒刑的。换言之，我们能长期不去理会的资金，一定是那些“丢了也无所谓”的闲钱。\n\n## 资本背后的智慧\n\n我知道你现在可能会觉得“无期徒刑”既残酷又没必要——可这就是你要习得的智慧：**挣扎着学会分的清楚“很想要却不能够”与“可以却不一定要”之间的巨大区别。**这就好像一个人已经拿到大学录取通知书之后竟然不去，和他其实并没有拿到录取通知书却声称“我根本不想去”，这根本就是两码事吧？就相当于你给你的资金判个无期徒刑然后最终却选择在两年之后就结束他的无期徒刑，和你其实没办法给你的资金判一个无期徒刑但最终也做到两年后结束它的刑期，即便结果是一样的，这其中也是有巨大差异的——这不仅仅会影响你的大脑工作方式，而不仅仅是思考质量这么简单。\n\n无论是工作还是学习，总有一群人比别人更加出色。\n\n除去所谓的能力差异，这群人还有一个特质：\n\n**他们通常会主动选择。**\n\n\n顺带说，你现在应该明白为什么“借钱投资”在大多数情况下是胜算渺茫了罢？\n\n1.金额甚至算不上太小，那其实干脆是负数。\n2.时限总是不够长，反正不能判上个无期徒刑。\n3.连以上两个问题都想不到，那脑筋根本不配站在资本之后。\n\n如此看来，这三点关键点就是突破所在。而接下来要做的，便是践行了。\n\n可能接下来，要做的就是要好好审视一下自己手中的钱了。确实，概念才是我们做对事情的前提。\n\n**做对的事情，比把事情做对更加重要。**\n\n如果你从根本概念上就出现了偏差，那坑内越勤奋离目标就越远。\n\n准确的说，我们每天做的都是投资。一天过得好或不好，时间都会过去，所以大部分人也就习惯性地忽略了这一点。\n但是真金白银的投资能让你看到更明显的损失。从这一点的反馈，就足以提醒你：\n\n>我可能真的不会投资。\n\n在这种残酷的环境下学到的知识，其实可以应用到生活的各个领域，比如你的注意力如何投资。\n\n人生三大坑其中就有：**火急火燎地随大流。**越是大家都火急火燎的时候，越是考验你耐心的时候。\n\n耐心这种事情真的是需要平时锻炼，也只能在平时锻炼。看穿表象认清实质，从来就是只有少数人才能做到的事情，别着急，慢慢练，早晚有一天你会自己想明白你看到的现象背后究竟有些什么。\n\n这个世界上不存在“错过的机会”，如果你没准备好，那么那些所谓的机会并不属于你。\n如果你准备好了，你会发现原本在别人眼里称不上机会的事情，都有可能成为你的机遇。\n\n走好每一步，时长回顾之前的知识，将每个概念刻在自己的脑子里。只有这样我们才能结结实实地改变自己的处境。\n\n接下来好好思考一下罢，更好的投资自己。\n\n","source":"_posts/通向自由之路/通向自由之路(2)资本篇.md","raw":"---\ntitle: 通向自由之路(2)资本篇\ndate: 2016-09-06 16:06:50\ntags: \n- 通向自由之路\ncategories: 反思\n---\n\n继续来讲笑来老师的自由之路。这次先跳过前面没补上的，先跟上进度，看看这一个太重要的概念:资本。\n\n## 资本和资金的区别\n\n举个例子，房子确实使用砖头造的，但，仅仅一堆砖头摆在那里肯定算不上房子。同理，资本确实是由钱构成的，但一堆钱放在那里肯定算不上资本。\n\n那么，资本和资金的区别到底在哪呢？资金需要哪些要素才能配得上被称为资本呢？\n<!-- more -->\n1.资金的金额大小\n2.资金的使用时限\n3.资金背后的智慧\n\n同样的钱，在不同人手里，会发挥不同的威力。当然，有一个更加残酷的事实就是：\n\n>大多数人其实不配站在资本之后。\n\n尽管是笑来老师，也花了很大力气很长时间才勉强觉得自己可以站在资本之后。\n\n好消息是，那种站在资本之后的实力是可以习得的。习得的方法，是从各个维度逐步循环突破。\n## 真正在乎的应该是相对值\n第一个要突破的并不是金额——这也是绝大多数人止步不前的根本陷阱。\n\n其实，投资的重点并不在于盈亏绝对值的大小，而是在于盈亏比例的大小。\n**把焦点放在盈亏比例上（相对值），而不是在于本金上（绝对值）**，是90% 的投资者终生都没有学会的东西。\n\n很多人的成长都死在了相互比较上。不论起点的绝对值是多少，你相对于你自己的起点永远都是一样的。\n\n还记得复利公式么？\n```\n（1+r）^n\n```\n我们大家每天都是站在自己的起点上向前迈出一小步，不论这一小步有多小，只要他对于你是进步就足够了。\n\n在这方面使用“相对视角”，可以为自己屏蔽掉很多不必要的麻烦。因为别人已经领先了，而放弃自己的成长，相当愚蠢。\n\n## 给资产判一个“无期”\n第二个要突破的，也是最重要的：\n\n**能不能给自己的投资款“判上一个无期徒刑”。**\n\n心理学家研究表明，大约2/3以上的人在丢失了自己年收入百分之10的话，其实根本不会影响生活质量。\n\n**不能心平气和地被判上无期徒刑的资金，就别假装资本混迹江湖了......**\n\n投资知识、经验、智慧，几乎只能从实战中获得——书上所写的、牛人所讲的、都和你没关系，因为只有那些东西在你的骨子里生根之后再发芽且不夭折而后还要等上很久才会茁壮甚至茂盛，\n\n千万别不相信这个漫长的过程不可或缺，这不是聪明可以跨越的。就好像生孩子一样，没有什么东西可以帮你凭空跨越那段经历。\n\n获取财富的诀窍之一就是不冒险。\n\n如果投资的金额超过一定比例，绝大数人都没有办法做到彻底的淡定。如果这一部分是动辄要去救急的资金，你是没有办法给它判上无期徒刑的。换言之，我们能长期不去理会的资金，一定是那些“丢了也无所谓”的闲钱。\n\n## 资本背后的智慧\n\n我知道你现在可能会觉得“无期徒刑”既残酷又没必要——可这就是你要习得的智慧：**挣扎着学会分的清楚“很想要却不能够”与“可以却不一定要”之间的巨大区别。**这就好像一个人已经拿到大学录取通知书之后竟然不去，和他其实并没有拿到录取通知书却声称“我根本不想去”，这根本就是两码事吧？就相当于你给你的资金判个无期徒刑然后最终却选择在两年之后就结束他的无期徒刑，和你其实没办法给你的资金判一个无期徒刑但最终也做到两年后结束它的刑期，即便结果是一样的，这其中也是有巨大差异的——这不仅仅会影响你的大脑工作方式，而不仅仅是思考质量这么简单。\n\n无论是工作还是学习，总有一群人比别人更加出色。\n\n除去所谓的能力差异，这群人还有一个特质：\n\n**他们通常会主动选择。**\n\n\n顺带说，你现在应该明白为什么“借钱投资”在大多数情况下是胜算渺茫了罢？\n\n1.金额甚至算不上太小，那其实干脆是负数。\n2.时限总是不够长，反正不能判上个无期徒刑。\n3.连以上两个问题都想不到，那脑筋根本不配站在资本之后。\n\n如此看来，这三点关键点就是突破所在。而接下来要做的，便是践行了。\n\n可能接下来，要做的就是要好好审视一下自己手中的钱了。确实，概念才是我们做对事情的前提。\n\n**做对的事情，比把事情做对更加重要。**\n\n如果你从根本概念上就出现了偏差，那坑内越勤奋离目标就越远。\n\n准确的说，我们每天做的都是投资。一天过得好或不好，时间都会过去，所以大部分人也就习惯性地忽略了这一点。\n但是真金白银的投资能让你看到更明显的损失。从这一点的反馈，就足以提醒你：\n\n>我可能真的不会投资。\n\n在这种残酷的环境下学到的知识，其实可以应用到生活的各个领域，比如你的注意力如何投资。\n\n人生三大坑其中就有：**火急火燎地随大流。**越是大家都火急火燎的时候，越是考验你耐心的时候。\n\n耐心这种事情真的是需要平时锻炼，也只能在平时锻炼。看穿表象认清实质，从来就是只有少数人才能做到的事情，别着急，慢慢练，早晚有一天你会自己想明白你看到的现象背后究竟有些什么。\n\n这个世界上不存在“错过的机会”，如果你没准备好，那么那些所谓的机会并不属于你。\n如果你准备好了，你会发现原本在别人眼里称不上机会的事情，都有可能成为你的机遇。\n\n走好每一步，时长回顾之前的知识，将每个概念刻在自己的脑子里。只有这样我们才能结结实实地改变自己的处境。\n\n接下来好好思考一下罢，更好的投资自己。\n\n","slug":"通向自由之路/通向自由之路(2)资本篇","published":1,"updated":"2019-03-22T14:44:36.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxl00524l3n1gaohfpf","content":"<p>继续来讲笑来老师的自由之路。这次先跳过前面没补上的，先跟上进度，看看这一个太重要的概念:资本。</p>\n<h2 id=\"资本和资金的区别\"><a href=\"#资本和资金的区别\" class=\"headerlink\" title=\"资本和资金的区别\"></a>资本和资金的区别</h2><p>举个例子，房子确实使用砖头造的，但，仅仅一堆砖头摆在那里肯定算不上房子。同理，资本确实是由钱构成的，但一堆钱放在那里肯定算不上资本。</p>\n<p>那么，资本和资金的区别到底在哪呢？资金需要哪些要素才能配得上被称为资本呢？<br><a id=\"more\"></a><br>1.资金的金额大小<br>2.资金的使用时限<br>3.资金背后的智慧</p>\n<p>同样的钱，在不同人手里，会发挥不同的威力。当然，有一个更加残酷的事实就是：</p>\n<blockquote>\n<p>大多数人其实不配站在资本之后。</p>\n</blockquote>\n<p>尽管是笑来老师，也花了很大力气很长时间才勉强觉得自己可以站在资本之后。</p>\n<p>好消息是，那种站在资本之后的实力是可以习得的。习得的方法，是从各个维度逐步循环突破。</p>\n<h2 id=\"真正在乎的应该是相对值\"><a href=\"#真正在乎的应该是相对值\" class=\"headerlink\" title=\"真正在乎的应该是相对值\"></a>真正在乎的应该是相对值</h2><p>第一个要突破的并不是金额——这也是绝大多数人止步不前的根本陷阱。</p>\n<p>其实，投资的重点并不在于盈亏绝对值的大小，而是在于盈亏比例的大小。<br><strong>把焦点放在盈亏比例上（相对值），而不是在于本金上（绝对值）</strong>，是90% 的投资者终生都没有学会的东西。</p>\n<p>很多人的成长都死在了相互比较上。不论起点的绝对值是多少，你相对于你自己的起点永远都是一样的。</p>\n<p>还记得复利公式么？<br><figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>+<span class=\"keyword\">r</span>）<span class=\"symbol\">^n</span></span><br></pre></td></tr></table></figure></p>\n<p>我们大家每天都是站在自己的起点上向前迈出一小步，不论这一小步有多小，只要他对于你是进步就足够了。</p>\n<p>在这方面使用“相对视角”，可以为自己屏蔽掉很多不必要的麻烦。因为别人已经领先了，而放弃自己的成长，相当愚蠢。</p>\n<h2 id=\"给资产判一个“无期”\"><a href=\"#给资产判一个“无期”\" class=\"headerlink\" title=\"给资产判一个“无期”\"></a>给资产判一个“无期”</h2><p>第二个要突破的，也是最重要的：</p>\n<p><strong>能不能给自己的投资款“判上一个无期徒刑”。</strong></p>\n<p>心理学家研究表明，大约2/3以上的人在丢失了自己年收入百分之10的话，其实根本不会影响生活质量。</p>\n<p><strong>不能心平气和地被判上无期徒刑的资金，就别假装资本混迹江湖了……</strong></p>\n<p>投资知识、经验、智慧，几乎只能从实战中获得——书上所写的、牛人所讲的、都和你没关系，因为只有那些东西在你的骨子里生根之后再发芽且不夭折而后还要等上很久才会茁壮甚至茂盛，</p>\n<p>千万别不相信这个漫长的过程不可或缺，这不是聪明可以跨越的。就好像生孩子一样，没有什么东西可以帮你凭空跨越那段经历。</p>\n<p>获取财富的诀窍之一就是不冒险。</p>\n<p>如果投资的金额超过一定比例，绝大数人都没有办法做到彻底的淡定。如果这一部分是动辄要去救急的资金，你是没有办法给它判上无期徒刑的。换言之，我们能长期不去理会的资金，一定是那些“丢了也无所谓”的闲钱。</p>\n<h2 id=\"资本背后的智慧\"><a href=\"#资本背后的智慧\" class=\"headerlink\" title=\"资本背后的智慧\"></a>资本背后的智慧</h2><p>我知道你现在可能会觉得“无期徒刑”既残酷又没必要——可这就是你要习得的智慧：<strong>挣扎着学会分的清楚“很想要却不能够”与“可以却不一定要”之间的巨大区别。</strong>这就好像一个人已经拿到大学录取通知书之后竟然不去，和他其实并没有拿到录取通知书却声称“我根本不想去”，这根本就是两码事吧？就相当于你给你的资金判个无期徒刑然后最终却选择在两年之后就结束他的无期徒刑，和你其实没办法给你的资金判一个无期徒刑但最终也做到两年后结束它的刑期，即便结果是一样的，这其中也是有巨大差异的——这不仅仅会影响你的大脑工作方式，而不仅仅是思考质量这么简单。</p>\n<p>无论是工作还是学习，总有一群人比别人更加出色。</p>\n<p>除去所谓的能力差异，这群人还有一个特质：</p>\n<p><strong>他们通常会主动选择。</strong></p>\n<p>顺带说，你现在应该明白为什么“借钱投资”在大多数情况下是胜算渺茫了罢？</p>\n<p>1.金额甚至算不上太小，那其实干脆是负数。<br>2.时限总是不够长，反正不能判上个无期徒刑。<br>3.连以上两个问题都想不到，那脑筋根本不配站在资本之后。</p>\n<p>如此看来，这三点关键点就是突破所在。而接下来要做的，便是践行了。</p>\n<p>可能接下来，要做的就是要好好审视一下自己手中的钱了。确实，概念才是我们做对事情的前提。</p>\n<p><strong>做对的事情，比把事情做对更加重要。</strong></p>\n<p>如果你从根本概念上就出现了偏差，那坑内越勤奋离目标就越远。</p>\n<p>准确的说，我们每天做的都是投资。一天过得好或不好，时间都会过去，所以大部分人也就习惯性地忽略了这一点。<br>但是真金白银的投资能让你看到更明显的损失。从这一点的反馈，就足以提醒你：</p>\n<blockquote>\n<p>我可能真的不会投资。</p>\n</blockquote>\n<p>在这种残酷的环境下学到的知识，其实可以应用到生活的各个领域，比如你的注意力如何投资。</p>\n<p>人生三大坑其中就有：<strong>火急火燎地随大流。</strong>越是大家都火急火燎的时候，越是考验你耐心的时候。</p>\n<p>耐心这种事情真的是需要平时锻炼，也只能在平时锻炼。看穿表象认清实质，从来就是只有少数人才能做到的事情，别着急，慢慢练，早晚有一天你会自己想明白你看到的现象背后究竟有些什么。</p>\n<p>这个世界上不存在“错过的机会”，如果你没准备好，那么那些所谓的机会并不属于你。<br>如果你准备好了，你会发现原本在别人眼里称不上机会的事情，都有可能成为你的机遇。</p>\n<p>走好每一步，时长回顾之前的知识，将每个概念刻在自己的脑子里。只有这样我们才能结结实实地改变自己的处境。</p>\n<p>接下来好好思考一下罢，更好的投资自己。</p>\n","site":{"data":{}},"excerpt":"<p>继续来讲笑来老师的自由之路。这次先跳过前面没补上的，先跟上进度，看看这一个太重要的概念:资本。</p>\n<h2 id=\"资本和资金的区别\"><a href=\"#资本和资金的区别\" class=\"headerlink\" title=\"资本和资金的区别\"></a>资本和资金的区别</h2><p>举个例子，房子确实使用砖头造的，但，仅仅一堆砖头摆在那里肯定算不上房子。同理，资本确实是由钱构成的，但一堆钱放在那里肯定算不上资本。</p>\n<p>那么，资本和资金的区别到底在哪呢？资金需要哪些要素才能配得上被称为资本呢？<br></p>","more":"<br>1.资金的金额大小<br>2.资金的使用时限<br>3.资金背后的智慧<p></p>\n<p>同样的钱，在不同人手里，会发挥不同的威力。当然，有一个更加残酷的事实就是：</p>\n<blockquote>\n<p>大多数人其实不配站在资本之后。</p>\n</blockquote>\n<p>尽管是笑来老师，也花了很大力气很长时间才勉强觉得自己可以站在资本之后。</p>\n<p>好消息是，那种站在资本之后的实力是可以习得的。习得的方法，是从各个维度逐步循环突破。</p>\n<h2 id=\"真正在乎的应该是相对值\"><a href=\"#真正在乎的应该是相对值\" class=\"headerlink\" title=\"真正在乎的应该是相对值\"></a>真正在乎的应该是相对值</h2><p>第一个要突破的并不是金额——这也是绝大多数人止步不前的根本陷阱。</p>\n<p>其实，投资的重点并不在于盈亏绝对值的大小，而是在于盈亏比例的大小。<br><strong>把焦点放在盈亏比例上（相对值），而不是在于本金上（绝对值）</strong>，是90% 的投资者终生都没有学会的东西。</p>\n<p>很多人的成长都死在了相互比较上。不论起点的绝对值是多少，你相对于你自己的起点永远都是一样的。</p>\n<p>还记得复利公式么？<br><figure class=\"highlight cos\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（<span class=\"number\">1</span>+<span class=\"keyword\">r</span>）<span class=\"symbol\">^n</span></span><br></pre></td></tr></table></figure></p>\n<p>我们大家每天都是站在自己的起点上向前迈出一小步，不论这一小步有多小，只要他对于你是进步就足够了。</p>\n<p>在这方面使用“相对视角”，可以为自己屏蔽掉很多不必要的麻烦。因为别人已经领先了，而放弃自己的成长，相当愚蠢。</p>\n<h2 id=\"给资产判一个“无期”\"><a href=\"#给资产判一个“无期”\" class=\"headerlink\" title=\"给资产判一个“无期”\"></a>给资产判一个“无期”</h2><p>第二个要突破的，也是最重要的：</p>\n<p><strong>能不能给自己的投资款“判上一个无期徒刑”。</strong></p>\n<p>心理学家研究表明，大约2/3以上的人在丢失了自己年收入百分之10的话，其实根本不会影响生活质量。</p>\n<p><strong>不能心平气和地被判上无期徒刑的资金，就别假装资本混迹江湖了……</strong></p>\n<p>投资知识、经验、智慧，几乎只能从实战中获得——书上所写的、牛人所讲的、都和你没关系，因为只有那些东西在你的骨子里生根之后再发芽且不夭折而后还要等上很久才会茁壮甚至茂盛，</p>\n<p>千万别不相信这个漫长的过程不可或缺，这不是聪明可以跨越的。就好像生孩子一样，没有什么东西可以帮你凭空跨越那段经历。</p>\n<p>获取财富的诀窍之一就是不冒险。</p>\n<p>如果投资的金额超过一定比例，绝大数人都没有办法做到彻底的淡定。如果这一部分是动辄要去救急的资金，你是没有办法给它判上无期徒刑的。换言之，我们能长期不去理会的资金，一定是那些“丢了也无所谓”的闲钱。</p>\n<h2 id=\"资本背后的智慧\"><a href=\"#资本背后的智慧\" class=\"headerlink\" title=\"资本背后的智慧\"></a>资本背后的智慧</h2><p>我知道你现在可能会觉得“无期徒刑”既残酷又没必要——可这就是你要习得的智慧：<strong>挣扎着学会分的清楚“很想要却不能够”与“可以却不一定要”之间的巨大区别。</strong>这就好像一个人已经拿到大学录取通知书之后竟然不去，和他其实并没有拿到录取通知书却声称“我根本不想去”，这根本就是两码事吧？就相当于你给你的资金判个无期徒刑然后最终却选择在两年之后就结束他的无期徒刑，和你其实没办法给你的资金判一个无期徒刑但最终也做到两年后结束它的刑期，即便结果是一样的，这其中也是有巨大差异的——这不仅仅会影响你的大脑工作方式，而不仅仅是思考质量这么简单。</p>\n<p>无论是工作还是学习，总有一群人比别人更加出色。</p>\n<p>除去所谓的能力差异，这群人还有一个特质：</p>\n<p><strong>他们通常会主动选择。</strong></p>\n<p>顺带说，你现在应该明白为什么“借钱投资”在大多数情况下是胜算渺茫了罢？</p>\n<p>1.金额甚至算不上太小，那其实干脆是负数。<br>2.时限总是不够长，反正不能判上个无期徒刑。<br>3.连以上两个问题都想不到，那脑筋根本不配站在资本之后。</p>\n<p>如此看来，这三点关键点就是突破所在。而接下来要做的，便是践行了。</p>\n<p>可能接下来，要做的就是要好好审视一下自己手中的钱了。确实，概念才是我们做对事情的前提。</p>\n<p><strong>做对的事情，比把事情做对更加重要。</strong></p>\n<p>如果你从根本概念上就出现了偏差，那坑内越勤奋离目标就越远。</p>\n<p>准确的说，我们每天做的都是投资。一天过得好或不好，时间都会过去，所以大部分人也就习惯性地忽略了这一点。<br>但是真金白银的投资能让你看到更明显的损失。从这一点的反馈，就足以提醒你：</p>\n<blockquote>\n<p>我可能真的不会投资。</p>\n</blockquote>\n<p>在这种残酷的环境下学到的知识，其实可以应用到生活的各个领域，比如你的注意力如何投资。</p>\n<p>人生三大坑其中就有：<strong>火急火燎地随大流。</strong>越是大家都火急火燎的时候，越是考验你耐心的时候。</p>\n<p>耐心这种事情真的是需要平时锻炼，也只能在平时锻炼。看穿表象认清实质，从来就是只有少数人才能做到的事情，别着急，慢慢练，早晚有一天你会自己想明白你看到的现象背后究竟有些什么。</p>\n<p>这个世界上不存在“错过的机会”，如果你没准备好，那么那些所谓的机会并不属于你。<br>如果你准备好了，你会发现原本在别人眼里称不上机会的事情，都有可能成为你的机遇。</p>\n<p>走好每一步，时长回顾之前的知识，将每个概念刻在自己的脑子里。只有这样我们才能结结实实地改变自己的处境。</p>\n<p>接下来好好思考一下罢，更好的投资自己。</p>"},{"title":"设计模式之美--面向对象设计原则","date":"2020-02-04T14:49:22.000Z","_content":"\n### 基于接口而非实现编程\n这句话实际表达的是，基于抽象而非实现编程，接口是自上而下的，要有抽象意识，越抽象，越灵活，可拓展，\n定义接口时，命名要足够通用，不包含具体实现相关字眼。\n\n如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口。\n\n<!-- more -->\n\n### 组合优于继承\n\n继承表示的是类之间的`is-a`关系，可以解决代码复用的问题。但是继承层次太深，过于复杂，\n比如，鸟类是否会飞，是否会叫，是否会下蛋等各种行为，都会引出类似纲目科属种这样的继承关系，也将影响到代码的可维护性。\n我们可以通过组合来优化这些问题。这里的组合是组合，接口，委托三种的统称。\n之前我们说过，接口表示某种行为特性。但是接口只声明了方法，没有实现，那每一个实现类都要实现一遍相同逻辑的代码，也会导致代码重复。那如何解决呢？\n我们可以针对接口再定义实现类，来表示拥有这种行为的能力，例如，`Flyable`接口，其实现类可以定义为`FlyAbility`，然后通过组合和委托来消除代码重复。\n例如：\n\n```java\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟 \n    private TweetAbility tweetAbility = new TweetAbility(); //组合\n     private EggLayAbility eggLayAbility = new EggLayAbility(); //组合 \n     //... 省略其他属性和方法... \n     @Override public void tweet() { tweetAbility.tweet(); // 委托 \n     } \n     @Override public void layEgg() { eggLayAbility.layEgg(); // 委托 \n     }\n }\n```\n\n理论上，通过接口，委托和组合就可以完全替换继承，达到简化代码的效果，增加了可维护性。\n\n但其并不完美，我们相应的增加了很多其他的类和接口，在实际开发中，还是要根据实际需求来选择继承，还是组合。\n\n装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。\n\n\n### 领域驱动设计（DDD）\n要讲这个之前先讲讲什么是贫血模型和充血模型。\n贫血模型：只包含数据，不包含业务逻辑；\n充血模型：数据和类都被封装到同一个类中。\n\n领域驱动设计（DDD）是基于充血模型的， 主要用于如何解耦业务系统。划分业务模块，定义业务领域模型以及其交互。\n\n我们所说的复杂系统，更看重业务的复杂度，将复杂度降低的方法则是分而治之。这样可以降低复杂度。\n\n复杂要解决三个问题：规模问题，结构问题和需求变化问题。无论是技术复杂度或业务复杂度，只要能解决这三种复杂度问题就是好的方法。\n\n\n基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。DDD模型其实是将Model层做重。因为业务核心是技术无关的。传统MVC用于C/S模型，也依然是重Model层的。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。\n\n在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类就变得很薄。Service 主要负责于Repository交互，负责跨领域模型的业务聚合。负责非功能性及与第三方系统交互的工作。\n\n","source":"_posts/设计模式/设计模式之设计原则.md","raw":"---\ntitle: 设计模式之美--面向对象设计原则\ndate: 2020-02-04 22:49:22\ntags:\n- 心法\ncategories: 设计模式\n---\n\n### 基于接口而非实现编程\n这句话实际表达的是，基于抽象而非实现编程，接口是自上而下的，要有抽象意识，越抽象，越灵活，可拓展，\n定义接口时，命名要足够通用，不包含具体实现相关字眼。\n\n如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口。\n\n<!-- more -->\n\n### 组合优于继承\n\n继承表示的是类之间的`is-a`关系，可以解决代码复用的问题。但是继承层次太深，过于复杂，\n比如，鸟类是否会飞，是否会叫，是否会下蛋等各种行为，都会引出类似纲目科属种这样的继承关系，也将影响到代码的可维护性。\n我们可以通过组合来优化这些问题。这里的组合是组合，接口，委托三种的统称。\n之前我们说过，接口表示某种行为特性。但是接口只声明了方法，没有实现，那每一个实现类都要实现一遍相同逻辑的代码，也会导致代码重复。那如何解决呢？\n我们可以针对接口再定义实现类，来表示拥有这种行为的能力，例如，`Flyable`接口，其实现类可以定义为`FlyAbility`，然后通过组合和委托来消除代码重复。\n例如：\n\n```java\npublic class Ostrich implements Tweetable, EggLayable {//鸵鸟 \n    private TweetAbility tweetAbility = new TweetAbility(); //组合\n     private EggLayAbility eggLayAbility = new EggLayAbility(); //组合 \n     //... 省略其他属性和方法... \n     @Override public void tweet() { tweetAbility.tweet(); // 委托 \n     } \n     @Override public void layEgg() { eggLayAbility.layEgg(); // 委托 \n     }\n }\n```\n\n理论上，通过接口，委托和组合就可以完全替换继承，达到简化代码的效果，增加了可维护性。\n\n但其并不完美，我们相应的增加了很多其他的类和接口，在实际开发中，还是要根据实际需求来选择继承，还是组合。\n\n装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。\n\n\n### 领域驱动设计（DDD）\n要讲这个之前先讲讲什么是贫血模型和充血模型。\n贫血模型：只包含数据，不包含业务逻辑；\n充血模型：数据和类都被封装到同一个类中。\n\n领域驱动设计（DDD）是基于充血模型的， 主要用于如何解耦业务系统。划分业务模块，定义业务领域模型以及其交互。\n\n我们所说的复杂系统，更看重业务的复杂度，将复杂度降低的方法则是分而治之。这样可以降低复杂度。\n\n复杂要解决三个问题：规模问题，结构问题和需求变化问题。无论是技术复杂度或业务复杂度，只要能解决这三种复杂度问题就是好的方法。\n\n\n基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。DDD模型其实是将Model层做重。因为业务核心是技术无关的。传统MVC用于C/S模型，也依然是重Model层的。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。\n\n在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类就变得很薄。Service 主要负责于Repository交互，负责跨领域模型的业务聚合。负责非功能性及与第三方系统交互的工作。\n\n","slug":"设计模式/设计模式之设计原则","published":1,"updated":"2020-02-06T13:41:08.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxn00544l3nn193pnfd","content":"<h3 id=\"基于接口而非实现编程\"><a href=\"#基于接口而非实现编程\" class=\"headerlink\" title=\"基于接口而非实现编程\"></a>基于接口而非实现编程</h3><p>这句话实际表达的是，基于抽象而非实现编程，接口是自上而下的，要有抽象意识，越抽象，越灵活，可拓展，<br>定义接口时，命名要足够通用，不包含具体实现相关字眼。</p>\n<p>如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口。</p>\n<a id=\"more\"></a>\n<h3 id=\"组合优于继承\"><a href=\"#组合优于继承\" class=\"headerlink\" title=\"组合优于继承\"></a>组合优于继承</h3><p>继承表示的是类之间的<code>is-a</code>关系，可以解决代码复用的问题。但是继承层次太深，过于复杂，<br>比如，鸟类是否会飞，是否会叫，是否会下蛋等各种行为，都会引出类似纲目科属种这样的继承关系，也将影响到代码的可维护性。<br>我们可以通过组合来优化这些问题。这里的组合是组合，接口，委托三种的统称。<br>之前我们说过，接口表示某种行为特性。但是接口只声明了方法，没有实现，那每一个实现类都要实现一遍相同逻辑的代码，也会导致代码重复。那如何解决呢？<br>我们可以针对接口再定义实现类，来表示拥有这种行为的能力，例如，<code>Flyable</code>接口，其实现类可以定义为<code>FlyAbility</code>，然后通过组合和委托来消除代码重复。<br>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title\">Tweetable</span>, <span class=\"title\">EggLayable</span> </span>&#123;<span class=\"comment\">//鸵鸟 </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TweetAbility tweetAbility = <span class=\"keyword\">new</span> TweetAbility(); <span class=\"comment\">//组合</span></span><br><span class=\"line\">     <span class=\"keyword\">private</span> EggLayAbility eggLayAbility = <span class=\"keyword\">new</span> EggLayAbility(); <span class=\"comment\">//组合 </span></span><br><span class=\"line\">     <span class=\"comment\">//... 省略其他属性和方法... </span></span><br><span class=\"line\">     <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tweet</span><span class=\"params\">()</span> </span>&#123; tweetAbility.tweet(); <span class=\"comment\">// 委托 </span></span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layEgg</span><span class=\"params\">()</span> </span>&#123; eggLayAbility.layEgg(); <span class=\"comment\">// 委托 </span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>理论上，通过接口，委托和组合就可以完全替换继承，达到简化代码的效果，增加了可维护性。</p>\n<p>但其并不完美，我们相应的增加了很多其他的类和接口，在实际开发中，还是要根据实际需求来选择继承，还是组合。</p>\n<p>装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</p>\n<h3 id=\"领域驱动设计（DDD）\"><a href=\"#领域驱动设计（DDD）\" class=\"headerlink\" title=\"领域驱动设计（DDD）\"></a>领域驱动设计（DDD）</h3><p>要讲这个之前先讲讲什么是贫血模型和充血模型。<br>贫血模型：只包含数据，不包含业务逻辑；<br>充血模型：数据和类都被封装到同一个类中。</p>\n<p>领域驱动设计（DDD）是基于充血模型的， 主要用于如何解耦业务系统。划分业务模块，定义业务领域模型以及其交互。</p>\n<p>我们所说的复杂系统，更看重业务的复杂度，将复杂度降低的方法则是分而治之。这样可以降低复杂度。</p>\n<p>复杂要解决三个问题：规模问题，结构问题和需求变化问题。无论是技术复杂度或业务复杂度，只要能解决这三种复杂度问题就是好的方法。</p>\n<p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。DDD模型其实是将Model层做重。因为业务核心是技术无关的。传统MVC用于C/S模型，也依然是重Model层的。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。</p>\n<p>在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类就变得很薄。Service 主要负责于Repository交互，负责跨领域模型的业务聚合。负责非功能性及与第三方系统交互的工作。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"基于接口而非实现编程\"><a href=\"#基于接口而非实现编程\" class=\"headerlink\" title=\"基于接口而非实现编程\"></a>基于接口而非实现编程</h3><p>这句话实际表达的是，基于抽象而非实现编程，接口是自上而下的，要有抽象意识，越抽象，越灵活，可拓展，<br>定义接口时，命名要足够通用，不包含具体实现相关字眼。</p>\n<p>如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口。</p>","more":"<h3 id=\"组合优于继承\"><a href=\"#组合优于继承\" class=\"headerlink\" title=\"组合优于继承\"></a>组合优于继承</h3><p>继承表示的是类之间的<code>is-a</code>关系，可以解决代码复用的问题。但是继承层次太深，过于复杂，<br>比如，鸟类是否会飞，是否会叫，是否会下蛋等各种行为，都会引出类似纲目科属种这样的继承关系，也将影响到代码的可维护性。<br>我们可以通过组合来优化这些问题。这里的组合是组合，接口，委托三种的统称。<br>之前我们说过，接口表示某种行为特性。但是接口只声明了方法，没有实现，那每一个实现类都要实现一遍相同逻辑的代码，也会导致代码重复。那如何解决呢？<br>我们可以针对接口再定义实现类，来表示拥有这种行为的能力，例如，<code>Flyable</code>接口，其实现类可以定义为<code>FlyAbility</code>，然后通过组合和委托来消除代码重复。<br>例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Ostrich</span> <span class=\"keyword\">implements</span> <span class=\"title\">Tweetable</span>, <span class=\"title\">EggLayable</span> </span>&#123;<span class=\"comment\">//鸵鸟 </span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TweetAbility tweetAbility = <span class=\"keyword\">new</span> TweetAbility(); <span class=\"comment\">//组合</span></span><br><span class=\"line\">     <span class=\"keyword\">private</span> EggLayAbility eggLayAbility = <span class=\"keyword\">new</span> EggLayAbility(); <span class=\"comment\">//组合 </span></span><br><span class=\"line\">     <span class=\"comment\">//... 省略其他属性和方法... </span></span><br><span class=\"line\">     <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">tweet</span><span class=\"params\">()</span> </span>&#123; tweetAbility.tweet(); <span class=\"comment\">// 委托 </span></span><br><span class=\"line\">     &#125; </span><br><span class=\"line\">     <span class=\"meta\">@Override</span> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">layEgg</span><span class=\"params\">()</span> </span>&#123; eggLayAbility.layEgg(); <span class=\"comment\">// 委托 </span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n<p>理论上，通过接口，委托和组合就可以完全替换继承，达到简化代码的效果，增加了可维护性。</p>\n<p>但其并不完美，我们相应的增加了很多其他的类和接口，在实际开发中，还是要根据实际需求来选择继承，还是组合。</p>\n<p>装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。</p>\n<h3 id=\"领域驱动设计（DDD）\"><a href=\"#领域驱动设计（DDD）\" class=\"headerlink\" title=\"领域驱动设计（DDD）\"></a>领域驱动设计（DDD）</h3><p>要讲这个之前先讲讲什么是贫血模型和充血模型。<br>贫血模型：只包含数据，不包含业务逻辑；<br>充血模型：数据和类都被封装到同一个类中。</p>\n<p>领域驱动设计（DDD）是基于充血模型的， 主要用于如何解耦业务系统。划分业务模块，定义业务领域模型以及其交互。</p>\n<p>我们所说的复杂系统，更看重业务的复杂度，将复杂度降低的方法则是分而治之。这样可以降低复杂度。</p>\n<p>复杂要解决三个问题：规模问题，结构问题和需求变化问题。无论是技术复杂度或业务复杂度，只要能解决这三种复杂度问题就是好的方法。</p>\n<p>基于充血模型的 DDD 开发模式跟基于贫血模型的传统开发模式相比，主要区别在 Service 层。DDD模型其实是将Model层做重。因为业务核心是技术无关的。传统MVC用于C/S模型，也依然是重Model层的。在基于充血模型的开发模式下，我们将部分原来在 Service 类中的业务逻辑移动到了一个充血的 Domain 领域模型中，让 Service 类的实现依赖这个 Domain 类。</p>\n<p>在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类就变得很薄。Service 主要负责于Repository交互，负责跨领域模型的业务聚合。负责非功能性及与第三方系统交互的工作。</p>"},{"title":"通向自由之路(4)多维竞争篇","date":"2016-09-25T02:17:50.000Z","_content":"\n上周谈到了“落后”的话题，自己有许多地方都没有达到20%，甚至焦虑不堪。可笑来老师在文末告诉我们：\n\n>放心，我们一定有办法解决“危机感”所带来的焦虑。\n\n那么，今天来讲讲什么该如何做到。\n<!-- more -->\n从某一个角度上来看，绝大多数人的幸福感是建立在比较的基础上的。很多时候，比较就是一个大坑。比如，为了衡量自己的实力或者竞争力，就要对自己所掌握的技能有充分，深入，真实，客观的判断。虽然大多数人总是过高估计自己的能力，但很少有人对量化的数字产生一丝丝错觉。那些被量化的数字是最无法忽视的，有了可以量化比较数据之后，我们能够更加客观地认识自己。更重要的是我们能实事求是的寻找解决方法，而不是一味的安慰自己。\n\n但是一个很不幸的事实是：\n\n所谓的成长，就是不断把别人比下去的过程。如愿比下去了也倒还好，比不过就非常痛苦——那就意味着自己被比下去了。体育赛事里经常出现银牌得主苦拼十多年还是没有斗过金牌得主，你不妨想象一下，如果你身为那个银牌得主，那一路上不断听到的来自好人的安慰是不是犹如千刀万剐缓慢折磨？\n\n在某个技能上死磕，确实是一个策略，但不是最好的策略。仔细想想还有哪些策略？可生活有许多的维度，有些时候只是转换一下角度，就能有机会找到新的突破口。\n\n比如，“维度”是线性代数的概念，但用它来与自身的能力做一个类比，或许能提供一个新的思路。\n\n时不时拿出已经掌握的概念，看看能否再运用到其他领域。很多时候，一个领域的问题，可能需要其他领域的知识才能解决。\n\n反观每年奥运，每年都有好多拿金牌的得主，不过当年拿金牌的得主们，你们还记得多少呢？我记忆中只剩郎平，李宁，邓亚萍之类的了，然而大部分都早已被人淡忘。\n\n为什么他们看起来是更加成功的呢？他们两个都是在自己曾经做得最好的维度之外，另外开拓了一个甚至多个维度。\n\n这也就解释了为什么真正有这一个维度，出息的都是那些当年成绩一般般的同学，因为除了在校考试成绩之外，还有很多很多其他的维度。\n\n**其实，一个人也可以是一个“团队”。**\n\n在校期间只有“成绩”这一个维度，其实很多人都没有想过，自己其实可以有多个“团队成员”。\n\n学习了编程就多了一个工程师，学习了演讲就多了一个市场部经理等等。这其实也是应试教育最坑人的地方，因为他没有尽可能的还原这个世界原有的样子，甚至没有告诉成绩一般的学生，可以多维度获得成功。\n\n其实这种多维度的技巧可以运用的地方很多。\n\n当你给别人解释问题的时候，运用的维度越多，对方能够理解的概率也就越大。\n\n背单词从只是看着背，到边看，边写，边听可以说就从一个维度变为了三个维度。\n\n乔布斯的成功就是这种策略的好实例。当早期的极客们痴迷于各种技术参数之时，他凭直觉给电脑加上了另一个别人没有想到的维度：艺术设计。时间越久，这个维度带来的合成竞争力也就越大。\n\n当然，打造多个维度不代表走马观花式的堆砌。做事认真永远是稀缺的品质。即便是做一件非常小的事情，也能把它落实好，不出错就已经非常不容易了。好比是盖房子。无论是开始时的第一块砖，还是十几层后的那块砖都应该认真码放，而不是草草了事。\n同样，我们可以打造不同的维度，但是对于每一个维度都应该足够认真，至少学过的东西就让他成为自己的一部分，而不是只会说几个专业名词唬唬人。\n所以重要的不一定是每个维度都深入且精通，而是自己在这个维度学过的知识、做过的研究都实实在在能够经得住考验。\n\n\n另外，**事实也证明，跨界成本越大，越有可能获得极大的利润。**由于成本太大，所以在没开始之前，就已经甩掉了大部分竞争者。\n所以在学习这件事上，不应该太局限。我经常会寻找一些貌似无关的领域去学习，因为我知道，一旦用上了，能够带来的回报也是巨大的。\n\n不过，这个简单的方法论里，还有一个很重要的窍门：\n\n**你至少要在一个维度上足够突出。**\n\n你可以理解为：\n\n**凡事都需要成本。**\n\n这就好像是你赚钱的时候，“生活必需开支”就是你的成本，你赚到的钱不超过这个数值，你的赚钱技能实际上就是负分。\n\n其实不论是单维度的死磕，还是多维度的拓展，我们的目的都是希望最终能够得到一个“最高分”。而每个人都应该根据自己现有的情况，规划一个最适合自己的路径。\n\n如果暂时还没有足够突出的维度，那就好好打磨自己的技能；如果已经在某个维度足够优秀，不要沉浸在已有的成绩中，不妨换个维度去突破一下自己的局限。\n\n处处平庸是不行的，不求处处突出，但起码要在一个甚至多个维度上处于一个相当优异的位置，这样的时候，多维度的意义就开始几何级数增长。\n\n为自己打造多维度的竞争力才是出路。\n\n知识改变命运，绝对不是空话。\n\n","source":"_posts/通向自由之路/通向自由之路(4)多维竞争篇.md","raw":"---\ntitle: 通向自由之路(4)多维竞争篇\ndate: 2016-09-25 10:17:50\ntags: \n- 通向自由之路\ncategories: 反思\n---\n\n上周谈到了“落后”的话题，自己有许多地方都没有达到20%，甚至焦虑不堪。可笑来老师在文末告诉我们：\n\n>放心，我们一定有办法解决“危机感”所带来的焦虑。\n\n那么，今天来讲讲什么该如何做到。\n<!-- more -->\n从某一个角度上来看，绝大多数人的幸福感是建立在比较的基础上的。很多时候，比较就是一个大坑。比如，为了衡量自己的实力或者竞争力，就要对自己所掌握的技能有充分，深入，真实，客观的判断。虽然大多数人总是过高估计自己的能力，但很少有人对量化的数字产生一丝丝错觉。那些被量化的数字是最无法忽视的，有了可以量化比较数据之后，我们能够更加客观地认识自己。更重要的是我们能实事求是的寻找解决方法，而不是一味的安慰自己。\n\n但是一个很不幸的事实是：\n\n所谓的成长，就是不断把别人比下去的过程。如愿比下去了也倒还好，比不过就非常痛苦——那就意味着自己被比下去了。体育赛事里经常出现银牌得主苦拼十多年还是没有斗过金牌得主，你不妨想象一下，如果你身为那个银牌得主，那一路上不断听到的来自好人的安慰是不是犹如千刀万剐缓慢折磨？\n\n在某个技能上死磕，确实是一个策略，但不是最好的策略。仔细想想还有哪些策略？可生活有许多的维度，有些时候只是转换一下角度，就能有机会找到新的突破口。\n\n比如，“维度”是线性代数的概念，但用它来与自身的能力做一个类比，或许能提供一个新的思路。\n\n时不时拿出已经掌握的概念，看看能否再运用到其他领域。很多时候，一个领域的问题，可能需要其他领域的知识才能解决。\n\n反观每年奥运，每年都有好多拿金牌的得主，不过当年拿金牌的得主们，你们还记得多少呢？我记忆中只剩郎平，李宁，邓亚萍之类的了，然而大部分都早已被人淡忘。\n\n为什么他们看起来是更加成功的呢？他们两个都是在自己曾经做得最好的维度之外，另外开拓了一个甚至多个维度。\n\n这也就解释了为什么真正有这一个维度，出息的都是那些当年成绩一般般的同学，因为除了在校考试成绩之外，还有很多很多其他的维度。\n\n**其实，一个人也可以是一个“团队”。**\n\n在校期间只有“成绩”这一个维度，其实很多人都没有想过，自己其实可以有多个“团队成员”。\n\n学习了编程就多了一个工程师，学习了演讲就多了一个市场部经理等等。这其实也是应试教育最坑人的地方，因为他没有尽可能的还原这个世界原有的样子，甚至没有告诉成绩一般的学生，可以多维度获得成功。\n\n其实这种多维度的技巧可以运用的地方很多。\n\n当你给别人解释问题的时候，运用的维度越多，对方能够理解的概率也就越大。\n\n背单词从只是看着背，到边看，边写，边听可以说就从一个维度变为了三个维度。\n\n乔布斯的成功就是这种策略的好实例。当早期的极客们痴迷于各种技术参数之时，他凭直觉给电脑加上了另一个别人没有想到的维度：艺术设计。时间越久，这个维度带来的合成竞争力也就越大。\n\n当然，打造多个维度不代表走马观花式的堆砌。做事认真永远是稀缺的品质。即便是做一件非常小的事情，也能把它落实好，不出错就已经非常不容易了。好比是盖房子。无论是开始时的第一块砖，还是十几层后的那块砖都应该认真码放，而不是草草了事。\n同样，我们可以打造不同的维度，但是对于每一个维度都应该足够认真，至少学过的东西就让他成为自己的一部分，而不是只会说几个专业名词唬唬人。\n所以重要的不一定是每个维度都深入且精通，而是自己在这个维度学过的知识、做过的研究都实实在在能够经得住考验。\n\n\n另外，**事实也证明，跨界成本越大，越有可能获得极大的利润。**由于成本太大，所以在没开始之前，就已经甩掉了大部分竞争者。\n所以在学习这件事上，不应该太局限。我经常会寻找一些貌似无关的领域去学习，因为我知道，一旦用上了，能够带来的回报也是巨大的。\n\n不过，这个简单的方法论里，还有一个很重要的窍门：\n\n**你至少要在一个维度上足够突出。**\n\n你可以理解为：\n\n**凡事都需要成本。**\n\n这就好像是你赚钱的时候，“生活必需开支”就是你的成本，你赚到的钱不超过这个数值，你的赚钱技能实际上就是负分。\n\n其实不论是单维度的死磕，还是多维度的拓展，我们的目的都是希望最终能够得到一个“最高分”。而每个人都应该根据自己现有的情况，规划一个最适合自己的路径。\n\n如果暂时还没有足够突出的维度，那就好好打磨自己的技能；如果已经在某个维度足够优秀，不要沉浸在已有的成绩中，不妨换个维度去突破一下自己的局限。\n\n处处平庸是不行的，不求处处突出，但起码要在一个甚至多个维度上处于一个相当优异的位置，这样的时候，多维度的意义就开始几何级数增长。\n\n为自己打造多维度的竞争力才是出路。\n\n知识改变命运，绝对不是空话。\n\n","slug":"通向自由之路/通向自由之路(4)多维竞争篇","published":1,"updated":"2019-03-22T14:44:36.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxp00584l3nhy0l027x","content":"<p>上周谈到了“落后”的话题，自己有许多地方都没有达到20%，甚至焦虑不堪。可笑来老师在文末告诉我们：</p>\n<blockquote>\n<p>放心，我们一定有办法解决“危机感”所带来的焦虑。</p>\n</blockquote>\n<p>那么，今天来讲讲什么该如何做到。<br><a id=\"more\"></a><br>从某一个角度上来看，绝大多数人的幸福感是建立在比较的基础上的。很多时候，比较就是一个大坑。比如，为了衡量自己的实力或者竞争力，就要对自己所掌握的技能有充分，深入，真实，客观的判断。虽然大多数人总是过高估计自己的能力，但很少有人对量化的数字产生一丝丝错觉。那些被量化的数字是最无法忽视的，有了可以量化比较数据之后，我们能够更加客观地认识自己。更重要的是我们能实事求是的寻找解决方法，而不是一味的安慰自己。</p>\n<p>但是一个很不幸的事实是：</p>\n<p>所谓的成长，就是不断把别人比下去的过程。如愿比下去了也倒还好，比不过就非常痛苦——那就意味着自己被比下去了。体育赛事里经常出现银牌得主苦拼十多年还是没有斗过金牌得主，你不妨想象一下，如果你身为那个银牌得主，那一路上不断听到的来自好人的安慰是不是犹如千刀万剐缓慢折磨？</p>\n<p>在某个技能上死磕，确实是一个策略，但不是最好的策略。仔细想想还有哪些策略？可生活有许多的维度，有些时候只是转换一下角度，就能有机会找到新的突破口。</p>\n<p>比如，“维度”是线性代数的概念，但用它来与自身的能力做一个类比，或许能提供一个新的思路。</p>\n<p>时不时拿出已经掌握的概念，看看能否再运用到其他领域。很多时候，一个领域的问题，可能需要其他领域的知识才能解决。</p>\n<p>反观每年奥运，每年都有好多拿金牌的得主，不过当年拿金牌的得主们，你们还记得多少呢？我记忆中只剩郎平，李宁，邓亚萍之类的了，然而大部分都早已被人淡忘。</p>\n<p>为什么他们看起来是更加成功的呢？他们两个都是在自己曾经做得最好的维度之外，另外开拓了一个甚至多个维度。</p>\n<p>这也就解释了为什么真正有这一个维度，出息的都是那些当年成绩一般般的同学，因为除了在校考试成绩之外，还有很多很多其他的维度。</p>\n<p><strong>其实，一个人也可以是一个“团队”。</strong></p>\n<p>在校期间只有“成绩”这一个维度，其实很多人都没有想过，自己其实可以有多个“团队成员”。</p>\n<p>学习了编程就多了一个工程师，学习了演讲就多了一个市场部经理等等。这其实也是应试教育最坑人的地方，因为他没有尽可能的还原这个世界原有的样子，甚至没有告诉成绩一般的学生，可以多维度获得成功。</p>\n<p>其实这种多维度的技巧可以运用的地方很多。</p>\n<p>当你给别人解释问题的时候，运用的维度越多，对方能够理解的概率也就越大。</p>\n<p>背单词从只是看着背，到边看，边写，边听可以说就从一个维度变为了三个维度。</p>\n<p>乔布斯的成功就是这种策略的好实例。当早期的极客们痴迷于各种技术参数之时，他凭直觉给电脑加上了另一个别人没有想到的维度：艺术设计。时间越久，这个维度带来的合成竞争力也就越大。</p>\n<p>当然，打造多个维度不代表走马观花式的堆砌。做事认真永远是稀缺的品质。即便是做一件非常小的事情，也能把它落实好，不出错就已经非常不容易了。好比是盖房子。无论是开始时的第一块砖，还是十几层后的那块砖都应该认真码放，而不是草草了事。<br>同样，我们可以打造不同的维度，但是对于每一个维度都应该足够认真，至少学过的东西就让他成为自己的一部分，而不是只会说几个专业名词唬唬人。<br>所以重要的不一定是每个维度都深入且精通，而是自己在这个维度学过的知识、做过的研究都实实在在能够经得住考验。</p>\n<p>另外，<strong>事实也证明，跨界成本越大，越有可能获得极大的利润。</strong>由于成本太大，所以在没开始之前，就已经甩掉了大部分竞争者。<br>所以在学习这件事上，不应该太局限。我经常会寻找一些貌似无关的领域去学习，因为我知道，一旦用上了，能够带来的回报也是巨大的。</p>\n<p>不过，这个简单的方法论里，还有一个很重要的窍门：</p>\n<p><strong>你至少要在一个维度上足够突出。</strong></p>\n<p>你可以理解为：</p>\n<p><strong>凡事都需要成本。</strong></p>\n<p>这就好像是你赚钱的时候，“生活必需开支”就是你的成本，你赚到的钱不超过这个数值，你的赚钱技能实际上就是负分。</p>\n<p>其实不论是单维度的死磕，还是多维度的拓展，我们的目的都是希望最终能够得到一个“最高分”。而每个人都应该根据自己现有的情况，规划一个最适合自己的路径。</p>\n<p>如果暂时还没有足够突出的维度，那就好好打磨自己的技能；如果已经在某个维度足够优秀，不要沉浸在已有的成绩中，不妨换个维度去突破一下自己的局限。</p>\n<p>处处平庸是不行的，不求处处突出，但起码要在一个甚至多个维度上处于一个相当优异的位置，这样的时候，多维度的意义就开始几何级数增长。</p>\n<p>为自己打造多维度的竞争力才是出路。</p>\n<p>知识改变命运，绝对不是空话。</p>\n","site":{"data":{}},"excerpt":"<p>上周谈到了“落后”的话题，自己有许多地方都没有达到20%，甚至焦虑不堪。可笑来老师在文末告诉我们：</p>\n<blockquote>\n<p>放心，我们一定有办法解决“危机感”所带来的焦虑。</p>\n</blockquote>\n<p>那么，今天来讲讲什么该如何做到。<br></p>","more":"<br>从某一个角度上来看，绝大多数人的幸福感是建立在比较的基础上的。很多时候，比较就是一个大坑。比如，为了衡量自己的实力或者竞争力，就要对自己所掌握的技能有充分，深入，真实，客观的判断。虽然大多数人总是过高估计自己的能力，但很少有人对量化的数字产生一丝丝错觉。那些被量化的数字是最无法忽视的，有了可以量化比较数据之后，我们能够更加客观地认识自己。更重要的是我们能实事求是的寻找解决方法，而不是一味的安慰自己。<p></p>\n<p>但是一个很不幸的事实是：</p>\n<p>所谓的成长，就是不断把别人比下去的过程。如愿比下去了也倒还好，比不过就非常痛苦——那就意味着自己被比下去了。体育赛事里经常出现银牌得主苦拼十多年还是没有斗过金牌得主，你不妨想象一下，如果你身为那个银牌得主，那一路上不断听到的来自好人的安慰是不是犹如千刀万剐缓慢折磨？</p>\n<p>在某个技能上死磕，确实是一个策略，但不是最好的策略。仔细想想还有哪些策略？可生活有许多的维度，有些时候只是转换一下角度，就能有机会找到新的突破口。</p>\n<p>比如，“维度”是线性代数的概念，但用它来与自身的能力做一个类比，或许能提供一个新的思路。</p>\n<p>时不时拿出已经掌握的概念，看看能否再运用到其他领域。很多时候，一个领域的问题，可能需要其他领域的知识才能解决。</p>\n<p>反观每年奥运，每年都有好多拿金牌的得主，不过当年拿金牌的得主们，你们还记得多少呢？我记忆中只剩郎平，李宁，邓亚萍之类的了，然而大部分都早已被人淡忘。</p>\n<p>为什么他们看起来是更加成功的呢？他们两个都是在自己曾经做得最好的维度之外，另外开拓了一个甚至多个维度。</p>\n<p>这也就解释了为什么真正有这一个维度，出息的都是那些当年成绩一般般的同学，因为除了在校考试成绩之外，还有很多很多其他的维度。</p>\n<p><strong>其实，一个人也可以是一个“团队”。</strong></p>\n<p>在校期间只有“成绩”这一个维度，其实很多人都没有想过，自己其实可以有多个“团队成员”。</p>\n<p>学习了编程就多了一个工程师，学习了演讲就多了一个市场部经理等等。这其实也是应试教育最坑人的地方，因为他没有尽可能的还原这个世界原有的样子，甚至没有告诉成绩一般的学生，可以多维度获得成功。</p>\n<p>其实这种多维度的技巧可以运用的地方很多。</p>\n<p>当你给别人解释问题的时候，运用的维度越多，对方能够理解的概率也就越大。</p>\n<p>背单词从只是看着背，到边看，边写，边听可以说就从一个维度变为了三个维度。</p>\n<p>乔布斯的成功就是这种策略的好实例。当早期的极客们痴迷于各种技术参数之时，他凭直觉给电脑加上了另一个别人没有想到的维度：艺术设计。时间越久，这个维度带来的合成竞争力也就越大。</p>\n<p>当然，打造多个维度不代表走马观花式的堆砌。做事认真永远是稀缺的品质。即便是做一件非常小的事情，也能把它落实好，不出错就已经非常不容易了。好比是盖房子。无论是开始时的第一块砖，还是十几层后的那块砖都应该认真码放，而不是草草了事。<br>同样，我们可以打造不同的维度，但是对于每一个维度都应该足够认真，至少学过的东西就让他成为自己的一部分，而不是只会说几个专业名词唬唬人。<br>所以重要的不一定是每个维度都深入且精通，而是自己在这个维度学过的知识、做过的研究都实实在在能够经得住考验。</p>\n<p>另外，<strong>事实也证明，跨界成本越大，越有可能获得极大的利润。</strong>由于成本太大，所以在没开始之前，就已经甩掉了大部分竞争者。<br>所以在学习这件事上，不应该太局限。我经常会寻找一些貌似无关的领域去学习，因为我知道，一旦用上了，能够带来的回报也是巨大的。</p>\n<p>不过，这个简单的方法论里，还有一个很重要的窍门：</p>\n<p><strong>你至少要在一个维度上足够突出。</strong></p>\n<p>你可以理解为：</p>\n<p><strong>凡事都需要成本。</strong></p>\n<p>这就好像是你赚钱的时候，“生活必需开支”就是你的成本，你赚到的钱不超过这个数值，你的赚钱技能实际上就是负分。</p>\n<p>其实不论是单维度的死磕，还是多维度的拓展，我们的目的都是希望最终能够得到一个“最高分”。而每个人都应该根据自己现有的情况，规划一个最适合自己的路径。</p>\n<p>如果暂时还没有足够突出的维度，那就好好打磨自己的技能；如果已经在某个维度足够优秀，不要沉浸在已有的成绩中，不妨换个维度去突破一下自己的局限。</p>\n<p>处处平庸是不行的，不求处处突出，但起码要在一个甚至多个维度上处于一个相当优异的位置，这样的时候，多维度的意义就开始几何级数增长。</p>\n<p>为自己打造多维度的竞争力才是出路。</p>\n<p>知识改变命运，绝对不是空话。</p>"},{"title":"设计模式之美--抽象类与接口","date":"2019-11-23T14:49:22.000Z","_content":"\n面向对象编程中，抽象类和接口是两个经常被用到的语法概念。我们经常在工作中用到，也会在面试中被提及。比如两者的区别在哪里？今天就来理一理这两者的关系。\n\n<!-- more -->\n\n### 抽象类\n抽象目的是复用，有三个特性。\n\n1. 抽象类不允许被实例化，只能被继承。\n2. 抽象类可以包含属性和方法。方法可以包含代码实现，也可以不包含。\n3. 子类继承抽象类，必须实现抽象类中的 **所有** 抽象方法。\n\n继承关系是一种 `is-a` 关系。为了解决代码复用问题。\n\n#### 抽象类解决了什么问题\n\n如果没有抽象类，作为普通的父类的情况下，当我们写好父类的方法后，由于不是抽象类，则编译器不会强制要求子类重写该方法，我们有可能会忘记重新实现该方法。另一方面，父类可以被实例化，这也增加了类被误调用的风险，虽然可以通过设置私有的构造函数的方式来解决（比如单例模式），但是不够优雅。\n\n### 接口\n\n接口目的是拓展，也有三个特性。\n\n1. 接口不能包含属性。\n2. 接口只能声明方法，方法不能包含代码实现。\n3. 类实现接口的时候，必须实现接口中声明的 **所有** 方法。\n\n接口表示 `has-a` 关系，表示具有某些功能。对于接口，有个更加形象的叫法，就是`协议`，表示一种规范。\n\n#### 接口解决了什么问题\n\n接口侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约。你可以联想类比一下API接口。调用者只需要关注抽象的接口，不需要了解具体的实现。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可拓展性。\n\n### 如何决定该用抽象类还是接口？\n\n根据我们想要表示的关系来进行判断。另外，从类的继承层册来看，抽象是一种自下而上的设计思路，现有子类的代码重复，然后在有上层的父类抽象。而接口正好相反，他是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，然后考虑其具体实现。\n\n\n\n\n","source":"_posts/设计模式/设计模式之美--抽象类与接口.md","raw":"---\ntitle: 设计模式之美--抽象类与接口\ndate: 2019-11-23 22:49:22\ntags:\n- 心法\ncategories: 设计模式\n---\n\n面向对象编程中，抽象类和接口是两个经常被用到的语法概念。我们经常在工作中用到，也会在面试中被提及。比如两者的区别在哪里？今天就来理一理这两者的关系。\n\n<!-- more -->\n\n### 抽象类\n抽象目的是复用，有三个特性。\n\n1. 抽象类不允许被实例化，只能被继承。\n2. 抽象类可以包含属性和方法。方法可以包含代码实现，也可以不包含。\n3. 子类继承抽象类，必须实现抽象类中的 **所有** 抽象方法。\n\n继承关系是一种 `is-a` 关系。为了解决代码复用问题。\n\n#### 抽象类解决了什么问题\n\n如果没有抽象类，作为普通的父类的情况下，当我们写好父类的方法后，由于不是抽象类，则编译器不会强制要求子类重写该方法，我们有可能会忘记重新实现该方法。另一方面，父类可以被实例化，这也增加了类被误调用的风险，虽然可以通过设置私有的构造函数的方式来解决（比如单例模式），但是不够优雅。\n\n### 接口\n\n接口目的是拓展，也有三个特性。\n\n1. 接口不能包含属性。\n2. 接口只能声明方法，方法不能包含代码实现。\n3. 类实现接口的时候，必须实现接口中声明的 **所有** 方法。\n\n接口表示 `has-a` 关系，表示具有某些功能。对于接口，有个更加形象的叫法，就是`协议`，表示一种规范。\n\n#### 接口解决了什么问题\n\n接口侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约。你可以联想类比一下API接口。调用者只需要关注抽象的接口，不需要了解具体的实现。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可拓展性。\n\n### 如何决定该用抽象类还是接口？\n\n根据我们想要表示的关系来进行判断。另外，从类的继承层册来看，抽象是一种自下而上的设计思路，现有子类的代码重复，然后在有上层的父类抽象。而接口正好相反，他是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，然后考虑其具体实现。\n\n\n\n\n","slug":"设计模式/设计模式之美--抽象类与接口","published":1,"updated":"2020-02-05T14:42:21.973Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxr005b4l3njpwywsc7","content":"<p>面向对象编程中，抽象类和接口是两个经常被用到的语法概念。我们经常在工作中用到，也会在面试中被提及。比如两者的区别在哪里？今天就来理一理这两者的关系。</p>\n<a id=\"more\"></a>\n<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>抽象目的是复用，有三个特性。</p>\n<ol>\n<li>抽象类不允许被实例化，只能被继承。</li>\n<li>抽象类可以包含属性和方法。方法可以包含代码实现，也可以不包含。</li>\n<li>子类继承抽象类，必须实现抽象类中的 <strong>所有</strong> 抽象方法。</li>\n</ol>\n<p>继承关系是一种 <code>is-a</code> 关系。为了解决代码复用问题。</p>\n<h4 id=\"抽象类解决了什么问题\"><a href=\"#抽象类解决了什么问题\" class=\"headerlink\" title=\"抽象类解决了什么问题\"></a>抽象类解决了什么问题</h4><p>如果没有抽象类，作为普通的父类的情况下，当我们写好父类的方法后，由于不是抽象类，则编译器不会强制要求子类重写该方法，我们有可能会忘记重新实现该方法。另一方面，父类可以被实例化，这也增加了类被误调用的风险，虽然可以通过设置私有的构造函数的方式来解决（比如单例模式），但是不够优雅。</p>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>接口目的是拓展，也有三个特性。</p>\n<ol>\n<li>接口不能包含属性。</li>\n<li>接口只能声明方法，方法不能包含代码实现。</li>\n<li>类实现接口的时候，必须实现接口中声明的 <strong>所有</strong> 方法。</li>\n</ol>\n<p>接口表示 <code>has-a</code> 关系，表示具有某些功能。对于接口，有个更加形象的叫法，就是<code>协议</code>，表示一种规范。</p>\n<h4 id=\"接口解决了什么问题\"><a href=\"#接口解决了什么问题\" class=\"headerlink\" title=\"接口解决了什么问题\"></a>接口解决了什么问题</h4><p>接口侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约。你可以联想类比一下API接口。调用者只需要关注抽象的接口，不需要了解具体的实现。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可拓展性。</p>\n<h3 id=\"如何决定该用抽象类还是接口？\"><a href=\"#如何决定该用抽象类还是接口？\" class=\"headerlink\" title=\"如何决定该用抽象类还是接口？\"></a>如何决定该用抽象类还是接口？</h3><p>根据我们想要表示的关系来进行判断。另外，从类的继承层册来看，抽象是一种自下而上的设计思路，现有子类的代码重复，然后在有上层的父类抽象。而接口正好相反，他是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，然后考虑其具体实现。</p>\n","site":{"data":{}},"excerpt":"<p>面向对象编程中，抽象类和接口是两个经常被用到的语法概念。我们经常在工作中用到，也会在面试中被提及。比如两者的区别在哪里？今天就来理一理这两者的关系。</p>","more":"<h3 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h3><p>抽象目的是复用，有三个特性。</p>\n<ol>\n<li>抽象类不允许被实例化，只能被继承。</li>\n<li>抽象类可以包含属性和方法。方法可以包含代码实现，也可以不包含。</li>\n<li>子类继承抽象类，必须实现抽象类中的 <strong>所有</strong> 抽象方法。</li>\n</ol>\n<p>继承关系是一种 <code>is-a</code> 关系。为了解决代码复用问题。</p>\n<h4 id=\"抽象类解决了什么问题\"><a href=\"#抽象类解决了什么问题\" class=\"headerlink\" title=\"抽象类解决了什么问题\"></a>抽象类解决了什么问题</h4><p>如果没有抽象类，作为普通的父类的情况下，当我们写好父类的方法后，由于不是抽象类，则编译器不会强制要求子类重写该方法，我们有可能会忘记重新实现该方法。另一方面，父类可以被实例化，这也增加了类被误调用的风险，虽然可以通过设置私有的构造函数的方式来解决（比如单例模式），但是不够优雅。</p>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><p>接口目的是拓展，也有三个特性。</p>\n<ol>\n<li>接口不能包含属性。</li>\n<li>接口只能声明方法，方法不能包含代码实现。</li>\n<li>类实现接口的时候，必须实现接口中声明的 <strong>所有</strong> 方法。</li>\n</ol>\n<p>接口表示 <code>has-a</code> 关系，表示具有某些功能。对于接口，有个更加形象的叫法，就是<code>协议</code>，表示一种规范。</p>\n<h4 id=\"接口解决了什么问题\"><a href=\"#接口解决了什么问题\" class=\"headerlink\" title=\"接口解决了什么问题\"></a>接口解决了什么问题</h4><p>接口侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约。你可以联想类比一下API接口。调用者只需要关注抽象的接口，不需要了解具体的实现。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可拓展性。</p>\n<h3 id=\"如何决定该用抽象类还是接口？\"><a href=\"#如何决定该用抽象类还是接口？\" class=\"headerlink\" title=\"如何决定该用抽象类还是接口？\"></a>如何决定该用抽象类还是接口？</h3><p>根据我们想要表示的关系来进行判断。另外，从类的继承层册来看，抽象是一种自下而上的设计思路，现有子类的代码重复，然后在有上层的父类抽象。而接口正好相反，他是一种自上而下的设计思路。我们在编程的时候，一般都是先设计接口，然后考虑其具体实现。</p>"},{"title":"通向自由之路(7)钥匙篇","date":"2016-11-06T13:15:50.000Z","_content":"当你遇到一扇被锁着的门，你应该去哪里找钥匙？尽管不知道到底去哪找，但是不应该只盯着锁头看，是吧？\n\n<!-- more -->\n当我们遇到任何问题的时候，也是一样的道理。只盯着问题看，只盯着问题想，盯着问题找解决方案往往都是以无奈告终的。\n\n但在实际生活中，我们的注意力除了被各种娱乐新闻占据之外，还有很大一部分被“困扰我们的问题”所占据。\n\n而我们投入了大量注意力了之后，之所以最终收效甚微，很大程度上是因为我们关注点仅仅放在了问题本身上。这其实也是一种用蛮力解决问题的表现。\n之所以说的“学习学习再学习“，也就是希望你用对力的方向。如果方向错了，越努力就可能结果越糟。\n\n一旦你遇到问题发现自己正在“之盯着问题本身思考”的时候，你的元认知能力应该被激活。让它告诉自己：\n\n**不对，我得把我的注意力从问题本身移开，因为解决方案肯定在其他地方。**\n\n调用元认知能力就想系统的“自动弹窗”一样。，知道了训练方法，了解了原理还不够，最重要的是要让它成为一种本能反应。这必须要经过刻意训练才能完成。\n这就好像你升级了操作系统，但不去使用，而对新功能不闻不问。那这和没有更新其实一样，甚至更糟。\n\n其实不光是我们的元认知能力。回想之前的内容，有多少概念已经模糊，甚至不记得了，及时回顾之前的知识，使其成为自己的习惯。\n\n一个最好笑的例子是，谈恋爱这事儿，真的很锻炼元认知能力，也很需要元认知能力。明明刚才还好好的，怎么突然之间女朋友就变脸了？！最大的苦恼就是：\n\n女生怎么不能就事论事呢？\n\n其实调换一下角度也是如此，本质上跟性别没有必然的逻辑锁定关系。另，别觉得谈恋爱跟长期开开心心谈恋爱，就会省出很多用来伤心难过的时间去做正事，这其实跟财富也是有很多必然相关性的,在这点上还是强烈认同的。\n\n遇到了必须解决的问题，别人盯着问题看，我却能想明白应该去别的地方找钥匙：管好自己就行了，想办法做正确的事情，这个最重要；然后再想办法找正确的方式,哪怕做事的方式错了也不所谓，那毕竟是可以修正的；哪怕效率低下一点也可以接受，毕竟只要做了就有累积。\n\n很多人说，自己没有那么多的积累，现在没有办法找到合适的钥匙。\n\n其实没有人一开始就能轻松打开困扰自己的锁头，更别说有足够多的领域去寻找自己需要的钥匙了。\n\n比如说，心理学虽然是个隐藏大量钥匙的地方，如果你没有“找钥匙”概念，即便读到了一些内容，你也不会应用到生活中来。\n所以，平时就要养成自己的记录习惯。\n\n不论是遇到什么锁头，还是什么钥匙，都要记得记录下来，不断的回顾总结。\n\n赚钱这事也一样。民间早有这样的说法：**你追钱，追不上钱；钱追你，你跑不掉...**别人都盯着钱看，这确实是个问题，但我觉得最终的解决方案一定在其他地方，最终，我认定能力最重要，盯着自己的能力看，盯着自己的能力成长才是真正的“钥匙”啊。\n\n这也正是为什么自由之路不谈钱的原因。总盯着钱的人，通常赚不到钱。真正赚到钱的人，通常会把注意力放到自身能力的提高上。我相信这一点，这也是我常常记录博客的原因。\n\n如果你能合理使用自己的注意力，试着活在未来，并且刻意打磨自己的元认知能力，估计不想要赚到钱也很难。\n\n在起点上，自己确实是有缺点的，可能落后于他人许多，但只要处在正确的学习状态，每天进步一点点的人，都是在不断的累积，正在一点点的变好。\n\n最近在《精进：如何成为一个很厉害的人》里面也正有提到这个事情，分析一件事情值不值得去做，花多少精力去做的时候，可以从两个角度评估：一是这件事在当下将给我带来的收益的大小，这个收益可以是心智、情感层面的，也可以是身体、物质层面的，我称之为“收益值”，二是这项收益随时间的衰减程度，我称之为“收益半衰期”,半衰期时间长的，其影响也就越持久。\n\n做事判断的两个标准：\n1.收益值的高低无关紧要，只要不是做短半衰期的事情，这只要这个收益可以被累加，就尽管去做。\n2.不要只盯着“高大上”的事情，一些不重要，不紧急的事情，只要对你的长期有益处，仍旧可以去做。\n\n因此，这个万能钥匙是这样的：\n\n当你遇到锁头的时候，要想到你应该去别的地方找钥匙......\n\n这也正体现了多维度思考的一个方面这把万能钥匙用法很多。\n比如，很多人苦恼自己的英语遇到了瓶颈，其实钥匙并不在其他地方，而在于你自己本身的语文（母语）就很差；很多父母苦恼：“孩子怎么这么没耐心呢？”其实他们作为父母就是没有耐心的；甚至，很多人认为“这个世界太不公平了”的人，其实没想过那很可能不是这个世界的问题，甚至不是公平不公平的问题，而是TA是否配得上被公平对待的问题......\n\n其实自己在英语听力方面很差，确实问题有可能不是出在听上面，而是出在说上面。道理很简单：只要说的出，就能听得懂。所以听说双管齐下也许会好一点。\n这是放在哪门语言都通用的道理。你甚至不需要说的很标准就可以听得懂，这就好比我们很多地区的人普通话不标准，但是几乎没有人抱怨过听不懂新闻联播。\n","source":"_posts/通向自由之路/通向自由之路(7)钥匙篇.md","raw":"---\ntitle: 通向自由之路(7)钥匙篇\ndate: 2016-11-06 21:15:50\ntags: \n- 通向自由之路\ncategories: 反思\n---\n当你遇到一扇被锁着的门，你应该去哪里找钥匙？尽管不知道到底去哪找，但是不应该只盯着锁头看，是吧？\n\n<!-- more -->\n当我们遇到任何问题的时候，也是一样的道理。只盯着问题看，只盯着问题想，盯着问题找解决方案往往都是以无奈告终的。\n\n但在实际生活中，我们的注意力除了被各种娱乐新闻占据之外，还有很大一部分被“困扰我们的问题”所占据。\n\n而我们投入了大量注意力了之后，之所以最终收效甚微，很大程度上是因为我们关注点仅仅放在了问题本身上。这其实也是一种用蛮力解决问题的表现。\n之所以说的“学习学习再学习“，也就是希望你用对力的方向。如果方向错了，越努力就可能结果越糟。\n\n一旦你遇到问题发现自己正在“之盯着问题本身思考”的时候，你的元认知能力应该被激活。让它告诉自己：\n\n**不对，我得把我的注意力从问题本身移开，因为解决方案肯定在其他地方。**\n\n调用元认知能力就想系统的“自动弹窗”一样。，知道了训练方法，了解了原理还不够，最重要的是要让它成为一种本能反应。这必须要经过刻意训练才能完成。\n这就好像你升级了操作系统，但不去使用，而对新功能不闻不问。那这和没有更新其实一样，甚至更糟。\n\n其实不光是我们的元认知能力。回想之前的内容，有多少概念已经模糊，甚至不记得了，及时回顾之前的知识，使其成为自己的习惯。\n\n一个最好笑的例子是，谈恋爱这事儿，真的很锻炼元认知能力，也很需要元认知能力。明明刚才还好好的，怎么突然之间女朋友就变脸了？！最大的苦恼就是：\n\n女生怎么不能就事论事呢？\n\n其实调换一下角度也是如此，本质上跟性别没有必然的逻辑锁定关系。另，别觉得谈恋爱跟长期开开心心谈恋爱，就会省出很多用来伤心难过的时间去做正事，这其实跟财富也是有很多必然相关性的,在这点上还是强烈认同的。\n\n遇到了必须解决的问题，别人盯着问题看，我却能想明白应该去别的地方找钥匙：管好自己就行了，想办法做正确的事情，这个最重要；然后再想办法找正确的方式,哪怕做事的方式错了也不所谓，那毕竟是可以修正的；哪怕效率低下一点也可以接受，毕竟只要做了就有累积。\n\n很多人说，自己没有那么多的积累，现在没有办法找到合适的钥匙。\n\n其实没有人一开始就能轻松打开困扰自己的锁头，更别说有足够多的领域去寻找自己需要的钥匙了。\n\n比如说，心理学虽然是个隐藏大量钥匙的地方，如果你没有“找钥匙”概念，即便读到了一些内容，你也不会应用到生活中来。\n所以，平时就要养成自己的记录习惯。\n\n不论是遇到什么锁头，还是什么钥匙，都要记得记录下来，不断的回顾总结。\n\n赚钱这事也一样。民间早有这样的说法：**你追钱，追不上钱；钱追你，你跑不掉...**别人都盯着钱看，这确实是个问题，但我觉得最终的解决方案一定在其他地方，最终，我认定能力最重要，盯着自己的能力看，盯着自己的能力成长才是真正的“钥匙”啊。\n\n这也正是为什么自由之路不谈钱的原因。总盯着钱的人，通常赚不到钱。真正赚到钱的人，通常会把注意力放到自身能力的提高上。我相信这一点，这也是我常常记录博客的原因。\n\n如果你能合理使用自己的注意力，试着活在未来，并且刻意打磨自己的元认知能力，估计不想要赚到钱也很难。\n\n在起点上，自己确实是有缺点的，可能落后于他人许多，但只要处在正确的学习状态，每天进步一点点的人，都是在不断的累积，正在一点点的变好。\n\n最近在《精进：如何成为一个很厉害的人》里面也正有提到这个事情，分析一件事情值不值得去做，花多少精力去做的时候，可以从两个角度评估：一是这件事在当下将给我带来的收益的大小，这个收益可以是心智、情感层面的，也可以是身体、物质层面的，我称之为“收益值”，二是这项收益随时间的衰减程度，我称之为“收益半衰期”,半衰期时间长的，其影响也就越持久。\n\n做事判断的两个标准：\n1.收益值的高低无关紧要，只要不是做短半衰期的事情，这只要这个收益可以被累加，就尽管去做。\n2.不要只盯着“高大上”的事情，一些不重要，不紧急的事情，只要对你的长期有益处，仍旧可以去做。\n\n因此，这个万能钥匙是这样的：\n\n当你遇到锁头的时候，要想到你应该去别的地方找钥匙......\n\n这也正体现了多维度思考的一个方面这把万能钥匙用法很多。\n比如，很多人苦恼自己的英语遇到了瓶颈，其实钥匙并不在其他地方，而在于你自己本身的语文（母语）就很差；很多父母苦恼：“孩子怎么这么没耐心呢？”其实他们作为父母就是没有耐心的；甚至，很多人认为“这个世界太不公平了”的人，其实没想过那很可能不是这个世界的问题，甚至不是公平不公平的问题，而是TA是否配得上被公平对待的问题......\n\n其实自己在英语听力方面很差，确实问题有可能不是出在听上面，而是出在说上面。道理很简单：只要说的出，就能听得懂。所以听说双管齐下也许会好一点。\n这是放在哪门语言都通用的道理。你甚至不需要说的很标准就可以听得懂，这就好比我们很多地区的人普通话不标准，但是几乎没有人抱怨过听不懂新闻联播。\n","slug":"通向自由之路/通向自由之路(7)钥匙篇","published":1,"updated":"2019-03-22T14:44:36.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxs005e4l3n4z6q1iop","content":"<p>当你遇到一扇被锁着的门，你应该去哪里找钥匙？尽管不知道到底去哪找，但是不应该只盯着锁头看，是吧？</p>\n<a id=\"more\"></a>\n<p>当我们遇到任何问题的时候，也是一样的道理。只盯着问题看，只盯着问题想，盯着问题找解决方案往往都是以无奈告终的。</p>\n<p>但在实际生活中，我们的注意力除了被各种娱乐新闻占据之外，还有很大一部分被“困扰我们的问题”所占据。</p>\n<p>而我们投入了大量注意力了之后，之所以最终收效甚微，很大程度上是因为我们关注点仅仅放在了问题本身上。这其实也是一种用蛮力解决问题的表现。<br>之所以说的“学习学习再学习“，也就是希望你用对力的方向。如果方向错了，越努力就可能结果越糟。</p>\n<p>一旦你遇到问题发现自己正在“之盯着问题本身思考”的时候，你的元认知能力应该被激活。让它告诉自己：</p>\n<p><strong>不对，我得把我的注意力从问题本身移开，因为解决方案肯定在其他地方。</strong></p>\n<p>调用元认知能力就想系统的“自动弹窗”一样。，知道了训练方法，了解了原理还不够，最重要的是要让它成为一种本能反应。这必须要经过刻意训练才能完成。<br>这就好像你升级了操作系统，但不去使用，而对新功能不闻不问。那这和没有更新其实一样，甚至更糟。</p>\n<p>其实不光是我们的元认知能力。回想之前的内容，有多少概念已经模糊，甚至不记得了，及时回顾之前的知识，使其成为自己的习惯。</p>\n<p>一个最好笑的例子是，谈恋爱这事儿，真的很锻炼元认知能力，也很需要元认知能力。明明刚才还好好的，怎么突然之间女朋友就变脸了？！最大的苦恼就是：</p>\n<p>女生怎么不能就事论事呢？</p>\n<p>其实调换一下角度也是如此，本质上跟性别没有必然的逻辑锁定关系。另，别觉得谈恋爱跟长期开开心心谈恋爱，就会省出很多用来伤心难过的时间去做正事，这其实跟财富也是有很多必然相关性的,在这点上还是强烈认同的。</p>\n<p>遇到了必须解决的问题，别人盯着问题看，我却能想明白应该去别的地方找钥匙：管好自己就行了，想办法做正确的事情，这个最重要；然后再想办法找正确的方式,哪怕做事的方式错了也不所谓，那毕竟是可以修正的；哪怕效率低下一点也可以接受，毕竟只要做了就有累积。</p>\n<p>很多人说，自己没有那么多的积累，现在没有办法找到合适的钥匙。</p>\n<p>其实没有人一开始就能轻松打开困扰自己的锁头，更别说有足够多的领域去寻找自己需要的钥匙了。</p>\n<p>比如说，心理学虽然是个隐藏大量钥匙的地方，如果你没有“找钥匙”概念，即便读到了一些内容，你也不会应用到生活中来。<br>所以，平时就要养成自己的记录习惯。</p>\n<p>不论是遇到什么锁头，还是什么钥匙，都要记得记录下来，不断的回顾总结。</p>\n<p>赚钱这事也一样。民间早有这样的说法：<strong>你追钱，追不上钱；钱追你，你跑不掉…</strong>别人都盯着钱看，这确实是个问题，但我觉得最终的解决方案一定在其他地方，最终，我认定能力最重要，盯着自己的能力看，盯着自己的能力成长才是真正的“钥匙”啊。</p>\n<p>这也正是为什么自由之路不谈钱的原因。总盯着钱的人，通常赚不到钱。真正赚到钱的人，通常会把注意力放到自身能力的提高上。我相信这一点，这也是我常常记录博客的原因。</p>\n<p>如果你能合理使用自己的注意力，试着活在未来，并且刻意打磨自己的元认知能力，估计不想要赚到钱也很难。</p>\n<p>在起点上，自己确实是有缺点的，可能落后于他人许多，但只要处在正确的学习状态，每天进步一点点的人，都是在不断的累积，正在一点点的变好。</p>\n<p>最近在《精进：如何成为一个很厉害的人》里面也正有提到这个事情，分析一件事情值不值得去做，花多少精力去做的时候，可以从两个角度评估：一是这件事在当下将给我带来的收益的大小，这个收益可以是心智、情感层面的，也可以是身体、物质层面的，我称之为“收益值”，二是这项收益随时间的衰减程度，我称之为“收益半衰期”,半衰期时间长的，其影响也就越持久。</p>\n<p>做事判断的两个标准：<br>1.收益值的高低无关紧要，只要不是做短半衰期的事情，这只要这个收益可以被累加，就尽管去做。<br>2.不要只盯着“高大上”的事情，一些不重要，不紧急的事情，只要对你的长期有益处，仍旧可以去做。</p>\n<p>因此，这个万能钥匙是这样的：</p>\n<p>当你遇到锁头的时候，要想到你应该去别的地方找钥匙……</p>\n<p>这也正体现了多维度思考的一个方面这把万能钥匙用法很多。<br>比如，很多人苦恼自己的英语遇到了瓶颈，其实钥匙并不在其他地方，而在于你自己本身的语文（母语）就很差；很多父母苦恼：“孩子怎么这么没耐心呢？”其实他们作为父母就是没有耐心的；甚至，很多人认为“这个世界太不公平了”的人，其实没想过那很可能不是这个世界的问题，甚至不是公平不公平的问题，而是TA是否配得上被公平对待的问题……</p>\n<p>其实自己在英语听力方面很差，确实问题有可能不是出在听上面，而是出在说上面。道理很简单：只要说的出，就能听得懂。所以听说双管齐下也许会好一点。<br>这是放在哪门语言都通用的道理。你甚至不需要说的很标准就可以听得懂，这就好比我们很多地区的人普通话不标准，但是几乎没有人抱怨过听不懂新闻联播。</p>\n","site":{"data":{}},"excerpt":"<p>当你遇到一扇被锁着的门，你应该去哪里找钥匙？尽管不知道到底去哪找，但是不应该只盯着锁头看，是吧？</p>","more":"<p>当我们遇到任何问题的时候，也是一样的道理。只盯着问题看，只盯着问题想，盯着问题找解决方案往往都是以无奈告终的。</p>\n<p>但在实际生活中，我们的注意力除了被各种娱乐新闻占据之外，还有很大一部分被“困扰我们的问题”所占据。</p>\n<p>而我们投入了大量注意力了之后，之所以最终收效甚微，很大程度上是因为我们关注点仅仅放在了问题本身上。这其实也是一种用蛮力解决问题的表现。<br>之所以说的“学习学习再学习“，也就是希望你用对力的方向。如果方向错了，越努力就可能结果越糟。</p>\n<p>一旦你遇到问题发现自己正在“之盯着问题本身思考”的时候，你的元认知能力应该被激活。让它告诉自己：</p>\n<p><strong>不对，我得把我的注意力从问题本身移开，因为解决方案肯定在其他地方。</strong></p>\n<p>调用元认知能力就想系统的“自动弹窗”一样。，知道了训练方法，了解了原理还不够，最重要的是要让它成为一种本能反应。这必须要经过刻意训练才能完成。<br>这就好像你升级了操作系统，但不去使用，而对新功能不闻不问。那这和没有更新其实一样，甚至更糟。</p>\n<p>其实不光是我们的元认知能力。回想之前的内容，有多少概念已经模糊，甚至不记得了，及时回顾之前的知识，使其成为自己的习惯。</p>\n<p>一个最好笑的例子是，谈恋爱这事儿，真的很锻炼元认知能力，也很需要元认知能力。明明刚才还好好的，怎么突然之间女朋友就变脸了？！最大的苦恼就是：</p>\n<p>女生怎么不能就事论事呢？</p>\n<p>其实调换一下角度也是如此，本质上跟性别没有必然的逻辑锁定关系。另，别觉得谈恋爱跟长期开开心心谈恋爱，就会省出很多用来伤心难过的时间去做正事，这其实跟财富也是有很多必然相关性的,在这点上还是强烈认同的。</p>\n<p>遇到了必须解决的问题，别人盯着问题看，我却能想明白应该去别的地方找钥匙：管好自己就行了，想办法做正确的事情，这个最重要；然后再想办法找正确的方式,哪怕做事的方式错了也不所谓，那毕竟是可以修正的；哪怕效率低下一点也可以接受，毕竟只要做了就有累积。</p>\n<p>很多人说，自己没有那么多的积累，现在没有办法找到合适的钥匙。</p>\n<p>其实没有人一开始就能轻松打开困扰自己的锁头，更别说有足够多的领域去寻找自己需要的钥匙了。</p>\n<p>比如说，心理学虽然是个隐藏大量钥匙的地方，如果你没有“找钥匙”概念，即便读到了一些内容，你也不会应用到生活中来。<br>所以，平时就要养成自己的记录习惯。</p>\n<p>不论是遇到什么锁头，还是什么钥匙，都要记得记录下来，不断的回顾总结。</p>\n<p>赚钱这事也一样。民间早有这样的说法：<strong>你追钱，追不上钱；钱追你，你跑不掉…</strong>别人都盯着钱看，这确实是个问题，但我觉得最终的解决方案一定在其他地方，最终，我认定能力最重要，盯着自己的能力看，盯着自己的能力成长才是真正的“钥匙”啊。</p>\n<p>这也正是为什么自由之路不谈钱的原因。总盯着钱的人，通常赚不到钱。真正赚到钱的人，通常会把注意力放到自身能力的提高上。我相信这一点，这也是我常常记录博客的原因。</p>\n<p>如果你能合理使用自己的注意力，试着活在未来，并且刻意打磨自己的元认知能力，估计不想要赚到钱也很难。</p>\n<p>在起点上，自己确实是有缺点的，可能落后于他人许多，但只要处在正确的学习状态，每天进步一点点的人，都是在不断的累积，正在一点点的变好。</p>\n<p>最近在《精进：如何成为一个很厉害的人》里面也正有提到这个事情，分析一件事情值不值得去做，花多少精力去做的时候，可以从两个角度评估：一是这件事在当下将给我带来的收益的大小，这个收益可以是心智、情感层面的，也可以是身体、物质层面的，我称之为“收益值”，二是这项收益随时间的衰减程度，我称之为“收益半衰期”,半衰期时间长的，其影响也就越持久。</p>\n<p>做事判断的两个标准：<br>1.收益值的高低无关紧要，只要不是做短半衰期的事情，这只要这个收益可以被累加，就尽管去做。<br>2.不要只盯着“高大上”的事情，一些不重要，不紧急的事情，只要对你的长期有益处，仍旧可以去做。</p>\n<p>因此，这个万能钥匙是这样的：</p>\n<p>当你遇到锁头的时候，要想到你应该去别的地方找钥匙……</p>\n<p>这也正体现了多维度思考的一个方面这把万能钥匙用法很多。<br>比如，很多人苦恼自己的英语遇到了瓶颈，其实钥匙并不在其他地方，而在于你自己本身的语文（母语）就很差；很多父母苦恼：“孩子怎么这么没耐心呢？”其实他们作为父母就是没有耐心的；甚至，很多人认为“这个世界太不公平了”的人，其实没想过那很可能不是这个世界的问题，甚至不是公平不公平的问题，而是TA是否配得上被公平对待的问题……</p>\n<p>其实自己在英语听力方面很差，确实问题有可能不是出在听上面，而是出在说上面。道理很简单：只要说的出，就能听得懂。所以听说双管齐下也许会好一点。<br>这是放在哪门语言都通用的道理。你甚至不需要说的很标准就可以听得懂，这就好比我们很多地区的人普通话不标准，但是几乎没有人抱怨过听不懂新闻联播。</p>"},{"title":"手动下载github Desktop","date":"2016-11-28T16:34:50.000Z","_content":"\n`github Desktop`是`github`推出的桌面版图形界面，由于最近我升了win10，就需要重新下载`github Desktop`，又要经历一遍痛苦的过程。为什么说是痛苦的呢？安装的时候一直卡在下载界面，下了几十兆就断开连接，又要重新开始。挂vpn，加host，加信任站点，能试的都试了一遍，还是不行。关于这个[问题](https://www.zhihu.com/question/23110947),轮子哥说的好，“我也遇到过这种问题，后来我解决了他，方法就是：明天再说。”看到知乎里有大神自己手动下载下来了github离线版，可是就是不甘心啊，想要自己来试试这个过程，也顺便做个记录。\n<!-- more -->\n通过一些搜寻，还是找到一些方法的。可以先下载`http://github-windows.s3.amazonaws.com/GitHub.application`(直接在网页打开并下载)，接下来运行`GitHub.application`，会发现报错了。原因是没有找到`GitHub.exe.manifest`，继续找了对应的url，也进行了下载并放在了其目录下。一开始并不知道`GitHub.exe.manifest`的作用，还是傻瓜式的报错下文件，但参考了[姚泽源](http://www.yaozeyuan.online/2015/10/02/2015%E5%B9%B410%E6%9C%882%E6%97%A5081458-github-windows%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E7%89%88/)所说的内容之后，我开始查看其源码。\n\n发现其`file`格式里的`name`和`codebase`里的内容即为文件名，于是通过正则`codebase=\"(.*?)\"`匹配得到了所有的文件名。\n![正则匹配文件名](http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161128/234440549.png)\n\n然后，将其匹配出来的复制到另一个文本中。图中仅仅是`codebase`的部分内容。\n![codebase的部分内容](http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161129/002029641.png)\n\n再使用正则将其改为URL格式，再用迅雷进行下载。\n![mark](http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161129/002153759.png)\n其中会出现有部分文件无法下载，可用浏览器下载并放在对应目录下。\n\n以下是我[最新版github离线版安装包](http://pan.baidu.com/s/1i59bG1n)可以直接下载。","source":"_posts/通用杂货/手动下载github Desktop.md","raw":"---\ntitle: 手动下载github Desktop\ndate: 2016-11-29 00:34:50\ntags: \n- github\ncategories: 总结\n---\n\n`github Desktop`是`github`推出的桌面版图形界面，由于最近我升了win10，就需要重新下载`github Desktop`，又要经历一遍痛苦的过程。为什么说是痛苦的呢？安装的时候一直卡在下载界面，下了几十兆就断开连接，又要重新开始。挂vpn，加host，加信任站点，能试的都试了一遍，还是不行。关于这个[问题](https://www.zhihu.com/question/23110947),轮子哥说的好，“我也遇到过这种问题，后来我解决了他，方法就是：明天再说。”看到知乎里有大神自己手动下载下来了github离线版，可是就是不甘心啊，想要自己来试试这个过程，也顺便做个记录。\n<!-- more -->\n通过一些搜寻，还是找到一些方法的。可以先下载`http://github-windows.s3.amazonaws.com/GitHub.application`(直接在网页打开并下载)，接下来运行`GitHub.application`，会发现报错了。原因是没有找到`GitHub.exe.manifest`，继续找了对应的url，也进行了下载并放在了其目录下。一开始并不知道`GitHub.exe.manifest`的作用，还是傻瓜式的报错下文件，但参考了[姚泽源](http://www.yaozeyuan.online/2015/10/02/2015%E5%B9%B410%E6%9C%882%E6%97%A5081458-github-windows%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E7%89%88/)所说的内容之后，我开始查看其源码。\n\n发现其`file`格式里的`name`和`codebase`里的内容即为文件名，于是通过正则`codebase=\"(.*?)\"`匹配得到了所有的文件名。\n![正则匹配文件名](http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161128/234440549.png)\n\n然后，将其匹配出来的复制到另一个文本中。图中仅仅是`codebase`的部分内容。\n![codebase的部分内容](http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161129/002029641.png)\n\n再使用正则将其改为URL格式，再用迅雷进行下载。\n![mark](http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161129/002153759.png)\n其中会出现有部分文件无法下载，可用浏览器下载并放在对应目录下。\n\n以下是我[最新版github离线版安装包](http://pan.baidu.com/s/1i59bG1n)可以直接下载。","slug":"通用杂货/手动下载github Desktop","published":1,"updated":"2019-03-22T14:44:36.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxt005h4l3nft348wgo","content":"<p><code>github Desktop</code>是<code>github</code>推出的桌面版图形界面，由于最近我升了win10，就需要重新下载<code>github Desktop</code>，又要经历一遍痛苦的过程。为什么说是痛苦的呢？安装的时候一直卡在下载界面，下了几十兆就断开连接，又要重新开始。挂vpn，加host，加信任站点，能试的都试了一遍，还是不行。关于这个<a href=\"https://www.zhihu.com/question/23110947\" target=\"_blank\" rel=\"noopener\">问题</a>,轮子哥说的好，“我也遇到过这种问题，后来我解决了他，方法就是：明天再说。”看到知乎里有大神自己手动下载下来了github离线版，可是就是不甘心啊，想要自己来试试这个过程，也顺便做个记录。<br><a id=\"more\"></a><br>通过一些搜寻，还是找到一些方法的。可以先下载<code>http://github-windows.s3.amazonaws.com/GitHub.application</code>(直接在网页打开并下载)，接下来运行<code>GitHub.application</code>，会发现报错了。原因是没有找到<code>GitHub.exe.manifest</code>，继续找了对应的url，也进行了下载并放在了其目录下。一开始并不知道<code>GitHub.exe.manifest</code>的作用，还是傻瓜式的报错下文件，但参考了<a href=\"http://www.yaozeyuan.online/2015/10/02/2015%E5%B9%B410%E6%9C%882%E6%97%A5081458-github-windows%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E7%89%88/\" target=\"_blank\" rel=\"noopener\">姚泽源</a>所说的内容之后，我开始查看其源码。</p>\n<p>发现其<code>file</code>格式里的<code>name</code>和<code>codebase</code>里的内容即为文件名，于是通过正则<code>codebase=&quot;(.*?)&quot;</code>匹配得到了所有的文件名。<br><img src=\"http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161128/234440549.png\" alt=\"正则匹配文件名\"></p>\n<p>然后，将其匹配出来的复制到另一个文本中。图中仅仅是<code>codebase</code>的部分内容。<br><img src=\"http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161129/002029641.png\" alt=\"codebase的部分内容\"></p>\n<p>再使用正则将其改为URL格式，再用迅雷进行下载。<br><img src=\"http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161129/002153759.png\" alt=\"mark\"><br>其中会出现有部分文件无法下载，可用浏览器下载并放在对应目录下。</p>\n<p>以下是我<a href=\"http://pan.baidu.com/s/1i59bG1n\" target=\"_blank\" rel=\"noopener\">最新版github离线版安装包</a>可以直接下载。</p>\n","site":{"data":{}},"excerpt":"<p><code>github Desktop</code>是<code>github</code>推出的桌面版图形界面，由于最近我升了win10，就需要重新下载<code>github Desktop</code>，又要经历一遍痛苦的过程。为什么说是痛苦的呢？安装的时候一直卡在下载界面，下了几十兆就断开连接，又要重新开始。挂vpn，加host，加信任站点，能试的都试了一遍，还是不行。关于这个<a href=\"https://www.zhihu.com/question/23110947\" target=\"_blank\" rel=\"noopener\">问题</a>,轮子哥说的好，“我也遇到过这种问题，后来我解决了他，方法就是：明天再说。”看到知乎里有大神自己手动下载下来了github离线版，可是就是不甘心啊，想要自己来试试这个过程，也顺便做个记录。<br></p>","more":"<br>通过一些搜寻，还是找到一些方法的。可以先下载<code>http://github-windows.s3.amazonaws.com/GitHub.application</code>(直接在网页打开并下载)，接下来运行<code>GitHub.application</code>，会发现报错了。原因是没有找到<code>GitHub.exe.manifest</code>，继续找了对应的url，也进行了下载并放在了其目录下。一开始并不知道<code>GitHub.exe.manifest</code>的作用，还是傻瓜式的报错下文件，但参考了<a href=\"http://www.yaozeyuan.online/2015/10/02/2015%E5%B9%B410%E6%9C%882%E6%97%A5081458-github-windows%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%A6%BB%E7%BA%BF%E5%AE%89%E8%A3%85%E7%89%88/\" target=\"_blank\" rel=\"noopener\">姚泽源</a>所说的内容之后，我开始查看其源码。<p></p>\n<p>发现其<code>file</code>格式里的<code>name</code>和<code>codebase</code>里的内容即为文件名，于是通过正则<code>codebase=&quot;(.*?)&quot;</code>匹配得到了所有的文件名。<br><img src=\"http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161128/234440549.png\" alt=\"正则匹配文件名\"></p>\n<p>然后，将其匹配出来的复制到另一个文本中。图中仅仅是<code>codebase</code>的部分内容。<br><img src=\"http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161129/002029641.png\" alt=\"codebase的部分内容\"></p>\n<p>再使用正则将其改为URL格式，再用迅雷进行下载。<br><img src=\"http://7xsp7y.com1.z0.glb.clouddn.com/blog/20161129/002153759.png\" alt=\"mark\"><br>其中会出现有部分文件无法下载，可用浏览器下载并放在对应目录下。</p>\n<p>以下是我<a href=\"http://pan.baidu.com/s/1i59bG1n\" target=\"_blank\" rel=\"noopener\">最新版github离线版安装包</a>可以直接下载。</p>"},{"title":"Buy America. I am.","date":"2018-10-13T15:34:50.000Z","_content":"\n2018年10月12号,上证指数2606.91点,偶然看到巴菲特2008年全球金融危机高潮的时候发表在纽约时报上的一篇特约文章,做个记录。\n<!-- more -->\n### Buy America. I am. \n\nA simple rule dictates my buying: Be fearful when others are greedy, and be greedy when others are fearful. And most certainly, fear is now widespread, gripping even seasoned investors. To be sure, investors are right to be wary of highly leveraged entities or businesses in weak competitive positions. But fears regarding the long-term prosperity of the nation’s many sound companies make no sense. These businesses will indeed suffer earnings hiccups, as they always have. But most major companies will be setting new profit records 5, 10 and 20 years from now.\n\n我买入的一个简单规则是： 别人恐慌的时候我贪婪,别人贪婪的时候我恐慌.显然,如今恐慌已经充斥着整个市场,老投资者们也不例外。 说实话，对于那些背负着高杠杆应处于竞争劣势的公司或者实体来说,保持警惕是对的；但是大多数美国公司经营状况良好,长期前景光明，这种担心毫无道理。尽管短期内可能会暂时陷入困境，但是如果把眼光拉长到5年、10年、20年，这些公司一定会创造新的营收记录。\n\nLet me be clear on one point: I can’t predict the short-term movements of the stock market. I haven’t the faintest idea as to whether stocks will be higher or lower a month — or a year — from now. What is likely, however, is that the market will move higher, perhaps substantially so, well before either sentiment or the economy turns up. So if you wait for the robins, spring will be over.\n\n重要的事情说三遍：我无法预测短期市场的走势。1个月、甚至1年以后市场是涨是跌，我毫无头绪。然而，在情绪或经济的基本面好转之前，股市一定已经开始上涨，甚至大幅上涨了。如果等待知更鸟的叫声，你将错过整个春天。\n\nA little history here: During the Depression, the Dow hit its low, 41, on July 8, 1932. Economic conditions, though, kept deteriorating until Franklin D. Roosevelt took office in March 1933. By that time, the market had already advanced 30 percent. Or think back to the early days of World War II, when things were going badly for the United States in Europe and the Pacific. The market hit bottom in April 1942, well before Allied fortunes turned. Again, in the early 1980s, the time to buy stocks was when inflation raged and the economy was in the tank. In short, bad news is an investor’s best friend. It lets you buy a slice of America’s future at a marked-down price.\n\n回顾历史：大萧条时期，1932年7月8日，道指跌到41点，创下当时的历史新低。之后，经济情况继续恶化，直到罗斯福在1933年3月上任，美国经济开始企稳上升，而这时美国股市已经上涨了30%；再让我们把目光投到二战时期，我们在欧洲和太平洋战局不利，1942年4月，股市触底开始上涨，后来同盟国才扭转颓势；通胀充斥的80年代也是如此。总之，坏消息是投资者的好朋友，它让你有机会以打折价买一份美国的未来。\n\nOver the long term, the stock market news will be good. In the 20th century, the United States endured two world wars and other traumatic and expensive military conflicts; the Depression; a dozen or so recessions and financial panics; oil shocks; a flu epidemic; and the resignation of a disgraced president. Yet the Dow rose from 66 to 11,497.\n\n长期来看，股市带来的都是好消息。20世纪，美国经历了两次世界大战，还有其它大大小小的军事冲突；美国经历了大萧条，还有其它大大小小几十次经济衰退和金融危机。其它还有石油危机、世纪大流感、总统丑闻辞职等等。然而，道指从66点上升到11497点。\n\nYou might think it would have been impossible for an investor to lose money during a century marked by such an extraordinary gain. But some investors did. The hapless ones bought stocks only when they felt comfort in doing so and then proceeded to sell when the headlines made them queasy.\n\n这么大的涨幅，你可能觉得投资者不可能亏钱。恰恰相反。有些倒霉鬼亏了钱：当媒体欢欣鼓舞的时候，他们买入；而当头条充斥着坏消息的时候，他们卖出。\n\nToday people who hold cash equivalents feel comfortable. They shouldn’t. They have opted for a terrible long-term asset, one that pays virtually nothing and is certain to depreciate in value. Indeed, the policies that government will follow in its efforts to alleviate the current crisis will probably prove inflationary and therefore accelerate declines in the real value of cash accounts.\n\n现在，许多人持有现金感到安心。他们错了。长期来看，现金不能创造利润，只会贬值，是一种不值得长期持有的资产。而且，政府为缓解危机所制定的一些政策很可能导致通胀加剧，从而加快现金的真实价值贬损的速度。\n\nEquities will almost certainly outperform cash over the next decade, probably by a substantial degree. Those investors who cling now to cash are betting they can efficiently time their move away from it later. In waiting for the comfort of good news, they are ignoring Wayne Gretzky’s advice: “I skate to where the puck is going to be, not to where it has been.”\n\n未来10年（孟岩注：现在刚好是验证时刻），股票几乎肯定会战胜现金，很可能是大幅战胜。有些手持现金的投资者在赌更好的时机。他们在等待好消息的时候，忘了冰球之王韦恩 · 格雷茨基 ( Wayne Gretzky ) 的建议：“我总是滑向冰球要去的地方，而非冰球现在的位置”。\n\nI don’t like to opine on the stock market, and again I emphasize that I have no idea what the market will do in the short term. Nevertheless, I’ll follow the lead of a restaurant that opened in an empty bank building and then advertised: “Put your mouth where your money was.” Today my money and my mouth both say equities.\n\n我一般不喜欢谈论股市，我再强调一下我对短期股市的涨跌一无所知。然而，我愿意效仿一则在银行大厦里新开的餐馆的广告：“Put your mouth where your money was.”（孟岩注：这句话是个双关，来自 “Put your money where your mouth was.”，意味着 “口说无凭，行胜于言”）。行胜于言，我今天真金白银的买入了美国的未来。\n\n### 实证\n十年前的十月份，是金融危机最为恐慌的时候。从2008年的1月到2008年的10月份，道琼斯指数下跌了40%左右，自2004年以后首次跌破10000点，\n\n巴菲特的文章发表后，道琼斯继续跌了6个月左右，当时的中文媒体世界充斥着各种各样的文章，标题无外乎“巴菲特老了”，“巴菲特也被套”。是的，在短视的人眼中，巴菲特被套了。在他发文后美国股市继续下跌，直到2009年3月份，创下6600点的最低点。\n\n时隔10年，截至昨天收盘，道琼斯指数收在25000点。从巴菲特的公开信到现在，刚好10年的时间，指数的年化收益率在 `13% `左右。","source":"_posts/通用杂货/buying_Amercia.md","raw":"---\ntitle: Buy America. I am.\ndate: 2018-10-13 23:34:50\ntags: \n- 总结\ncategories: 总结\n---\n\n2018年10月12号,上证指数2606.91点,偶然看到巴菲特2008年全球金融危机高潮的时候发表在纽约时报上的一篇特约文章,做个记录。\n<!-- more -->\n### Buy America. I am. \n\nA simple rule dictates my buying: Be fearful when others are greedy, and be greedy when others are fearful. And most certainly, fear is now widespread, gripping even seasoned investors. To be sure, investors are right to be wary of highly leveraged entities or businesses in weak competitive positions. But fears regarding the long-term prosperity of the nation’s many sound companies make no sense. These businesses will indeed suffer earnings hiccups, as they always have. But most major companies will be setting new profit records 5, 10 and 20 years from now.\n\n我买入的一个简单规则是： 别人恐慌的时候我贪婪,别人贪婪的时候我恐慌.显然,如今恐慌已经充斥着整个市场,老投资者们也不例外。 说实话，对于那些背负着高杠杆应处于竞争劣势的公司或者实体来说,保持警惕是对的；但是大多数美国公司经营状况良好,长期前景光明，这种担心毫无道理。尽管短期内可能会暂时陷入困境，但是如果把眼光拉长到5年、10年、20年，这些公司一定会创造新的营收记录。\n\nLet me be clear on one point: I can’t predict the short-term movements of the stock market. I haven’t the faintest idea as to whether stocks will be higher or lower a month — or a year — from now. What is likely, however, is that the market will move higher, perhaps substantially so, well before either sentiment or the economy turns up. So if you wait for the robins, spring will be over.\n\n重要的事情说三遍：我无法预测短期市场的走势。1个月、甚至1年以后市场是涨是跌，我毫无头绪。然而，在情绪或经济的基本面好转之前，股市一定已经开始上涨，甚至大幅上涨了。如果等待知更鸟的叫声，你将错过整个春天。\n\nA little history here: During the Depression, the Dow hit its low, 41, on July 8, 1932. Economic conditions, though, kept deteriorating until Franklin D. Roosevelt took office in March 1933. By that time, the market had already advanced 30 percent. Or think back to the early days of World War II, when things were going badly for the United States in Europe and the Pacific. The market hit bottom in April 1942, well before Allied fortunes turned. Again, in the early 1980s, the time to buy stocks was when inflation raged and the economy was in the tank. In short, bad news is an investor’s best friend. It lets you buy a slice of America’s future at a marked-down price.\n\n回顾历史：大萧条时期，1932年7月8日，道指跌到41点，创下当时的历史新低。之后，经济情况继续恶化，直到罗斯福在1933年3月上任，美国经济开始企稳上升，而这时美国股市已经上涨了30%；再让我们把目光投到二战时期，我们在欧洲和太平洋战局不利，1942年4月，股市触底开始上涨，后来同盟国才扭转颓势；通胀充斥的80年代也是如此。总之，坏消息是投资者的好朋友，它让你有机会以打折价买一份美国的未来。\n\nOver the long term, the stock market news will be good. In the 20th century, the United States endured two world wars and other traumatic and expensive military conflicts; the Depression; a dozen or so recessions and financial panics; oil shocks; a flu epidemic; and the resignation of a disgraced president. Yet the Dow rose from 66 to 11,497.\n\n长期来看，股市带来的都是好消息。20世纪，美国经历了两次世界大战，还有其它大大小小的军事冲突；美国经历了大萧条，还有其它大大小小几十次经济衰退和金融危机。其它还有石油危机、世纪大流感、总统丑闻辞职等等。然而，道指从66点上升到11497点。\n\nYou might think it would have been impossible for an investor to lose money during a century marked by such an extraordinary gain. But some investors did. The hapless ones bought stocks only when they felt comfort in doing so and then proceeded to sell when the headlines made them queasy.\n\n这么大的涨幅，你可能觉得投资者不可能亏钱。恰恰相反。有些倒霉鬼亏了钱：当媒体欢欣鼓舞的时候，他们买入；而当头条充斥着坏消息的时候，他们卖出。\n\nToday people who hold cash equivalents feel comfortable. They shouldn’t. They have opted for a terrible long-term asset, one that pays virtually nothing and is certain to depreciate in value. Indeed, the policies that government will follow in its efforts to alleviate the current crisis will probably prove inflationary and therefore accelerate declines in the real value of cash accounts.\n\n现在，许多人持有现金感到安心。他们错了。长期来看，现金不能创造利润，只会贬值，是一种不值得长期持有的资产。而且，政府为缓解危机所制定的一些政策很可能导致通胀加剧，从而加快现金的真实价值贬损的速度。\n\nEquities will almost certainly outperform cash over the next decade, probably by a substantial degree. Those investors who cling now to cash are betting they can efficiently time their move away from it later. In waiting for the comfort of good news, they are ignoring Wayne Gretzky’s advice: “I skate to where the puck is going to be, not to where it has been.”\n\n未来10年（孟岩注：现在刚好是验证时刻），股票几乎肯定会战胜现金，很可能是大幅战胜。有些手持现金的投资者在赌更好的时机。他们在等待好消息的时候，忘了冰球之王韦恩 · 格雷茨基 ( Wayne Gretzky ) 的建议：“我总是滑向冰球要去的地方，而非冰球现在的位置”。\n\nI don’t like to opine on the stock market, and again I emphasize that I have no idea what the market will do in the short term. Nevertheless, I’ll follow the lead of a restaurant that opened in an empty bank building and then advertised: “Put your mouth where your money was.” Today my money and my mouth both say equities.\n\n我一般不喜欢谈论股市，我再强调一下我对短期股市的涨跌一无所知。然而，我愿意效仿一则在银行大厦里新开的餐馆的广告：“Put your mouth where your money was.”（孟岩注：这句话是个双关，来自 “Put your money where your mouth was.”，意味着 “口说无凭，行胜于言”）。行胜于言，我今天真金白银的买入了美国的未来。\n\n### 实证\n十年前的十月份，是金融危机最为恐慌的时候。从2008年的1月到2008年的10月份，道琼斯指数下跌了40%左右，自2004年以后首次跌破10000点，\n\n巴菲特的文章发表后，道琼斯继续跌了6个月左右，当时的中文媒体世界充斥着各种各样的文章，标题无外乎“巴菲特老了”，“巴菲特也被套”。是的，在短视的人眼中，巴菲特被套了。在他发文后美国股市继续下跌，直到2009年3月份，创下6600点的最低点。\n\n时隔10年，截至昨天收盘，道琼斯指数收在25000点。从巴菲特的公开信到现在，刚好10年的时间，指数的年化收益率在 `13% `左右。","slug":"通用杂货/buying_Amercia","published":1,"updated":"2019-03-22T14:44:36.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxu005j4l3nvyiohtus","content":"<p>2018年10月12号,上证指数2606.91点,偶然看到巴菲特2008年全球金融危机高潮的时候发表在纽约时报上的一篇特约文章,做个记录。<br><a id=\"more\"></a></p>\n<h3 id=\"Buy-America-I-am\"><a href=\"#Buy-America-I-am\" class=\"headerlink\" title=\"Buy America. I am.\"></a>Buy America. I am.</h3><p>A simple rule dictates my buying: Be fearful when others are greedy, and be greedy when others are fearful. And most certainly, fear is now widespread, gripping even seasoned investors. To be sure, investors are right to be wary of highly leveraged entities or businesses in weak competitive positions. But fears regarding the long-term prosperity of the nation’s many sound companies make no sense. These businesses will indeed suffer earnings hiccups, as they always have. But most major companies will be setting new profit records 5, 10 and 20 years from now.</p>\n<p>我买入的一个简单规则是： 别人恐慌的时候我贪婪,别人贪婪的时候我恐慌.显然,如今恐慌已经充斥着整个市场,老投资者们也不例外。 说实话，对于那些背负着高杠杆应处于竞争劣势的公司或者实体来说,保持警惕是对的；但是大多数美国公司经营状况良好,长期前景光明，这种担心毫无道理。尽管短期内可能会暂时陷入困境，但是如果把眼光拉长到5年、10年、20年，这些公司一定会创造新的营收记录。</p>\n<p>Let me be clear on one point: I can’t predict the short-term movements of the stock market. I haven’t the faintest idea as to whether stocks will be higher or lower a month — or a year — from now. What is likely, however, is that the market will move higher, perhaps substantially so, well before either sentiment or the economy turns up. So if you wait for the robins, spring will be over.</p>\n<p>重要的事情说三遍：我无法预测短期市场的走势。1个月、甚至1年以后市场是涨是跌，我毫无头绪。然而，在情绪或经济的基本面好转之前，股市一定已经开始上涨，甚至大幅上涨了。如果等待知更鸟的叫声，你将错过整个春天。</p>\n<p>A little history here: During the Depression, the Dow hit its low, 41, on July 8, 1932. Economic conditions, though, kept deteriorating until Franklin D. Roosevelt took office in March 1933. By that time, the market had already advanced 30 percent. Or think back to the early days of World War II, when things were going badly for the United States in Europe and the Pacific. The market hit bottom in April 1942, well before Allied fortunes turned. Again, in the early 1980s, the time to buy stocks was when inflation raged and the economy was in the tank. In short, bad news is an investor’s best friend. It lets you buy a slice of America’s future at a marked-down price.</p>\n<p>回顾历史：大萧条时期，1932年7月8日，道指跌到41点，创下当时的历史新低。之后，经济情况继续恶化，直到罗斯福在1933年3月上任，美国经济开始企稳上升，而这时美国股市已经上涨了30%；再让我们把目光投到二战时期，我们在欧洲和太平洋战局不利，1942年4月，股市触底开始上涨，后来同盟国才扭转颓势；通胀充斥的80年代也是如此。总之，坏消息是投资者的好朋友，它让你有机会以打折价买一份美国的未来。</p>\n<p>Over the long term, the stock market news will be good. In the 20th century, the United States endured two world wars and other traumatic and expensive military conflicts; the Depression; a dozen or so recessions and financial panics; oil shocks; a flu epidemic; and the resignation of a disgraced president. Yet the Dow rose from 66 to 11,497.</p>\n<p>长期来看，股市带来的都是好消息。20世纪，美国经历了两次世界大战，还有其它大大小小的军事冲突；美国经历了大萧条，还有其它大大小小几十次经济衰退和金融危机。其它还有石油危机、世纪大流感、总统丑闻辞职等等。然而，道指从66点上升到11497点。</p>\n<p>You might think it would have been impossible for an investor to lose money during a century marked by such an extraordinary gain. But some investors did. The hapless ones bought stocks only when they felt comfort in doing so and then proceeded to sell when the headlines made them queasy.</p>\n<p>这么大的涨幅，你可能觉得投资者不可能亏钱。恰恰相反。有些倒霉鬼亏了钱：当媒体欢欣鼓舞的时候，他们买入；而当头条充斥着坏消息的时候，他们卖出。</p>\n<p>Today people who hold cash equivalents feel comfortable. They shouldn’t. They have opted for a terrible long-term asset, one that pays virtually nothing and is certain to depreciate in value. Indeed, the policies that government will follow in its efforts to alleviate the current crisis will probably prove inflationary and therefore accelerate declines in the real value of cash accounts.</p>\n<p>现在，许多人持有现金感到安心。他们错了。长期来看，现金不能创造利润，只会贬值，是一种不值得长期持有的资产。而且，政府为缓解危机所制定的一些政策很可能导致通胀加剧，从而加快现金的真实价值贬损的速度。</p>\n<p>Equities will almost certainly outperform cash over the next decade, probably by a substantial degree. Those investors who cling now to cash are betting they can efficiently time their move away from it later. In waiting for the comfort of good news, they are ignoring Wayne Gretzky’s advice: “I skate to where the puck is going to be, not to where it has been.”</p>\n<p>未来10年（孟岩注：现在刚好是验证时刻），股票几乎肯定会战胜现金，很可能是大幅战胜。有些手持现金的投资者在赌更好的时机。他们在等待好消息的时候，忘了冰球之王韦恩 · 格雷茨基 ( Wayne Gretzky ) 的建议：“我总是滑向冰球要去的地方，而非冰球现在的位置”。</p>\n<p>I don’t like to opine on the stock market, and again I emphasize that I have no idea what the market will do in the short term. Nevertheless, I’ll follow the lead of a restaurant that opened in an empty bank building and then advertised: “Put your mouth where your money was.” Today my money and my mouth both say equities.</p>\n<p>我一般不喜欢谈论股市，我再强调一下我对短期股市的涨跌一无所知。然而，我愿意效仿一则在银行大厦里新开的餐馆的广告：“Put your mouth where your money was.”（孟岩注：这句话是个双关，来自 “Put your money where your mouth was.”，意味着 “口说无凭，行胜于言”）。行胜于言，我今天真金白银的买入了美国的未来。</p>\n<h3 id=\"实证\"><a href=\"#实证\" class=\"headerlink\" title=\"实证\"></a>实证</h3><p>十年前的十月份，是金融危机最为恐慌的时候。从2008年的1月到2008年的10月份，道琼斯指数下跌了40%左右，自2004年以后首次跌破10000点，</p>\n<p>巴菲特的文章发表后，道琼斯继续跌了6个月左右，当时的中文媒体世界充斥着各种各样的文章，标题无外乎“巴菲特老了”，“巴菲特也被套”。是的，在短视的人眼中，巴菲特被套了。在他发文后美国股市继续下跌，直到2009年3月份，创下6600点的最低点。</p>\n<p>时隔10年，截至昨天收盘，道琼斯指数收在25000点。从巴菲特的公开信到现在，刚好10年的时间，指数的年化收益率在 <code>13%</code>左右。</p>\n","site":{"data":{}},"excerpt":"<p>2018年10月12号,上证指数2606.91点,偶然看到巴菲特2008年全球金融危机高潮的时候发表在纽约时报上的一篇特约文章,做个记录。<br></p>","more":"<p></p>\n<h3 id=\"Buy-America-I-am\"><a href=\"#Buy-America-I-am\" class=\"headerlink\" title=\"Buy America. I am.\"></a>Buy America. I am.</h3><p>A simple rule dictates my buying: Be fearful when others are greedy, and be greedy when others are fearful. And most certainly, fear is now widespread, gripping even seasoned investors. To be sure, investors are right to be wary of highly leveraged entities or businesses in weak competitive positions. But fears regarding the long-term prosperity of the nation’s many sound companies make no sense. These businesses will indeed suffer earnings hiccups, as they always have. But most major companies will be setting new profit records 5, 10 and 20 years from now.</p>\n<p>我买入的一个简单规则是： 别人恐慌的时候我贪婪,别人贪婪的时候我恐慌.显然,如今恐慌已经充斥着整个市场,老投资者们也不例外。 说实话，对于那些背负着高杠杆应处于竞争劣势的公司或者实体来说,保持警惕是对的；但是大多数美国公司经营状况良好,长期前景光明，这种担心毫无道理。尽管短期内可能会暂时陷入困境，但是如果把眼光拉长到5年、10年、20年，这些公司一定会创造新的营收记录。</p>\n<p>Let me be clear on one point: I can’t predict the short-term movements of the stock market. I haven’t the faintest idea as to whether stocks will be higher or lower a month — or a year — from now. What is likely, however, is that the market will move higher, perhaps substantially so, well before either sentiment or the economy turns up. So if you wait for the robins, spring will be over.</p>\n<p>重要的事情说三遍：我无法预测短期市场的走势。1个月、甚至1年以后市场是涨是跌，我毫无头绪。然而，在情绪或经济的基本面好转之前，股市一定已经开始上涨，甚至大幅上涨了。如果等待知更鸟的叫声，你将错过整个春天。</p>\n<p>A little history here: During the Depression, the Dow hit its low, 41, on July 8, 1932. Economic conditions, though, kept deteriorating until Franklin D. Roosevelt took office in March 1933. By that time, the market had already advanced 30 percent. Or think back to the early days of World War II, when things were going badly for the United States in Europe and the Pacific. The market hit bottom in April 1942, well before Allied fortunes turned. Again, in the early 1980s, the time to buy stocks was when inflation raged and the economy was in the tank. In short, bad news is an investor’s best friend. It lets you buy a slice of America’s future at a marked-down price.</p>\n<p>回顾历史：大萧条时期，1932年7月8日，道指跌到41点，创下当时的历史新低。之后，经济情况继续恶化，直到罗斯福在1933年3月上任，美国经济开始企稳上升，而这时美国股市已经上涨了30%；再让我们把目光投到二战时期，我们在欧洲和太平洋战局不利，1942年4月，股市触底开始上涨，后来同盟国才扭转颓势；通胀充斥的80年代也是如此。总之，坏消息是投资者的好朋友，它让你有机会以打折价买一份美国的未来。</p>\n<p>Over the long term, the stock market news will be good. In the 20th century, the United States endured two world wars and other traumatic and expensive military conflicts; the Depression; a dozen or so recessions and financial panics; oil shocks; a flu epidemic; and the resignation of a disgraced president. Yet the Dow rose from 66 to 11,497.</p>\n<p>长期来看，股市带来的都是好消息。20世纪，美国经历了两次世界大战，还有其它大大小小的军事冲突；美国经历了大萧条，还有其它大大小小几十次经济衰退和金融危机。其它还有石油危机、世纪大流感、总统丑闻辞职等等。然而，道指从66点上升到11497点。</p>\n<p>You might think it would have been impossible for an investor to lose money during a century marked by such an extraordinary gain. But some investors did. The hapless ones bought stocks only when they felt comfort in doing so and then proceeded to sell when the headlines made them queasy.</p>\n<p>这么大的涨幅，你可能觉得投资者不可能亏钱。恰恰相反。有些倒霉鬼亏了钱：当媒体欢欣鼓舞的时候，他们买入；而当头条充斥着坏消息的时候，他们卖出。</p>\n<p>Today people who hold cash equivalents feel comfortable. They shouldn’t. They have opted for a terrible long-term asset, one that pays virtually nothing and is certain to depreciate in value. Indeed, the policies that government will follow in its efforts to alleviate the current crisis will probably prove inflationary and therefore accelerate declines in the real value of cash accounts.</p>\n<p>现在，许多人持有现金感到安心。他们错了。长期来看，现金不能创造利润，只会贬值，是一种不值得长期持有的资产。而且，政府为缓解危机所制定的一些政策很可能导致通胀加剧，从而加快现金的真实价值贬损的速度。</p>\n<p>Equities will almost certainly outperform cash over the next decade, probably by a substantial degree. Those investors who cling now to cash are betting they can efficiently time their move away from it later. In waiting for the comfort of good news, they are ignoring Wayne Gretzky’s advice: “I skate to where the puck is going to be, not to where it has been.”</p>\n<p>未来10年（孟岩注：现在刚好是验证时刻），股票几乎肯定会战胜现金，很可能是大幅战胜。有些手持现金的投资者在赌更好的时机。他们在等待好消息的时候，忘了冰球之王韦恩 · 格雷茨基 ( Wayne Gretzky ) 的建议：“我总是滑向冰球要去的地方，而非冰球现在的位置”。</p>\n<p>I don’t like to opine on the stock market, and again I emphasize that I have no idea what the market will do in the short term. Nevertheless, I’ll follow the lead of a restaurant that opened in an empty bank building and then advertised: “Put your mouth where your money was.” Today my money and my mouth both say equities.</p>\n<p>我一般不喜欢谈论股市，我再强调一下我对短期股市的涨跌一无所知。然而，我愿意效仿一则在银行大厦里新开的餐馆的广告：“Put your mouth where your money was.”（孟岩注：这句话是个双关，来自 “Put your money where your mouth was.”，意味着 “口说无凭，行胜于言”）。行胜于言，我今天真金白银的买入了美国的未来。</p>\n<h3 id=\"实证\"><a href=\"#实证\" class=\"headerlink\" title=\"实证\"></a>实证</h3><p>十年前的十月份，是金融危机最为恐慌的时候。从2008年的1月到2008年的10月份，道琼斯指数下跌了40%左右，自2004年以后首次跌破10000点，</p>\n<p>巴菲特的文章发表后，道琼斯继续跌了6个月左右，当时的中文媒体世界充斥着各种各样的文章，标题无外乎“巴菲特老了”，“巴菲特也被套”。是的，在短视的人眼中，巴菲特被套了。在他发文后美国股市继续下跌，直到2009年3月份，创下6600点的最低点。</p>\n<p>时隔10年，截至昨天收盘，道琼斯指数收在25000点。从巴菲特的公开信到现在，刚好10年的时间，指数的年化收益率在 <code>13%</code>左右。</p>"},{"title":"敏捷开发","date":"2018-11-05T12:22:50.000Z","_content":"\n敏捷开发（scrum）是一种软件开发的流程，强调快速反应、快速迭代、价值驱动。\n\n<!-- more -->\n### 价值观\n1. 以价值为向导\n2. 强调以人为本，强调人与人的面对面沟通\n3.  快速响应变化\n\n### 敏捷宣言\n1.个体的交互 胜过 过程和工具\n2.可以工作的软件胜过面面俱到的文档\n3.客户合作胜过合同谈判\n4.响应变化胜过遵循计划\n\n### 与传统模式的区别\n\n传统开发模式以文档为驱动，而敏捷开发提倡少写文档。\n\n传统开发模式下开发人员按照产品文档进行研发，过程中客户不参与到产品的验收和体验中，这样就会导致最后开发出来的成品并不是客户想要的。 而敏捷开发模式从开始就强调客户协作，分步提供产品模块客户体验。\n\n常用的敏捷开发模式有Scrum和Kanban,这边主要讲的是Scrum方法。\n\n### 三种角色\n\n1. `product owner`: 使用者\n2. `Scrum Team`: 多面手\n3. `Scrum Master`： 保证与1,2有效沟通\n\n### 四个事件\n\n1. planning meeting 计划会议 product owner 优先级,价值\n2. Daily Stand Up 每日站立会 15分钟\n3. Project Review 评审会议\n4. Retrospective 回顾会议\n\n### 三种产物\n\n1. Product Backlog 产品代办列表\n2. Sprint Backlog Sprint代办列表\n3. 增量\n\n### 游戏\n意大利面棉花糖叠高塔，强调团队分工协作。","source":"_posts/通用杂货/敏捷开发.md","raw":"---\ntitle: 敏捷开发\ndate: 2018-11-05 20:22:50\ntags: \n- 敏捷开发\ncategories: 总结\n---\n\n敏捷开发（scrum）是一种软件开发的流程，强调快速反应、快速迭代、价值驱动。\n\n<!-- more -->\n### 价值观\n1. 以价值为向导\n2. 强调以人为本，强调人与人的面对面沟通\n3.  快速响应变化\n\n### 敏捷宣言\n1.个体的交互 胜过 过程和工具\n2.可以工作的软件胜过面面俱到的文档\n3.客户合作胜过合同谈判\n4.响应变化胜过遵循计划\n\n### 与传统模式的区别\n\n传统开发模式以文档为驱动，而敏捷开发提倡少写文档。\n\n传统开发模式下开发人员按照产品文档进行研发，过程中客户不参与到产品的验收和体验中，这样就会导致最后开发出来的成品并不是客户想要的。 而敏捷开发模式从开始就强调客户协作，分步提供产品模块客户体验。\n\n常用的敏捷开发模式有Scrum和Kanban,这边主要讲的是Scrum方法。\n\n### 三种角色\n\n1. `product owner`: 使用者\n2. `Scrum Team`: 多面手\n3. `Scrum Master`： 保证与1,2有效沟通\n\n### 四个事件\n\n1. planning meeting 计划会议 product owner 优先级,价值\n2. Daily Stand Up 每日站立会 15分钟\n3. Project Review 评审会议\n4. Retrospective 回顾会议\n\n### 三种产物\n\n1. Product Backlog 产品代办列表\n2. Sprint Backlog Sprint代办列表\n3. 增量\n\n### 游戏\n意大利面棉花糖叠高塔，强调团队分工协作。","slug":"通用杂货/敏捷开发","published":1,"updated":"2019-03-22T14:44:36.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxv005o4l3no2tdgt1r","content":"<p>敏捷开发（scrum）是一种软件开发的流程，强调快速反应、快速迭代、价值驱动。</p>\n<a id=\"more\"></a>\n<h3 id=\"价值观\"><a href=\"#价值观\" class=\"headerlink\" title=\"价值观\"></a>价值观</h3><ol>\n<li>以价值为向导</li>\n<li>强调以人为本，强调人与人的面对面沟通</li>\n<li>快速响应变化</li>\n</ol>\n<h3 id=\"敏捷宣言\"><a href=\"#敏捷宣言\" class=\"headerlink\" title=\"敏捷宣言\"></a>敏捷宣言</h3><p>1.个体的交互 胜过 过程和工具<br>2.可以工作的软件胜过面面俱到的文档<br>3.客户合作胜过合同谈判<br>4.响应变化胜过遵循计划</p>\n<h3 id=\"与传统模式的区别\"><a href=\"#与传统模式的区别\" class=\"headerlink\" title=\"与传统模式的区别\"></a>与传统模式的区别</h3><p>传统开发模式以文档为驱动，而敏捷开发提倡少写文档。</p>\n<p>传统开发模式下开发人员按照产品文档进行研发，过程中客户不参与到产品的验收和体验中，这样就会导致最后开发出来的成品并不是客户想要的。 而敏捷开发模式从开始就强调客户协作，分步提供产品模块客户体验。</p>\n<p>常用的敏捷开发模式有Scrum和Kanban,这边主要讲的是Scrum方法。</p>\n<h3 id=\"三种角色\"><a href=\"#三种角色\" class=\"headerlink\" title=\"三种角色\"></a>三种角色</h3><ol>\n<li><code>product owner</code>: 使用者</li>\n<li><code>Scrum Team</code>: 多面手</li>\n<li><code>Scrum Master</code>： 保证与1,2有效沟通</li>\n</ol>\n<h3 id=\"四个事件\"><a href=\"#四个事件\" class=\"headerlink\" title=\"四个事件\"></a>四个事件</h3><ol>\n<li>planning meeting 计划会议 product owner 优先级,价值</li>\n<li>Daily Stand Up 每日站立会 15分钟</li>\n<li>Project Review 评审会议</li>\n<li>Retrospective 回顾会议</li>\n</ol>\n<h3 id=\"三种产物\"><a href=\"#三种产物\" class=\"headerlink\" title=\"三种产物\"></a>三种产物</h3><ol>\n<li>Product Backlog 产品代办列表</li>\n<li>Sprint Backlog Sprint代办列表</li>\n<li>增量</li>\n</ol>\n<h3 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h3><p>意大利面棉花糖叠高塔，强调团队分工协作。</p>\n","site":{"data":{}},"excerpt":"<p>敏捷开发（scrum）是一种软件开发的流程，强调快速反应、快速迭代、价值驱动。</p>","more":"<h3 id=\"价值观\"><a href=\"#价值观\" class=\"headerlink\" title=\"价值观\"></a>价值观</h3><ol>\n<li>以价值为向导</li>\n<li>强调以人为本，强调人与人的面对面沟通</li>\n<li>快速响应变化</li>\n</ol>\n<h3 id=\"敏捷宣言\"><a href=\"#敏捷宣言\" class=\"headerlink\" title=\"敏捷宣言\"></a>敏捷宣言</h3><p>1.个体的交互 胜过 过程和工具<br>2.可以工作的软件胜过面面俱到的文档<br>3.客户合作胜过合同谈判<br>4.响应变化胜过遵循计划</p>\n<h3 id=\"与传统模式的区别\"><a href=\"#与传统模式的区别\" class=\"headerlink\" title=\"与传统模式的区别\"></a>与传统模式的区别</h3><p>传统开发模式以文档为驱动，而敏捷开发提倡少写文档。</p>\n<p>传统开发模式下开发人员按照产品文档进行研发，过程中客户不参与到产品的验收和体验中，这样就会导致最后开发出来的成品并不是客户想要的。 而敏捷开发模式从开始就强调客户协作，分步提供产品模块客户体验。</p>\n<p>常用的敏捷开发模式有Scrum和Kanban,这边主要讲的是Scrum方法。</p>\n<h3 id=\"三种角色\"><a href=\"#三种角色\" class=\"headerlink\" title=\"三种角色\"></a>三种角色</h3><ol>\n<li><code>product owner</code>: 使用者</li>\n<li><code>Scrum Team</code>: 多面手</li>\n<li><code>Scrum Master</code>： 保证与1,2有效沟通</li>\n</ol>\n<h3 id=\"四个事件\"><a href=\"#四个事件\" class=\"headerlink\" title=\"四个事件\"></a>四个事件</h3><ol>\n<li>planning meeting 计划会议 product owner 优先级,价值</li>\n<li>Daily Stand Up 每日站立会 15分钟</li>\n<li>Project Review 评审会议</li>\n<li>Retrospective 回顾会议</li>\n</ol>\n<h3 id=\"三种产物\"><a href=\"#三种产物\" class=\"headerlink\" title=\"三种产物\"></a>三种产物</h3><ol>\n<li>Product Backlog 产品代办列表</li>\n<li>Sprint Backlog Sprint代办列表</li>\n<li>增量</li>\n</ol>\n<h3 id=\"游戏\"><a href=\"#游戏\" class=\"headerlink\" title=\"游戏\"></a>游戏</h3><p>意大利面棉花糖叠高塔，强调团队分工协作。</p>"},{"title":"《聪明的投资者》读书笔记","date":"2008-11-20T09:35:00.000Z","_content":"\n\n投资操作是以深入分析为基础,确保本金的安全,并获得适当的回报,不满足这些要求的操作就是投机。\n\n\n","source":"_posts/通用杂货/聪明的投资者.md","raw":"---\ntitle: 《聪明的投资者》读书笔记\ndate: 2008-11-20 17:35:00\ntags: \n- 投资\ncategories: 总结\n---\n\n\n投资操作是以深入分析为基础,确保本金的安全,并获得适当的回报,不满足这些要求的操作就是投机。\n\n\n","slug":"通用杂货/聪明的投资者","published":1,"updated":"2019-03-22T14:44:36.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxw005r4l3n7m3m2krh","content":"<p>投资操作是以深入分析为基础,确保本金的安全,并获得适当的回报,不满足这些要求的操作就是投机。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>投资操作是以深入分析为基础,确保本金的安全,并获得适当的回报,不满足这些要求的操作就是投机。</p>\n"},{"title":"神TM矛盾纠结体","date":"2016-10-23T03:23:52.000Z","_content":"\n## 去图书馆\n\n早上起来，睁眼，灰蒙蒙的一片，已经差不多灰了一周的天气了，去图书馆继续学习吧。唉，可天气这么差，床却这么暖。啪一下打醒自己，现在才10月啊，你就嫌冷。爬起来洗漱干净。正打算走，包背了又放下，又有东西没有收拾进去，包背起又放下，好像天气有点干燥，脸上得抹些东西，总算背起包直直的走出了门，可离预想的出发时间却晚了半个小时。\n\n<!-- more -->\n## 写文章\n\n明明看了不少内容，网页啊书啊七七八八打开一堆，心中早已规划好大小标题和内容，还没动手，就觉得一篇好文正对我挥舞双手。刚刚打开`Sublime`，手还没打上一行字，就停住了，心中矛盾的不可开交，确实是构思出些什么了，但却怎么也写不出来，自己表达能力的欠缺，生怕自己硬生生地毁了那些好素材。还是再想想该如何起笔。自己鼠标却无意识的点开其他标签页，跳出的还是昨天没写完的文章，思绪一下子就被那篇文章牵扯过去了。又零零散散的打开了一些其他文章，看看知乎dalao们关于这个问题的回答，又补补写写，告一段落。可之前的鸿篇巨制已经差不多忘得一干二净了。看看之前打开的网页，依稀回忆起来点什么。好不容易搜集这些有用的东西，关了可惜，又做了点摘抄出来，零零散散的拼凑些东西。唉，都写了这么多了，不改点什么，整合一下么？于是乎，改着改着，一篇文章改出来了。\n\n## 码代码\n\n码代码就更是如此了。心想最近学`python`学的不错，动手写点什么，刚刚打开`Pycharm`,没写两行，基本的一些写法就硬是记不起来了，我是老了么？这都记不起来之后怎么靠这个吃饭？现在还没到这个地步吧？这玩意儿不是很简单么？我该不会不适合做程序员吧？一顿怀疑人生之后，决定`google`一下，东改西改，别人代码好的地方借鉴一下，哈，成了。一时又觉得手痒，这样写OK了么，这里不再改点什么么？都一顿乱改，怀疑人生的劲头不知道去哪儿了。完成之后，又觉得自己可以征服全世界了，哈哈哈。一逛知乎，又啪啪啪地被打脸。你还差得远呢！\n\n\n\n有趣，神TM矛盾纠结体。","source":"_posts/随记/神TM矛盾纠结体.md","raw":"---\ntitle: 神TM矛盾纠结体\ndate: 2016-10-23 11:23:52\ntags:\n- 胡思\ncategories: 杂谈\n---\n\n## 去图书馆\n\n早上起来，睁眼，灰蒙蒙的一片，已经差不多灰了一周的天气了，去图书馆继续学习吧。唉，可天气这么差，床却这么暖。啪一下打醒自己，现在才10月啊，你就嫌冷。爬起来洗漱干净。正打算走，包背了又放下，又有东西没有收拾进去，包背起又放下，好像天气有点干燥，脸上得抹些东西，总算背起包直直的走出了门，可离预想的出发时间却晚了半个小时。\n\n<!-- more -->\n## 写文章\n\n明明看了不少内容，网页啊书啊七七八八打开一堆，心中早已规划好大小标题和内容，还没动手，就觉得一篇好文正对我挥舞双手。刚刚打开`Sublime`，手还没打上一行字，就停住了，心中矛盾的不可开交，确实是构思出些什么了，但却怎么也写不出来，自己表达能力的欠缺，生怕自己硬生生地毁了那些好素材。还是再想想该如何起笔。自己鼠标却无意识的点开其他标签页，跳出的还是昨天没写完的文章，思绪一下子就被那篇文章牵扯过去了。又零零散散的打开了一些其他文章，看看知乎dalao们关于这个问题的回答，又补补写写，告一段落。可之前的鸿篇巨制已经差不多忘得一干二净了。看看之前打开的网页，依稀回忆起来点什么。好不容易搜集这些有用的东西，关了可惜，又做了点摘抄出来，零零散散的拼凑些东西。唉，都写了这么多了，不改点什么，整合一下么？于是乎，改着改着，一篇文章改出来了。\n\n## 码代码\n\n码代码就更是如此了。心想最近学`python`学的不错，动手写点什么，刚刚打开`Pycharm`,没写两行，基本的一些写法就硬是记不起来了，我是老了么？这都记不起来之后怎么靠这个吃饭？现在还没到这个地步吧？这玩意儿不是很简单么？我该不会不适合做程序员吧？一顿怀疑人生之后，决定`google`一下，东改西改，别人代码好的地方借鉴一下，哈，成了。一时又觉得手痒，这样写OK了么，这里不再改点什么么？都一顿乱改，怀疑人生的劲头不知道去哪儿了。完成之后，又觉得自己可以征服全世界了，哈哈哈。一逛知乎，又啪啪啪地被打脸。你还差得远呢！\n\n\n\n有趣，神TM矛盾纠结体。","slug":"随记/神TM矛盾纠结体","published":1,"updated":"2019-03-22T14:44:36.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmxx005w4l3nzpefgfwh","content":"<h2 id=\"去图书馆\"><a href=\"#去图书馆\" class=\"headerlink\" title=\"去图书馆\"></a>去图书馆</h2><p>早上起来，睁眼，灰蒙蒙的一片，已经差不多灰了一周的天气了，去图书馆继续学习吧。唉，可天气这么差，床却这么暖。啪一下打醒自己，现在才10月啊，你就嫌冷。爬起来洗漱干净。正打算走，包背了又放下，又有东西没有收拾进去，包背起又放下，好像天气有点干燥，脸上得抹些东西，总算背起包直直的走出了门，可离预想的出发时间却晚了半个小时。</p>\n<a id=\"more\"></a>\n<h2 id=\"写文章\"><a href=\"#写文章\" class=\"headerlink\" title=\"写文章\"></a>写文章</h2><p>明明看了不少内容，网页啊书啊七七八八打开一堆，心中早已规划好大小标题和内容，还没动手，就觉得一篇好文正对我挥舞双手。刚刚打开<code>Sublime</code>，手还没打上一行字，就停住了，心中矛盾的不可开交，确实是构思出些什么了，但却怎么也写不出来，自己表达能力的欠缺，生怕自己硬生生地毁了那些好素材。还是再想想该如何起笔。自己鼠标却无意识的点开其他标签页，跳出的还是昨天没写完的文章，思绪一下子就被那篇文章牵扯过去了。又零零散散的打开了一些其他文章，看看知乎dalao们关于这个问题的回答，又补补写写，告一段落。可之前的鸿篇巨制已经差不多忘得一干二净了。看看之前打开的网页，依稀回忆起来点什么。好不容易搜集这些有用的东西，关了可惜，又做了点摘抄出来，零零散散的拼凑些东西。唉，都写了这么多了，不改点什么，整合一下么？于是乎，改着改着，一篇文章改出来了。</p>\n<h2 id=\"码代码\"><a href=\"#码代码\" class=\"headerlink\" title=\"码代码\"></a>码代码</h2><p>码代码就更是如此了。心想最近学<code>python</code>学的不错，动手写点什么，刚刚打开<code>Pycharm</code>,没写两行，基本的一些写法就硬是记不起来了，我是老了么？这都记不起来之后怎么靠这个吃饭？现在还没到这个地步吧？这玩意儿不是很简单么？我该不会不适合做程序员吧？一顿怀疑人生之后，决定<code>google</code>一下，东改西改，别人代码好的地方借鉴一下，哈，成了。一时又觉得手痒，这样写OK了么，这里不再改点什么么？都一顿乱改，怀疑人生的劲头不知道去哪儿了。完成之后，又觉得自己可以征服全世界了，哈哈哈。一逛知乎，又啪啪啪地被打脸。你还差得远呢！</p>\n<p>有趣，神TM矛盾纠结体。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"去图书馆\"><a href=\"#去图书馆\" class=\"headerlink\" title=\"去图书馆\"></a>去图书馆</h2><p>早上起来，睁眼，灰蒙蒙的一片，已经差不多灰了一周的天气了，去图书馆继续学习吧。唉，可天气这么差，床却这么暖。啪一下打醒自己，现在才10月啊，你就嫌冷。爬起来洗漱干净。正打算走，包背了又放下，又有东西没有收拾进去，包背起又放下，好像天气有点干燥，脸上得抹些东西，总算背起包直直的走出了门，可离预想的出发时间却晚了半个小时。</p>","more":"<h2 id=\"写文章\"><a href=\"#写文章\" class=\"headerlink\" title=\"写文章\"></a>写文章</h2><p>明明看了不少内容，网页啊书啊七七八八打开一堆，心中早已规划好大小标题和内容，还没动手，就觉得一篇好文正对我挥舞双手。刚刚打开<code>Sublime</code>，手还没打上一行字，就停住了，心中矛盾的不可开交，确实是构思出些什么了，但却怎么也写不出来，自己表达能力的欠缺，生怕自己硬生生地毁了那些好素材。还是再想想该如何起笔。自己鼠标却无意识的点开其他标签页，跳出的还是昨天没写完的文章，思绪一下子就被那篇文章牵扯过去了。又零零散散的打开了一些其他文章，看看知乎dalao们关于这个问题的回答，又补补写写，告一段落。可之前的鸿篇巨制已经差不多忘得一干二净了。看看之前打开的网页，依稀回忆起来点什么。好不容易搜集这些有用的东西，关了可惜，又做了点摘抄出来，零零散散的拼凑些东西。唉，都写了这么多了，不改点什么，整合一下么？于是乎，改着改着，一篇文章改出来了。</p>\n<h2 id=\"码代码\"><a href=\"#码代码\" class=\"headerlink\" title=\"码代码\"></a>码代码</h2><p>码代码就更是如此了。心想最近学<code>python</code>学的不错，动手写点什么，刚刚打开<code>Pycharm</code>,没写两行，基本的一些写法就硬是记不起来了，我是老了么？这都记不起来之后怎么靠这个吃饭？现在还没到这个地步吧？这玩意儿不是很简单么？我该不会不适合做程序员吧？一顿怀疑人生之后，决定<code>google</code>一下，东改西改，别人代码好的地方借鉴一下，哈，成了。一时又觉得手痒，这样写OK了么，这里不再改点什么么？都一顿乱改，怀疑人生的劲头不知道去哪儿了。完成之后，又觉得自己可以征服全世界了，哈哈哈。一逛知乎，又啪啪啪地被打脸。你还差得远呢！</p>\n<p>有趣，神TM矛盾纠结体。</p>"},{"title":"OPC开发小结","date":"2016-05-21T12:51:02.000Z","_content":"\n总算完成了这个小项目的开发，是时候总结一下用过的东西了。这个小项目完成了什么功能呢？通过一个c#的窗口程序来访问`OPC`底层的数据然后读取并上传到mysql数据库中进行保存。考虑到有可能运行该程序的电脑无法联网，于是增加了通过串口来传输数据。\n\n<!-- more -->\n\n## 什么是OPC\n\n`OPC`(OLE for Process Control, 用于过程控制的OLE)是一个工业标准，管理这个标准国际组织是`OPC`基金会，`OPC`基金会现有会员已超过220家。遍布全球，包括世界上所有主要的自动化控制系统、仪器仪表及过程控制系统的公司。基于微软的OLE(现在的Active X)、COM （部件对象模型）和DCOM （分布式部件对象模型）技术。`OPC`包括一整套接口、属性和方法的标准集，用于过程控制和制造业自动化系统。\n`OPC`是为了连接数据源(`OPC`服务器)和数据的使用者(`OPC`应用程序)之间的软件接口标准。简单的说，就是连接硬件的驱动器和与其连接的应用程序之间的接口的一个统一的标准。通过`OPC`就可以访问到底层的数据啦！\n`OPC`客户端源码本身就已经是很早以前的技术了，网上能找到的都在2012年左右，原型采用[大尾巴狼啊](http://www.cnblogs.com/badnewfish/archive/2009/04/11/1374966.html)提供的源码(原博客被删了，只能找到转载的了)，对于初学者真的作用很大。\n\n##  OPC数据定时读取\n\n由于opc数据实时更新，需要定时读取数据。因此在原有的程序上增加了定时器timer。采用的是`System.Timers.Timer`。\n\n\n```\n  private void initializetimer()//初始化定时器\n        {\n            Timers_Timer.Interval = 5000;//每5秒读取一次\n            Timers_Timer.Enabled = true;\n            Timers_Timer.Elapsed += new System.Timers.ElapsedEventHandler(Timers_Timer_Elapsed);\n            Timers_Timer.AutoReset = true;//自动重启\n        }\n  void Timers_Timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)\n        {\n        \t//添加定时器到时后所需运行的代码\n        }\n```\n## OPC数据异步读\n\n之后采用的`OPC`异步读取参考了[OPCDAAuto.dll的C#使用方法浅析](http://www.cnblogs.com/zjjking/archive/2009/01/23/1380218.html)，需注意的是，Array ServerHandle 数组从下标1开始而非0！之后调用 `AsyncRead` 异步读方法。\n\n![异步读写](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-5-26/55772370.jpg)\n\n异步通讯时，OPC客户程序对服务器进行请求时，OPC客户程序请求后立刻返回，不用等待OPC服务器响应，可以进行其他操作。OPC服务完成响应后，再通知客户端进行读操作，此时调用`GroupAsyncReadComplete`，来进行后续的写入mysql程序。\n\n```cs\n    KepGroup.AsyncRead(listBox1.Items.Count, ref serverHandles, out Errors, 1, out cancelID);\n\n    void GroupAsyncReadComplete(int TransactionID, int NumItems, ref System.Array ClientHandles, ref System.Array ItemValues, ref System.Array Qualities, ref System.Array TimeStamps, ref System.Array Errors)\n    {\n    \t//添加后续写入mysql程序\n    }\n```\n\n##　C#连接mysql数据库\n\n由于用到的是阿里云服务器下搭建的数据库，采用`navicat`进行远程连接并数据库管理。由于C#\n连接mysql数据库需添加[mysql.data.dll](http://hovertree.com/h/bjaf/0sft36s9.htm)引用。\n下载Mysql.Data.dll，然后在项目中添加该组件的引用，在代码页里输入using Mysql.Data.MysqlClient，我们就可以顺利的使用该类库的函数建立连接了。\n实现实例代码：\n\n ```cs\n string M_str_sqlcon = \"server=localhost;user id=root;password=root;database=abc\"; //根据自己的设置\n MySqlConnection myCon = new MySqlConnection(M_str_sqlcon);\n mysqlcon.Open();\n MySqlCommand mysqlcom = new MySqlCommand(M_str_sqlstr, mysqlcon);//M_str_sqlstr 为sql语句，需另外定义\n mysqlcom.ExecuteNonQuery();\n mysqlcom.Dispose();\n mysqlcon.Close();\n mysqlcon.Dispose();\n```\n之后便可以用`navicat`远程连接到数据库进行查看。\n\n## opc数据用串口发送\n\n### 什么是串口\n串口是计算机上一种非常通用设备通信的协议(不要与通用串行总线Universal Serial Bus或者USB混淆).大多数计算机包含两个基于RS232的串口.串口同时也是仪器仪表设备通用的通信协议;很多GPIB兼容的设备也带有RS-232口.同时,串口通信协议也可以用于获取远程采集设备的数据.串口通信的概念非常简单，串口按位(bit)发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并且能够实现远距离通信。比如IEEE488定义并行通行状态时，规定设备线总常不得超过20米，并且任意两个设备间的长度不得超过2米；而对于串口而言，长度可达1200米。 典型地，串口用于ASCII码字符的传输。通信使用3根线完成：（1）地线，（2）发送，（3）接收。由于串口通信是异步，端口能够在一根线上发送数据同时在另一根线上接收数据。其他线用于握手，但是不是必须的。串口通信最重要的参数是波特率、数据位、停止位和奇偶校验。对于两个进行通行的端口，这些参数必须匹配。\nMS在.NET FrameWork2.0中对串口通讯进行了封装，我们可以在.net2.0及以上版本开发时直接使用SerialPort类对串口进行读写操作。\n\n接下来讲讲几个比较重要的属性：\n\n**串口名称 PortName**\n\n通信的端口名称，例如COM1,COM2 之类\n\n**波特率 BaudRate**\n\n用来衡量通信速度的参数。它表示每秒钟传送的bit的个数。例如9600波特表示每秒钟发送9600个bit。当我们提到时钟周期时，我们就是指波特率例如如果协议需要4800波特率，那么时钟是4800Hz。这意味着串口通信在数据线上的采样率为4800Hz。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。\n\n**数据位 DataBits**\n\n这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是5、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。\n\n**停止位 StopBits** \n\n用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。\n\n**奇偶校验 Parity**\n\n奇偶校验位：在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位位1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步\nMSDN 讲解http://msdn.microsoft.com/zh-cn/library/system.io.ports.parity.aspx\n关于奇偶校验的讲解http://baike.baidu.com/view/444171.htm?func=retitle\n\n**握手控制协议 Handshake**\n\n主要设置控制串口的方式，软件控制，硬件控制，等等\nMSDN 讲解http://msdn.microsoft.com/zh-cn/library/system.io.ports.handshake.aspx\n串口相关内容转自[Tony.Y](http://www.cnblogs.com/tony-yang/archive/2009/06/03/learnserialport.html)\n\n\n串口通信通过模拟串口简单做了一个实现，使用之前需添加允许using System.IO.Ports。\n实例如下代码所示：\n```\n\t\tprivate SerialPort sp=null;\n \t\t/// <summary>\n        /// 初始化串口并打开串口\n        /// </summary>\n        ///  <param name=\"protName\">串口号</param>\n        /// <param name=\"baudRate\">波特率</param>\n        /// <param name=\"DataBits\">数据位</param>\n        /// <param name=\"StopBits\">停止位</param>\n        /// <returns></returns>\n        public bool OpenCom(string protName, int baudRate)\n        {\n            bool flag = true;\n            if (sp == null)\n            {\n                sp = new SerialPort();\n            }\n            sp.PortName = protName;//串口号\n            sp.BaudRate = baudRate;//波特率\n            sp.DataBits = 8;\n            sp.StopBits = StopBits.One;\n            try\n            {\n                if (!sp.IsOpen)\n                {\n                    sp.Open();\n\n                }\n            }\n            catch (Exception)\n            {\n                flag = false;\n            }\n            return flag;\n        }\n        /// <summary>\n        /// 关闭串口\n        /// </summary>\n        /// <returns></returns>\n        public void CloseCom()\n        {\n                if (sp.IsOpen)\n                {\n                    sp.Close();\n                }\n            \n        }\n            OpenCom(\"COM1\", 9600);\n            sp.WriteLine(data_opc);//需写入的数据\n            CloseCom();\n```\n模拟串口可以实现，实操可能还需改动。目前先记录到此。","source":"_posts/C#/opc开发小结.md","raw":"---\ntitle: OPC开发小结\ndate: 2016-05-21 20:51:02\ntags:\n- c#\n- mysql\n- 串口\ncategories: 总结\n---\n\n总算完成了这个小项目的开发，是时候总结一下用过的东西了。这个小项目完成了什么功能呢？通过一个c#的窗口程序来访问`OPC`底层的数据然后读取并上传到mysql数据库中进行保存。考虑到有可能运行该程序的电脑无法联网，于是增加了通过串口来传输数据。\n\n<!-- more -->\n\n## 什么是OPC\n\n`OPC`(OLE for Process Control, 用于过程控制的OLE)是一个工业标准，管理这个标准国际组织是`OPC`基金会，`OPC`基金会现有会员已超过220家。遍布全球，包括世界上所有主要的自动化控制系统、仪器仪表及过程控制系统的公司。基于微软的OLE(现在的Active X)、COM （部件对象模型）和DCOM （分布式部件对象模型）技术。`OPC`包括一整套接口、属性和方法的标准集，用于过程控制和制造业自动化系统。\n`OPC`是为了连接数据源(`OPC`服务器)和数据的使用者(`OPC`应用程序)之间的软件接口标准。简单的说，就是连接硬件的驱动器和与其连接的应用程序之间的接口的一个统一的标准。通过`OPC`就可以访问到底层的数据啦！\n`OPC`客户端源码本身就已经是很早以前的技术了，网上能找到的都在2012年左右，原型采用[大尾巴狼啊](http://www.cnblogs.com/badnewfish/archive/2009/04/11/1374966.html)提供的源码(原博客被删了，只能找到转载的了)，对于初学者真的作用很大。\n\n##  OPC数据定时读取\n\n由于opc数据实时更新，需要定时读取数据。因此在原有的程序上增加了定时器timer。采用的是`System.Timers.Timer`。\n\n\n```\n  private void initializetimer()//初始化定时器\n        {\n            Timers_Timer.Interval = 5000;//每5秒读取一次\n            Timers_Timer.Enabled = true;\n            Timers_Timer.Elapsed += new System.Timers.ElapsedEventHandler(Timers_Timer_Elapsed);\n            Timers_Timer.AutoReset = true;//自动重启\n        }\n  void Timers_Timer_Elapsed(object sender, System.Timers.ElapsedEventArgs e)\n        {\n        \t//添加定时器到时后所需运行的代码\n        }\n```\n## OPC数据异步读\n\n之后采用的`OPC`异步读取参考了[OPCDAAuto.dll的C#使用方法浅析](http://www.cnblogs.com/zjjking/archive/2009/01/23/1380218.html)，需注意的是，Array ServerHandle 数组从下标1开始而非0！之后调用 `AsyncRead` 异步读方法。\n\n![异步读写](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-5-26/55772370.jpg)\n\n异步通讯时，OPC客户程序对服务器进行请求时，OPC客户程序请求后立刻返回，不用等待OPC服务器响应，可以进行其他操作。OPC服务完成响应后，再通知客户端进行读操作，此时调用`GroupAsyncReadComplete`，来进行后续的写入mysql程序。\n\n```cs\n    KepGroup.AsyncRead(listBox1.Items.Count, ref serverHandles, out Errors, 1, out cancelID);\n\n    void GroupAsyncReadComplete(int TransactionID, int NumItems, ref System.Array ClientHandles, ref System.Array ItemValues, ref System.Array Qualities, ref System.Array TimeStamps, ref System.Array Errors)\n    {\n    \t//添加后续写入mysql程序\n    }\n```\n\n##　C#连接mysql数据库\n\n由于用到的是阿里云服务器下搭建的数据库，采用`navicat`进行远程连接并数据库管理。由于C#\n连接mysql数据库需添加[mysql.data.dll](http://hovertree.com/h/bjaf/0sft36s9.htm)引用。\n下载Mysql.Data.dll，然后在项目中添加该组件的引用，在代码页里输入using Mysql.Data.MysqlClient，我们就可以顺利的使用该类库的函数建立连接了。\n实现实例代码：\n\n ```cs\n string M_str_sqlcon = \"server=localhost;user id=root;password=root;database=abc\"; //根据自己的设置\n MySqlConnection myCon = new MySqlConnection(M_str_sqlcon);\n mysqlcon.Open();\n MySqlCommand mysqlcom = new MySqlCommand(M_str_sqlstr, mysqlcon);//M_str_sqlstr 为sql语句，需另外定义\n mysqlcom.ExecuteNonQuery();\n mysqlcom.Dispose();\n mysqlcon.Close();\n mysqlcon.Dispose();\n```\n之后便可以用`navicat`远程连接到数据库进行查看。\n\n## opc数据用串口发送\n\n### 什么是串口\n串口是计算机上一种非常通用设备通信的协议(不要与通用串行总线Universal Serial Bus或者USB混淆).大多数计算机包含两个基于RS232的串口.串口同时也是仪器仪表设备通用的通信协议;很多GPIB兼容的设备也带有RS-232口.同时,串口通信协议也可以用于获取远程采集设备的数据.串口通信的概念非常简单，串口按位(bit)发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并且能够实现远距离通信。比如IEEE488定义并行通行状态时，规定设备线总常不得超过20米，并且任意两个设备间的长度不得超过2米；而对于串口而言，长度可达1200米。 典型地，串口用于ASCII码字符的传输。通信使用3根线完成：（1）地线，（2）发送，（3）接收。由于串口通信是异步，端口能够在一根线上发送数据同时在另一根线上接收数据。其他线用于握手，但是不是必须的。串口通信最重要的参数是波特率、数据位、停止位和奇偶校验。对于两个进行通行的端口，这些参数必须匹配。\nMS在.NET FrameWork2.0中对串口通讯进行了封装，我们可以在.net2.0及以上版本开发时直接使用SerialPort类对串口进行读写操作。\n\n接下来讲讲几个比较重要的属性：\n\n**串口名称 PortName**\n\n通信的端口名称，例如COM1,COM2 之类\n\n**波特率 BaudRate**\n\n用来衡量通信速度的参数。它表示每秒钟传送的bit的个数。例如9600波特表示每秒钟发送9600个bit。当我们提到时钟周期时，我们就是指波特率例如如果协议需要4800波特率，那么时钟是4800Hz。这意味着串口通信在数据线上的采样率为4800Hz。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。\n\n**数据位 DataBits**\n\n这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是5、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。\n\n**停止位 StopBits** \n\n用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。\n\n**奇偶校验 Parity**\n\n奇偶校验位：在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位位1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步\nMSDN 讲解http://msdn.microsoft.com/zh-cn/library/system.io.ports.parity.aspx\n关于奇偶校验的讲解http://baike.baidu.com/view/444171.htm?func=retitle\n\n**握手控制协议 Handshake**\n\n主要设置控制串口的方式，软件控制，硬件控制，等等\nMSDN 讲解http://msdn.microsoft.com/zh-cn/library/system.io.ports.handshake.aspx\n串口相关内容转自[Tony.Y](http://www.cnblogs.com/tony-yang/archive/2009/06/03/learnserialport.html)\n\n\n串口通信通过模拟串口简单做了一个实现，使用之前需添加允许using System.IO.Ports。\n实例如下代码所示：\n```\n\t\tprivate SerialPort sp=null;\n \t\t/// <summary>\n        /// 初始化串口并打开串口\n        /// </summary>\n        ///  <param name=\"protName\">串口号</param>\n        /// <param name=\"baudRate\">波特率</param>\n        /// <param name=\"DataBits\">数据位</param>\n        /// <param name=\"StopBits\">停止位</param>\n        /// <returns></returns>\n        public bool OpenCom(string protName, int baudRate)\n        {\n            bool flag = true;\n            if (sp == null)\n            {\n                sp = new SerialPort();\n            }\n            sp.PortName = protName;//串口号\n            sp.BaudRate = baudRate;//波特率\n            sp.DataBits = 8;\n            sp.StopBits = StopBits.One;\n            try\n            {\n                if (!sp.IsOpen)\n                {\n                    sp.Open();\n\n                }\n            }\n            catch (Exception)\n            {\n                flag = false;\n            }\n            return flag;\n        }\n        /// <summary>\n        /// 关闭串口\n        /// </summary>\n        /// <returns></returns>\n        public void CloseCom()\n        {\n                if (sp.IsOpen)\n                {\n                    sp.Close();\n                }\n            \n        }\n            OpenCom(\"COM1\", 9600);\n            sp.WriteLine(data_opc);//需写入的数据\n            CloseCom();\n```\n模拟串口可以实现，实操可能还需改动。目前先记录到此。","slug":"C#/opc开发小结","published":1,"updated":"2019-03-22T14:44:36.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwmzz00904l3ngh7q6tyt","content":"<p>总算完成了这个小项目的开发，是时候总结一下用过的东西了。这个小项目完成了什么功能呢？通过一个c#的窗口程序来访问<code>OPC</code>底层的数据然后读取并上传到mysql数据库中进行保存。考虑到有可能运行该程序的电脑无法联网，于是增加了通过串口来传输数据。</p>\n<a id=\"more\"></a>\n<h2 id=\"什么是OPC\"><a href=\"#什么是OPC\" class=\"headerlink\" title=\"什么是OPC\"></a>什么是OPC</h2><p><code>OPC</code>(OLE for Process Control, 用于过程控制的OLE)是一个工业标准，管理这个标准国际组织是<code>OPC</code>基金会，<code>OPC</code>基金会现有会员已超过220家。遍布全球，包括世界上所有主要的自动化控制系统、仪器仪表及过程控制系统的公司。基于微软的OLE(现在的Active X)、COM （部件对象模型）和DCOM （分布式部件对象模型）技术。<code>OPC</code>包括一整套接口、属性和方法的标准集，用于过程控制和制造业自动化系统。<br><code>OPC</code>是为了连接数据源(<code>OPC</code>服务器)和数据的使用者(<code>OPC</code>应用程序)之间的软件接口标准。简单的说，就是连接硬件的驱动器和与其连接的应用程序之间的接口的一个统一的标准。通过<code>OPC</code>就可以访问到底层的数据啦！<br><code>OPC</code>客户端源码本身就已经是很早以前的技术了，网上能找到的都在2012年左右，原型采用<a href=\"http://www.cnblogs.com/badnewfish/archive/2009/04/11/1374966.html\" target=\"_blank\" rel=\"noopener\">大尾巴狼啊</a>提供的源码(原博客被删了，只能找到转载的了)，对于初学者真的作用很大。</p>\n<h2 id=\"OPC数据定时读取\"><a href=\"#OPC数据定时读取\" class=\"headerlink\" title=\"OPC数据定时读取\"></a>OPC数据定时读取</h2><p>由于opc数据实时更新，需要定时读取数据。因此在原有的程序上增加了定时器timer。采用的是<code>System.Timers.Timer</code>。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initializetimer</span>(<span class=\"params\"></span>)<span class=\"comment\">//初始化定时器</span></span></span><br><span class=\"line\"><span class=\"function\"></span>      &#123;</span><br><span class=\"line\">          Timers_Timer.Interval = <span class=\"number\">5000</span>;<span class=\"comment\">//每5秒读取一次</span></span><br><span class=\"line\">          Timers_Timer.Enabled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          Timers_Timer.Elapsed += <span class=\"keyword\">new</span> System.Timers.ElapsedEventHandler(Timers_Timer_Elapsed);</span><br><span class=\"line\">          Timers_Timer.AutoReset = <span class=\"literal\">true</span>;<span class=\"comment\">//自动重启</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Timers_Timer_Elapsed</span>(<span class=\"params\"><span class=\"keyword\">object</span> sender, System.Timers.ElapsedEventArgs e</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>      &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">//添加定时器到时后所需运行的代码</span></span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"OPC数据异步读\"><a href=\"#OPC数据异步读\" class=\"headerlink\" title=\"OPC数据异步读\"></a>OPC数据异步读</h2><p>之后采用的<code>OPC</code>异步读取参考了<a href=\"http://www.cnblogs.com/zjjking/archive/2009/01/23/1380218.html\" target=\"_blank\" rel=\"noopener\">OPCDAAuto.dll的C#使用方法浅析</a>，需注意的是，Array ServerHandle 数组从下标1开始而非0！之后调用 <code>AsyncRead</code> 异步读方法。</p>\n<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-5-26/55772370.jpg\" alt=\"异步读写\"></p>\n<p>异步通讯时，OPC客户程序对服务器进行请求时，OPC客户程序请求后立刻返回，不用等待OPC服务器响应，可以进行其他操作。OPC服务完成响应后，再通知客户端进行读操作，此时调用<code>GroupAsyncReadComplete</code>，来进行后续的写入mysql程序。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KepGroup.AsyncRead(listBox1.Items.Count, <span class=\"keyword\">ref</span> serverHandles, <span class=\"keyword\">out</span> Errors, <span class=\"number\">1</span>, <span class=\"keyword\">out</span> cancelID);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GroupAsyncReadComplete</span>(<span class=\"params\"><span class=\"keyword\">int</span> TransactionID, <span class=\"keyword\">int</span> NumItems, <span class=\"keyword\">ref</span> System.Array ClientHandles, <span class=\"keyword\">ref</span> System.Array ItemValues, <span class=\"keyword\">ref</span> System.Array Qualities, <span class=\"keyword\">ref</span> System.Array TimeStamps, <span class=\"keyword\">ref</span> System.Array Errors</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//添加后续写入mysql程序</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##　C#连接mysql数据库</p>\n<p>由于用到的是阿里云服务器下搭建的数据库，采用<code>navicat</code>进行远程连接并数据库管理。由于C#<br>连接mysql数据库需添加<a href=\"http://hovertree.com/h/bjaf/0sft36s9.htm\" target=\"_blank\" rel=\"noopener\">mysql.data.dll</a>引用。<br>下载Mysql.Data.dll，然后在项目中添加该组件的引用，在代码页里输入using Mysql.Data.MysqlClient，我们就可以顺利的使用该类库的函数建立连接了。<br>实现实例代码：</p>\n <figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">string</span> M_str_sqlcon = <span class=\"string\">\"server=localhost;user id=root;password=root;database=abc\"</span>; <span class=\"comment\">//根据自己的设置</span></span><br><span class=\"line\">MySqlConnection myCon = <span class=\"keyword\">new</span> MySqlConnection(M_str_sqlcon);</span><br><span class=\"line\">mysqlcon.Open();</span><br><span class=\"line\">MySqlCommand mysqlcom = <span class=\"keyword\">new</span> MySqlCommand(M_str_sqlstr, mysqlcon);<span class=\"comment\">//M_str_sqlstr 为sql语句，需另外定义</span></span><br><span class=\"line\">mysqlcom.ExecuteNonQuery();</span><br><span class=\"line\">mysqlcom.Dispose();</span><br><span class=\"line\">mysqlcon.Close();</span><br><span class=\"line\">mysqlcon.Dispose();</span><br></pre></td></tr></table></figure>\n<p>之后便可以用<code>navicat</code>远程连接到数据库进行查看。</p>\n<h2 id=\"opc数据用串口发送\"><a href=\"#opc数据用串口发送\" class=\"headerlink\" title=\"opc数据用串口发送\"></a>opc数据用串口发送</h2><h3 id=\"什么是串口\"><a href=\"#什么是串口\" class=\"headerlink\" title=\"什么是串口\"></a>什么是串口</h3><p>串口是计算机上一种非常通用设备通信的协议(不要与通用串行总线Universal Serial Bus或者USB混淆).大多数计算机包含两个基于RS232的串口.串口同时也是仪器仪表设备通用的通信协议;很多GPIB兼容的设备也带有RS-232口.同时,串口通信协议也可以用于获取远程采集设备的数据.串口通信的概念非常简单，串口按位(bit)发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并且能够实现远距离通信。比如IEEE488定义并行通行状态时，规定设备线总常不得超过20米，并且任意两个设备间的长度不得超过2米；而对于串口而言，长度可达1200米。 典型地，串口用于ASCII码字符的传输。通信使用3根线完成：（1）地线，（2）发送，（3）接收。由于串口通信是异步，端口能够在一根线上发送数据同时在另一根线上接收数据。其他线用于握手，但是不是必须的。串口通信最重要的参数是波特率、数据位、停止位和奇偶校验。对于两个进行通行的端口，这些参数必须匹配。<br>MS在.NET FrameWork2.0中对串口通讯进行了封装，我们可以在.net2.0及以上版本开发时直接使用SerialPort类对串口进行读写操作。</p>\n<p>接下来讲讲几个比较重要的属性：</p>\n<p><strong>串口名称 PortName</strong></p>\n<p>通信的端口名称，例如COM1,COM2 之类</p>\n<p><strong>波特率 BaudRate</strong></p>\n<p>用来衡量通信速度的参数。它表示每秒钟传送的bit的个数。例如9600波特表示每秒钟发送9600个bit。当我们提到时钟周期时，我们就是指波特率例如如果协议需要4800波特率，那么时钟是4800Hz。这意味着串口通信在数据线上的采样率为4800Hz。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。</p>\n<p><strong>数据位 DataBits</strong></p>\n<p>这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是5、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。</p>\n<p><strong>停止位 StopBits</strong> </p>\n<p>用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。</p>\n<p><strong>奇偶校验 Parity</strong></p>\n<p>奇偶校验位：在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位位1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步<br>MSDN 讲解<a href=\"http://msdn.microsoft.com/zh-cn/library/system.io.ports.parity.aspx\" target=\"_blank\" rel=\"noopener\">http://msdn.microsoft.com/zh-cn/library/system.io.ports.parity.aspx</a><br>关于奇偶校验的讲解<a href=\"http://baike.baidu.com/view/444171.htm?func=retitle\" target=\"_blank\" rel=\"noopener\">http://baike.baidu.com/view/444171.htm?func=retitle</a></p>\n<p><strong>握手控制协议 Handshake</strong></p>\n<p>主要设置控制串口的方式，软件控制，硬件控制，等等<br>MSDN 讲解<a href=\"http://msdn.microsoft.com/zh-cn/library/system.io.ports.handshake.aspx\" target=\"_blank\" rel=\"noopener\">http://msdn.microsoft.com/zh-cn/library/system.io.ports.handshake.aspx</a><br>串口相关内容转自<a href=\"http://www.cnblogs.com/tony-yang/archive/2009/06/03/learnserialport.html\" target=\"_blank\" rel=\"noopener\">Tony.Y</a></p>\n<p>串口通信通过模拟串口简单做了一个实现，使用之前需添加允许using System.IO.Ports。<br>实例如下代码所示：<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> SerialPort sp=<span class=\"literal\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> 初始化串口并打开串口</span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span>  <span class=\"doctag\">&lt;param name=\"protName\"&gt;</span>串口号<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=\"baudRate\"&gt;</span>波特率<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=\"DataBits\"&gt;</span>数据位<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=\"StopBits\"&gt;</span>停止位<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span><span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">OpenCom</span>(<span class=\"params\"><span class=\"keyword\">string</span> protName, <span class=\"keyword\">int</span> baudRate</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sp == <span class=\"literal\">null</span>)</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">              sp = <span class=\"keyword\">new</span> SerialPort();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          sp.PortName = protName;<span class=\"comment\">//串口号</span></span><br><span class=\"line\">          sp.BaudRate = baudRate;<span class=\"comment\">//波特率</span></span><br><span class=\"line\">          sp.DataBits = <span class=\"number\">8</span>;</span><br><span class=\"line\">          sp.StopBits = StopBits.One;</span><br><span class=\"line\">          <span class=\"keyword\">try</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!sp.IsOpen)</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                  sp.Open();</span><br><span class=\"line\"></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">catch</span> (Exception)</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">              flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> 关闭串口</span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span><span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">CloseCom</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>      &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (sp.IsOpen)</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                  sp.Close();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">          OpenCom(<span class=\"string\">\"COM1\"</span>, <span class=\"number\">9600</span>);</span><br><span class=\"line\">          sp.WriteLine(data_opc);<span class=\"comment\">//需写入的数据</span></span><br><span class=\"line\">          CloseCom();</span><br></pre></td></tr></table></figure></p>\n<p>模拟串口可以实现，实操可能还需改动。目前先记录到此。</p>\n","site":{"data":{}},"excerpt":"<p>总算完成了这个小项目的开发，是时候总结一下用过的东西了。这个小项目完成了什么功能呢？通过一个c#的窗口程序来访问<code>OPC</code>底层的数据然后读取并上传到mysql数据库中进行保存。考虑到有可能运行该程序的电脑无法联网，于是增加了通过串口来传输数据。</p>","more":"<h2 id=\"什么是OPC\"><a href=\"#什么是OPC\" class=\"headerlink\" title=\"什么是OPC\"></a>什么是OPC</h2><p><code>OPC</code>(OLE for Process Control, 用于过程控制的OLE)是一个工业标准，管理这个标准国际组织是<code>OPC</code>基金会，<code>OPC</code>基金会现有会员已超过220家。遍布全球，包括世界上所有主要的自动化控制系统、仪器仪表及过程控制系统的公司。基于微软的OLE(现在的Active X)、COM （部件对象模型）和DCOM （分布式部件对象模型）技术。<code>OPC</code>包括一整套接口、属性和方法的标准集，用于过程控制和制造业自动化系统。<br><code>OPC</code>是为了连接数据源(<code>OPC</code>服务器)和数据的使用者(<code>OPC</code>应用程序)之间的软件接口标准。简单的说，就是连接硬件的驱动器和与其连接的应用程序之间的接口的一个统一的标准。通过<code>OPC</code>就可以访问到底层的数据啦！<br><code>OPC</code>客户端源码本身就已经是很早以前的技术了，网上能找到的都在2012年左右，原型采用<a href=\"http://www.cnblogs.com/badnewfish/archive/2009/04/11/1374966.html\" target=\"_blank\" rel=\"noopener\">大尾巴狼啊</a>提供的源码(原博客被删了，只能找到转载的了)，对于初学者真的作用很大。</p>\n<h2 id=\"OPC数据定时读取\"><a href=\"#OPC数据定时读取\" class=\"headerlink\" title=\"OPC数据定时读取\"></a>OPC数据定时读取</h2><p>由于opc数据实时更新，需要定时读取数据。因此在原有的程序上增加了定时器timer。采用的是<code>System.Timers.Timer</code>。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">initializetimer</span>(<span class=\"params\"></span>)<span class=\"comment\">//初始化定时器</span></span></span><br><span class=\"line\"><span class=\"function\"></span>      &#123;</span><br><span class=\"line\">          Timers_Timer.Interval = <span class=\"number\">5000</span>;<span class=\"comment\">//每5秒读取一次</span></span><br><span class=\"line\">          Timers_Timer.Enabled = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          Timers_Timer.Elapsed += <span class=\"keyword\">new</span> System.Timers.ElapsedEventHandler(Timers_Timer_Elapsed);</span><br><span class=\"line\">          Timers_Timer.AutoReset = <span class=\"literal\">true</span>;<span class=\"comment\">//自动重启</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Timers_Timer_Elapsed</span>(<span class=\"params\"><span class=\"keyword\">object</span> sender, System.Timers.ElapsedEventArgs e</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>      &#123;</span><br><span class=\"line\">      \t<span class=\"comment\">//添加定时器到时后所需运行的代码</span></span><br><span class=\"line\">      &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"OPC数据异步读\"><a href=\"#OPC数据异步读\" class=\"headerlink\" title=\"OPC数据异步读\"></a>OPC数据异步读</h2><p>之后采用的<code>OPC</code>异步读取参考了<a href=\"http://www.cnblogs.com/zjjking/archive/2009/01/23/1380218.html\" target=\"_blank\" rel=\"noopener\">OPCDAAuto.dll的C#使用方法浅析</a>，需注意的是，Array ServerHandle 数组从下标1开始而非0！之后调用 <code>AsyncRead</code> 异步读方法。</p>\n<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-5-26/55772370.jpg\" alt=\"异步读写\"></p>\n<p>异步通讯时，OPC客户程序对服务器进行请求时，OPC客户程序请求后立刻返回，不用等待OPC服务器响应，可以进行其他操作。OPC服务完成响应后，再通知客户端进行读操作，此时调用<code>GroupAsyncReadComplete</code>，来进行后续的写入mysql程序。</p>\n<figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">KepGroup.AsyncRead(listBox1.Items.Count, <span class=\"keyword\">ref</span> serverHandles, <span class=\"keyword\">out</span> Errors, <span class=\"number\">1</span>, <span class=\"keyword\">out</span> cancelID);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">GroupAsyncReadComplete</span>(<span class=\"params\"><span class=\"keyword\">int</span> TransactionID, <span class=\"keyword\">int</span> NumItems, <span class=\"keyword\">ref</span> System.Array ClientHandles, <span class=\"keyword\">ref</span> System.Array ItemValues, <span class=\"keyword\">ref</span> System.Array Qualities, <span class=\"keyword\">ref</span> System.Array TimeStamps, <span class=\"keyword\">ref</span> System.Array Errors</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//添加后续写入mysql程序</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>##　C#连接mysql数据库</p>\n<p>由于用到的是阿里云服务器下搭建的数据库，采用<code>navicat</code>进行远程连接并数据库管理。由于C#<br>连接mysql数据库需添加<a href=\"http://hovertree.com/h/bjaf/0sft36s9.htm\" target=\"_blank\" rel=\"noopener\">mysql.data.dll</a>引用。<br>下载Mysql.Data.dll，然后在项目中添加该组件的引用，在代码页里输入using Mysql.Data.MysqlClient，我们就可以顺利的使用该类库的函数建立连接了。<br>实现实例代码：</p>\n <figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">string</span> M_str_sqlcon = <span class=\"string\">\"server=localhost;user id=root;password=root;database=abc\"</span>; <span class=\"comment\">//根据自己的设置</span></span><br><span class=\"line\">MySqlConnection myCon = <span class=\"keyword\">new</span> MySqlConnection(M_str_sqlcon);</span><br><span class=\"line\">mysqlcon.Open();</span><br><span class=\"line\">MySqlCommand mysqlcom = <span class=\"keyword\">new</span> MySqlCommand(M_str_sqlstr, mysqlcon);<span class=\"comment\">//M_str_sqlstr 为sql语句，需另外定义</span></span><br><span class=\"line\">mysqlcom.ExecuteNonQuery();</span><br><span class=\"line\">mysqlcom.Dispose();</span><br><span class=\"line\">mysqlcon.Close();</span><br><span class=\"line\">mysqlcon.Dispose();</span><br></pre></td></tr></table></figure>\n<p>之后便可以用<code>navicat</code>远程连接到数据库进行查看。</p>\n<h2 id=\"opc数据用串口发送\"><a href=\"#opc数据用串口发送\" class=\"headerlink\" title=\"opc数据用串口发送\"></a>opc数据用串口发送</h2><h3 id=\"什么是串口\"><a href=\"#什么是串口\" class=\"headerlink\" title=\"什么是串口\"></a>什么是串口</h3><p>串口是计算机上一种非常通用设备通信的协议(不要与通用串行总线Universal Serial Bus或者USB混淆).大多数计算机包含两个基于RS232的串口.串口同时也是仪器仪表设备通用的通信协议;很多GPIB兼容的设备也带有RS-232口.同时,串口通信协议也可以用于获取远程采集设备的数据.串口通信的概念非常简单，串口按位(bit)发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并且能够实现远距离通信。比如IEEE488定义并行通行状态时，规定设备线总常不得超过20米，并且任意两个设备间的长度不得超过2米；而对于串口而言，长度可达1200米。 典型地，串口用于ASCII码字符的传输。通信使用3根线完成：（1）地线，（2）发送，（3）接收。由于串口通信是异步，端口能够在一根线上发送数据同时在另一根线上接收数据。其他线用于握手，但是不是必须的。串口通信最重要的参数是波特率、数据位、停止位和奇偶校验。对于两个进行通行的端口，这些参数必须匹配。<br>MS在.NET FrameWork2.0中对串口通讯进行了封装，我们可以在.net2.0及以上版本开发时直接使用SerialPort类对串口进行读写操作。</p>\n<p>接下来讲讲几个比较重要的属性：</p>\n<p><strong>串口名称 PortName</strong></p>\n<p>通信的端口名称，例如COM1,COM2 之类</p>\n<p><strong>波特率 BaudRate</strong></p>\n<p>用来衡量通信速度的参数。它表示每秒钟传送的bit的个数。例如9600波特表示每秒钟发送9600个bit。当我们提到时钟周期时，我们就是指波特率例如如果协议需要4800波特率，那么时钟是4800Hz。这意味着串口通信在数据线上的采样率为4800Hz。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。</p>\n<p><strong>数据位 DataBits</strong></p>\n<p>这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是5、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。</p>\n<p><strong>停止位 StopBits</strong> </p>\n<p>用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。</p>\n<p><strong>奇偶校验 Parity</strong></p>\n<p>奇偶校验位：在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位位1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步<br>MSDN 讲解<a href=\"http://msdn.microsoft.com/zh-cn/library/system.io.ports.parity.aspx\" target=\"_blank\" rel=\"noopener\">http://msdn.microsoft.com/zh-cn/library/system.io.ports.parity.aspx</a><br>关于奇偶校验的讲解<a href=\"http://baike.baidu.com/view/444171.htm?func=retitle\" target=\"_blank\" rel=\"noopener\">http://baike.baidu.com/view/444171.htm?func=retitle</a></p>\n<p><strong>握手控制协议 Handshake</strong></p>\n<p>主要设置控制串口的方式，软件控制，硬件控制，等等<br>MSDN 讲解<a href=\"http://msdn.microsoft.com/zh-cn/library/system.io.ports.handshake.aspx\" target=\"_blank\" rel=\"noopener\">http://msdn.microsoft.com/zh-cn/library/system.io.ports.handshake.aspx</a><br>串口相关内容转自<a href=\"http://www.cnblogs.com/tony-yang/archive/2009/06/03/learnserialport.html\" target=\"_blank\" rel=\"noopener\">Tony.Y</a></p>\n<p>串口通信通过模拟串口简单做了一个实现，使用之前需添加允许using System.IO.Ports。<br>实例如下代码所示：<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> SerialPort sp=<span class=\"literal\">null</span>;</span><br><span class=\"line\">\t<span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> 初始化串口并打开串口</span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span>  <span class=\"doctag\">&lt;param name=\"protName\"&gt;</span>串口号<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=\"baudRate\"&gt;</span>波特率<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=\"DataBits\"&gt;</span>数据位<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;param name=\"StopBits\"&gt;</span>停止位<span class=\"doctag\">&lt;/param&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span><span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">bool</span> <span class=\"title\">OpenCom</span>(<span class=\"params\"><span class=\"keyword\">string</span> protName, <span class=\"keyword\">int</span> baudRate</span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>      &#123;</span><br><span class=\"line\">          <span class=\"keyword\">bool</span> flag = <span class=\"literal\">true</span>;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (sp == <span class=\"literal\">null</span>)</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">              sp = <span class=\"keyword\">new</span> SerialPort();</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          sp.PortName = protName;<span class=\"comment\">//串口号</span></span><br><span class=\"line\">          sp.BaudRate = baudRate;<span class=\"comment\">//波特率</span></span><br><span class=\"line\">          sp.DataBits = <span class=\"number\">8</span>;</span><br><span class=\"line\">          sp.StopBits = StopBits.One;</span><br><span class=\"line\">          <span class=\"keyword\">try</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (!sp.IsOpen)</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                  sp.Open();</span><br><span class=\"line\"></span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">catch</span> (Exception)</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">              flag = <span class=\"literal\">false</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">return</span> flag;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;summary&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> 关闭串口</span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;/summary&gt;</span></span></span><br><span class=\"line\">      <span class=\"comment\"><span class=\"doctag\">///</span> <span class=\"doctag\">&lt;returns&gt;</span><span class=\"doctag\">&lt;/returns&gt;</span></span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">CloseCom</span>(<span class=\"params\"></span>)</span></span><br><span class=\"line\"><span class=\"function\"></span>      &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (sp.IsOpen)</span><br><span class=\"line\">              &#123;</span><br><span class=\"line\">                  sp.Close();</span><br><span class=\"line\">              &#125;</span><br><span class=\"line\">          </span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">          OpenCom(<span class=\"string\">\"COM1\"</span>, <span class=\"number\">9600</span>);</span><br><span class=\"line\">          sp.WriteLine(data_opc);<span class=\"comment\">//需写入的数据</span></span><br><span class=\"line\">          CloseCom();</span><br></pre></td></tr></table></figure></p>\n<p>模拟串口可以实现，实操可能还需改动。目前先记录到此。</p>"},{"title":"HTTP协议入门","date":"2016-09-12T13:22:50.000Z","_content":">原文出处： [阮一峰 （@ruanyf）](http://www.ruanyifeng.com/blog/2016/08/http.html)\n\n最近成了阮一峰的迷弟，最近做实验正需要恶补一下协议的相关知识，因此写博客来记录一下学习之路。\n\n## 什么是HTTP？\n\n超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n<!-- more -->\n## HTTP/0.9\n\nHTTP 是基于 TCP/IP协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。\n最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。\n```\nGET /index.html\n```\n上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页`index.html`。\n\n协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。\n\n服务器发送完毕，就关闭TCP连接。\n\n## HTTP/1.0\n\n1996年5月，HTTP/1.0 版本发布，内容大大增加。\n\n首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。\n\n其次，除了`GET`命令，还引入了还引入了`POST`命令和`HEAD`命令，丰富了浏览器与服务器的互动手段。\n\n其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。\n\n### 请求格式\n\n```\nGET / HTTP/1.0\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)\nAccept: */*\n```\n可以看到，这个格式与0.9版有很大变化。\n第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。\n\n### 回应格式\n服务器的回应如下。\n```\nHTTP/1.0 200 OK \nContent-Type: text/plain\nContent-Length: 137582\nExpires: Thu, 05 Dec 1997 16:00:00 GMT\nLast-Modified: Wed, 5 August 1996 15:55:28 GMT\nServer: Apache 0.84\n\n<html>\n  <body>Hello World</body>\n</html>\n```\n回应的格式是\"头信息 + 一个空行（\\r\\n） + 数据\"。其中，第一行是\"协议版本 + 状态码（status code） + 状态描述\"。\n\n### Content-Type 字段\n关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。\n下面是一些常见的Content-Type字段的值。\n>text/plain\n>text/html\n>text/css\n>image/jpeg\n>image/png\n>image/svg+xml\n>audio/mp4\n>video/mp4\n>application/javascript\n>application/pdf\n>application/zip\n>application/atom+xml\n\n这些数据类型总称为`MIME type`，每个值包括一级类型和二级类型，之间用斜杠分隔。\n除了预定义的类型，厂商也可以自定义类型。\n```\napplication/vnd.debian.binary-package\n```\n上面的类型表明，发送的是Debian系统的二进制数据包。\n\n`MIME type`还可以在尾部使用分号，添加参数。\n```\nContent-Type: text/html; charset=utf-8\n```\n\n客户端请求的时候，可以使用`Accept`字段声明自己可以接受哪些数据格式。\n```\nAccept: */*\n```\n\n### Content-Encoding 字段\n\n由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。\n```\nContent-Encoding: gzip\nContent-Encoding: compress\nContent-Encoding: deflate\n```\n客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。\n```\nAccept-Encoding: gzip, deflate\n```\n### 缺点\nHTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。\n\nTCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。\n\n为了解决这个问题，有些浏览器在请求时，用了一个非标准的`Connection`字段。\n```\nConnection: keep-alive\n```\n这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。\n\n一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。\n\n## HTTP/1.1\n1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。\n\n###　持久连接\n1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`。\n客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`，明确要求服务器关闭TCP连接。\n\n目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。\n\n### 管道机制\n\n1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。\n\n举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是**服务器还是按照顺序，先回应A请求，完成后再回应B请求。**\n\n### Content-Length 字段\n\n一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是`Content-length`字段的作用，声明本次回应的数据长度。\n```\nContent-Length: 3495\n```\n上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。\n在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。\n\n### 分块传输编码\n使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。\n\n对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用\"流模式\"（stream）取代\"缓存模式\"（buffer）。\n\n因此，1.1版规定可以不使用Content-Length字段，而使用\"分块传输编码\"（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。\n```\nTransfer-Encoding: chunked\n```\n每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。\n```\nHTTP/1.1 200 OK\nContent-Type: text/plain\nTransfer-Encoding: chunked\n\n25\nThis is the data in the first chunk\n\n1C\nand this is the second one\n\n3\ncon\n\n8\nsequence\n\n0\n\n```\n### 其他功能\n1.1版还新增了许多动词方法：`PUT`、`PATCH`、`HEAD`、 `OPTIONS`、`DELETE`。\n另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。\n```\nHost: www.example.com\n```\n有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。\n\n### 缺点\n虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为\"队头堵塞\"（Head-of-line blocking）。\n\n为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。\n\n## SPDY 协议\n\n2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。\n\n这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。\n\n## HTTP/2\n2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。\n\n### 二进制协议\nHTTP/1.1版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为\"帧\"（frame）：头信息帧和数据帧。\n\n二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。\n\n### 多工\nHTTP/2复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了\"队头堵塞\"。\n\n举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。\n这样双向的、实时的通信，就叫做`多工（Multiplexing）`。\n\n### 数据流\n因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。\nHTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。\n\n数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。\n\n客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。\n\n### 头信息压缩\nHTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。\n\nHTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。\n\n### 服务器推送\nHTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。\n\n常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。","source":"_posts/WEB交互/HTTP协议入门.md","raw":"---\ntitle: HTTP协议入门\ndate: 2016-09-12 21:22:50\ntags: \n- 协议\ncategories: 总结\n---\n>原文出处： [阮一峰 （@ruanyf）](http://www.ruanyifeng.com/blog/2016/08/http.html)\n\n最近成了阮一峰的迷弟，最近做实验正需要恶补一下协议的相关知识，因此写博客来记录一下学习之路。\n\n## 什么是HTTP？\n\n超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。\n<!-- more -->\n## HTTP/0.9\n\nHTTP 是基于 TCP/IP协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。\n最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。\n```\nGET /index.html\n```\n上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页`index.html`。\n\n协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。\n\n服务器发送完毕，就关闭TCP连接。\n\n## HTTP/1.0\n\n1996年5月，HTTP/1.0 版本发布，内容大大增加。\n\n首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。\n\n其次，除了`GET`命令，还引入了还引入了`POST`命令和`HEAD`命令，丰富了浏览器与服务器的互动手段。\n\n其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。\n\n### 请求格式\n\n```\nGET / HTTP/1.0\nUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)\nAccept: */*\n```\n可以看到，这个格式与0.9版有很大变化。\n第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。\n\n### 回应格式\n服务器的回应如下。\n```\nHTTP/1.0 200 OK \nContent-Type: text/plain\nContent-Length: 137582\nExpires: Thu, 05 Dec 1997 16:00:00 GMT\nLast-Modified: Wed, 5 August 1996 15:55:28 GMT\nServer: Apache 0.84\n\n<html>\n  <body>Hello World</body>\n</html>\n```\n回应的格式是\"头信息 + 一个空行（\\r\\n） + 数据\"。其中，第一行是\"协议版本 + 状态码（status code） + 状态描述\"。\n\n### Content-Type 字段\n关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。\n下面是一些常见的Content-Type字段的值。\n>text/plain\n>text/html\n>text/css\n>image/jpeg\n>image/png\n>image/svg+xml\n>audio/mp4\n>video/mp4\n>application/javascript\n>application/pdf\n>application/zip\n>application/atom+xml\n\n这些数据类型总称为`MIME type`，每个值包括一级类型和二级类型，之间用斜杠分隔。\n除了预定义的类型，厂商也可以自定义类型。\n```\napplication/vnd.debian.binary-package\n```\n上面的类型表明，发送的是Debian系统的二进制数据包。\n\n`MIME type`还可以在尾部使用分号，添加参数。\n```\nContent-Type: text/html; charset=utf-8\n```\n\n客户端请求的时候，可以使用`Accept`字段声明自己可以接受哪些数据格式。\n```\nAccept: */*\n```\n\n### Content-Encoding 字段\n\n由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。\n```\nContent-Encoding: gzip\nContent-Encoding: compress\nContent-Encoding: deflate\n```\n客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。\n```\nAccept-Encoding: gzip, deflate\n```\n### 缺点\nHTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。\n\nTCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。\n\n为了解决这个问题，有些浏览器在请求时，用了一个非标准的`Connection`字段。\n```\nConnection: keep-alive\n```\n这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。\n\n一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。\n\n## HTTP/1.1\n1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。\n\n###　持久连接\n1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明`Connection: keep-alive`。\n客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送`Connection: close`，明确要求服务器关闭TCP连接。\n\n目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。\n\n### 管道机制\n\n1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。\n\n举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是**服务器还是按照顺序，先回应A请求，完成后再回应B请求。**\n\n### Content-Length 字段\n\n一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是`Content-length`字段的作用，声明本次回应的数据长度。\n```\nContent-Length: 3495\n```\n上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。\n在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。\n\n### 分块传输编码\n使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。\n\n对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用\"流模式\"（stream）取代\"缓存模式\"（buffer）。\n\n因此，1.1版规定可以不使用Content-Length字段，而使用\"分块传输编码\"（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。\n```\nTransfer-Encoding: chunked\n```\n每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。\n```\nHTTP/1.1 200 OK\nContent-Type: text/plain\nTransfer-Encoding: chunked\n\n25\nThis is the data in the first chunk\n\n1C\nand this is the second one\n\n3\ncon\n\n8\nsequence\n\n0\n\n```\n### 其他功能\n1.1版还新增了许多动词方法：`PUT`、`PATCH`、`HEAD`、 `OPTIONS`、`DELETE`。\n另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。\n```\nHost: www.example.com\n```\n有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。\n\n### 缺点\n虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为\"队头堵塞\"（Head-of-line blocking）。\n\n为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。\n\n## SPDY 协议\n\n2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。\n\n这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。\n\n## HTTP/2\n2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。\n\n### 二进制协议\nHTTP/1.1版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为\"帧\"（frame）：头信息帧和数据帧。\n\n二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。\n\n### 多工\nHTTP/2复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了\"队头堵塞\"。\n\n举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。\n这样双向的、实时的通信，就叫做`多工（Multiplexing）`。\n\n### 数据流\n因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。\nHTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。\n\n数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。\n\n客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。\n\n### 头信息压缩\nHTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。\n\nHTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。\n\n### 服务器推送\nHTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。\n\n常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。","slug":"WEB交互/HTTP协议入门","published":1,"updated":"2019-03-22T14:44:36.719Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0300914l3ndf8khi3m","content":"<blockquote>\n<p>原文出处： <a href=\"http://www.ruanyifeng.com/blog/2016/08/http.html\" target=\"_blank\" rel=\"noopener\">阮一峰 （@ruanyf）</a></p>\n</blockquote>\n<p>最近成了阮一峰的迷弟，最近做实验正需要恶补一下协议的相关知识，因此写博客来记录一下学习之路。</p>\n<h2 id=\"什么是HTTP？\"><a href=\"#什么是HTTP？\" class=\"headerlink\" title=\"什么是HTTP？\"></a>什么是HTTP？</h2><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。<br><a id=\"more\"></a></p>\n<h2 id=\"HTTP-0-9\"><a href=\"#HTTP-0-9\" class=\"headerlink\" title=\"HTTP/0.9\"></a>HTTP/0.9</h2><p>HTTP 是基于 TCP/IP协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。<br>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"builtin-name\">GET</span> /index.html</span><br></pre></td></tr></table></figure></p>\n<p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p>\n<p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p>\n<p>服务器发送完毕，就关闭TCP连接。</p>\n<h2 id=\"HTTP-1-0\"><a href=\"#HTTP-1-0\" class=\"headerlink\" title=\"HTTP/1.0\"></a>HTTP/1.0</h2><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。</p>\n<p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p>\n<p>其次，除了<code>GET</code>命令，还引入了还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p>\n<p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>\n<h3 id=\"请求格式\"><a href=\"#请求格式\" class=\"headerlink\" title=\"请求格式\"></a>请求格式</h3><figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/</span> HTTP/1.0</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class=\"line\"><span class=\"attribute\">Accept</span>: */*</span><br></pre></td></tr></table></figure>\n<p>可以看到，这个格式与0.9版有很大变化。<br>第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。</p>\n<h3 id=\"回应格式\"><a href=\"#回应格式\" class=\"headerlink\" title=\"回应格式\"></a>回应格式</h3><p>服务器的回应如下。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.0 <span class=\"number\">200</span> OK </span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/plain</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 137582</span><br><span class=\"line\"><span class=\"attribute\">Expires</span>: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class=\"line\"><span class=\"attribute\">Last-Modified</span>: Wed, 5 August 1996 15:55:28 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server</span>: Apache 0.84</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>回应的格式是”头信息 + 一个空行（\\r\\n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p>\n<h3 id=\"Content-Type-字段\"><a href=\"#Content-Type-字段\" class=\"headerlink\" title=\"Content-Type 字段\"></a>Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。<br>下面是一些常见的Content-Type字段的值。</p>\n<blockquote>\n<p>text/plain<br>text/html<br>text/css<br>image/jpeg<br>image/png<br>image/svg+xml<br>audio/mp4<br>video/mp4<br>application/javascript<br>application/pdf<br>application/zip<br>application/atom+xml</p>\n</blockquote>\n<p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。<br>除了预定义的类型，厂商也可以自定义类型。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">application/vnd<span class=\"selector-class\">.debian</span><span class=\"selector-class\">.binary-package</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的类型表明，发送的是Debian系统的二进制数据包。</p>\n<p><code>MIME type</code>还可以在尾部使用分号，添加参数。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: text/html; <span class=\"attribute\">charset</span>=utf-8</span><br></pre></td></tr></table></figure></p>\n<p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Accept</span>: */*</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Content-Encoding-字段\"><a href=\"#Content-Encoding-字段\" class=\"headerlink\" title=\"Content-Encoding 字段\"></a>Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。<br><figure class=\"highlight csp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Content-Encoding</span>: gzip</span><br><span class=\"line\"><span class=\"attribute\">Content-Encoding</span>: compress</span><br><span class=\"line\"><span class=\"attribute\">Content-Encoding</span>: deflate</span><br></pre></td></tr></table></figure></p>\n<p>客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Accept</span>-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>\n<p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p>\n<p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。<br><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">Connection</span>: <span class=\"meta\">keep</span>-alive</span><br></pre></td></tr></table></figure></p>\n<p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p>\n<p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>\n<h2 id=\"HTTP-1-1\"><a href=\"#HTTP-1-1\" class=\"headerlink\" title=\"HTTP/1.1\"></a>HTTP/1.1</h2><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p>\n<p>###　持久连接<br>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。<br>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p>\n<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>\n<h3 id=\"管道机制\"><a href=\"#管道机制\" class=\"headerlink\" title=\"管道机制\"></a>管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>\n<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是<strong>服务器还是按照顺序，先回应A请求，完成后再回应B请求。</strong></p>\n<h3 id=\"Content-Length-字段\"><a href=\"#Content-Length-字段\" class=\"headerlink\" title=\"Content-Length 字段\"></a>Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。<br><figure class=\"highlight csp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 3495</span><br></pre></td></tr></table></figure></p>\n<p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。<br>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p>\n<h3 id=\"分块传输编码\"><a href=\"#分块传输编码\" class=\"headerlink\" title=\"分块传输编码\"></a>分块传输编码</h3><p>使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>\n<p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p>\n<p>因此，1.1版规定可以不使用Content-Length字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。<br><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Transfer</span>-Encoding: chunked</span><br></pre></td></tr></table></figure></p>\n<p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。<br><figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/plain</span><br><span class=\"line\"><span class=\"attribute\">Transfer-Encoding</span>: chunked</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">25</span></span><br><span class=\"line\">This is the data in the first chunk</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">1C</span></span><br><span class=\"line\">and this is the second one</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">3</span></span><br><span class=\"line\"><span class=\"attribute\">con</span></span><br><span class=\"line\"><span class=\"attribute\"></span></span><br><span class=\"line\"><span class=\"attribute\">8</span></span><br><span class=\"line\"><span class=\"attribute\">sequence</span></span><br><span class=\"line\"><span class=\"attribute\"></span></span><br><span class=\"line\"><span class=\"attribute\">0</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。<br>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host: www<span class=\"selector-class\">.example</span><span class=\"selector-class\">.com</span></span><br></pre></td></tr></table></figure></p>\n<p>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p>\n<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>\n<h2 id=\"SPDY-协议\"><a href=\"#SPDY-协议\" class=\"headerlink\" title=\"SPDY 协议\"></a>SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p>\n<p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p>\n<h2 id=\"HTTP-2\"><a href=\"#HTTP-2\" class=\"headerlink\" title=\"HTTP/2\"></a>HTTP/2</h2><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p>\n<h3 id=\"二进制协议\"><a href=\"#二进制协议\" class=\"headerlink\" title=\"二进制协议\"></a>二进制协议</h3><p>HTTP/1.1版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p>\n<p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>\n<h3 id=\"多工\"><a href=\"#多工\" class=\"headerlink\" title=\"多工\"></a>多工</h3><p>HTTP/2复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>\n<p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。<br>这样双向的、实时的通信，就叫做<code>多工（Multiplexing）</code>。</p>\n<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p>\n<p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p>\n<p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>\n<h3 id=\"头信息压缩\"><a href=\"#头信息压缩\" class=\"headerlink\" title=\"头信息压缩\"></a>头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>\n<p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>\n<h3 id=\"服务器推送\"><a href=\"#服务器推送\" class=\"headerlink\" title=\"服务器推送\"></a>服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p>\n<p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>原文出处： <a href=\"http://www.ruanyifeng.com/blog/2016/08/http.html\" target=\"_blank\" rel=\"noopener\">阮一峰 （@ruanyf）</a></p>\n</blockquote>\n<p>最近成了阮一峰的迷弟，最近做实验正需要恶补一下协议的相关知识，因此写博客来记录一下学习之路。</p>\n<h2 id=\"什么是HTTP？\"><a href=\"#什么是HTTP？\" class=\"headerlink\" title=\"什么是HTTP？\"></a>什么是HTTP？</h2><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。<br></p>","more":"<p></p>\n<h2 id=\"HTTP-0-9\"><a href=\"#HTTP-0-9\" class=\"headerlink\" title=\"HTTP/0.9\"></a>HTTP/0.9</h2><p>HTTP 是基于 TCP/IP协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用80端口。<br>最早版本是1991年发布的0.9版。该版本极其简单，只有一个命令GET。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"builtin-name\">GET</span> /index.html</span><br></pre></td></tr></table></figure></p>\n<p>上面命令表示，TCP 连接（connection）建立后，客户端向服务器请求（request）网页<code>index.html</code>。</p>\n<p>协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式。</p>\n<p>服务器发送完毕，就关闭TCP连接。</p>\n<h2 id=\"HTTP-1-0\"><a href=\"#HTTP-1-0\" class=\"headerlink\" title=\"HTTP/1.0\"></a>HTTP/1.0</h2><p>1996年5月，HTTP/1.0 版本发布，内容大大增加。</p>\n<p>首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。</p>\n<p>其次，除了<code>GET</code>命令，还引入了还引入了<code>POST</code>命令和<code>HEAD</code>命令，丰富了浏览器与服务器的互动手段。</p>\n<p>其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。</p>\n<h3 id=\"请求格式\"><a href=\"#请求格式\" class=\"headerlink\" title=\"请求格式\"></a>请求格式</h3><figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">GET</span> <span class=\"string\">/</span> HTTP/1.0</span><br><span class=\"line\"><span class=\"attribute\">User-Agent</span>: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_5)</span><br><span class=\"line\"><span class=\"attribute\">Accept</span>: */*</span><br></pre></td></tr></table></figure>\n<p>可以看到，这个格式与0.9版有很大变化。<br>第一行是请求命令，必须在尾部添加协议版本（HTTP/1.0）。后面就是多行头信息，描述客户端的情况。</p>\n<h3 id=\"回应格式\"><a href=\"#回应格式\" class=\"headerlink\" title=\"回应格式\"></a>回应格式</h3><p>服务器的回应如下。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.0 <span class=\"number\">200</span> OK </span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/plain</span><br><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 137582</span><br><span class=\"line\"><span class=\"attribute\">Expires</span>: Thu, 05 Dec 1997 16:00:00 GMT</span><br><span class=\"line\"><span class=\"attribute\">Last-Modified</span>: Wed, 5 August 1996 15:55:28 GMT</span><br><span class=\"line\"><span class=\"attribute\">Server</span>: Apache 0.84</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;html&gt;</span><br><span class=\"line\">  &lt;body&gt;Hello World&lt;/body&gt;</span><br><span class=\"line\">&lt;/html&gt;</span><br></pre></td></tr></table></figure></p>\n<p>回应的格式是”头信息 + 一个空行（\\r\\n） + 数据”。其中，第一行是”协议版本 + 状态码（status code） + 状态描述”。</p>\n<h3 id=\"Content-Type-字段\"><a href=\"#Content-Type-字段\" class=\"headerlink\" title=\"Content-Type 字段\"></a>Content-Type 字段</h3><p>关于字符的编码，1.0版规定，头信息必须是 ASCII 码，后面的数据可以是任何格式。因此，服务器回应的时候，必须告诉客户端，数据是什么格式，这就是Content-Type字段的作用。<br>下面是一些常见的Content-Type字段的值。</p>\n<blockquote>\n<p>text/plain<br>text/html<br>text/css<br>image/jpeg<br>image/png<br>image/svg+xml<br>audio/mp4<br>video/mp4<br>application/javascript<br>application/pdf<br>application/zip<br>application/atom+xml</p>\n</blockquote>\n<p>这些数据类型总称为<code>MIME type</code>，每个值包括一级类型和二级类型，之间用斜杠分隔。<br>除了预定义的类型，厂商也可以自定义类型。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">application/vnd<span class=\"selector-class\">.debian</span><span class=\"selector-class\">.binary-package</span></span><br></pre></td></tr></table></figure></p>\n<p>上面的类型表明，发送的是Debian系统的二进制数据包。</p>\n<p><code>MIME type</code>还可以在尾部使用分号，添加参数。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Content-Type: text/html; <span class=\"attribute\">charset</span>=utf-8</span><br></pre></td></tr></table></figure></p>\n<p>客户端请求的时候，可以使用<code>Accept</code>字段声明自己可以接受哪些数据格式。<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Accept</span>: */*</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Content-Encoding-字段\"><a href=\"#Content-Encoding-字段\" class=\"headerlink\" title=\"Content-Encoding 字段\"></a>Content-Encoding 字段</h3><p>由于发送的数据可以是任何格式，因此可以把数据压缩后再发送。Content-Encoding字段说明数据的压缩方法。<br><figure class=\"highlight csp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Content-Encoding</span>: gzip</span><br><span class=\"line\"><span class=\"attribute\">Content-Encoding</span>: compress</span><br><span class=\"line\"><span class=\"attribute\">Content-Encoding</span>: deflate</span><br></pre></td></tr></table></figure></p>\n<p>客户端在请求时，用Accept-Encoding字段说明自己可以接受哪些压缩方法。<br><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">Accept</span>-Encoding: gzip, deflate</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。</p>\n<p>TCP连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。</p>\n<p>为了解决这个问题，有些浏览器在请求时，用了一个非标准的<code>Connection</code>字段。<br><figure class=\"highlight armasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"symbol\">Connection</span>: <span class=\"meta\">keep</span>-alive</span><br></pre></td></tr></table></figure></p>\n<p>这个字段要求服务器不要关闭TCP连接，以便其他请求复用。服务器同样回应这个字段。</p>\n<p>一个可以复用的TCP连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。</p>\n<h2 id=\"HTTP-1-1\"><a href=\"#HTTP-1-1\" class=\"headerlink\" title=\"HTTP/1.1\"></a>HTTP/1.1</h2><p>1997年1月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了20年后的今天，直到现在还是最流行的版本。</p>\n<p>###　持久连接<br>1.1 版的最大变化，就是引入了持久连接（persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明<code>Connection: keep-alive</code>。<br>客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送<code>Connection: close</code>，明确要求服务器关闭TCP连接。</p>\n<p>目前，对于同一个域名，大多数浏览器允许同时建立6个持久连接。</p>\n<h3 id=\"管道机制\"><a href=\"#管道机制\" class=\"headerlink\" title=\"管道机制\"></a>管道机制</h3><p>1.1 版还引入了管道机制（pipelining），即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。</p>\n<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送A请求，然后等待服务器做出回应，收到后再发出B请求。管道机制则是允许浏览器同时发出A请求和B请求，但是<strong>服务器还是按照顺序，先回应A请求，完成后再回应B请求。</strong></p>\n<h3 id=\"Content-Length-字段\"><a href=\"#Content-Length-字段\" class=\"headerlink\" title=\"Content-Length 字段\"></a>Content-Length 字段</h3><p>一个TCP连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是<code>Content-length</code>字段的作用，声明本次回应的数据长度。<br><figure class=\"highlight csp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">Content-Length</span>: 3495</span><br></pre></td></tr></table></figure></p>\n<p>上面代码告诉浏览器，本次回应的长度是3495个字节，后面的字节就属于下一个回应了。<br>在1.0版中，Content-Length字段不是必需的，因为浏览器发现服务器关闭了TCP连接，就表明收到的数据包已经全了。</p>\n<h3 id=\"分块传输编码\"><a href=\"#分块传输编码\" class=\"headerlink\" title=\"分块传输编码\"></a>分块传输编码</h3><p>使用Content-Length字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。</p>\n<p>对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用”流模式”（stream）取代”缓存模式”（buffer）。</p>\n<p>因此，1.1版规定可以不使用Content-Length字段，而使用”分块传输编码”（chunked transfer encoding）。只要请求或回应的头信息有Transfer-Encoding字段，就表明回应将由数量未定的数据块组成。<br><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Transfer</span>-Encoding: chunked</span><br></pre></td></tr></table></figure></p>\n<p>每个非空的数据块之前，会有一个16进制的数值，表示这个块的长度。最后是一个大小为0的块，就表示本次回应的数据发送完了。下面是一个例子。<br><figure class=\"highlight http\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP/1.1 <span class=\"number\">200</span> OK</span><br><span class=\"line\"><span class=\"attribute\">Content-Type</span>: text/plain</span><br><span class=\"line\"><span class=\"attribute\">Transfer-Encoding</span>: chunked</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">25</span></span><br><span class=\"line\">This is the data in the first chunk</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">1C</span></span><br><span class=\"line\">and this is the second one</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attribute\">3</span></span><br><span class=\"line\"><span class=\"attribute\">con</span></span><br><span class=\"line\"><span class=\"attribute\"></span></span><br><span class=\"line\"><span class=\"attribute\">8</span></span><br><span class=\"line\"><span class=\"attribute\">sequence</span></span><br><span class=\"line\"><span class=\"attribute\"></span></span><br><span class=\"line\"><span class=\"attribute\">0</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"其他功能\"><a href=\"#其他功能\" class=\"headerlink\" title=\"其他功能\"></a>其他功能</h3><p>1.1版还新增了许多动词方法：<code>PUT</code>、<code>PATCH</code>、<code>HEAD</code>、 <code>OPTIONS</code>、<code>DELETE</code>。<br>另外，客户端请求的头信息新增了Host字段，用来指定服务器的域名。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host: www<span class=\"selector-class\">.example</span><span class=\"selector-class\">.com</span></span><br></pre></td></tr></table></figure></p>\n<p>有了Host字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。</p>\n<h3 id=\"缺点-1\"><a href=\"#缺点-1\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>虽然1.1版允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p>\n<p>为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入CSS代码、域名分片（domain sharding）等等。如果HTTP协议设计得更好一些，这些额外的工作是可以避免的。</p>\n<h2 id=\"SPDY-协议\"><a href=\"#SPDY-协议\" class=\"headerlink\" title=\"SPDY 协议\"></a>SPDY 协议</h2><p>2009年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。</p>\n<p>这个协议在Chrome浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。</p>\n<h2 id=\"HTTP-2\"><a href=\"#HTTP-2\" class=\"headerlink\" title=\"HTTP/2\"></a>HTTP/2</h2><p>2015年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。</p>\n<h3 id=\"二进制协议\"><a href=\"#二进制协议\" class=\"headerlink\" title=\"二进制协议\"></a>二进制协议</h3><p>HTTP/1.1版的头信息肯定是文本（ASCII编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”（frame）：头信息帧和数据帧。</p>\n<p>二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。</p>\n<h3 id=\"多工\"><a href=\"#多工\" class=\"headerlink\" title=\"多工\"></a>多工</h3><p>HTTP/2复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了”队头堵塞”。</p>\n<p>举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。<br>这样双向的、实时的通信，就叫做<code>多工（Multiplexing）</code>。</p>\n<h3 id=\"数据流\"><a href=\"#数据流\" class=\"headerlink\" title=\"数据流\"></a>数据流</h3><p>因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。<br>HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID一律为奇数，服务器发出的，ID为偶数。</p>\n<p>数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM帧），取消这个数据流。1.1版取消数据流的唯一方法，就是关闭TCP连接。这就是说，HTTP/2 可以取消某一次请求，同时保证TCP连接还打开着，可以被其他请求使用。</p>\n<p>客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。</p>\n<h3 id=\"头信息压缩\"><a href=\"#头信息压缩\" class=\"headerlink\" title=\"头信息压缩\"></a>头信息压缩</h3><p>HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如Cookie和User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。</p>\n<p>HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用gzip或compress压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>\n<h3 id=\"服务器推送\"><a href=\"#服务器推送\" class=\"headerlink\" title=\"服务器推送\"></a>服务器推送</h3><p>HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。</p>\n<p>常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析HTML源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。</p>"},{"title":"互联网协议入门(2)","date":"2016-09-10T12:59:50.000Z","_content":"\n>原文出处： [阮一峰 （@ruanyf）](http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html)\n\n\n之前上一篇中提到过，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：\n![以太网的数据包](http://image.beekka.com/blog/201205/bg2012052913.png)\n\n<!-- more -->\n\n发送这个包，需要知道两个地址：\n\n　* 对方的MAC地址\n　* 对方的IP地址\n\n有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。\n\n![网关](http://image.beekka.com/blog/201206/bg2012061101.jpg)\n\n上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。\n\n1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：\n\n\n|场景\t|数据包地址|\n|-----------|:-----------------|\n|同一个子网络\t|对方的MAC地址，对方的IP地址|\n|非同一个子网络\t|网关的MAC地址，对方的IP地址|\n\n发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。\n\n## 用户的上网设置\n你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？\n\n通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：\n\n* 本机的IP地址\n* 子网掩码\n* 网关的IP地址\n* DNS的IP地址\n\n这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作\"静态IP地址上网\"。\n\n但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用\"动态IP地址上网\"。\n\n### 动态IP地址\n\n所谓\"动态IP地址\"，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做`DHCP协议`。\n\n这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做\"DHCP服务器\"。新的计算机加入网络，必须向\"DHCP服务器\"发送一个\"DHCP请求\"数据包，申请IP地址和相关的网络参数。\n\n前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？\n\nDHCP协议做了一些巧妙的规定。\n\n### DHCP协议\n\n首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：\n\n![UDP](http://image.beekka.com/blog/201206/bg2012061102.png)\n\n（1）最前面的\"以太网标头\"，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。\n\n（2）后面的\"IP标头\"，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。\n\n（3）最后的\"UDP标头\"，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。\n\n这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道\"这个包是发给我的\"，而其他计算机就可以丢弃这个包。\n\n接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个\"DHCP响应\"数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。\n新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。\n\n### 小结\n需要记住的就是一点：不管是\"静态IP地址\"还是\"动态IP地址\"，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：\n\n* 本机的IP地址\n* 子网掩码\n* 网关的IP地址\n* DNS的IP地址\n\n有了这几个数值，电脑就可以上网\"冲浪\"了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。\n\n## 一个实例：访问网页\n我们假定，经过上一节的步骤，用户设置好了自己的网络参数：\n\n　　* 本机的IP地址：192.168.1.100\n　　* 子网掩码：255.255.255.0\n　　* 网关的IP地址：192.168.1.1\n　　* DNS的IP地址：8.8.8.8\n\n然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。\n\n这意味着，浏览器要向Google发送一个网页请求的数据包。\n\n### DNS协议\n我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。\n\n首先我们了解一下DNS。\n\nDNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。DNS是因特网的一项核心服务,它作为可以将域名和IP地址相互映射的一个分布式数据库。\n\nDNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。\n\n### 子网掩码\n\n接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。\n\n已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。\n\n因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。\n\n###　应用层协议\n浏览网页用的是HTTP协议，它的整个数据包构造是这样的：\n![HTTP](http://image.beekka.com/blog/201206/bg2012061106.png)\nHTTP部分的内容，类似于下面这样：\n```\n　GET / HTTP/1.1\n　　Host: www.google.com\n　　Connection: keep-alive\n　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ......\n　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n　　Accept-Encoding: gzip,deflate,sdch\n　　Accept-Language: zh-CN,zh;q=0.8\n　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3\n　　Cookie: ... ...\n```\n我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。\n\n### TCP协议\n\nTCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。\n\nTCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。\n\n\n### IP协议\n\n然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。\n\nIP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。\n\n### 以太网协议\n最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。\n\n以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。\n\n![以太网协议](http://image.beekka.com/blog/201206/bg2012061106.png)\n\n### 服务器端响应\n经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。\n\n根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的\"HTTP请求\"，接着做出\"HTTP响应\"，再用TCP协议发回来。\n\n本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。\n\n至此，网页才得以显示。\n\n虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。","source":"_posts/WEB交互/互联网协议入门(2).md","raw":"---\ntitle: 互联网协议入门(2)\ndate: 2016-09-10 20:59:50\ntags: \n- 协议\ncategories: 总结\n---\n\n>原文出处： [阮一峰 （@ruanyf）](http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html)\n\n\n之前上一篇中提到过，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：\n![以太网的数据包](http://image.beekka.com/blog/201205/bg2012052913.png)\n\n<!-- more -->\n\n发送这个包，需要知道两个地址：\n\n　* 对方的MAC地址\n　* 对方的IP地址\n\n有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。\n\n![网关](http://image.beekka.com/blog/201206/bg2012061101.jpg)\n\n上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。\n\n1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：\n\n\n|场景\t|数据包地址|\n|-----------|:-----------------|\n|同一个子网络\t|对方的MAC地址，对方的IP地址|\n|非同一个子网络\t|网关的MAC地址，对方的IP地址|\n\n发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。\n\n## 用户的上网设置\n你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？\n\n通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：\n\n* 本机的IP地址\n* 子网掩码\n* 网关的IP地址\n* DNS的IP地址\n\n这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作\"静态IP地址上网\"。\n\n但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用\"动态IP地址上网\"。\n\n### 动态IP地址\n\n所谓\"动态IP地址\"，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做`DHCP协议`。\n\n这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做\"DHCP服务器\"。新的计算机加入网络，必须向\"DHCP服务器\"发送一个\"DHCP请求\"数据包，申请IP地址和相关的网络参数。\n\n前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？\n\nDHCP协议做了一些巧妙的规定。\n\n### DHCP协议\n\n首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：\n\n![UDP](http://image.beekka.com/blog/201206/bg2012061102.png)\n\n（1）最前面的\"以太网标头\"，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。\n\n（2）后面的\"IP标头\"，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。\n\n（3）最后的\"UDP标头\"，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。\n\n这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道\"这个包是发给我的\"，而其他计算机就可以丢弃这个包。\n\n接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个\"DHCP响应\"数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。\n新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。\n\n### 小结\n需要记住的就是一点：不管是\"静态IP地址\"还是\"动态IP地址\"，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：\n\n* 本机的IP地址\n* 子网掩码\n* 网关的IP地址\n* DNS的IP地址\n\n有了这几个数值，电脑就可以上网\"冲浪\"了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。\n\n## 一个实例：访问网页\n我们假定，经过上一节的步骤，用户设置好了自己的网络参数：\n\n　　* 本机的IP地址：192.168.1.100\n　　* 子网掩码：255.255.255.0\n　　* 网关的IP地址：192.168.1.1\n　　* DNS的IP地址：8.8.8.8\n\n然后他打开浏览器，想要访问Google，在地址栏输入了网址：www.google.com。\n\n这意味着，浏览器要向Google发送一个网页请求的数据包。\n\n### DNS协议\n我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址www.google.com，不知道它的IP地址。\n\n首先我们了解一下DNS。\n\nDNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。DNS是因特网的一项核心服务,它作为可以将域名和IP地址相互映射的一个分布式数据库。\n\nDNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。\n\n### 子网掩码\n\n接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。\n\n已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。\n\n因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。\n\n###　应用层协议\n浏览网页用的是HTTP协议，它的整个数据包构造是这样的：\n![HTTP](http://image.beekka.com/blog/201206/bg2012061106.png)\nHTTP部分的内容，类似于下面这样：\n```\n　GET / HTTP/1.1\n　　Host: www.google.com\n　　Connection: keep-alive\n　　User-Agent: Mozilla/5.0 (Windows NT 6.1) ......\n　　Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n　　Accept-Encoding: gzip,deflate,sdch\n　　Accept-Language: zh-CN,zh;q=0.8\n　　Accept-Charset: GBK,utf-8;q=0.7,*;q=0.3\n　　Cookie: ... ...\n```\n我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。\n\n### TCP协议\n\nTCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。\n\nTCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。\n\n\n### IP协议\n\n然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。\n\nIP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。\n\n### 以太网协议\n最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。\n\n以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。\n\n![以太网协议](http://image.beekka.com/blog/201206/bg2012061106.png)\n\n### 服务器端响应\n经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。\n\n根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的\"HTTP请求\"，接着做出\"HTTP响应\"，再用TCP协议发回来。\n\n本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。\n\n至此，网页才得以显示。\n\n虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。","slug":"WEB交互/互联网协议入门(2)","published":1,"updated":"2019-03-22T14:44:36.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0400934l3nyn3d3yho","content":"<blockquote>\n<p>原文出处： <a href=\"http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html\" target=\"_blank\" rel=\"noopener\">阮一峰 （@ruanyf）</a></p>\n</blockquote>\n<p>之前上一篇中提到过，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：<br><img src=\"http://image.beekka.com/blog/201205/bg2012052913.png\" alt=\"以太网的数据包\"></p>\n<a id=\"more\"></a>\n<p>发送这个包，需要知道两个地址：</p>\n<p>　<em> 对方的MAC地址\n　</em> 对方的IP地址</p>\n<p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p>\n<p><img src=\"http://image.beekka.com/blog/201206/bg2012061101.jpg\" alt=\"网关\"></p>\n<p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p>\n<p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：</p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th style=\"text-align:left\">数据包地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同一个子网络</td>\n<td style=\"text-align:left\">对方的MAC地址，对方的IP地址</td>\n</tr>\n<tr>\n<td>非同一个子网络</td>\n<td style=\"text-align:left\">网关的MAC地址，对方的IP地址</td>\n</tr>\n</tbody>\n</table>\n<p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。</p>\n<h2 id=\"用户的上网设置\"><a href=\"#用户的上网设置\" class=\"headerlink\" title=\"用户的上网设置\"></a>用户的上网设置</h2><p>你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？</p>\n<p>通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p>\n<ul>\n<li>本机的IP地址</li>\n<li>子网掩码</li>\n<li>网关的IP地址</li>\n<li>DNS的IP地址</li>\n</ul>\n<p>这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。</p>\n<p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p>\n<h3 id=\"动态IP地址\"><a href=\"#动态IP地址\" class=\"headerlink\" title=\"动态IP地址\"></a>动态IP地址</h3><p>所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做<code>DHCP协议</code>。</p>\n<p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p>\n<p>前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p>\n<p>DHCP协议做了一些巧妙的规定。</p>\n<h3 id=\"DHCP协议\"><a href=\"#DHCP协议\" class=\"headerlink\" title=\"DHCP协议\"></a>DHCP协议</h3><p>首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</p>\n<p><img src=\"http://image.beekka.com/blog/201206/bg2012061102.png\" alt=\"UDP\"></p>\n<p>（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p>\n<p>（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p>\n<p>（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p>\n<p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p>\n<p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。<br>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：</p>\n<ul>\n<li>本机的IP地址</li>\n<li>子网掩码</li>\n<li>网关的IP地址</li>\n<li>DNS的IP地址</li>\n</ul>\n<p>有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。</p>\n<h2 id=\"一个实例：访问网页\"><a href=\"#一个实例：访问网页\" class=\"headerlink\" title=\"一个实例：访问网页\"></a>一个实例：访问网页</h2><p>我们假定，经过上一节的步骤，用户设置好了自己的网络参数：</p>\n<p>　　<em> 本机的IP地址：192.168.1.100\n　　</em> 子网掩码：255.255.255.0<br>　　<em> 网关的IP地址：192.168.1.1\n　　</em> DNS的IP地址：8.8.8.8</p>\n<p>然后他打开浏览器，想要访问Google，在地址栏输入了网址：<a href=\"http://www.google.com。\" target=\"_blank\" rel=\"noopener\">www.google.com。</a></p>\n<p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p>\n<h3 id=\"DNS协议\"><a href=\"#DNS协议\" class=\"headerlink\" title=\"DNS协议\"></a>DNS协议</h3><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址<a href=\"http://www.google.com，不知道它的IP地址。\" target=\"_blank\" rel=\"noopener\">www.google.com，不知道它的IP地址。</a></p>\n<p>首先我们了解一下DNS。</p>\n<p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。DNS是因特网的一项核心服务,它作为可以将域名和IP地址相互映射的一个分布式数据库。</p>\n<p>DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</p>\n<h3 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h3><p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p>\n<p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p>\n<p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p>\n<p>###　应用层协议<br>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：<br><img src=\"http://image.beekka.com/blog/201206/bg2012061106.png\" alt=\"HTTP\"><br>HTTP部分的内容，类似于下面这样：<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　<span class=\"builtin-name\">GET</span> / HTTP/1.1</span><br><span class=\"line\">　　Host: www.google.com</span><br><span class=\"line\">　　Connection: keep-alive</span><br><span class=\"line\">　　User-Agent: Mozilla/5.0 (Windows NT 6.1) <span class=\"built_in\">..</span><span class=\"built_in\">..</span><span class=\"built_in\">..</span></span><br><span class=\"line\">　　Accept: text/html,application/xhtml+xml,application/xml;<span class=\"attribute\">q</span>=0.9,*/*;q=0.8</span><br><span class=\"line\">　　Accept-Encoding: gzip,deflate,sdch</span><br><span class=\"line\">　　Accept-Language: zh-CN,zh;<span class=\"attribute\">q</span>=0.8</span><br><span class=\"line\">　　Accept-Charset: GBK,utf-8;<span class=\"attribute\">q</span>=0.7,*;q=0.3</span><br><span class=\"line\">　　Cookie: <span class=\"built_in\">..</span>. <span class=\"built_in\">..</span>.</span><br></pre></td></tr></table></figure></p>\n<p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p>\n<h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p>\n<p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p>\n<h3 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h3><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p>\n<p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p>\n<h3 id=\"以太网协议\"><a href=\"#以太网协议\" class=\"headerlink\" title=\"以太网协议\"></a>以太网协议</h3><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p>\n<p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p>\n<p><img src=\"http://image.beekka.com/blog/201206/bg2012061106.png\" alt=\"以太网协议\"></p>\n<h3 id=\"服务器端响应\"><a href=\"#服务器端响应\" class=\"headerlink\" title=\"服务器端响应\"></a>服务器端响应</h3><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p>\n<p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p>\n<p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>\n<p>至此，网页才得以显示。</p>\n<p>虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>原文出处： <a href=\"http://www.ruanyifeng.com/blog/2012/06/internet_protocol_suite_part_ii.html\" target=\"_blank\" rel=\"noopener\">阮一峰 （@ruanyf）</a></p>\n</blockquote>\n<p>之前上一篇中提到过，网络通信就是交换数据包。电脑A向电脑B发送一个数据包，后者收到了，回复一个数据包，从而实现两台电脑之间的通信。数据包的结构，基本上是下面这样：<br><img src=\"http://image.beekka.com/blog/201205/bg2012052913.png\" alt=\"以太网的数据包\"></p>","more":"<p>发送这个包，需要知道两个地址：</p>\n<p>　<em> 对方的MAC地址\n　</em> 对方的IP地址</p>\n<p>有了这两个地址，数据包才能准确送到接收者手中。但是，前面说过，MAC地址有局限性，如果两台电脑不在同一个子网络，就无法知道对方的MAC地址，必须通过网关（gateway）转发。</p>\n<p><img src=\"http://image.beekka.com/blog/201206/bg2012061101.jpg\" alt=\"网关\"></p>\n<p>上图中，1号电脑要向4号电脑发送一个数据包。它先判断4号电脑是否在同一个子网络，结果发现不是（后文介绍判断方法），于是就把这个数据包发到网关A。网关A通过路由协议，发现4号电脑位于子网络B，又把数据包发给网关B，网关B再转发到4号电脑。</p>\n<p>1号电脑把数据包发到网关A，必须知道网关A的MAC地址。所以，数据包的目标地址，实际上分成两种情况：</p>\n<table>\n<thead>\n<tr>\n<th>场景</th>\n<th style=\"text-align:left\">数据包地址</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>同一个子网络</td>\n<td style=\"text-align:left\">对方的MAC地址，对方的IP地址</td>\n</tr>\n<tr>\n<td>非同一个子网络</td>\n<td style=\"text-align:left\">网关的MAC地址，对方的IP地址</td>\n</tr>\n</tbody>\n</table>\n<p>发送数据包之前，电脑必须判断对方是否在同一个子网络，然后选择相应的MAC地址。接下来，我们就来看，实际使用中，这个过程是怎么完成的。</p>\n<h2 id=\"用户的上网设置\"><a href=\"#用户的上网设置\" class=\"headerlink\" title=\"用户的上网设置\"></a>用户的上网设置</h2><p>你买了一台新电脑，插上网线，开机，这时电脑能够上网吗？</p>\n<p>通常你必须做一些设置。有时，管理员（或者ISP）会告诉你下面四个参数，你把它们填入操作系统，计算机就能连上网了：</p>\n<ul>\n<li>本机的IP地址</li>\n<li>子网掩码</li>\n<li>网关的IP地址</li>\n<li>DNS的IP地址</li>\n</ul>\n<p>这四个参数缺一不可，后文会解释为什么需要知道它们才能上网。由于它们是给定的，计算机每次开机，都会分到同样的IP地址，所以这种情况被称作”静态IP地址上网”。</p>\n<p>但是，这样的设置很专业，普通用户望而生畏，而且如果一台电脑的IP地址保持不变，其他电脑就不能使用这个地址，不够灵活。出于这两个原因，大多数用户使用”动态IP地址上网”。</p>\n<h3 id=\"动态IP地址\"><a href=\"#动态IP地址\" class=\"headerlink\" title=\"动态IP地址\"></a>动态IP地址</h3><p>所谓”动态IP地址”，指计算机开机后，会自动分配到一个IP地址，不用人为设定。它使用的协议叫做<code>DHCP协议</code>。</p>\n<p>这个协议规定，每一个子网络中，有一台计算机负责管理本网络的所有IP地址，它叫做”DHCP服务器”。新的计算机加入网络，必须向”DHCP服务器”发送一个”DHCP请求”数据包，申请IP地址和相关的网络参数。</p>\n<p>前面说过，如果两台计算机在同一个子网络，必须知道对方的MAC地址和IP地址，才能发送数据包。但是，新加入的计算机不知道这两个地址，怎么发送数据包呢？</p>\n<p>DHCP协议做了一些巧妙的规定。</p>\n<h3 id=\"DHCP协议\"><a href=\"#DHCP协议\" class=\"headerlink\" title=\"DHCP协议\"></a>DHCP协议</h3><p>首先，它是一种应用层协议，建立在UDP协议之上，所以整个数据包是这样的：</p>\n<p><img src=\"http://image.beekka.com/blog/201206/bg2012061102.png\" alt=\"UDP\"></p>\n<p>（1）最前面的”以太网标头”，设置发出方（本机）的MAC地址和接收方（DHCP服务器）的MAC地址。前者就是本机网卡的MAC地址，后者这时不知道，就填入一个广播地址：FF-FF-FF-FF-FF-FF。</p>\n<p>（2）后面的”IP标头”，设置发出方的IP地址和接收方的IP地址。这时，对于这两者，本机都不知道。于是，发出方的IP地址就设为0.0.0.0，接收方的IP地址设为255.255.255.255。</p>\n<p>（3）最后的”UDP标头”，设置发出方的端口和接收方的端口。这一部分是DHCP协议规定好的，发出方是68端口，接收方是67端口。</p>\n<p>这个数据包构造完成后，就可以发出了。以太网是广播发送，同一个子网络的每台计算机都收到了这个包。因为接收方的MAC地址是FF-FF-FF-FF-FF-FF，看不出是发给谁的，所以每台收到这个包的计算机，还必须分析这个包的IP地址，才能确定是不是发给自己的。当看到发出方IP地址是0.0.0.0，接收方是255.255.255.255，于是DHCP服务器知道”这个包是发给我的”，而其他计算机就可以丢弃这个包。</p>\n<p>接下来，DHCP服务器读出这个包的数据内容，分配好IP地址，发送回去一个”DHCP响应”数据包。这个响应包的结构也是类似的，以太网标头的MAC地址是双方的网卡地址，IP标头的IP地址是DHCP服务器的IP地址（发出方）和255.255.255.255（接收方），UDP标头的端口是67（发出方）和68（接收方），分配给请求端的IP地址和本网络的具体参数则包含在Data部分。<br>新加入的计算机收到这个响应包，于是就知道了自己的IP地址、子网掩码、网关地址、DNS服务器等等参数。</p>\n<h3 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h3><p>需要记住的就是一点：不管是”静态IP地址”还是”动态IP地址”，电脑上网的首要步骤，是确定四个参数。这四个值很重要，值得重复一遍：</p>\n<ul>\n<li>本机的IP地址</li>\n<li>子网掩码</li>\n<li>网关的IP地址</li>\n<li>DNS的IP地址</li>\n</ul>\n<p>有了这几个数值，电脑就可以上网”冲浪”了。接下来，我们来看一个实例，当用户访问网页的时候，互联网协议是怎么运作的。</p>\n<h2 id=\"一个实例：访问网页\"><a href=\"#一个实例：访问网页\" class=\"headerlink\" title=\"一个实例：访问网页\"></a>一个实例：访问网页</h2><p>我们假定，经过上一节的步骤，用户设置好了自己的网络参数：</p>\n<p>　　<em> 本机的IP地址：192.168.1.100\n　　</em> 子网掩码：255.255.255.0<br>　　<em> 网关的IP地址：192.168.1.1\n　　</em> DNS的IP地址：8.8.8.8</p>\n<p>然后他打开浏览器，想要访问Google，在地址栏输入了网址：<a href=\"http://www.google.com。\" target=\"_blank\" rel=\"noopener\">www.google.com。</a></p>\n<p>这意味着，浏览器要向Google发送一个网页请求的数据包。</p>\n<h3 id=\"DNS协议\"><a href=\"#DNS协议\" class=\"headerlink\" title=\"DNS协议\"></a>DNS协议</h3><p>我们知道，发送数据包，必须要知道对方的IP地址。但是，现在，我们只知道网址<a href=\"http://www.google.com，不知道它的IP地址。\" target=\"_blank\" rel=\"noopener\">www.google.com，不知道它的IP地址。</a></p>\n<p>首先我们了解一下DNS。</p>\n<p>DNS是域名系统(DomainNameSystem)的缩写，该系统用于命名组织到域层次结构中的计算机和网络服务。域名是由圆点分开一串单词或缩写组成的，每一个域名都对应一个惟一的IP地址，在Internet上域名与IP地址之间是一一对应的，DNS就是进行域名解析的服务器。DNS命名用于Internet等TCP/IP网络中，通过用户友好的名称查找计算机和服务。DNS是因特网的一项核心服务,它作为可以将域名和IP地址相互映射的一个分布式数据库。</p>\n<p>DNS协议可以帮助我们，将这个网址转换成IP地址。已知DNS服务器为8.8.8.8，于是我们向这个地址发送一个DNS数据包（53端口）。</p>\n<h3 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h3><p>接下来，我们要判断，这个IP地址是不是在同一个子网络，这就要用到子网掩码。</p>\n<p>已知子网掩码是255.255.255.0，本机用它对自己的IP地址192.168.1.100，做一个二进制的AND运算（两个数位都为1，结果为1，否则为0），计算结果为192.168.1.0；然后对Google的IP地址172.194.72.105也做一个AND运算，计算结果为172.194.72.0。这两个结果不相等，所以结论是，Google与本机不在同一个子网络。</p>\n<p>因此，我们要向Google发送数据包，必须通过网关192.168.1.1转发，也就是说，接收方的MAC地址将是网关的MAC地址。</p>\n<p>###　应用层协议<br>浏览网页用的是HTTP协议，它的整个数据包构造是这样的：<br><img src=\"http://image.beekka.com/blog/201206/bg2012061106.png\" alt=\"HTTP\"><br>HTTP部分的内容，类似于下面这样：<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　<span class=\"builtin-name\">GET</span> / HTTP/1.1</span><br><span class=\"line\">　　Host: www.google.com</span><br><span class=\"line\">　　Connection: keep-alive</span><br><span class=\"line\">　　User-Agent: Mozilla/5.0 (Windows NT 6.1) <span class=\"built_in\">..</span><span class=\"built_in\">..</span><span class=\"built_in\">..</span></span><br><span class=\"line\">　　Accept: text/html,application/xhtml+xml,application/xml;<span class=\"attribute\">q</span>=0.9,*/*;q=0.8</span><br><span class=\"line\">　　Accept-Encoding: gzip,deflate,sdch</span><br><span class=\"line\">　　Accept-Language: zh-CN,zh;<span class=\"attribute\">q</span>=0.8</span><br><span class=\"line\">　　Accept-Charset: GBK,utf-8;<span class=\"attribute\">q</span>=0.7,*;q=0.3</span><br><span class=\"line\">　　Cookie: <span class=\"built_in\">..</span>. <span class=\"built_in\">..</span>.</span><br></pre></td></tr></table></figure></p>\n<p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p>\n<h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p>\n<p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p>\n<h3 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h3><p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p>\n<p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p>\n<h3 id=\"以太网协议\"><a href=\"#以太网协议\" class=\"headerlink\" title=\"以太网协议\"></a>以太网协议</h3><p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p>\n<p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560。</p>\n<p><img src=\"http://image.beekka.com/blog/201206/bg2012061106.png\" alt=\"以太网协议\"></p>\n<h3 id=\"服务器端响应\"><a href=\"#服务器端响应\" class=\"headerlink\" title=\"服务器端响应\"></a>服务器端响应</h3><p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p>\n<p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p>\n<p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>\n<p>至此，网页才得以显示。</p>\n<p>虽然经过了简化，但它大致上反映了互联网协议的整个通信过程。</p>"},{"title":"对java的理解","date":"2018-11-08T09:35:00.000Z","_content":"\n\n### Write once， run anywhere\n\n“Write once， run anywhere” 说的是Java语言跨平台的特性，Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。有了编译器就屏蔽了不同机器语言的区别，有了系统API就屏蔽了不同硬件的区别，有了JVM就屏蔽了不同操作系统的区别，有了TCP/IP就屏蔽了不同系统之间通讯的差异。\n\n<!-- more -->\n\n### java语言特性\n\n包括面向对象，泛型、反射、Lambda等语言特性；\n\n#### Java类库\n\n核心类库包括集合、IO/NIO等，网络，并发，安全等基础类库，其他第三方类库。\n\n#### Java的类加载机制\n\n常用版本JDK内嵌的Class-Loader，例如Bootstrap、Application和Extension Class-loader， 以及自定义Class-Loader等。\n\n#### 类加载的大致过程\n\n加载 \\rightarrow 验证 \\rightarrow 链接 \\rightarrow 初始化\n\n#### 垃圾收集的基本原理\n\n最常见额垃圾收集器，如SerialGC、Parallel GC、CMS、G1等，适用于什么样的负载\n还有运行时，动态编译，辅助功能JFR等\n\n#### 工具类\n\n`辅助工具`：jlink、jar、jdeps之类\n`编译器`：javac，sjavac\n`诊断工具`：jmap、jstack、jconsole、jhsdb，jcmd等进行监控诊断工具，程序的性能进行监控诊断，进行程序的诊断和调优工作\n\n#### Java/JVM生态\n\nJava EE，spring， Hadoop，Spark，Cassandra，ElasticSearch，Maven\n\n### Java的编译时和运行时\n\nJava分为编译时和运行时。\n编译指的是生成`。class`字节码，而不是可以直接执行的机器码，通过字节码和Java虚拟机(JVM)这种跨平台的抽象来屏蔽了操作系统和硬件的细节，从而实现`write once， run anywhere。\n\n在运行时，JVM会通过类加载器(class-Loader)加载字节码，解释或者编译执行。主流Java版本中，如JDK 8实际是解释和编译混合的一种模式，即混合模式(-Xmixed)。通常运行在server模式的JVM。会进行上万次调用以收集足够的信息来进行高效的编译，Client模式这个门限是1500次。Oracle Hotspot JVM 内置了两个不同的JIT complier，C1对应前面说的Client模式，适用于对于启动速度敏感的应用，比如普通的java桌面应用;C2对应server模式，他的优化是为长时间运行的服务器端的应用设计的。默认是采用所谓的分层编译(TieredCompilation)。\n\nJava虚拟机启动时，可以指定不同的参数对运行模式进行选择。比如指定`-Xint`，就是告诉JVM只进行解释执行，不对代码进行编译，这种模式抛弃了JIT可能带来的性能优势。毕竟解释其是逐条读入，逐条运行的。与其相对应的，还有一个`-XComp`会导致JVM启动变慢很多，同时有些JIT编译器优化方式，比如分支预测，如果不进行profilling，往往并不能进行有效优化。\n\n\n### 哪些是发生在编译时，运行时，或者两者都有？\n\n方法重载发生在编译时，方法重载也被称为编译时多态，因为编译器根据参数的类型来选择使用哪个方法。\n方法覆盖发生在运行时，方法覆盖被称为运行时多态，因为在编译期编译器不知道并且没法知道该去调用哪个方法。JVM会在代码运行的时候做出决定。\n\nJava编译器会在编译时进行常量折叠，由于`final`变量的值不会改变，因此可以对它们进行优化。\n\n泛型（又称类型检验）发生在编译期的。编译器负责检查程序中类型的正确性，然后把使用了泛型的代码翻译或者重写成可以执行在当前JVM上的非泛型代码。这个技术被称为“类型擦除“。换句话来说，编译器会擦除所有在尖括号里的类型信息，来保证和版本1。4。0或者更早版本的JRE的兼容性。\n\n在运行时或者编译时都可以使用注解。\n@Override可以用来捕获类似于在子类中把toString()写成tostring()这样的错误。在Java 5中，用户自定义的注解可以用注解处理工具(Anotation Process Tool ——APT)在编译时进行处理。到了Java 6，这个功能已经是编译器的一部分了。\n\n@Test是JUnit框架用来在运行时通过反射来决定调用测试类的哪个（些）方法的注解。@Test (timeout=100)如果运行时间超过100ms的话，测试用例就会失败。\n\n在运行时或者编译时都可以使用异常。\n\n运行时异常（RuntimeException）也称作未检测的异常（unchecked exception），这表示这种异常不需要编译器来检测。RuntimeException是所有可以在运行时抛出的异常的父类。一个方法除要捕获异常外，如果它执行的时候可能会抛出RuntimeException的子类，那么它就不需要用throw语句来声明抛出的异常。\n\n受检查异常（checked exception）都是编译器在编译时进行校验的，通过throws语句或者try{}cathch{} 语句块来处理检测异常。编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。\n\n面向切面的编程（Aspect Oriented Programming-AOP）：切面可以在编译时，运行时或，加载时或者运行时织入。\n\n1. 编译期：编译期织入是最简单的方式。如果你拥有应用的代码，你可以使用AOP编译器（例如，ajc – AspectJ编译器）对源码进行编译，然后输出织入完成的class文件。AOP编译的过程包含了waver的调用。切面的形式可以是源码的形式也可以是二进制的形式。如果切面需要针对受影响的类进行编译，那么你就需要在编译期织入了。\n\n2. 编译后：这种方式有时候也被称为二进制织入，它被用来织入已有的class文件和jar文件。和编译时织入方式相同，用来织入的切面可以是源码也可以是二进制的形式，并且它们自己也可以被织入切面。\n\n3. 装载期：这种织入是一种二进制织入，它被延迟到JVM加载class文件和定义类的时候。为了支持这种织入方式，需要显式地由运行时环境或者通过一种“织入代理（weaving agent）“来提供一个或者多个“织入类加载器（weaving class loader）”。\n\n4. 运行时：对已经加载到JVM里的类进行织入。\n\n继承发生在编译时，因为它是静态的。\n\n代理或者组合发生在运行时，因为它更加具有动态性和灵活性。\n\n这也是为什么有`组合优于继承`这种说法，继承是一种多态工具，而不是一种代码复用工具。过度使用继承（通过“extends”关键字）的话，如果修改了父类，会损坏所有的子类。这是因为子类和父类的紧耦合关系是在编译期产生的。果你的类之间没有继承关系，并且你想要实现多态，那么你可以通过接口和组合的方式来实现，这样不仅可以实现代码重用，同时也可以实现运行时的灵活性。\n\n\n### AOT\n\n除了日常最常见的java使用模式，还有一种新的编译方式，即所谓的AOT(Ahead-of-Time Compilation)，直接将字节码编译成机器代码，这样就避免了JIT预热等各方面的开销，比如Oracle JDK 9 就引入了实验性的AOT特性，并且增加了新的jaotc工具，利用下面的命令吧某一类或者摸个模块编译成为AOT库。\n\n```java\n\njaotc --output libHelloWorld.so HelloWorld.class\njaotc --output libjava.base.so --module java.base\n\n```\n\n然后，在启动时直接指定的指定就可以了。\n\n\n```\n\njava -XX:AOTLibrary=./libHelloWorld.so ./libjava.base.so HelloWorld\n\n```\n\n\n\n\n而且，Oracle JDK支持分层编译和AOT协作使用，并不是二选一的关系。AOT也不仅仅是只有这一种方式，业界早有第三方工具(如GCJ，Excelsior JET)提供相关功能。\n\n另外，JVM作为一个强大的平台，不仅仅只有java语言可以运行在JVM上，本质上合规的字节码都可以运行，Java语言自身也为此提供了便利，类似Clojure、Scala、Groovy、Jruby、Jython等大量JVM语言，活跃在不同的场景。\n\n\n\n### 提问\n\n1. JVM的内存模型，堆、栈、方法区；字节码的跨平台性；对象在JVM中的强引用，弱引用，软引用，虚引用，是否可用finalise方法救救它？;双亲委派进行类加载，什么是双亲呢？双亲就是多亲，一份文档由我加载，然后你也加载，这份文档在JVM中是一样的吗？；多态思想是Java需要最核心的概念，也是面向对象的行为的一个最好诠释；理解方法重载与重写在内存中的执行流程，怎么定位到这个具体方法的。\n2. 发展流程，JDK5(重写bug)，JDK6(商用最稳定版)，JDK7(switch的字符串支持)，JDK8(函数式编程)，一直在发展进化。\n3. 理解祖先类Object，它的行为是怎样与现实生活连接起来的。\n4. 理解23种设计模式，因为它是道与术的结合体。\n\n\n-------------------\n参考:\n\n[知乎专栏](https://zhuanlan。zhihu。com/p/22886648)\n[Java核心36讲](https://time。geekbang。org/column/article/6845)","source":"_posts/java学习/java的理解.md","raw":"---\ntitle: 对java的理解\ndate: 2018-11-08 17:35:00\ntags: \n- java\ncategories: 总结\n---\n\n\n### Write once， run anywhere\n\n“Write once， run anywhere” 说的是Java语言跨平台的特性，Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。有了编译器就屏蔽了不同机器语言的区别，有了系统API就屏蔽了不同硬件的区别，有了JVM就屏蔽了不同操作系统的区别，有了TCP/IP就屏蔽了不同系统之间通讯的差异。\n\n<!-- more -->\n\n### java语言特性\n\n包括面向对象，泛型、反射、Lambda等语言特性；\n\n#### Java类库\n\n核心类库包括集合、IO/NIO等，网络，并发，安全等基础类库，其他第三方类库。\n\n#### Java的类加载机制\n\n常用版本JDK内嵌的Class-Loader，例如Bootstrap、Application和Extension Class-loader， 以及自定义Class-Loader等。\n\n#### 类加载的大致过程\n\n加载 \\rightarrow 验证 \\rightarrow 链接 \\rightarrow 初始化\n\n#### 垃圾收集的基本原理\n\n最常见额垃圾收集器，如SerialGC、Parallel GC、CMS、G1等，适用于什么样的负载\n还有运行时，动态编译，辅助功能JFR等\n\n#### 工具类\n\n`辅助工具`：jlink、jar、jdeps之类\n`编译器`：javac，sjavac\n`诊断工具`：jmap、jstack、jconsole、jhsdb，jcmd等进行监控诊断工具，程序的性能进行监控诊断，进行程序的诊断和调优工作\n\n#### Java/JVM生态\n\nJava EE，spring， Hadoop，Spark，Cassandra，ElasticSearch，Maven\n\n### Java的编译时和运行时\n\nJava分为编译时和运行时。\n编译指的是生成`。class`字节码，而不是可以直接执行的机器码，通过字节码和Java虚拟机(JVM)这种跨平台的抽象来屏蔽了操作系统和硬件的细节，从而实现`write once， run anywhere。\n\n在运行时，JVM会通过类加载器(class-Loader)加载字节码，解释或者编译执行。主流Java版本中，如JDK 8实际是解释和编译混合的一种模式，即混合模式(-Xmixed)。通常运行在server模式的JVM。会进行上万次调用以收集足够的信息来进行高效的编译，Client模式这个门限是1500次。Oracle Hotspot JVM 内置了两个不同的JIT complier，C1对应前面说的Client模式，适用于对于启动速度敏感的应用，比如普通的java桌面应用;C2对应server模式，他的优化是为长时间运行的服务器端的应用设计的。默认是采用所谓的分层编译(TieredCompilation)。\n\nJava虚拟机启动时，可以指定不同的参数对运行模式进行选择。比如指定`-Xint`，就是告诉JVM只进行解释执行，不对代码进行编译，这种模式抛弃了JIT可能带来的性能优势。毕竟解释其是逐条读入，逐条运行的。与其相对应的，还有一个`-XComp`会导致JVM启动变慢很多，同时有些JIT编译器优化方式，比如分支预测，如果不进行profilling，往往并不能进行有效优化。\n\n\n### 哪些是发生在编译时，运行时，或者两者都有？\n\n方法重载发生在编译时，方法重载也被称为编译时多态，因为编译器根据参数的类型来选择使用哪个方法。\n方法覆盖发生在运行时，方法覆盖被称为运行时多态，因为在编译期编译器不知道并且没法知道该去调用哪个方法。JVM会在代码运行的时候做出决定。\n\nJava编译器会在编译时进行常量折叠，由于`final`变量的值不会改变，因此可以对它们进行优化。\n\n泛型（又称类型检验）发生在编译期的。编译器负责检查程序中类型的正确性，然后把使用了泛型的代码翻译或者重写成可以执行在当前JVM上的非泛型代码。这个技术被称为“类型擦除“。换句话来说，编译器会擦除所有在尖括号里的类型信息，来保证和版本1。4。0或者更早版本的JRE的兼容性。\n\n在运行时或者编译时都可以使用注解。\n@Override可以用来捕获类似于在子类中把toString()写成tostring()这样的错误。在Java 5中，用户自定义的注解可以用注解处理工具(Anotation Process Tool ——APT)在编译时进行处理。到了Java 6，这个功能已经是编译器的一部分了。\n\n@Test是JUnit框架用来在运行时通过反射来决定调用测试类的哪个（些）方法的注解。@Test (timeout=100)如果运行时间超过100ms的话，测试用例就会失败。\n\n在运行时或者编译时都可以使用异常。\n\n运行时异常（RuntimeException）也称作未检测的异常（unchecked exception），这表示这种异常不需要编译器来检测。RuntimeException是所有可以在运行时抛出的异常的父类。一个方法除要捕获异常外，如果它执行的时候可能会抛出RuntimeException的子类，那么它就不需要用throw语句来声明抛出的异常。\n\n受检查异常（checked exception）都是编译器在编译时进行校验的，通过throws语句或者try{}cathch{} 语句块来处理检测异常。编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。\n\n面向切面的编程（Aspect Oriented Programming-AOP）：切面可以在编译时，运行时或，加载时或者运行时织入。\n\n1. 编译期：编译期织入是最简单的方式。如果你拥有应用的代码，你可以使用AOP编译器（例如，ajc – AspectJ编译器）对源码进行编译，然后输出织入完成的class文件。AOP编译的过程包含了waver的调用。切面的形式可以是源码的形式也可以是二进制的形式。如果切面需要针对受影响的类进行编译，那么你就需要在编译期织入了。\n\n2. 编译后：这种方式有时候也被称为二进制织入，它被用来织入已有的class文件和jar文件。和编译时织入方式相同，用来织入的切面可以是源码也可以是二进制的形式，并且它们自己也可以被织入切面。\n\n3. 装载期：这种织入是一种二进制织入，它被延迟到JVM加载class文件和定义类的时候。为了支持这种织入方式，需要显式地由运行时环境或者通过一种“织入代理（weaving agent）“来提供一个或者多个“织入类加载器（weaving class loader）”。\n\n4. 运行时：对已经加载到JVM里的类进行织入。\n\n继承发生在编译时，因为它是静态的。\n\n代理或者组合发生在运行时，因为它更加具有动态性和灵活性。\n\n这也是为什么有`组合优于继承`这种说法，继承是一种多态工具，而不是一种代码复用工具。过度使用继承（通过“extends”关键字）的话，如果修改了父类，会损坏所有的子类。这是因为子类和父类的紧耦合关系是在编译期产生的。果你的类之间没有继承关系，并且你想要实现多态，那么你可以通过接口和组合的方式来实现，这样不仅可以实现代码重用，同时也可以实现运行时的灵活性。\n\n\n### AOT\n\n除了日常最常见的java使用模式，还有一种新的编译方式，即所谓的AOT(Ahead-of-Time Compilation)，直接将字节码编译成机器代码，这样就避免了JIT预热等各方面的开销，比如Oracle JDK 9 就引入了实验性的AOT特性，并且增加了新的jaotc工具，利用下面的命令吧某一类或者摸个模块编译成为AOT库。\n\n```java\n\njaotc --output libHelloWorld.so HelloWorld.class\njaotc --output libjava.base.so --module java.base\n\n```\n\n然后，在启动时直接指定的指定就可以了。\n\n\n```\n\njava -XX:AOTLibrary=./libHelloWorld.so ./libjava.base.so HelloWorld\n\n```\n\n\n\n\n而且，Oracle JDK支持分层编译和AOT协作使用，并不是二选一的关系。AOT也不仅仅是只有这一种方式，业界早有第三方工具(如GCJ，Excelsior JET)提供相关功能。\n\n另外，JVM作为一个强大的平台，不仅仅只有java语言可以运行在JVM上，本质上合规的字节码都可以运行，Java语言自身也为此提供了便利，类似Clojure、Scala、Groovy、Jruby、Jython等大量JVM语言，活跃在不同的场景。\n\n\n\n### 提问\n\n1. JVM的内存模型，堆、栈、方法区；字节码的跨平台性；对象在JVM中的强引用，弱引用，软引用，虚引用，是否可用finalise方法救救它？;双亲委派进行类加载，什么是双亲呢？双亲就是多亲，一份文档由我加载，然后你也加载，这份文档在JVM中是一样的吗？；多态思想是Java需要最核心的概念，也是面向对象的行为的一个最好诠释；理解方法重载与重写在内存中的执行流程，怎么定位到这个具体方法的。\n2. 发展流程，JDK5(重写bug)，JDK6(商用最稳定版)，JDK7(switch的字符串支持)，JDK8(函数式编程)，一直在发展进化。\n3. 理解祖先类Object，它的行为是怎样与现实生活连接起来的。\n4. 理解23种设计模式，因为它是道与术的结合体。\n\n\n-------------------\n参考:\n\n[知乎专栏](https://zhuanlan。zhihu。com/p/22886648)\n[Java核心36讲](https://time。geekbang。org/column/article/6845)","slug":"java学习/java的理解","published":1,"updated":"2019-03-22T14:44:36.721Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0600954l3nl41ajhlm","content":"<h3 id=\"Write-once，-run-anywhere\"><a href=\"#Write-once，-run-anywhere\" class=\"headerlink\" title=\"Write once， run anywhere\"></a>Write once， run anywhere</h3><p>“Write once， run anywhere” 说的是Java语言跨平台的特性，Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。有了编译器就屏蔽了不同机器语言的区别，有了系统API就屏蔽了不同硬件的区别，有了JVM就屏蔽了不同操作系统的区别，有了TCP/IP就屏蔽了不同系统之间通讯的差异。</p>\n<a id=\"more\"></a>\n<h3 id=\"java语言特性\"><a href=\"#java语言特性\" class=\"headerlink\" title=\"java语言特性\"></a>java语言特性</h3><p>包括面向对象，泛型、反射、Lambda等语言特性；</p>\n<h4 id=\"Java类库\"><a href=\"#Java类库\" class=\"headerlink\" title=\"Java类库\"></a>Java类库</h4><p>核心类库包括集合、IO/NIO等，网络，并发，安全等基础类库，其他第三方类库。</p>\n<h4 id=\"Java的类加载机制\"><a href=\"#Java的类加载机制\" class=\"headerlink\" title=\"Java的类加载机制\"></a>Java的类加载机制</h4><p>常用版本JDK内嵌的Class-Loader，例如Bootstrap、Application和Extension Class-loader， 以及自定义Class-Loader等。</p>\n<h4 id=\"类加载的大致过程\"><a href=\"#类加载的大致过程\" class=\"headerlink\" title=\"类加载的大致过程\"></a>类加载的大致过程</h4><p>加载 \\rightarrow 验证 \\rightarrow 链接 \\rightarrow 初始化</p>\n<h4 id=\"垃圾收集的基本原理\"><a href=\"#垃圾收集的基本原理\" class=\"headerlink\" title=\"垃圾收集的基本原理\"></a>垃圾收集的基本原理</h4><p>最常见额垃圾收集器，如SerialGC、Parallel GC、CMS、G1等，适用于什么样的负载<br>还有运行时，动态编译，辅助功能JFR等</p>\n<h4 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h4><p><code>辅助工具</code>：jlink、jar、jdeps之类<br><code>编译器</code>：javac，sjavac<br><code>诊断工具</code>：jmap、jstack、jconsole、jhsdb，jcmd等进行监控诊断工具，程序的性能进行监控诊断，进行程序的诊断和调优工作</p>\n<h4 id=\"Java-JVM生态\"><a href=\"#Java-JVM生态\" class=\"headerlink\" title=\"Java/JVM生态\"></a>Java/JVM生态</h4><p>Java EE，spring， Hadoop，Spark，Cassandra，ElasticSearch，Maven</p>\n<h3 id=\"Java的编译时和运行时\"><a href=\"#Java的编译时和运行时\" class=\"headerlink\" title=\"Java的编译时和运行时\"></a>Java的编译时和运行时</h3><p>Java分为编译时和运行时。<br>编译指的是生成<code>。class</code>字节码，而不是可以直接执行的机器码，通过字节码和Java虚拟机(JVM)这种跨平台的抽象来屏蔽了操作系统和硬件的细节，从而实现`write once， run anywhere。</p>\n<p>在运行时，JVM会通过类加载器(class-Loader)加载字节码，解释或者编译执行。主流Java版本中，如JDK 8实际是解释和编译混合的一种模式，即混合模式(-Xmixed)。通常运行在server模式的JVM。会进行上万次调用以收集足够的信息来进行高效的编译，Client模式这个门限是1500次。Oracle Hotspot JVM 内置了两个不同的JIT complier，C1对应前面说的Client模式，适用于对于启动速度敏感的应用，比如普通的java桌面应用;C2对应server模式，他的优化是为长时间运行的服务器端的应用设计的。默认是采用所谓的分层编译(TieredCompilation)。</p>\n<p>Java虚拟机启动时，可以指定不同的参数对运行模式进行选择。比如指定<code>-Xint</code>，就是告诉JVM只进行解释执行，不对代码进行编译，这种模式抛弃了JIT可能带来的性能优势。毕竟解释其是逐条读入，逐条运行的。与其相对应的，还有一个<code>-XComp</code>会导致JVM启动变慢很多，同时有些JIT编译器优化方式，比如分支预测，如果不进行profilling，往往并不能进行有效优化。</p>\n<h3 id=\"哪些是发生在编译时，运行时，或者两者都有？\"><a href=\"#哪些是发生在编译时，运行时，或者两者都有？\" class=\"headerlink\" title=\"哪些是发生在编译时，运行时，或者两者都有？\"></a>哪些是发生在编译时，运行时，或者两者都有？</h3><p>方法重载发生在编译时，方法重载也被称为编译时多态，因为编译器根据参数的类型来选择使用哪个方法。<br>方法覆盖发生在运行时，方法覆盖被称为运行时多态，因为在编译期编译器不知道并且没法知道该去调用哪个方法。JVM会在代码运行的时候做出决定。</p>\n<p>Java编译器会在编译时进行常量折叠，由于<code>final</code>变量的值不会改变，因此可以对它们进行优化。</p>\n<p>泛型（又称类型检验）发生在编译期的。编译器负责检查程序中类型的正确性，然后把使用了泛型的代码翻译或者重写成可以执行在当前JVM上的非泛型代码。这个技术被称为“类型擦除“。换句话来说，编译器会擦除所有在尖括号里的类型信息，来保证和版本1。4。0或者更早版本的JRE的兼容性。</p>\n<p>在运行时或者编译时都可以使用注解。<br>@Override可以用来捕获类似于在子类中把toString()写成tostring()这样的错误。在Java 5中，用户自定义的注解可以用注解处理工具(Anotation Process Tool ——APT)在编译时进行处理。到了Java 6，这个功能已经是编译器的一部分了。</p>\n<p>@Test是JUnit框架用来在运行时通过反射来决定调用测试类的哪个（些）方法的注解。@Test (timeout=100)如果运行时间超过100ms的话，测试用例就会失败。</p>\n<p>在运行时或者编译时都可以使用异常。</p>\n<p>运行时异常（RuntimeException）也称作未检测的异常（unchecked exception），这表示这种异常不需要编译器来检测。RuntimeException是所有可以在运行时抛出的异常的父类。一个方法除要捕获异常外，如果它执行的时候可能会抛出RuntimeException的子类，那么它就不需要用throw语句来声明抛出的异常。</p>\n<p>受检查异常（checked exception）都是编译器在编译时进行校验的，通过throws语句或者try{}cathch{} 语句块来处理检测异常。编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。</p>\n<p>面向切面的编程（Aspect Oriented Programming-AOP）：切面可以在编译时，运行时或，加载时或者运行时织入。</p>\n<ol>\n<li><p>编译期：编译期织入是最简单的方式。如果你拥有应用的代码，你可以使用AOP编译器（例如，ajc – AspectJ编译器）对源码进行编译，然后输出织入完成的class文件。AOP编译的过程包含了waver的调用。切面的形式可以是源码的形式也可以是二进制的形式。如果切面需要针对受影响的类进行编译，那么你就需要在编译期织入了。</p>\n</li>\n<li><p>编译后：这种方式有时候也被称为二进制织入，它被用来织入已有的class文件和jar文件。和编译时织入方式相同，用来织入的切面可以是源码也可以是二进制的形式，并且它们自己也可以被织入切面。</p>\n</li>\n<li><p>装载期：这种织入是一种二进制织入，它被延迟到JVM加载class文件和定义类的时候。为了支持这种织入方式，需要显式地由运行时环境或者通过一种“织入代理（weaving agent）“来提供一个或者多个“织入类加载器（weaving class loader）”。</p>\n</li>\n<li><p>运行时：对已经加载到JVM里的类进行织入。</p>\n</li>\n</ol>\n<p>继承发生在编译时，因为它是静态的。</p>\n<p>代理或者组合发生在运行时，因为它更加具有动态性和灵活性。</p>\n<p>这也是为什么有<code>组合优于继承</code>这种说法，继承是一种多态工具，而不是一种代码复用工具。过度使用继承（通过“extends”关键字）的话，如果修改了父类，会损坏所有的子类。这是因为子类和父类的紧耦合关系是在编译期产生的。果你的类之间没有继承关系，并且你想要实现多态，那么你可以通过接口和组合的方式来实现，这样不仅可以实现代码重用，同时也可以实现运行时的灵活性。</p>\n<h3 id=\"AOT\"><a href=\"#AOT\" class=\"headerlink\" title=\"AOT\"></a>AOT</h3><p>除了日常最常见的java使用模式，还有一种新的编译方式，即所谓的AOT(Ahead-of-Time Compilation)，直接将字节码编译成机器代码，这样就避免了JIT预热等各方面的开销，比如Oracle JDK 9 就引入了实验性的AOT特性，并且增加了新的jaotc工具，利用下面的命令吧某一类或者摸个模块编译成为AOT库。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">jaotc --output libHelloWorld.so HelloWorld.class</span><br><span class=\"line\">jaotc --output libjava.base.so --<span class=\"keyword\">module</span> java.base</span><br></pre></td></tr></table></figure>\n<p>然后，在启动时直接指定的指定就可以了。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">java -XX:AOTLibrary=./libHelloWorld<span class=\"selector-class\">.so</span> ./libjava<span class=\"selector-class\">.base</span><span class=\"selector-class\">.so</span> HelloWorld</span><br></pre></td></tr></table></figure>\n<p>而且，Oracle JDK支持分层编译和AOT协作使用，并不是二选一的关系。AOT也不仅仅是只有这一种方式，业界早有第三方工具(如GCJ，Excelsior JET)提供相关功能。</p>\n<p>另外，JVM作为一个强大的平台，不仅仅只有java语言可以运行在JVM上，本质上合规的字节码都可以运行，Java语言自身也为此提供了便利，类似Clojure、Scala、Groovy、Jruby、Jython等大量JVM语言，活跃在不同的场景。</p>\n<h3 id=\"提问\"><a href=\"#提问\" class=\"headerlink\" title=\"提问\"></a>提问</h3><ol>\n<li>JVM的内存模型，堆、栈、方法区；字节码的跨平台性；对象在JVM中的强引用，弱引用，软引用，虚引用，是否可用finalise方法救救它？;双亲委派进行类加载，什么是双亲呢？双亲就是多亲，一份文档由我加载，然后你也加载，这份文档在JVM中是一样的吗？；多态思想是Java需要最核心的概念，也是面向对象的行为的一个最好诠释；理解方法重载与重写在内存中的执行流程，怎么定位到这个具体方法的。</li>\n<li>发展流程，JDK5(重写bug)，JDK6(商用最稳定版)，JDK7(switch的字符串支持)，JDK8(函数式编程)，一直在发展进化。</li>\n<li>理解祖先类Object，它的行为是怎样与现实生活连接起来的。</li>\n<li>理解23种设计模式，因为它是道与术的结合体。</li>\n</ol>\n<hr>\n<p>参考:</p>\n<p><a href=\"https://zhuanlan。zhihu。com/p/22886648\" target=\"_blank\" rel=\"noopener\">知乎专栏</a><br><a href=\"https://time。geekbang。org/column/article/6845\" target=\"_blank\" rel=\"noopener\">Java核心36讲</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Write-once，-run-anywhere\"><a href=\"#Write-once，-run-anywhere\" class=\"headerlink\" title=\"Write once， run anywhere\"></a>Write once， run anywhere</h3><p>“Write once， run anywhere” 说的是Java语言跨平台的特性，Java的跨平台特性与Java虚拟机的存在密不可分，可在不同的环境中运行。比如说Windows平台和Linux平台都有相应的JDK，安装好JDK后也就有了Java语言的运行环境。其实Java语言本身与其他的编程语言没有特别大的差异，并不是说Java语言可以跨平台，而是在不同的平台都有可以让Java语言运行的环境而已，所以才有了Java一次编译，到处运行这样的效果。有了编译器就屏蔽了不同机器语言的区别，有了系统API就屏蔽了不同硬件的区别，有了JVM就屏蔽了不同操作系统的区别，有了TCP/IP就屏蔽了不同系统之间通讯的差异。</p>","more":"<h3 id=\"java语言特性\"><a href=\"#java语言特性\" class=\"headerlink\" title=\"java语言特性\"></a>java语言特性</h3><p>包括面向对象，泛型、反射、Lambda等语言特性；</p>\n<h4 id=\"Java类库\"><a href=\"#Java类库\" class=\"headerlink\" title=\"Java类库\"></a>Java类库</h4><p>核心类库包括集合、IO/NIO等，网络，并发，安全等基础类库，其他第三方类库。</p>\n<h4 id=\"Java的类加载机制\"><a href=\"#Java的类加载机制\" class=\"headerlink\" title=\"Java的类加载机制\"></a>Java的类加载机制</h4><p>常用版本JDK内嵌的Class-Loader，例如Bootstrap、Application和Extension Class-loader， 以及自定义Class-Loader等。</p>\n<h4 id=\"类加载的大致过程\"><a href=\"#类加载的大致过程\" class=\"headerlink\" title=\"类加载的大致过程\"></a>类加载的大致过程</h4><p>加载 \\rightarrow 验证 \\rightarrow 链接 \\rightarrow 初始化</p>\n<h4 id=\"垃圾收集的基本原理\"><a href=\"#垃圾收集的基本原理\" class=\"headerlink\" title=\"垃圾收集的基本原理\"></a>垃圾收集的基本原理</h4><p>最常见额垃圾收集器，如SerialGC、Parallel GC、CMS、G1等，适用于什么样的负载<br>还有运行时，动态编译，辅助功能JFR等</p>\n<h4 id=\"工具类\"><a href=\"#工具类\" class=\"headerlink\" title=\"工具类\"></a>工具类</h4><p><code>辅助工具</code>：jlink、jar、jdeps之类<br><code>编译器</code>：javac，sjavac<br><code>诊断工具</code>：jmap、jstack、jconsole、jhsdb，jcmd等进行监控诊断工具，程序的性能进行监控诊断，进行程序的诊断和调优工作</p>\n<h4 id=\"Java-JVM生态\"><a href=\"#Java-JVM生态\" class=\"headerlink\" title=\"Java/JVM生态\"></a>Java/JVM生态</h4><p>Java EE，spring， Hadoop，Spark，Cassandra，ElasticSearch，Maven</p>\n<h3 id=\"Java的编译时和运行时\"><a href=\"#Java的编译时和运行时\" class=\"headerlink\" title=\"Java的编译时和运行时\"></a>Java的编译时和运行时</h3><p>Java分为编译时和运行时。<br>编译指的是生成<code>。class</code>字节码，而不是可以直接执行的机器码，通过字节码和Java虚拟机(JVM)这种跨平台的抽象来屏蔽了操作系统和硬件的细节，从而实现`write once， run anywhere。</p>\n<p>在运行时，JVM会通过类加载器(class-Loader)加载字节码，解释或者编译执行。主流Java版本中，如JDK 8实际是解释和编译混合的一种模式，即混合模式(-Xmixed)。通常运行在server模式的JVM。会进行上万次调用以收集足够的信息来进行高效的编译，Client模式这个门限是1500次。Oracle Hotspot JVM 内置了两个不同的JIT complier，C1对应前面说的Client模式，适用于对于启动速度敏感的应用，比如普通的java桌面应用;C2对应server模式，他的优化是为长时间运行的服务器端的应用设计的。默认是采用所谓的分层编译(TieredCompilation)。</p>\n<p>Java虚拟机启动时，可以指定不同的参数对运行模式进行选择。比如指定<code>-Xint</code>，就是告诉JVM只进行解释执行，不对代码进行编译，这种模式抛弃了JIT可能带来的性能优势。毕竟解释其是逐条读入，逐条运行的。与其相对应的，还有一个<code>-XComp</code>会导致JVM启动变慢很多，同时有些JIT编译器优化方式，比如分支预测，如果不进行profilling，往往并不能进行有效优化。</p>\n<h3 id=\"哪些是发生在编译时，运行时，或者两者都有？\"><a href=\"#哪些是发生在编译时，运行时，或者两者都有？\" class=\"headerlink\" title=\"哪些是发生在编译时，运行时，或者两者都有？\"></a>哪些是发生在编译时，运行时，或者两者都有？</h3><p>方法重载发生在编译时，方法重载也被称为编译时多态，因为编译器根据参数的类型来选择使用哪个方法。<br>方法覆盖发生在运行时，方法覆盖被称为运行时多态，因为在编译期编译器不知道并且没法知道该去调用哪个方法。JVM会在代码运行的时候做出决定。</p>\n<p>Java编译器会在编译时进行常量折叠，由于<code>final</code>变量的值不会改变，因此可以对它们进行优化。</p>\n<p>泛型（又称类型检验）发生在编译期的。编译器负责检查程序中类型的正确性，然后把使用了泛型的代码翻译或者重写成可以执行在当前JVM上的非泛型代码。这个技术被称为“类型擦除“。换句话来说，编译器会擦除所有在尖括号里的类型信息，来保证和版本1。4。0或者更早版本的JRE的兼容性。</p>\n<p>在运行时或者编译时都可以使用注解。<br>@Override可以用来捕获类似于在子类中把toString()写成tostring()这样的错误。在Java 5中，用户自定义的注解可以用注解处理工具(Anotation Process Tool ——APT)在编译时进行处理。到了Java 6，这个功能已经是编译器的一部分了。</p>\n<p>@Test是JUnit框架用来在运行时通过反射来决定调用测试类的哪个（些）方法的注解。@Test (timeout=100)如果运行时间超过100ms的话，测试用例就会失败。</p>\n<p>在运行时或者编译时都可以使用异常。</p>\n<p>运行时异常（RuntimeException）也称作未检测的异常（unchecked exception），这表示这种异常不需要编译器来检测。RuntimeException是所有可以在运行时抛出的异常的父类。一个方法除要捕获异常外，如果它执行的时候可能会抛出RuntimeException的子类，那么它就不需要用throw语句来声明抛出的异常。</p>\n<p>受检查异常（checked exception）都是编译器在编译时进行校验的，通过throws语句或者try{}cathch{} 语句块来处理检测异常。编译器会分析哪些异常会在执行一个方法或者构造函数的时候抛出。</p>\n<p>面向切面的编程（Aspect Oriented Programming-AOP）：切面可以在编译时，运行时或，加载时或者运行时织入。</p>\n<ol>\n<li><p>编译期：编译期织入是最简单的方式。如果你拥有应用的代码，你可以使用AOP编译器（例如，ajc – AspectJ编译器）对源码进行编译，然后输出织入完成的class文件。AOP编译的过程包含了waver的调用。切面的形式可以是源码的形式也可以是二进制的形式。如果切面需要针对受影响的类进行编译，那么你就需要在编译期织入了。</p>\n</li>\n<li><p>编译后：这种方式有时候也被称为二进制织入，它被用来织入已有的class文件和jar文件。和编译时织入方式相同，用来织入的切面可以是源码也可以是二进制的形式，并且它们自己也可以被织入切面。</p>\n</li>\n<li><p>装载期：这种织入是一种二进制织入，它被延迟到JVM加载class文件和定义类的时候。为了支持这种织入方式，需要显式地由运行时环境或者通过一种“织入代理（weaving agent）“来提供一个或者多个“织入类加载器（weaving class loader）”。</p>\n</li>\n<li><p>运行时：对已经加载到JVM里的类进行织入。</p>\n</li>\n</ol>\n<p>继承发生在编译时，因为它是静态的。</p>\n<p>代理或者组合发生在运行时，因为它更加具有动态性和灵活性。</p>\n<p>这也是为什么有<code>组合优于继承</code>这种说法，继承是一种多态工具，而不是一种代码复用工具。过度使用继承（通过“extends”关键字）的话，如果修改了父类，会损坏所有的子类。这是因为子类和父类的紧耦合关系是在编译期产生的。果你的类之间没有继承关系，并且你想要实现多态，那么你可以通过接口和组合的方式来实现，这样不仅可以实现代码重用，同时也可以实现运行时的灵活性。</p>\n<h3 id=\"AOT\"><a href=\"#AOT\" class=\"headerlink\" title=\"AOT\"></a>AOT</h3><p>除了日常最常见的java使用模式，还有一种新的编译方式，即所谓的AOT(Ahead-of-Time Compilation)，直接将字节码编译成机器代码，这样就避免了JIT预热等各方面的开销，比如Oracle JDK 9 就引入了实验性的AOT特性，并且增加了新的jaotc工具，利用下面的命令吧某一类或者摸个模块编译成为AOT库。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">jaotc --output libHelloWorld.so HelloWorld.class</span><br><span class=\"line\">jaotc --output libjava.base.so --<span class=\"keyword\">module</span> java.base</span><br></pre></td></tr></table></figure>\n<p>然后，在启动时直接指定的指定就可以了。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">java -XX:AOTLibrary=./libHelloWorld<span class=\"selector-class\">.so</span> ./libjava<span class=\"selector-class\">.base</span><span class=\"selector-class\">.so</span> HelloWorld</span><br></pre></td></tr></table></figure>\n<p>而且，Oracle JDK支持分层编译和AOT协作使用，并不是二选一的关系。AOT也不仅仅是只有这一种方式，业界早有第三方工具(如GCJ，Excelsior JET)提供相关功能。</p>\n<p>另外，JVM作为一个强大的平台，不仅仅只有java语言可以运行在JVM上，本质上合规的字节码都可以运行，Java语言自身也为此提供了便利，类似Clojure、Scala、Groovy、Jruby、Jython等大量JVM语言，活跃在不同的场景。</p>\n<h3 id=\"提问\"><a href=\"#提问\" class=\"headerlink\" title=\"提问\"></a>提问</h3><ol>\n<li>JVM的内存模型，堆、栈、方法区；字节码的跨平台性；对象在JVM中的强引用，弱引用，软引用，虚引用，是否可用finalise方法救救它？;双亲委派进行类加载，什么是双亲呢？双亲就是多亲，一份文档由我加载，然后你也加载，这份文档在JVM中是一样的吗？；多态思想是Java需要最核心的概念，也是面向对象的行为的一个最好诠释；理解方法重载与重写在内存中的执行流程，怎么定位到这个具体方法的。</li>\n<li>发展流程，JDK5(重写bug)，JDK6(商用最稳定版)，JDK7(switch的字符串支持)，JDK8(函数式编程)，一直在发展进化。</li>\n<li>理解祖先类Object，它的行为是怎样与现实生活连接起来的。</li>\n<li>理解23种设计模式，因为它是道与术的结合体。</li>\n</ol>\n<hr>\n<p>参考:</p>\n<p><a href=\"https://zhuanlan。zhihu。com/p/22886648\" target=\"_blank\" rel=\"noopener\">知乎专栏</a><br><a href=\"https://time。geekbang。org/column/article/6845\" target=\"_blank\" rel=\"noopener\">Java核心36讲</a></p>"},{"title":"如何保证容器是线程安全的?ConcurrentHashMap如何实现线程安全?","date":"2019-03-14T15:35:00.000Z","_content":"\nJava提供了不同层面的线程安全支持.在传统集合框架内部,除了Hashtable等同步容器,还提供了所谓的同步包装器, 我们可以调用collections工具类提供的包装方法,来获取一个同步的包装容器, 但是他们都是利用粗颗粒度的同步方式,在高并发的情况下,性能比较低下。\n\n<!-- more -->\n另外,更加普遍的选择是利用并发包提供的线程安全容器类,他提供了:\n* 各种并发容器，比如 ConcurrentHashMap、CopyOnWriteArrayList;\n* 各种线程安全队列,如ArrayBlockingQueue,SynchronousQueue;\n* 各种有序容器的线程安全版本等。\n\n### Hashtable，HashMap，TreeMap有何不同 ？\n\nHashtable是早期Java类库提供的一个哈希表实现，本身是同步的，不支持null键和值，HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现非常低下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。\n\nHashMap是应用更加广泛的哈希表实现，行为大致上与hashTable一致，主要区别在于hashMap不是同步的，支持null键和值等。通常情况下，HashMap进行put和get操作,可以达到常数时间的性能,所以他是绝大部分利用键值对存取场景的首先,比如,实现用户ID和用户信息对应的运行时的存储结构。\n\n初始化时：HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一定要为2的整数次幂；HashMap默认容量为16，且要求容量一定为2的整数次幂。\n扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍。\n\nTreeMap则是基于红黑树的一种提供顺序访问的Map，和HashMap不同，他的get，put，remove之类的操作时间复杂度都为O(log(n))，具体顺序可以由指定的Comparator来决定,或者根据键的自然顺序来判断。\n\n另外还有一些有序Map, 虽然LinkedHashMap和TreeMap都可以保证某种顺序,但是二者还是非常不同的。\n\nLinkedHashMap通常提供的是遍历顺序符合插入顺序，他的实现是通过维护一个双向链表，通过特定的构造函数，我们可以创建反应访问顺序的实例，普通的操作比如put,get等,都算作\"访问\"。\n\n在这种行为适用于一些特定的应用场景，例如，我们构建一个空间占用敏感的资源池，希望可以自动将最不常访问的对象释放掉，就可以用LinkedHashMap来实现。\n\n### HashMap的实现\n\nHashMap扩展自AbstractMao，其性能表现非常依赖于哈希码的有效性。这里就会讲到hashCode和equals的一些基本约定:\n* equals相等,hashcode也一定要相等;\n* 重写了hashcode也要重写equals;\n* hashCode需要保持一致性,状态改变返回的哈希值仍然需要一致;\n* equals的自反性，对称性，传递性，一致性,非空性等特性;\n\n```\n\n自反性: 对于任何非null的引用值x, x.equals(x)必须返回true;\n\n对称性: 对于任何非null的引用值x和y,当且仅当y.equals(x)返回true时，x.equals(y)必须返回true;\n\n传递性: 对于任何非null的引用值x,y和z，如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)返回true;\n\n一致性: 对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false;\n\n非空性: 对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false\n\n```\n\nHashMap的内部结构，可以看做是数组和链表组成的复合结构，数组被分为一个个桶(bucket)\n,通过哈希值来决定键值对在这个数组的寻址;哈希值相同的键值对,则以链表形式存储,如果链表的大小超过了阈值(TREEIFY_THRESHOLD, 8),就会被改造为树形结构。\n\n当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbent,\n               boolean evit) {\n    Node<K,V>[] tab; Node<K,V> p; int , i;\n    if ((tab = table) == null || (n = tab.length) = 0)\n        n = (tab = resize()).length;\n    if ((p = tab[i = (n - 1) & hash]) == ull)\n        tab[i] = newNode(hash, key, value, nll);\n    else {\n        // ...\n        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for first \n           treeifyBin(tab, hash);\n        //  ... \n     }\n}\n\n```\n从put源码中可以看到 ,如果表格为null,则通过resize来进行初始化,resize兼顾了两个职责,创建初始存储表格, 或者在容量不满足需求的时候进行扩容。因此HashMap按照lazy-load原则, 在首次使用时被初始化。\n\n具体键值对在哈希表的位置取决于下面的位运算。\n\n```java\ni = (n - 1) & hash\n```\n\n仔细观察哈希值的源头,我们就会发现,他并不是key本身的hashCode,而是来自于HashMap内部的另一个方法。为什么这里需要将高位数据移位到低位进行异或运算呢？这事因为有些数据计算出的哈希值差异主要在高位， 而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。\n\n```java\nstatic final int hash(Object kye) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>>16);\n}\n\n```\n\n下面我们继续看看resize方法, 经常会有面试题来追问他的源码设计。\n\n```java\nfinal Node<K,V>[] resize() {\n    // ...\n    else if ((newCap = oldCap << 1) < MAXIMUM_CAPACIY &&\n                oldCap >= DEFAULT_INITIAL_CAPAITY)\n        newThr = oldThr << 1; // double there\n       // ... \n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {  \n        // zero initial threshold signifies using defaultsfults\n        newCap = DEFAULT_INITIAL_CAPAITY;\n        newThr = (int)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；\n    }\n    if (newThr ==0){\n        float ft = (float)newCap * loadFator;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?(int)ft : Integer.MAX_VALUE);\n    }\n    threshold = neThr;\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newap];\n    table = n；\n    // 移动到新的数组结构 e 数组结构 \n   }\n\n```\n\n根据resize源码, 我们可以归纳为:\n* 门限值等于(负载因子) x 容量,如果构建HashMap的时候没有指定,那就按照默认常量值。\n\n* 门限通常是以倍数进行调整(newThr = oldThr << 1),前面提到,根据putVal中的逻辑,当元素个数超过门限大小时,则调整Map大小。\n\n* 扩容后，需要将老的数组中的元素放入新的数组，这是主要的开销来源；\n\n### 容量，负载因子和树化\n\n为什么我们需要在乎容量和负载因子呢？\n\n因为容量和负载洗漱决定了可用桶的数量，空桶太多会浪费空间，如果太慢则会严重影响操作性能，极端情况下，如果只有一个桶，那么他就退化成了链表，完全不能提供所谓的常数时间存的性能。\n\n那么我们在时间中应该如何选择呢？\n\n如果能够知道HashMap要存取的键值对数量，可以考虑预先设置合适的容量大小，具体数值我们可以根据扩容发生的条件来进行简单的预估，根据代码分析，需要\n\n```\n负载因子 * 容量 > 元素数量\n```\n所以,预先设置的容量需要满足,大于\"预估元素数量 / 负载因子\", 同时时2的幂数,就可以得到。\n\n而对于负载因子,我建议:\n\n* 如果没有特别需求,不要进行轻易地更改,因为JDK自身默认的负载因子就是非常符合通用场景的需求的。\n\n* 如果确实需要跳转，建议不要设置超过0.75的数值，因为会显著增加冲突，降低HashMap的性能；\n\n* 如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的消耗；\n\n下面来讲一讲对于树化的改造。\n```Java\nfinal void treeifyBin(Node<K,V>[] tab, int hash) {\n    int n, index; Node<K,V> e;\n    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n        resize();\n    else if ((e = tab[index = (n - 1) & hash]) != null) {\n        // 树化改造逻辑\n    }\n}\n\n\n```\n\n这是简化之后的treeifyBin示意,可以理解为,当bin的数量大于TREEIFY_THRESHOLD时:\n* 如果容量小于MIN_TREEIFY_CAPACITY,只会进行简单扩容;\n* 如果容量大于MIN_TREEIFY_CAPACITY,只会进行树化改造;\n\n那么为什么HashMap要树化呢?\n\n本质上是一个安全问题,其实也是一个性能问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置在同一个桶里，则会形成一个链表，我们都知道链表是线性的，会严重影响存取的性能。\n\n而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端进行交互，导致CPU大量占用，就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似的攻击事件。\n\n### 解决哈希冲突的办法\n\n解决哈希冲突的常用方法有：\n\n#### 开放定址法\n基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。\n\n#### 再哈希法\n这种方法是同时构造多个不同的哈希函数：\nHi=RH1（key）  i=1，2，…，k\n当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。\n\n#### 链地址法\n这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。\n\n#### 建立公共溢出区\n这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。\n\n#### 线性再散列\n最常用的方法就是线性再散列。即插入元素时，没有发生冲突放在原有的规则下的空槽下，发生冲突时，简单遍历hash表，找到表中下一个空槽，进行元素插入。查找元素时，找到相应的位置的元素，如果不匹配则进行遍历hash表。主要的缺点在于不能从表中删除元素。\n\n#### 非线性再散列\n就是冲突时，再hash，核心思想是，如果产生冲突，产生一个新的hash值进行寻址，如果还是冲突，则继续。主要的缺点在于不能从表中删除元素。\n","source":"_posts/java学习/容器如何实现线程安全.md","raw":"---\ntitle: 如何保证容器是线程安全的?ConcurrentHashMap如何实现线程安全?\ndate: 2019-03-14 23:35:00\ntags: \n- java\ncategories: 总结\n---\n\nJava提供了不同层面的线程安全支持.在传统集合框架内部,除了Hashtable等同步容器,还提供了所谓的同步包装器, 我们可以调用collections工具类提供的包装方法,来获取一个同步的包装容器, 但是他们都是利用粗颗粒度的同步方式,在高并发的情况下,性能比较低下。\n\n<!-- more -->\n另外,更加普遍的选择是利用并发包提供的线程安全容器类,他提供了:\n* 各种并发容器，比如 ConcurrentHashMap、CopyOnWriteArrayList;\n* 各种线程安全队列,如ArrayBlockingQueue,SynchronousQueue;\n* 各种有序容器的线程安全版本等。\n\n### Hashtable，HashMap，TreeMap有何不同 ？\n\nHashtable是早期Java类库提供的一个哈希表实现，本身是同步的，不支持null键和值，HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现非常低下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。\n\nHashMap是应用更加广泛的哈希表实现，行为大致上与hashTable一致，主要区别在于hashMap不是同步的，支持null键和值等。通常情况下，HashMap进行put和get操作,可以达到常数时间的性能,所以他是绝大部分利用键值对存取场景的首先,比如,实现用户ID和用户信息对应的运行时的存储结构。\n\n初始化时：HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一定要为2的整数次幂；HashMap默认容量为16，且要求容量一定为2的整数次幂。\n扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍。\n\nTreeMap则是基于红黑树的一种提供顺序访问的Map，和HashMap不同，他的get，put，remove之类的操作时间复杂度都为O(log(n))，具体顺序可以由指定的Comparator来决定,或者根据键的自然顺序来判断。\n\n另外还有一些有序Map, 虽然LinkedHashMap和TreeMap都可以保证某种顺序,但是二者还是非常不同的。\n\nLinkedHashMap通常提供的是遍历顺序符合插入顺序，他的实现是通过维护一个双向链表，通过特定的构造函数，我们可以创建反应访问顺序的实例，普通的操作比如put,get等,都算作\"访问\"。\n\n在这种行为适用于一些特定的应用场景，例如，我们构建一个空间占用敏感的资源池，希望可以自动将最不常访问的对象释放掉，就可以用LinkedHashMap来实现。\n\n### HashMap的实现\n\nHashMap扩展自AbstractMao，其性能表现非常依赖于哈希码的有效性。这里就会讲到hashCode和equals的一些基本约定:\n* equals相等,hashcode也一定要相等;\n* 重写了hashcode也要重写equals;\n* hashCode需要保持一致性,状态改变返回的哈希值仍然需要一致;\n* equals的自反性，对称性，传递性，一致性,非空性等特性;\n\n```\n\n自反性: 对于任何非null的引用值x, x.equals(x)必须返回true;\n\n对称性: 对于任何非null的引用值x和y,当且仅当y.equals(x)返回true时，x.equals(y)必须返回true;\n\n传递性: 对于任何非null的引用值x,y和z，如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)返回true;\n\n一致性: 对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false;\n\n非空性: 对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false\n\n```\n\nHashMap的内部结构，可以看做是数组和链表组成的复合结构，数组被分为一个个桶(bucket)\n,通过哈希值来决定键值对在这个数组的寻址;哈希值相同的键值对,则以链表形式存储,如果链表的大小超过了阈值(TREEIFY_THRESHOLD, 8),就会被改造为树形结构。\n\n当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。\n\n```java\npublic V put(K key, V value) {\n    return putVal(hash(key), key, value, false, true);\n}\n\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbent,\n               boolean evit) {\n    Node<K,V>[] tab; Node<K,V> p; int , i;\n    if ((tab = table) == null || (n = tab.length) = 0)\n        n = (tab = resize()).length;\n    if ((p = tab[i = (n - 1) & hash]) == ull)\n        tab[i] = newNode(hash, key, value, nll);\n    else {\n        // ...\n        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for first \n           treeifyBin(tab, hash);\n        //  ... \n     }\n}\n\n```\n从put源码中可以看到 ,如果表格为null,则通过resize来进行初始化,resize兼顾了两个职责,创建初始存储表格, 或者在容量不满足需求的时候进行扩容。因此HashMap按照lazy-load原则, 在首次使用时被初始化。\n\n具体键值对在哈希表的位置取决于下面的位运算。\n\n```java\ni = (n - 1) & hash\n```\n\n仔细观察哈希值的源头,我们就会发现,他并不是key本身的hashCode,而是来自于HashMap内部的另一个方法。为什么这里需要将高位数据移位到低位进行异或运算呢？这事因为有些数据计算出的哈希值差异主要在高位， 而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。\n\n```java\nstatic final int hash(Object kye) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>>16);\n}\n\n```\n\n下面我们继续看看resize方法, 经常会有面试题来追问他的源码设计。\n\n```java\nfinal Node<K,V>[] resize() {\n    // ...\n    else if ((newCap = oldCap << 1) < MAXIMUM_CAPACIY &&\n                oldCap >= DEFAULT_INITIAL_CAPAITY)\n        newThr = oldThr << 1; // double there\n       // ... \n    else if (oldThr > 0) // initial capacity was placed in threshold\n        newCap = oldThr;\n    else {  \n        // zero initial threshold signifies using defaultsfults\n        newCap = DEFAULT_INITIAL_CAPAITY;\n        newThr = (int)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；\n    }\n    if (newThr ==0){\n        float ft = (float)newCap * loadFator;\n        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?(int)ft : Integer.MAX_VALUE);\n    }\n    threshold = neThr;\n    Node<K,V>[] newTab = (Node<K,V>[])new Node[newap];\n    table = n；\n    // 移动到新的数组结构 e 数组结构 \n   }\n\n```\n\n根据resize源码, 我们可以归纳为:\n* 门限值等于(负载因子) x 容量,如果构建HashMap的时候没有指定,那就按照默认常量值。\n\n* 门限通常是以倍数进行调整(newThr = oldThr << 1),前面提到,根据putVal中的逻辑,当元素个数超过门限大小时,则调整Map大小。\n\n* 扩容后，需要将老的数组中的元素放入新的数组，这是主要的开销来源；\n\n### 容量，负载因子和树化\n\n为什么我们需要在乎容量和负载因子呢？\n\n因为容量和负载洗漱决定了可用桶的数量，空桶太多会浪费空间，如果太慢则会严重影响操作性能，极端情况下，如果只有一个桶，那么他就退化成了链表，完全不能提供所谓的常数时间存的性能。\n\n那么我们在时间中应该如何选择呢？\n\n如果能够知道HashMap要存取的键值对数量，可以考虑预先设置合适的容量大小，具体数值我们可以根据扩容发生的条件来进行简单的预估，根据代码分析，需要\n\n```\n负载因子 * 容量 > 元素数量\n```\n所以,预先设置的容量需要满足,大于\"预估元素数量 / 负载因子\", 同时时2的幂数,就可以得到。\n\n而对于负载因子,我建议:\n\n* 如果没有特别需求,不要进行轻易地更改,因为JDK自身默认的负载因子就是非常符合通用场景的需求的。\n\n* 如果确实需要跳转，建议不要设置超过0.75的数值，因为会显著增加冲突，降低HashMap的性能；\n\n* 如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的消耗；\n\n下面来讲一讲对于树化的改造。\n```Java\nfinal void treeifyBin(Node<K,V>[] tab, int hash) {\n    int n, index; Node<K,V> e;\n    if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)\n        resize();\n    else if ((e = tab[index = (n - 1) & hash]) != null) {\n        // 树化改造逻辑\n    }\n}\n\n\n```\n\n这是简化之后的treeifyBin示意,可以理解为,当bin的数量大于TREEIFY_THRESHOLD时:\n* 如果容量小于MIN_TREEIFY_CAPACITY,只会进行简单扩容;\n* 如果容量大于MIN_TREEIFY_CAPACITY,只会进行树化改造;\n\n那么为什么HashMap要树化呢?\n\n本质上是一个安全问题,其实也是一个性能问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置在同一个桶里，则会形成一个链表，我们都知道链表是线性的，会严重影响存取的性能。\n\n而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端进行交互，导致CPU大量占用，就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似的攻击事件。\n\n### 解决哈希冲突的办法\n\n解决哈希冲突的常用方法有：\n\n#### 开放定址法\n基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。\n\n#### 再哈希法\n这种方法是同时构造多个不同的哈希函数：\nHi=RH1（key）  i=1，2，…，k\n当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。\n\n#### 链地址法\n这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。\n\n#### 建立公共溢出区\n这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。\n\n#### 线性再散列\n最常用的方法就是线性再散列。即插入元素时，没有发生冲突放在原有的规则下的空槽下，发生冲突时，简单遍历hash表，找到表中下一个空槽，进行元素插入。查找元素时，找到相应的位置的元素，如果不匹配则进行遍历hash表。主要的缺点在于不能从表中删除元素。\n\n#### 非线性再散列\n就是冲突时，再hash，核心思想是，如果产生冲突，产生一个新的hash值进行寻址，如果还是冲突，则继续。主要的缺点在于不能从表中删除元素。\n","slug":"java学习/容器如何实现线程安全","published":1,"updated":"2019-03-22T14:44:36.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0900984l3nsfn6zhc3","content":"<p>Java提供了不同层面的线程安全支持.在传统集合框架内部,除了Hashtable等同步容器,还提供了所谓的同步包装器, 我们可以调用collections工具类提供的包装方法,来获取一个同步的包装容器, 但是他们都是利用粗颗粒度的同步方式,在高并发的情况下,性能比较低下。</p>\n<a id=\"more\"></a>\n<p>另外,更加普遍的选择是利用并发包提供的线程安全容器类,他提供了:</p>\n<ul>\n<li>各种并发容器，比如 ConcurrentHashMap、CopyOnWriteArrayList;</li>\n<li>各种线程安全队列,如ArrayBlockingQueue,SynchronousQueue;</li>\n<li>各种有序容器的线程安全版本等。</li>\n</ul>\n<h3 id=\"Hashtable，HashMap，TreeMap有何不同-？\"><a href=\"#Hashtable，HashMap，TreeMap有何不同-？\" class=\"headerlink\" title=\"Hashtable，HashMap，TreeMap有何不同 ？\"></a>Hashtable，HashMap，TreeMap有何不同 ？</h3><p>Hashtable是早期Java类库提供的一个哈希表实现，本身是同步的，不支持null键和值，HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现非常低下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。</p>\n<p>HashMap是应用更加广泛的哈希表实现，行为大致上与hashTable一致，主要区别在于hashMap不是同步的，支持null键和值等。通常情况下，HashMap进行put和get操作,可以达到常数时间的性能,所以他是绝大部分利用键值对存取场景的首先,比如,实现用户ID和用户信息对应的运行时的存储结构。</p>\n<p>初始化时：HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一定要为2的整数次幂；HashMap默认容量为16，且要求容量一定为2的整数次幂。<br>扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍。</p>\n<p>TreeMap则是基于红黑树的一种提供顺序访问的Map，和HashMap不同，他的get，put，remove之类的操作时间复杂度都为O(log(n))，具体顺序可以由指定的Comparator来决定,或者根据键的自然顺序来判断。</p>\n<p>另外还有一些有序Map, 虽然LinkedHashMap和TreeMap都可以保证某种顺序,但是二者还是非常不同的。</p>\n<p>LinkedHashMap通常提供的是遍历顺序符合插入顺序，他的实现是通过维护一个双向链表，通过特定的构造函数，我们可以创建反应访问顺序的实例，普通的操作比如put,get等,都算作”访问”。</p>\n<p>在这种行为适用于一些特定的应用场景，例如，我们构建一个空间占用敏感的资源池，希望可以自动将最不常访问的对象释放掉，就可以用LinkedHashMap来实现。</p>\n<h3 id=\"HashMap的实现\"><a href=\"#HashMap的实现\" class=\"headerlink\" title=\"HashMap的实现\"></a>HashMap的实现</h3><p>HashMap扩展自AbstractMao，其性能表现非常依赖于哈希码的有效性。这里就会讲到hashCode和equals的一些基本约定:</p>\n<ul>\n<li>equals相等,hashcode也一定要相等;</li>\n<li>重写了hashcode也要重写equals;</li>\n<li>hashCode需要保持一致性,状态改变返回的哈希值仍然需要一致;</li>\n<li>equals的自反性，对称性，传递性，一致性,非空性等特性;</li>\n</ul>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">自反性: 对于任何非<span class=\"keyword\">null</span>的引用值<span class=\"keyword\">x</span>, <span class=\"keyword\">x</span>.equals(<span class=\"keyword\">x</span>)必须返回<span class=\"keyword\">true</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">对称性: 对于任何非null的引用值x和y,当且仅当y.equals(x)返回true时，x.equals(y)必须返回true;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">传递性: 对于任何非null的引用值x,y和z，如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)返回true;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">一致性: 对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">非空性: 对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false</span></span><br></pre></td></tr></table></figure>\n<p>HashMap的内部结构，可以看做是数组和链表组成的复合结构，数组被分为一个个桶(bucket)<br>,通过哈希值来决定键值对在这个数组的寻址;哈希值相同的键值对,则以链表形式存储,如果链表的大小超过了阈值(TREEIFY_THRESHOLD, 8),就会被改造为树形结构。</p>\n<p>当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evit)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> , i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) = <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == ull)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, nll);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for first </span></span><br><span class=\"line\">           treeifyBin(tab, hash);</span><br><span class=\"line\">        <span class=\"comment\">//  ... </span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从put源码中可以看到 ,如果表格为null,则通过resize来进行初始化,resize兼顾了两个职责,创建初始存储表格, 或者在容量不满足需求的时候进行扩容。因此HashMap按照lazy-load原则, 在首次使用时被初始化。</p>\n<p>具体键值对在哈希表的位置取决于下面的位运算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (n - <span class=\"number\">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>\n<p>仔细观察哈希值的源头,我们就会发现,他并不是key本身的hashCode,而是来自于HashMap内部的另一个方法。为什么这里需要将高位数据移位到低位进行异或运算呢？这事因为有些数据计算出的哈希值差异主要在高位， 而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object kye)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt;<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们继续看看resize方法, 经常会有面试题来追问他的源码设计。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACIY &amp;&amp;</span><br><span class=\"line\">                oldCap &gt;= DEFAULT_INITIAL_CAPAITY)</span><br><span class=\"line\">        newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double there</span></span><br><span class=\"line\">       <span class=\"comment\">// ... </span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// zero initial threshold signifies using defaultsfults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPAITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr ==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFator;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?(<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = neThr;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newap];</span><br><span class=\"line\">    table = n；</span><br><span class=\"line\">    <span class=\"comment\">// 移动到新的数组结构 e 数组结构 </span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>根据resize源码, 我们可以归纳为:</p>\n<ul>\n<li><p>门限值等于(负载因子) x 容量,如果构建HashMap的时候没有指定,那就按照默认常量值。</p>\n</li>\n<li><p>门限通常是以倍数进行调整(newThr = oldThr &lt;&lt; 1),前面提到,根据putVal中的逻辑,当元素个数超过门限大小时,则调整Map大小。</p>\n</li>\n<li><p>扩容后，需要将老的数组中的元素放入新的数组，这是主要的开销来源；</p>\n</li>\n</ul>\n<h3 id=\"容量，负载因子和树化\"><a href=\"#容量，负载因子和树化\" class=\"headerlink\" title=\"容量，负载因子和树化\"></a>容量，负载因子和树化</h3><p>为什么我们需要在乎容量和负载因子呢？</p>\n<p>因为容量和负载洗漱决定了可用桶的数量，空桶太多会浪费空间，如果太慢则会严重影响操作性能，极端情况下，如果只有一个桶，那么他就退化成了链表，完全不能提供所谓的常数时间存的性能。</p>\n<p>那么我们在时间中应该如何选择呢？</p>\n<p>如果能够知道HashMap要存取的键值对数量，可以考虑预先设置合适的容量大小，具体数值我们可以根据扩容发生的条件来进行简单的预估，根据代码分析，需要</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">负载因子 * 容量 &gt; 元素数量</span><br></pre></td></tr></table></figure>\n<p>所以,预先设置的容量需要满足,大于”预估元素数量 / 负载因子”, 同时时2的幂数,就可以得到。</p>\n<p>而对于负载因子,我建议:</p>\n<ul>\n<li><p>如果没有特别需求,不要进行轻易地更改,因为JDK自身默认的负载因子就是非常符合通用场景的需求的。</p>\n</li>\n<li><p>如果确实需要跳转，建议不要设置超过0.75的数值，因为会显著增加冲突，降低HashMap的性能；</p>\n</li>\n<li><p>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的消耗；</p>\n</li>\n</ul>\n<p>下面来讲一讲对于树化的改造。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 树化改造逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是简化之后的treeifyBin示意,可以理解为,当bin的数量大于TREEIFY_THRESHOLD时:</p>\n<ul>\n<li>如果容量小于MIN_TREEIFY_CAPACITY,只会进行简单扩容;</li>\n<li>如果容量大于MIN_TREEIFY_CAPACITY,只会进行树化改造;</li>\n</ul>\n<p>那么为什么HashMap要树化呢?</p>\n<p>本质上是一个安全问题,其实也是一个性能问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置在同一个桶里，则会形成一个链表，我们都知道链表是线性的，会严重影响存取的性能。</p>\n<p>而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端进行交互，导致CPU大量占用，就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似的攻击事件。</p>\n<h3 id=\"解决哈希冲突的办法\"><a href=\"#解决哈希冲突的办法\" class=\"headerlink\" title=\"解决哈希冲突的办法\"></a>解决哈希冲突的办法</h3><p>解决哈希冲突的常用方法有：</p>\n<h4 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h4><p>基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</p>\n<h4 id=\"再哈希法\"><a href=\"#再哈希法\" class=\"headerlink\" title=\"再哈希法\"></a>再哈希法</h4><p>这种方法是同时构造多个不同的哈希函数：<br>Hi=RH1（key）  i=1，2，…，k<br>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>\n<h4 id=\"链地址法\"><a href=\"#链地址法\" class=\"headerlink\" title=\"链地址法\"></a>链地址法</h4><p>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>\n<h4 id=\"建立公共溢出区\"><a href=\"#建立公共溢出区\" class=\"headerlink\" title=\"建立公共溢出区\"></a>建立公共溢出区</h4><p>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>\n<h4 id=\"线性再散列\"><a href=\"#线性再散列\" class=\"headerlink\" title=\"线性再散列\"></a>线性再散列</h4><p>最常用的方法就是线性再散列。即插入元素时，没有发生冲突放在原有的规则下的空槽下，发生冲突时，简单遍历hash表，找到表中下一个空槽，进行元素插入。查找元素时，找到相应的位置的元素，如果不匹配则进行遍历hash表。主要的缺点在于不能从表中删除元素。</p>\n<h4 id=\"非线性再散列\"><a href=\"#非线性再散列\" class=\"headerlink\" title=\"非线性再散列\"></a>非线性再散列</h4><p>就是冲突时，再hash，核心思想是，如果产生冲突，产生一个新的hash值进行寻址，如果还是冲突，则继续。主要的缺点在于不能从表中删除元素。</p>\n","site":{"data":{}},"excerpt":"<p>Java提供了不同层面的线程安全支持.在传统集合框架内部,除了Hashtable等同步容器,还提供了所谓的同步包装器, 我们可以调用collections工具类提供的包装方法,来获取一个同步的包装容器, 但是他们都是利用粗颗粒度的同步方式,在高并发的情况下,性能比较低下。</p>","more":"<p>另外,更加普遍的选择是利用并发包提供的线程安全容器类,他提供了:</p>\n<ul>\n<li>各种并发容器，比如 ConcurrentHashMap、CopyOnWriteArrayList;</li>\n<li>各种线程安全队列,如ArrayBlockingQueue,SynchronousQueue;</li>\n<li>各种有序容器的线程安全版本等。</li>\n</ul>\n<h3 id=\"Hashtable，HashMap，TreeMap有何不同-？\"><a href=\"#Hashtable，HashMap，TreeMap有何不同-？\" class=\"headerlink\" title=\"Hashtable，HashMap，TreeMap有何不同 ？\"></a>Hashtable，HashMap，TreeMap有何不同 ？</h3><p>Hashtable是早期Java类库提供的一个哈希表实现，本身是同步的，不支持null键和值，HashTable其方法函数都是同步的（采用synchronized修饰），不会出现两个线程同时对数据进行操作的情况，因此保证了线程安全性。也正因为如此，在多线程运行环境下效率表现非常低下。因为当一个线程访问HashTable的同步方法时，其他线程也访问同步方法就会进入阻塞状态。比如当一个线程在添加数据时候，另外一个线程即使执行获取其他数据的操作也必须被阻塞，大大降低了程序的运行效率，在新版本中已被废弃，不推荐使用。</p>\n<p>HashMap是应用更加广泛的哈希表实现，行为大致上与hashTable一致，主要区别在于hashMap不是同步的，支持null键和值等。通常情况下，HashMap进行put和get操作,可以达到常数时间的性能,所以他是绝大部分利用键值对存取场景的首先,比如,实现用户ID和用户信息对应的运行时的存储结构。</p>\n<p>初始化时：HashTable在不指定容量的情况下的默认容量为11，且不要求底层数组的容量一定要为2的整数次幂；HashMap默认容量为16，且要求容量一定为2的整数次幂。<br>扩容时：Hashtable将容量变为原来的2倍加1；HashMap扩容将容量变为原来的2倍。</p>\n<p>TreeMap则是基于红黑树的一种提供顺序访问的Map，和HashMap不同，他的get，put，remove之类的操作时间复杂度都为O(log(n))，具体顺序可以由指定的Comparator来决定,或者根据键的自然顺序来判断。</p>\n<p>另外还有一些有序Map, 虽然LinkedHashMap和TreeMap都可以保证某种顺序,但是二者还是非常不同的。</p>\n<p>LinkedHashMap通常提供的是遍历顺序符合插入顺序，他的实现是通过维护一个双向链表，通过特定的构造函数，我们可以创建反应访问顺序的实例，普通的操作比如put,get等,都算作”访问”。</p>\n<p>在这种行为适用于一些特定的应用场景，例如，我们构建一个空间占用敏感的资源池，希望可以自动将最不常访问的对象释放掉，就可以用LinkedHashMap来实现。</p>\n<h3 id=\"HashMap的实现\"><a href=\"#HashMap的实现\" class=\"headerlink\" title=\"HashMap的实现\"></a>HashMap的实现</h3><p>HashMap扩展自AbstractMao，其性能表现非常依赖于哈希码的有效性。这里就会讲到hashCode和equals的一些基本约定:</p>\n<ul>\n<li>equals相等,hashcode也一定要相等;</li>\n<li>重写了hashcode也要重写equals;</li>\n<li>hashCode需要保持一致性,状态改变返回的哈希值仍然需要一致;</li>\n<li>equals的自反性，对称性，传递性，一致性,非空性等特性;</li>\n</ul>\n<figure class=\"highlight llvm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">自反性: 对于任何非<span class=\"keyword\">null</span>的引用值<span class=\"keyword\">x</span>, <span class=\"keyword\">x</span>.equals(<span class=\"keyword\">x</span>)必须返回<span class=\"keyword\">true</span><span class=\"comment\">;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">对称性: 对于任何非null的引用值x和y,当且仅当y.equals(x)返回true时，x.equals(y)必须返回true;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">传递性: 对于任何非null的引用值x,y和z，如果x.equals(y)返回true，并且y.equals(z)返回true，那么x.equals(z)返回true;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">一致性: 对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false;</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">非空性: 对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y)就会一致地返回true，或者一致地返回false</span></span><br></pre></td></tr></table></figure>\n<p>HashMap的内部结构，可以看做是数组和链表组成的复合结构，数组被分为一个个桶(bucket)<br>,通过哈希值来决定键值对在这个数组的寻址;哈希值相同的键值对,则以链表形式存储,如果链表的大小超过了阈值(TREEIFY_THRESHOLD, 8),就会被改造为树形结构。</p>\n<p>当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，让后找到bucket位置来储存值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞了，对象将会储存在链表的下一个节点中。 HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法用来找到键值对。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> putVal(hash(key), key, value, <span class=\"keyword\">false</span>, <span class=\"keyword\">true</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> V <span class=\"title\">putVal</span><span class=\"params\">(<span class=\"keyword\">int</span> hash, K key, V value, <span class=\"keyword\">boolean</span> onlyIfAbent,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">               <span class=\"keyword\">boolean</span> evit)</span> </span>&#123;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class=\"keyword\">int</span> , i;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((tab = table) == <span class=\"keyword\">null</span> || (n = tab.length) = <span class=\"number\">0</span>)</span><br><span class=\"line\">        n = (tab = resize()).length;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((p = tab[i = (n - <span class=\"number\">1</span>) &amp; hash]) == ull)</span><br><span class=\"line\">        tab[i] = newNode(hash, key, value, nll);</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// ...</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class=\"number\">1</span>) <span class=\"comment\">// -1 for first </span></span><br><span class=\"line\">           treeifyBin(tab, hash);</span><br><span class=\"line\">        <span class=\"comment\">//  ... </span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>从put源码中可以看到 ,如果表格为null,则通过resize来进行初始化,resize兼顾了两个职责,创建初始存储表格, 或者在容量不满足需求的时候进行扩容。因此HashMap按照lazy-load原则, 在首次使用时被初始化。</p>\n<p>具体键值对在哈希表的位置取决于下面的位运算。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = (n - <span class=\"number\">1</span>) &amp; hash</span><br></pre></td></tr></table></figure>\n<p>仔细观察哈希值的源头,我们就会发现,他并不是key本身的hashCode,而是来自于HashMap内部的另一个方法。为什么这里需要将高位数据移位到低位进行异或运算呢？这事因为有些数据计算出的哈希值差异主要在高位， 而HashMap里的哈希寻址是忽略容量以上的高位的，那么这种处理就可以有效避免类似情况下的哈希碰撞。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hash</span><span class=\"params\">(Object kye)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> h;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (key == <span class=\"keyword\">null</span>) ? <span class=\"number\">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt;<span class=\"number\">16</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>下面我们继续看看resize方法, 经常会有面试题来追问他的源码设计。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((newCap = oldCap &lt;&lt; <span class=\"number\">1</span>) &lt; MAXIMUM_CAPACIY &amp;&amp;</span><br><span class=\"line\">                oldCap &gt;= DEFAULT_INITIAL_CAPAITY)</span><br><span class=\"line\">        newThr = oldThr &lt;&lt; <span class=\"number\">1</span>; <span class=\"comment\">// double there</span></span><br><span class=\"line\">       <span class=\"comment\">// ... </span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (oldThr &gt; <span class=\"number\">0</span>) <span class=\"comment\">// initial capacity was placed in threshold</span></span><br><span class=\"line\">        newCap = oldThr;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> &#123;  </span><br><span class=\"line\">        <span class=\"comment\">// zero initial threshold signifies using defaultsfults</span></span><br><span class=\"line\">        newCap = DEFAULT_INITIAL_CAPAITY;</span><br><span class=\"line\">        newThr = (<span class=\"keyword\">int</span>)(DEFAULT_LOAD_ATOR* DEFAULT_INITIAL_CAPACITY；</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (newThr ==<span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">float</span> ft = (<span class=\"keyword\">float</span>)newCap * loadFator;</span><br><span class=\"line\">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class=\"keyword\">float</span>)MAXIMUM_CAPACITY ?(<span class=\"keyword\">int</span>)ft : Integer.MAX_VALUE);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    threshold = neThr;</span><br><span class=\"line\">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class=\"keyword\">new</span> Node[newap];</span><br><span class=\"line\">    table = n；</span><br><span class=\"line\">    <span class=\"comment\">// 移动到新的数组结构 e 数组结构 </span></span><br><span class=\"line\">   &#125;</span><br></pre></td></tr></table></figure>\n<p>根据resize源码, 我们可以归纳为:</p>\n<ul>\n<li><p>门限值等于(负载因子) x 容量,如果构建HashMap的时候没有指定,那就按照默认常量值。</p>\n</li>\n<li><p>门限通常是以倍数进行调整(newThr = oldThr &lt;&lt; 1),前面提到,根据putVal中的逻辑,当元素个数超过门限大小时,则调整Map大小。</p>\n</li>\n<li><p>扩容后，需要将老的数组中的元素放入新的数组，这是主要的开销来源；</p>\n</li>\n</ul>\n<h3 id=\"容量，负载因子和树化\"><a href=\"#容量，负载因子和树化\" class=\"headerlink\" title=\"容量，负载因子和树化\"></a>容量，负载因子和树化</h3><p>为什么我们需要在乎容量和负载因子呢？</p>\n<p>因为容量和负载洗漱决定了可用桶的数量，空桶太多会浪费空间，如果太慢则会严重影响操作性能，极端情况下，如果只有一个桶，那么他就退化成了链表，完全不能提供所谓的常数时间存的性能。</p>\n<p>那么我们在时间中应该如何选择呢？</p>\n<p>如果能够知道HashMap要存取的键值对数量，可以考虑预先设置合适的容量大小，具体数值我们可以根据扩容发生的条件来进行简单的预估，根据代码分析，需要</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">负载因子 * 容量 &gt; 元素数量</span><br></pre></td></tr></table></figure>\n<p>所以,预先设置的容量需要满足,大于”预估元素数量 / 负载因子”, 同时时2的幂数,就可以得到。</p>\n<p>而对于负载因子,我建议:</p>\n<ul>\n<li><p>如果没有特别需求,不要进行轻易地更改,因为JDK自身默认的负载因子就是非常符合通用场景的需求的。</p>\n</li>\n<li><p>如果确实需要跳转，建议不要设置超过0.75的数值，因为会显著增加冲突，降低HashMap的性能；</p>\n</li>\n<li><p>如果使用太小的负载因子，按照上面的公式，预设容量值也进行调整，否则可能会导致更加频繁的扩容，增加无谓的消耗；</p>\n</li>\n</ul>\n<p>下面来讲一讲对于树化的改造。<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">treeifyBin</span><span class=\"params\">(Node&lt;K,V&gt;[] tab, <span class=\"keyword\">int</span> hash)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n, index; Node&lt;K,V&gt; e;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tab == <span class=\"keyword\">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class=\"line\">        resize();</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> ((e = tab[index = (n - <span class=\"number\">1</span>) &amp; hash]) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 树化改造逻辑</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这是简化之后的treeifyBin示意,可以理解为,当bin的数量大于TREEIFY_THRESHOLD时:</p>\n<ul>\n<li>如果容量小于MIN_TREEIFY_CAPACITY,只会进行简单扩容;</li>\n<li>如果容量大于MIN_TREEIFY_CAPACITY,只会进行树化改造;</li>\n</ul>\n<p>那么为什么HashMap要树化呢?</p>\n<p>本质上是一个安全问题,其实也是一个性能问题。因为在元素放置过程中，如果一个对象哈希冲突，都被放置在同一个桶里，则会形成一个链表，我们都知道链表是线性的，会严重影响存取的性能。</p>\n<p>而在现实世界，构造哈希冲突的数据并不是非常复杂的事情，恶意代码就可以利用这些数据大量与服务器端进行交互，导致CPU大量占用，就构成了哈希碰撞拒绝服务攻击，国内一线互联网公司就发生过类似的攻击事件。</p>\n<h3 id=\"解决哈希冲突的办法\"><a href=\"#解决哈希冲突的办法\" class=\"headerlink\" title=\"解决哈希冲突的办法\"></a>解决哈希冲突的办法</h3><p>解决哈希冲突的常用方法有：</p>\n<h4 id=\"开放定址法\"><a href=\"#开放定址法\" class=\"headerlink\" title=\"开放定址法\"></a>开放定址法</h4><p>基本思想是：当关键字key的哈希地址p=H（key）出现冲突时，以p为基础，产生另一个哈希地址p1，如果p1仍然冲突，再以p为基础，产生另一个哈希地址p2，…，直到找出一个不冲突的哈希地址pi ，将相应元素存入其中。</p>\n<h4 id=\"再哈希法\"><a href=\"#再哈希法\" class=\"headerlink\" title=\"再哈希法\"></a>再哈希法</h4><p>这种方法是同时构造多个不同的哈希函数：<br>Hi=RH1（key）  i=1，2，…，k<br>当哈希地址Hi=RH1（key）发生冲突时，再计算Hi=RH2（key）……，直到冲突不再产生。这种方法不易产生聚集，但增加了计算时间。</p>\n<h4 id=\"链地址法\"><a href=\"#链地址法\" class=\"headerlink\" title=\"链地址法\"></a>链地址法</h4><p>这种方法的基本思想是将所有哈希地址为i的元素构成一个称为同义词链的单链表，并将单链表的头指针存在哈希表的第i个单元中，因而查找、插入和删除主要在同义词链中进行。链地址法适用于经常进行插入和删除的情况。</p>\n<h4 id=\"建立公共溢出区\"><a href=\"#建立公共溢出区\" class=\"headerlink\" title=\"建立公共溢出区\"></a>建立公共溢出区</h4><p>这种方法的基本思想是：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表。</p>\n<h4 id=\"线性再散列\"><a href=\"#线性再散列\" class=\"headerlink\" title=\"线性再散列\"></a>线性再散列</h4><p>最常用的方法就是线性再散列。即插入元素时，没有发生冲突放在原有的规则下的空槽下，发生冲突时，简单遍历hash表，找到表中下一个空槽，进行元素插入。查找元素时，找到相应的位置的元素，如果不匹配则进行遍历hash表。主要的缺点在于不能从表中删除元素。</p>\n<h4 id=\"非线性再散列\"><a href=\"#非线性再散列\" class=\"headerlink\" title=\"非线性再散列\"></a>非线性再散列</h4><p>就是冲突时，再hash，核心思想是，如果产生冲突，产生一个新的hash值进行寻址，如果还是冲突，则继续。主要的缺点在于不能从表中删除元素。</p>"},{"title":"SQL语言的数据查询","date":"2016-10-27T13:22:50.000Z","_content":"此篇为上一篇的姊妹篇，感觉一不小心记的又臭又长了，不过内容确实不是一篇文章能说的清的。\n\n<!--more-->\n\nSELECT语句的一般格式为:\n```\n//格式一\nSELECT〈列名〉[{，〈列名〉}]\nFROM〈表名或视图名〉[{，〈表名或视图名〉}]\n[WHERE〈检索条件〉]\n[GROUP BY <列名1>[HAVING <条件表达式>]]\n[ORDER BY <列名2>[ASC|DESC]];\n//格式二\nSELECT  [ALL|DISTINCT][TOP N [PERCENT][WITH TIES]]\n   列名1 [AS 别名1]\n[, 列名2 [ AS 别名2]…]\n[INTO 新表名]\nFROM 表名 1[[AS] 表1别名]\n[INNER|RIGHT|FULL|OUTER][OUTER]JOIN\n    表名2 [[AS] 表2别名]\nON 条件\n```\n查询结束时仍然是一个表。\n\nSELECT语句的执行过程是:\n根据WHERE子句的检索条件，从FROM子句指定的基本表或视图中选取满足条件的元组，再按照SELECT子句中指定的列，投影得到结果表。\n如果有GROUP子句，则将查询结果按照<列名1>相同的值进行分组。\n如果GROUP子句后有HAVING短语，则只输出满足HAVING条件的元组。\n如果有ORDER子句，查询结果还要按照<列名2>的值进行排序。\n\n### 投影查询\n在查询中不使用WHERE子句的无条件查询，也称投影查询。\n```\n//查询选修了课程的学生号\nSELECT DISTINCT SNO FROM SC\n```\n利用投影查询可控制列名的顺序，并可通过指定别名改变查询结果的列标题的名字。\n```\n//查询全体学生的姓名、学号和年龄。\nSELECT SNAME NAME, SNO, AGE FROM S\n```\n其中，NAME为SNAME的别名。\n### 条件查询\n当要在表中找出满足某些条件的行时，则需使用WHERE子句指定查询条件。\n\nWHERE子句中，条件通常通过三部分来描述：\n1.列名；\n2.比较运算符；\n3.列名、常数。\n\n比较运算符，除了常规的大于小于等于之外，还有下列这些常用的比较运算符：\n\n不等于(<>)；多重条件(and,or);BETWEEN AND(确定范围)；IN(确定集合)；LIKE(字符匹配)；IS NULL（空值）\n#### 1.比较大小\n```\nSELECT SNO,CNO,SCORE FROM SC WHERE SCORE>85\n```\n#### 2.多重条件查询\n当WHERE子句需要指定一个以上的查询条件时，则需要使用逻辑运算符AND、OR和NOT将其连结成复合的逻辑表达式。\n其优先级由高到低为：NOT、AND、OR，用户可以使用括号改变优先级。\n```\n//查询选修C1或C2且分数大于等于85分学生的的学号、课程号和成绩。\nSELECT SNO，CNO，SCORE\n   FROM SC\nWHERE（CNO=’C1’ OR CNO=’C2’） AND\n SCORE>=85 \n```\n#### 3.确定范围\n```\n//查询工资在1000至1500之间的教师的教师号、姓名及职称。\nSELECT TNO,TN,PROF\n   FROM T\nWHERE SAL BETWEEN 1000 AND 1500\n//等价于\nSELECT TNO,TN,PROF\n   FROM T\nWHERE SAL>=1000 AND SAL<=1500\n```\n#### 4.确定集合\n利用“IN”操作可以查询属性值属于指定集合的元组。\n\n```\n//查询选修C1或C2的学生的学号、课程号和成绩。\nSELECT SNO, CNO, SCORE \n   FROM SC \nWHERE CNO IN(‘C1’, ‘C2’)\n//此语句也可以使用逻辑运算符“OR”实现。\n//利用“NOT IN”可以查询指定集合外的元组。\n```\n#### 5.部分匹配查询\n上例均属于完全匹配查询，当不知道完全精确的値时，用户还可以使用LIKE或NOT LIKE进行部分匹配查询（也称模糊查询）。\nLIKE定义的一般格式为：\n```\n<属性名> LIKE <字符串常量>\n```\n属性名必须为字符型，字符串常量的字符可以包含如下两个特殊符号：\n%：表示任意知长度的字符串；\n\n_：表示任意单个字符;\n\n\\[charlist]:字符列中的任何单一字符;\n\n\\[^charlist]或者[!charlist]:不在字符列中的任何单一字符。\n```\n//查询所有姓张但不包含国或辽的教师的教师号和姓名。\nselect  * \n from S\nwhere sname like '张[^国辽]_'\n```\n#### 6.空值查询\n某个字段没有值称之为具有空值（NULL）。空值不同于零和空格，它不占任何存储空间。\n\n例如，某些学生选课后没有参加考试，有选课记录，但没有考试成绩，考试成绩为空值，这与参加考试，成绩为零分的不同。\n```\nSELECT SNO, CNO\n   FROM SC\nWHERE SCORE IS NULL\n```\n### 常用库函数及统计汇总查询\n|函数名称|功能\n|------|------|\n|AVG|按列计算平均值|\n|SUM|按列计算值的总和|\n|MAX|求一列中的最大值|\n|MIN|求一列中的最小值|\n|COUNT|按列值计个数|\n\n```\n//求学号为S1学生的总分和平均分。\nSELECT SUM(SCORE) AS TotalScore, AVG(SCORE) AS AveScore\n   FROM SC\nWHERE (SNO = 'S1') \n\n//求学校中共有多少个系\nSELECT COUNT(DISTINCT DEPT) AS DeptNum \n   FROM S\n```\n注意：\n函数SUM和AVG只能对数值型字段进行计算。\n\nCOUNT函数对空值不计算，但对零进行计算。\n### 分组查询\n`GROUP BY`子句可以将查询结果按属性列或属性列组合在行的方向上进行分组，每组在属性列或属性列组合上具有相同的值。\n```\n查询各位教师的教师号及其任课的门数。\nSELECT TNO,COUNT(*) AS C_NUM\n  FROM TC\nGROUP BY TNO \n```\n若在分组后还要按照一定的条件进行筛选，则需使用HAVING子句。\n```\nSELECT SNO,COUNT(*) AS SC_NUM \n  FROM SC\nGROUP BY SNO       \nHAVING COUNT(*)>=2 \n\n```\n当在一个SQL查询中同时使用WHERE子句，`GROUP  BY `子句和`HAVING`子句时，其顺序是`WHERE－GROUP  BY－ HAVING`。\n\n**`WHERE`与`HAVING`子句的根本区别在于作用对象不同。**\n\nWHERE子句作用于基本表或视图，从中选择满足条件的元组；\nHAVING子句作用于组，选择满足条件的组，必须用于GROUP BY子句之后，但GROUP BY子句可没有HAVING子句。\n\n### 查询排序\n当需要对查询结果排序时，应该使用ORDER BY子句\nORDER BY子句必须出现在其他子句之后\n排序方式可以指定，DESC为降序，ASC为升序，缺省时为升序\n```\n//查询选修C2、C3、C4或C5课程的学号、课程号和成绩，查询结果按学号升序排列，学号相同再按成绩降序排列。\nSELECT SNO,CNO, SCORE \n   FROM SC\nWHERE CNO IN ('C2' ,'C3', 'C4','C5')\n   ORDER BY SNO,SCORE DESC \n//求选课在三门以上且各门课程均及格的学生的学号及其总    成绩，查询结果按总成绩降序列出。\n\nSELECT SNO,SUM(SCORE)AS TotalScore\nFROM SC\nWHERE SCORE>=60\nGROUP BY SNO\nHAVING COUNT(*)>=3\nORDER BY SUM(SCORE) DESC\n```\n上述执行过程如下：取出SC，筛选SCORE>=60 的元组，讲选出的元组按照SNO分组，筛选选课三门以上的分组，一剩下的组中提取学号和总成绩，将选取结果排序。\n\n另外，`ORDER BY SUM(SCORE) DESC`可以改写成\n`ORDER BY 2 DESC`,2 代表查询结果的第二列。 \n\n### INTO 子句\n在默认子段组中创建一个新表并将来自查询的结果行插入新表中。\n```\nSELECT *\n     INTO new_Table\n   FROM S\nWHERE Sex = ‘男’\n\n```\n### COMPUTE子句\n生成合计作为附加的汇总列出现在结果集的最后。\n```\nSELECT s.s#,sname,age,sex,c#,grade \n   FROM s,sc\nWHERE s.s#=sc.s# and\n               s.s#='200203080101'\nCOMPUTE sum(sc.grade),count(s.s#)\n```\n### 数据表连接及连接查询\n数据表之间的联系是通过表的字段值来体现的，这种字段称为连接字段。\n连接操作的目的就是通过加在连接字段的条件将多个表连接起来，以便从多个表中查询数据。\n前面的查询都是针对一个表进行的，当查询同时涉及两个以上的表时，称为连接查询。\n\n表的连接方法有两种：\n1.表之间满足一定的条件的行进行连接，此时FROM子句中指明进行连接的表名，`WHERE`子句指明连接的列名及其连接条件。\n2.利用关键字`JOIN`进行连接。\n\n具体分为下列几种：\n1.INNER JOIN：现在符合条件的记录，此为默认值。\n2.LEFT （OUTER） JOIN：显示符合条件的数据行以及左边表中不符合条件的数据行，此时右边数据行会以NULL来显示，此称为左连接。\n3.RIGHT （OUTER） JOIN：显示符合条件的数据行以及右边表中不符合条件的数据行，此时左边数据行会以NULL来显示，此称为右连接。\n4.FULL （OUTER） JOIN：显示符合条件的数据行以及左边表和右边表中不符合条件的数据行，此时缺乏数据的数据行会以NULL来显示。\n5.CROSS JOIN：会将一个表的每一笔数据和另一表的每笔数据匹配成新的数据行。\n\n当将`JOIN`关键词放于FROM子句中时，应有关键词`ON`与之相对应，以表明连接的条件。\n\n#### 等值连接与非等值连接\n查询刘伟老师所讲授的课程。\n\n方法1：\n```\nSELECT T.TNO ,TN,CNO\n   FROM T,TC\nWHERE (T.TNO = TC. TNO) AND (TN = ‘刘伟’)\n\n```\n上面的操作是将T表中的TNO 和TC表中的TNO相等的行连接，同时选取TN为“刘伟“的行，然后再在TN，CNO列上投影，这是连接、选取和投影的操作组合。\n\n这里，TN=‘刘伟’为查询条件，而T.TNO = TC.TNO 为连接条件，TNO为连接字段。连接条件的一般格式为：\n```\n[<表名1>.] <列名1> <比较运算符> [<表名2>.] <列名2> \n```\n其中,比较运算符主要有：＝、＞、＜、＞＝、＜＝、！＝。\n当比较运算符为“＝“时，称为等值连接，其他情况为非等值连接。\n\n当列名是唯一的，不需要加表名前缀。\n\n方法2：\n```\nSELECT T.TNO,TN,CNO\n   FROM T INNER JOIN TC \n    ON T.TNO=TC.TNO AND T.TN='刘伟'\n\n```\n方法3：\n```\nSELECT R2.TNO,R2.TN, R1.CNO \n   FROM\n      (SELECT TNO,CNO \n          FROM TC ) AS R1\n       INNER JOIN \n       (SELECT TNO ,TN \n            FROM T\n         WHERE TN='刘伟') AS R2\n        ON R1.TNO=R2.TNO\n\n```\n#### 自身连接\n\n查询所有比刘伟工资高的教师姓名、性别、工资和刘伟的工资。\n\n要查询的内容均在同一表T中，可以将表T分别取两个别名，一个是X，一个是Y。将X, Y 中满足比刘伟工资高的行连接起来。这实际上是同一表T的自身连接。\n方法1：\n```\nSELECT X.TN,X.SAL AS SAL_a, Y.SAL AS SAL_b \n   FROM T AS X ,T AS Y \nWHERE X.SAL>Y.SAL AND \n    Y.TN='刘伟'\n\n```\n方法2：\n```\nSELECT X.TN, X.SAL,Y.SAL \n   FROM T AS X INNER JOIN T AS Y\n      ON X.SAL>Y.SAL AND Y.TN='刘伟'\n```\n方法3：\n```\nSELECT R1.TN,R1.SAL, R2.SAL \n   FROM \n    (SELECT TN,SAL \n         FROM T ) AS R1\n    INNER JOIN \n    (SELECT SAL \n         FROM T\n      WHERE TN='刘伟') AS R2\n     ON R1.SAL>R2.SAL\n\n```\n#### 外连接\n在上面的连接操作中，不满足连接条件的元组不能作为查询结果输出。\n```\n//查询所有学生的学号、姓名、选课名称及成绩。（没有选课的同学的选课信息显示为空）则应写成如下的SQL语句。\nSELECT S.SNO,SN,CN,SCORE\n   FROM S\n       LEFT OUTER JOIN SC\n       ON S.SNO=SC.SNO\n       LEFT OUTER JOIN C\n       ON C.CNO=SC.CNO\n```\n则查询结果只包括所有的学生，没有选课的同学的选课信息显示为空。\n\n### 子查询\n在WHERE子句中包含一个形如SELECT-FROM-WHERE的查询块，此查询块称为子查询或嵌套查询，包含子查询的语句称为父查询或外部查询。\n\n子查询的嵌套层次最多可达到255层，以层层嵌套的方式构造查询充分体现了SQL“结构化”的特点。\n\n嵌套查询在执行时由里向外处理，每个子查询是在上一级外部查询处理之前完成，父查询要用到子查询的结果。\n\n#### 返回一组值的子查询\n如果子查询的返回值不止一个，而是一个集合时，则不能直接使用比较运算符，可以在比较运算符和子查询之间插入ANY或ALL。\n```\n//查询讲授课程号为C5的教师姓名。\nSELECT TN\n   FROM T\nWHERE TNO=ANY\n      (SELECT TNO \n          FROM TC\n       WHERE CNO='C5')\n//该例也可以使用前面所讲的连接操作来实现：\nSELECT TN\n   FROM T,TC\nWHERE T.TNO=TC.TNO AND\n               TC.CNO='C5‘\n\n```\n可见，对于同一查询可使用子查询和连接两种方法来解决，可根据习惯任意选用。 \n\n另外，还可以使用IN代替“=ANY”。\n```\nSELECT TN\n   FROM T\nWHERE TNO IN\n    (SELECT TNO \n        FROM TC\n     WHERE CNO='C5')\n```\n\n```\nSELECT DISTINCT TN\n   FROM T\nWHERE 'C5' !=ALL\n     ( SELECT CNO \n           FROM TC\n        WHERE TNO=T.TNO)\n```\n`!=ALL`的含义为不等于子查询结果中的任何一个值，也可使用`NOT IN`代替`!=ALL`。\n\n前面所讲的子查询均为普通子查询，而本例中子查询的查询条件引用了父查询表中的属性值（T表的TNO值），我们把这类查询称为相关子查询。\n\n二者的执行方式不同，相关子查询并不是先执行子查询，而是首先选取父查询表的第一行记录，内部的子查询利用此行中相关的属性值进行查询。\n然后父查询根据子查询返回的结果判断此行是否满足查询条件。如果满足条件，则把该行放入父查询的查询结果集合中。重复执行这一过程，直到处理完父查询表中的每一行数据。\n\n如上行所述，表T中每一行都要执行一次子查询。\n因此，相关子查询的执行次数是由父查询表的行数决定的。\n\n除了之前说的ALL,ANY,IN之外，还可以使用EXISTS来表示存在与否。带有EXISTS的子查询不返回任何实际数据，它只得到逻辑值“真”或“假”。\n\n```\n查询讲授课程号为C5的教师姓名。\nSELECT TN\n   FROM T\nWHERE EXISTS\n    (SELECT * \n        FROM TC\n     WHERE TNO=T.TNO\n    AND CNO='C5')\n```\n当子查询TC表存在一行记录满足其WHERE子句中的条件时，则父查询便得到一个TN值，重复执行以上过程，直到得出最后结果。\n\n### 集合查询\n集合操作分为并操作UNION,交操作INTERSECT,差操作EXCEPT。\n\n参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同。\n```\nSELECT *\n   FROM S\nWHERE dept= 'CS'\n  UNION\nSELECT *\n   FROM S\nWHERE age<=19\n//等于\nSELECT DISTINCT  *\n   FROM S\nWHERE dept= 'CS'  OR  age<=19；\n\n```\nUNION：将多个查询结果合并起来时，系统自动去掉重复元组。  `or`\nUNION ALL：将多个查询结果合并起来时，保留重复元组\nINTERSECT：求两个结果的交集 `and`\nEXCEPT:差集\n\n### SQL数据更新 \nSQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。\n\n#### 插入数据记录\n```\n//插入单行记录\nINSERT INTO <表名>[(<列名1>[,<列名2>…])] VALUES(<值>)\n//插入多行记录\nINSERT INTO <表名> [(<列名1>[,<列名2>…])] 子查询\n```\n\n#### 修改数据记录\n```\n//UPDATE <表名> SET <列名>=<表达式> [,<列名>=<表达式>] … [WHERE <条件>]\n//利用子查询提供要修改的值\nUPDATE T\nSET SAL =\n(SELECT 1.2*AVG(SAL) \nFROM T)\n```\n当需要多行修改多行时，\n```\n//多行修改多行\nUPDATE <表1> a\ninner join <表2> b ON <两表的关系>\nSET a.<列名>=b.<列名>\nWHERE\n<条件>\n\n//记得提交！\nCOMMIT;\n\n```\n\n#### 删除数据记录\n```\nDELETE \n    FROM <表名>\n[WHERE <条件>]\n//利用子查询选择要删除的行\nDELETE\n    FROM TC \n WHERE TNO=  \n(SELECT TNO\n    FROM T\n WHERE TN=’ 刘伟’)\n```\n### 正则匹配\n\nMYSQL可以使用正则表达式进行匹配。使用的运算符是 REGEXP。\n\n|模式 |模式匹配对象\n|-------|----------|\n|^  |字符串的开始位置|\n|$  |字符串的结尾|\n|.  |单个字符|\n|[...]  |一对方括号之间的字符|\n|[^...] |未在一对方括号之间的字符|\n|p1丨p2丨p3|  交替匹配模式1、模式2或模式3|\n|*  |匹配前面元素的零个或多个实例|\n|+  |匹配前面元素的一个或多个实例|\n|{n}  |匹配前面元素的n个实例|\n|{m,n}  |匹配前面元素的m~n个实例，m <= n|\n\n### 大小写敏感\n\n要想让搜索对大小写敏感，可以如下例一般，使用 BINARY 关键字。\n```\nSELECT p_Name name FROM persons WHERE p_Name REGEXP BINARY 'j';\n```","source":"_posts/mysql/SQL语言的数据查询.md","raw":"---\ntitle: SQL语言的数据查询\ndate: 2016-10-27 21:22:50\ntags: \n- 数据库\ncategories: 总结\n---\n此篇为上一篇的姊妹篇，感觉一不小心记的又臭又长了，不过内容确实不是一篇文章能说的清的。\n\n<!--more-->\n\nSELECT语句的一般格式为:\n```\n//格式一\nSELECT〈列名〉[{，〈列名〉}]\nFROM〈表名或视图名〉[{，〈表名或视图名〉}]\n[WHERE〈检索条件〉]\n[GROUP BY <列名1>[HAVING <条件表达式>]]\n[ORDER BY <列名2>[ASC|DESC]];\n//格式二\nSELECT  [ALL|DISTINCT][TOP N [PERCENT][WITH TIES]]\n   列名1 [AS 别名1]\n[, 列名2 [ AS 别名2]…]\n[INTO 新表名]\nFROM 表名 1[[AS] 表1别名]\n[INNER|RIGHT|FULL|OUTER][OUTER]JOIN\n    表名2 [[AS] 表2别名]\nON 条件\n```\n查询结束时仍然是一个表。\n\nSELECT语句的执行过程是:\n根据WHERE子句的检索条件，从FROM子句指定的基本表或视图中选取满足条件的元组，再按照SELECT子句中指定的列，投影得到结果表。\n如果有GROUP子句，则将查询结果按照<列名1>相同的值进行分组。\n如果GROUP子句后有HAVING短语，则只输出满足HAVING条件的元组。\n如果有ORDER子句，查询结果还要按照<列名2>的值进行排序。\n\n### 投影查询\n在查询中不使用WHERE子句的无条件查询，也称投影查询。\n```\n//查询选修了课程的学生号\nSELECT DISTINCT SNO FROM SC\n```\n利用投影查询可控制列名的顺序，并可通过指定别名改变查询结果的列标题的名字。\n```\n//查询全体学生的姓名、学号和年龄。\nSELECT SNAME NAME, SNO, AGE FROM S\n```\n其中，NAME为SNAME的别名。\n### 条件查询\n当要在表中找出满足某些条件的行时，则需使用WHERE子句指定查询条件。\n\nWHERE子句中，条件通常通过三部分来描述：\n1.列名；\n2.比较运算符；\n3.列名、常数。\n\n比较运算符，除了常规的大于小于等于之外，还有下列这些常用的比较运算符：\n\n不等于(<>)；多重条件(and,or);BETWEEN AND(确定范围)；IN(确定集合)；LIKE(字符匹配)；IS NULL（空值）\n#### 1.比较大小\n```\nSELECT SNO,CNO,SCORE FROM SC WHERE SCORE>85\n```\n#### 2.多重条件查询\n当WHERE子句需要指定一个以上的查询条件时，则需要使用逻辑运算符AND、OR和NOT将其连结成复合的逻辑表达式。\n其优先级由高到低为：NOT、AND、OR，用户可以使用括号改变优先级。\n```\n//查询选修C1或C2且分数大于等于85分学生的的学号、课程号和成绩。\nSELECT SNO，CNO，SCORE\n   FROM SC\nWHERE（CNO=’C1’ OR CNO=’C2’） AND\n SCORE>=85 \n```\n#### 3.确定范围\n```\n//查询工资在1000至1500之间的教师的教师号、姓名及职称。\nSELECT TNO,TN,PROF\n   FROM T\nWHERE SAL BETWEEN 1000 AND 1500\n//等价于\nSELECT TNO,TN,PROF\n   FROM T\nWHERE SAL>=1000 AND SAL<=1500\n```\n#### 4.确定集合\n利用“IN”操作可以查询属性值属于指定集合的元组。\n\n```\n//查询选修C1或C2的学生的学号、课程号和成绩。\nSELECT SNO, CNO, SCORE \n   FROM SC \nWHERE CNO IN(‘C1’, ‘C2’)\n//此语句也可以使用逻辑运算符“OR”实现。\n//利用“NOT IN”可以查询指定集合外的元组。\n```\n#### 5.部分匹配查询\n上例均属于完全匹配查询，当不知道完全精确的値时，用户还可以使用LIKE或NOT LIKE进行部分匹配查询（也称模糊查询）。\nLIKE定义的一般格式为：\n```\n<属性名> LIKE <字符串常量>\n```\n属性名必须为字符型，字符串常量的字符可以包含如下两个特殊符号：\n%：表示任意知长度的字符串；\n\n_：表示任意单个字符;\n\n\\[charlist]:字符列中的任何单一字符;\n\n\\[^charlist]或者[!charlist]:不在字符列中的任何单一字符。\n```\n//查询所有姓张但不包含国或辽的教师的教师号和姓名。\nselect  * \n from S\nwhere sname like '张[^国辽]_'\n```\n#### 6.空值查询\n某个字段没有值称之为具有空值（NULL）。空值不同于零和空格，它不占任何存储空间。\n\n例如，某些学生选课后没有参加考试，有选课记录，但没有考试成绩，考试成绩为空值，这与参加考试，成绩为零分的不同。\n```\nSELECT SNO, CNO\n   FROM SC\nWHERE SCORE IS NULL\n```\n### 常用库函数及统计汇总查询\n|函数名称|功能\n|------|------|\n|AVG|按列计算平均值|\n|SUM|按列计算值的总和|\n|MAX|求一列中的最大值|\n|MIN|求一列中的最小值|\n|COUNT|按列值计个数|\n\n```\n//求学号为S1学生的总分和平均分。\nSELECT SUM(SCORE) AS TotalScore, AVG(SCORE) AS AveScore\n   FROM SC\nWHERE (SNO = 'S1') \n\n//求学校中共有多少个系\nSELECT COUNT(DISTINCT DEPT) AS DeptNum \n   FROM S\n```\n注意：\n函数SUM和AVG只能对数值型字段进行计算。\n\nCOUNT函数对空值不计算，但对零进行计算。\n### 分组查询\n`GROUP BY`子句可以将查询结果按属性列或属性列组合在行的方向上进行分组，每组在属性列或属性列组合上具有相同的值。\n```\n查询各位教师的教师号及其任课的门数。\nSELECT TNO,COUNT(*) AS C_NUM\n  FROM TC\nGROUP BY TNO \n```\n若在分组后还要按照一定的条件进行筛选，则需使用HAVING子句。\n```\nSELECT SNO,COUNT(*) AS SC_NUM \n  FROM SC\nGROUP BY SNO       \nHAVING COUNT(*)>=2 \n\n```\n当在一个SQL查询中同时使用WHERE子句，`GROUP  BY `子句和`HAVING`子句时，其顺序是`WHERE－GROUP  BY－ HAVING`。\n\n**`WHERE`与`HAVING`子句的根本区别在于作用对象不同。**\n\nWHERE子句作用于基本表或视图，从中选择满足条件的元组；\nHAVING子句作用于组，选择满足条件的组，必须用于GROUP BY子句之后，但GROUP BY子句可没有HAVING子句。\n\n### 查询排序\n当需要对查询结果排序时，应该使用ORDER BY子句\nORDER BY子句必须出现在其他子句之后\n排序方式可以指定，DESC为降序，ASC为升序，缺省时为升序\n```\n//查询选修C2、C3、C4或C5课程的学号、课程号和成绩，查询结果按学号升序排列，学号相同再按成绩降序排列。\nSELECT SNO,CNO, SCORE \n   FROM SC\nWHERE CNO IN ('C2' ,'C3', 'C4','C5')\n   ORDER BY SNO,SCORE DESC \n//求选课在三门以上且各门课程均及格的学生的学号及其总    成绩，查询结果按总成绩降序列出。\n\nSELECT SNO,SUM(SCORE)AS TotalScore\nFROM SC\nWHERE SCORE>=60\nGROUP BY SNO\nHAVING COUNT(*)>=3\nORDER BY SUM(SCORE) DESC\n```\n上述执行过程如下：取出SC，筛选SCORE>=60 的元组，讲选出的元组按照SNO分组，筛选选课三门以上的分组，一剩下的组中提取学号和总成绩，将选取结果排序。\n\n另外，`ORDER BY SUM(SCORE) DESC`可以改写成\n`ORDER BY 2 DESC`,2 代表查询结果的第二列。 \n\n### INTO 子句\n在默认子段组中创建一个新表并将来自查询的结果行插入新表中。\n```\nSELECT *\n     INTO new_Table\n   FROM S\nWHERE Sex = ‘男’\n\n```\n### COMPUTE子句\n生成合计作为附加的汇总列出现在结果集的最后。\n```\nSELECT s.s#,sname,age,sex,c#,grade \n   FROM s,sc\nWHERE s.s#=sc.s# and\n               s.s#='200203080101'\nCOMPUTE sum(sc.grade),count(s.s#)\n```\n### 数据表连接及连接查询\n数据表之间的联系是通过表的字段值来体现的，这种字段称为连接字段。\n连接操作的目的就是通过加在连接字段的条件将多个表连接起来，以便从多个表中查询数据。\n前面的查询都是针对一个表进行的，当查询同时涉及两个以上的表时，称为连接查询。\n\n表的连接方法有两种：\n1.表之间满足一定的条件的行进行连接，此时FROM子句中指明进行连接的表名，`WHERE`子句指明连接的列名及其连接条件。\n2.利用关键字`JOIN`进行连接。\n\n具体分为下列几种：\n1.INNER JOIN：现在符合条件的记录，此为默认值。\n2.LEFT （OUTER） JOIN：显示符合条件的数据行以及左边表中不符合条件的数据行，此时右边数据行会以NULL来显示，此称为左连接。\n3.RIGHT （OUTER） JOIN：显示符合条件的数据行以及右边表中不符合条件的数据行，此时左边数据行会以NULL来显示，此称为右连接。\n4.FULL （OUTER） JOIN：显示符合条件的数据行以及左边表和右边表中不符合条件的数据行，此时缺乏数据的数据行会以NULL来显示。\n5.CROSS JOIN：会将一个表的每一笔数据和另一表的每笔数据匹配成新的数据行。\n\n当将`JOIN`关键词放于FROM子句中时，应有关键词`ON`与之相对应，以表明连接的条件。\n\n#### 等值连接与非等值连接\n查询刘伟老师所讲授的课程。\n\n方法1：\n```\nSELECT T.TNO ,TN,CNO\n   FROM T,TC\nWHERE (T.TNO = TC. TNO) AND (TN = ‘刘伟’)\n\n```\n上面的操作是将T表中的TNO 和TC表中的TNO相等的行连接，同时选取TN为“刘伟“的行，然后再在TN，CNO列上投影，这是连接、选取和投影的操作组合。\n\n这里，TN=‘刘伟’为查询条件，而T.TNO = TC.TNO 为连接条件，TNO为连接字段。连接条件的一般格式为：\n```\n[<表名1>.] <列名1> <比较运算符> [<表名2>.] <列名2> \n```\n其中,比较运算符主要有：＝、＞、＜、＞＝、＜＝、！＝。\n当比较运算符为“＝“时，称为等值连接，其他情况为非等值连接。\n\n当列名是唯一的，不需要加表名前缀。\n\n方法2：\n```\nSELECT T.TNO,TN,CNO\n   FROM T INNER JOIN TC \n    ON T.TNO=TC.TNO AND T.TN='刘伟'\n\n```\n方法3：\n```\nSELECT R2.TNO,R2.TN, R1.CNO \n   FROM\n      (SELECT TNO,CNO \n          FROM TC ) AS R1\n       INNER JOIN \n       (SELECT TNO ,TN \n            FROM T\n         WHERE TN='刘伟') AS R2\n        ON R1.TNO=R2.TNO\n\n```\n#### 自身连接\n\n查询所有比刘伟工资高的教师姓名、性别、工资和刘伟的工资。\n\n要查询的内容均在同一表T中，可以将表T分别取两个别名，一个是X，一个是Y。将X, Y 中满足比刘伟工资高的行连接起来。这实际上是同一表T的自身连接。\n方法1：\n```\nSELECT X.TN,X.SAL AS SAL_a, Y.SAL AS SAL_b \n   FROM T AS X ,T AS Y \nWHERE X.SAL>Y.SAL AND \n    Y.TN='刘伟'\n\n```\n方法2：\n```\nSELECT X.TN, X.SAL,Y.SAL \n   FROM T AS X INNER JOIN T AS Y\n      ON X.SAL>Y.SAL AND Y.TN='刘伟'\n```\n方法3：\n```\nSELECT R1.TN,R1.SAL, R2.SAL \n   FROM \n    (SELECT TN,SAL \n         FROM T ) AS R1\n    INNER JOIN \n    (SELECT SAL \n         FROM T\n      WHERE TN='刘伟') AS R2\n     ON R1.SAL>R2.SAL\n\n```\n#### 外连接\n在上面的连接操作中，不满足连接条件的元组不能作为查询结果输出。\n```\n//查询所有学生的学号、姓名、选课名称及成绩。（没有选课的同学的选课信息显示为空）则应写成如下的SQL语句。\nSELECT S.SNO,SN,CN,SCORE\n   FROM S\n       LEFT OUTER JOIN SC\n       ON S.SNO=SC.SNO\n       LEFT OUTER JOIN C\n       ON C.CNO=SC.CNO\n```\n则查询结果只包括所有的学生，没有选课的同学的选课信息显示为空。\n\n### 子查询\n在WHERE子句中包含一个形如SELECT-FROM-WHERE的查询块，此查询块称为子查询或嵌套查询，包含子查询的语句称为父查询或外部查询。\n\n子查询的嵌套层次最多可达到255层，以层层嵌套的方式构造查询充分体现了SQL“结构化”的特点。\n\n嵌套查询在执行时由里向外处理，每个子查询是在上一级外部查询处理之前完成，父查询要用到子查询的结果。\n\n#### 返回一组值的子查询\n如果子查询的返回值不止一个，而是一个集合时，则不能直接使用比较运算符，可以在比较运算符和子查询之间插入ANY或ALL。\n```\n//查询讲授课程号为C5的教师姓名。\nSELECT TN\n   FROM T\nWHERE TNO=ANY\n      (SELECT TNO \n          FROM TC\n       WHERE CNO='C5')\n//该例也可以使用前面所讲的连接操作来实现：\nSELECT TN\n   FROM T,TC\nWHERE T.TNO=TC.TNO AND\n               TC.CNO='C5‘\n\n```\n可见，对于同一查询可使用子查询和连接两种方法来解决，可根据习惯任意选用。 \n\n另外，还可以使用IN代替“=ANY”。\n```\nSELECT TN\n   FROM T\nWHERE TNO IN\n    (SELECT TNO \n        FROM TC\n     WHERE CNO='C5')\n```\n\n```\nSELECT DISTINCT TN\n   FROM T\nWHERE 'C5' !=ALL\n     ( SELECT CNO \n           FROM TC\n        WHERE TNO=T.TNO)\n```\n`!=ALL`的含义为不等于子查询结果中的任何一个值，也可使用`NOT IN`代替`!=ALL`。\n\n前面所讲的子查询均为普通子查询，而本例中子查询的查询条件引用了父查询表中的属性值（T表的TNO值），我们把这类查询称为相关子查询。\n\n二者的执行方式不同，相关子查询并不是先执行子查询，而是首先选取父查询表的第一行记录，内部的子查询利用此行中相关的属性值进行查询。\n然后父查询根据子查询返回的结果判断此行是否满足查询条件。如果满足条件，则把该行放入父查询的查询结果集合中。重复执行这一过程，直到处理完父查询表中的每一行数据。\n\n如上行所述，表T中每一行都要执行一次子查询。\n因此，相关子查询的执行次数是由父查询表的行数决定的。\n\n除了之前说的ALL,ANY,IN之外，还可以使用EXISTS来表示存在与否。带有EXISTS的子查询不返回任何实际数据，它只得到逻辑值“真”或“假”。\n\n```\n查询讲授课程号为C5的教师姓名。\nSELECT TN\n   FROM T\nWHERE EXISTS\n    (SELECT * \n        FROM TC\n     WHERE TNO=T.TNO\n    AND CNO='C5')\n```\n当子查询TC表存在一行记录满足其WHERE子句中的条件时，则父查询便得到一个TN值，重复执行以上过程，直到得出最后结果。\n\n### 集合查询\n集合操作分为并操作UNION,交操作INTERSECT,差操作EXCEPT。\n\n参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同。\n```\nSELECT *\n   FROM S\nWHERE dept= 'CS'\n  UNION\nSELECT *\n   FROM S\nWHERE age<=19\n//等于\nSELECT DISTINCT  *\n   FROM S\nWHERE dept= 'CS'  OR  age<=19；\n\n```\nUNION：将多个查询结果合并起来时，系统自动去掉重复元组。  `or`\nUNION ALL：将多个查询结果合并起来时，保留重复元组\nINTERSECT：求两个结果的交集 `and`\nEXCEPT:差集\n\n### SQL数据更新 \nSQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。\n\n#### 插入数据记录\n```\n//插入单行记录\nINSERT INTO <表名>[(<列名1>[,<列名2>…])] VALUES(<值>)\n//插入多行记录\nINSERT INTO <表名> [(<列名1>[,<列名2>…])] 子查询\n```\n\n#### 修改数据记录\n```\n//UPDATE <表名> SET <列名>=<表达式> [,<列名>=<表达式>] … [WHERE <条件>]\n//利用子查询提供要修改的值\nUPDATE T\nSET SAL =\n(SELECT 1.2*AVG(SAL) \nFROM T)\n```\n当需要多行修改多行时，\n```\n//多行修改多行\nUPDATE <表1> a\ninner join <表2> b ON <两表的关系>\nSET a.<列名>=b.<列名>\nWHERE\n<条件>\n\n//记得提交！\nCOMMIT;\n\n```\n\n#### 删除数据记录\n```\nDELETE \n    FROM <表名>\n[WHERE <条件>]\n//利用子查询选择要删除的行\nDELETE\n    FROM TC \n WHERE TNO=  \n(SELECT TNO\n    FROM T\n WHERE TN=’ 刘伟’)\n```\n### 正则匹配\n\nMYSQL可以使用正则表达式进行匹配。使用的运算符是 REGEXP。\n\n|模式 |模式匹配对象\n|-------|----------|\n|^  |字符串的开始位置|\n|$  |字符串的结尾|\n|.  |单个字符|\n|[...]  |一对方括号之间的字符|\n|[^...] |未在一对方括号之间的字符|\n|p1丨p2丨p3|  交替匹配模式1、模式2或模式3|\n|*  |匹配前面元素的零个或多个实例|\n|+  |匹配前面元素的一个或多个实例|\n|{n}  |匹配前面元素的n个实例|\n|{m,n}  |匹配前面元素的m~n个实例，m <= n|\n\n### 大小写敏感\n\n要想让搜索对大小写敏感，可以如下例一般，使用 BINARY 关键字。\n```\nSELECT p_Name name FROM persons WHERE p_Name REGEXP BINARY 'j';\n```","slug":"mysql/SQL语言的数据查询","published":1,"updated":"2019-03-22T14:44:36.722Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0d009b4l3ncn38ym5y","content":"<p>此篇为上一篇的姊妹篇，感觉一不小心记的又臭又长了，不过内容确实不是一篇文章能说的清的。</p>\n<a id=\"more\"></a>\n<p>SELECT语句的一般格式为:<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//格式一</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span>〈列名〉[&#123;，〈列名〉&#125;]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>〈表名或视图名〉[&#123;，〈表名或视图名〉&#125;]</span><br><span class=\"line\">[<span class=\"keyword\">WHERE</span>〈检索条件〉]</span><br><span class=\"line\">[<span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> &lt;列名<span class=\"number\">1</span>&gt;[<span class=\"keyword\">HAVING</span> &lt;条件表达式&gt;]]</span><br><span class=\"line\">[<span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> &lt;列名<span class=\"number\">2</span>&gt;[<span class=\"keyword\">ASC</span>|<span class=\"keyword\">DESC</span>]];</span><br><span class=\"line\">//格式二</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span>  [<span class=\"keyword\">ALL</span>|<span class=\"keyword\">DISTINCT</span>][TOP N [<span class=\"keyword\">PERCENT</span>][<span class=\"keyword\">WITH</span> <span class=\"keyword\">TIES</span>]]</span><br><span class=\"line\">   列名<span class=\"number\">1</span> [<span class=\"keyword\">AS</span> 别名<span class=\"number\">1</span>]</span><br><span class=\"line\">[, 列名<span class=\"number\">2</span> [ <span class=\"keyword\">AS</span> 别名<span class=\"number\">2</span>]…]</span><br><span class=\"line\">[<span class=\"keyword\">INTO</span> 新表名]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> 表名 <span class=\"number\">1</span>[[<span class=\"keyword\">AS</span>] 表<span class=\"number\">1</span>别名]</span><br><span class=\"line\">[<span class=\"keyword\">INNER</span>|<span class=\"keyword\">RIGHT</span>|<span class=\"keyword\">FULL</span>|<span class=\"keyword\">OUTER</span>][<span class=\"keyword\">OUTER</span>]<span class=\"keyword\">JOIN</span></span><br><span class=\"line\">    表名<span class=\"number\">2</span> [[<span class=\"keyword\">AS</span>] 表<span class=\"number\">2</span>别名]</span><br><span class=\"line\"><span class=\"keyword\">ON</span> 条件</span><br></pre></td></tr></table></figure></p>\n<p>查询结束时仍然是一个表。</p>\n<p>SELECT语句的执行过程是:<br>根据WHERE子句的检索条件，从FROM子句指定的基本表或视图中选取满足条件的元组，再按照SELECT子句中指定的列，投影得到结果表。<br>如果有GROUP子句，则将查询结果按照&lt;列名1&gt;相同的值进行分组。<br>如果GROUP子句后有HAVING短语，则只输出满足HAVING条件的元组。<br>如果有ORDER子句，查询结果还要按照&lt;列名2&gt;的值进行排序。</p>\n<h3 id=\"投影查询\"><a href=\"#投影查询\" class=\"headerlink\" title=\"投影查询\"></a>投影查询</h3><p>在查询中不使用WHERE子句的无条件查询，也称投影查询。<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询选修了课程的学生号</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> SNO <span class=\"keyword\">FROM</span> SC</span><br></pre></td></tr></table></figure></p>\n<p>利用投影查询可控制列名的顺序，并可通过指定别名改变查询结果的列标题的名字。<br><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询全体学生的姓名、学号和年龄。</span></span><br><span class=\"line\"><span class=\"built_in\">SELECT</span> SNAME <span class=\"built_in\">NAME</span>, SNO, AGE <span class=\"keyword\">FROM</span> S</span><br></pre></td></tr></table></figure></p>\n<p>其中，NAME为SNAME的别名。</p>\n<h3 id=\"条件查询\"><a href=\"#条件查询\" class=\"headerlink\" title=\"条件查询\"></a>条件查询</h3><p>当要在表中找出满足某些条件的行时，则需使用WHERE子句指定查询条件。</p>\n<p>WHERE子句中，条件通常通过三部分来描述：<br>1.列名；<br>2.比较运算符；<br>3.列名、常数。</p>\n<p>比较运算符，除了常规的大于小于等于之外，还有下列这些常用的比较运算符：</p>\n<p>不等于(&lt;&gt;)；多重条件(and,or);BETWEEN AND(确定范围)；IN(确定集合)；LIKE(字符匹配)；IS NULL（空值）</p>\n<h4 id=\"1-比较大小\"><a href=\"#1-比较大小\" class=\"headerlink\" title=\"1.比较大小\"></a>1.比较大小</h4><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">SELECT</span> SNO,CNO,<span class=\"built_in\">SCORE</span> <span class=\"keyword\">FROM</span> SC WHERE <span class=\"built_in\">SCORE</span>&gt;<span class=\"number\">85</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-多重条件查询\"><a href=\"#2-多重条件查询\" class=\"headerlink\" title=\"2.多重条件查询\"></a>2.多重条件查询</h4><p>当WHERE子句需要指定一个以上的查询条件时，则需要使用逻辑运算符AND、OR和NOT将其连结成复合的逻辑表达式。<br>其优先级由高到低为：NOT、AND、OR，用户可以使用括号改变优先级。<br><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询选修C1或C2且分数大于等于85分学生的的学号、课程号和成绩。</span></span><br><span class=\"line\"><span class=\"built_in\">SELECT</span> SNO，CNO，<span class=\"built_in\">SCORE</span></span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> SC</span><br><span class=\"line\">WHERE（CNO=’C1’ <span class=\"built_in\">OR</span> CNO=’C2’） <span class=\"built_in\">AND</span></span><br><span class=\"line\"> <span class=\"built_in\">SCORE</span>&gt;=<span class=\"number\">85</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-确定范围\"><a href=\"#3-确定范围\" class=\"headerlink\" title=\"3.确定范围\"></a>3.确定范围</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询工资在1000至1500之间的教师的教师号、姓名及职称。</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TNO,TN,PROF</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> SAL BETWEEN <span class=\"number\">1000</span> <span class=\"keyword\">AND</span> <span class=\"number\">1500</span></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TNO,TN,PROF</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> SAL&gt;=<span class=\"number\">1000</span> <span class=\"keyword\">AND</span> SAL&lt;=<span class=\"number\">1500</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-确定集合\"><a href=\"#4-确定集合\" class=\"headerlink\" title=\"4.确定集合\"></a>4.确定集合</h4><p>利用“IN”操作可以查询属性值属于指定集合的元组。</p>\n<figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//查询选修C1或C2的学生的学号、课程号和成绩。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SNO, CNO, SCORE </span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> SC </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> CNO <span class=\"keyword\">IN</span>(‘C1’, ‘C2’)</span><br><span class=\"line\">//此语句也可以使用逻辑运算符“<span class=\"keyword\">OR</span>”实现。</span><br><span class=\"line\">//利用“<span class=\"keyword\">NOT</span> <span class=\"keyword\">IN</span>”可以查询指定集合外的元组。</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-部分匹配查询\"><a href=\"#5-部分匹配查询\" class=\"headerlink\" title=\"5.部分匹配查询\"></a>5.部分匹配查询</h4><p>上例均属于完全匹配查询，当不知道完全精确的値时，用户还可以使用LIKE或NOT LIKE进行部分匹配查询（也称模糊查询）。<br>LIKE定义的一般格式为：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">属性名</span>&gt;</span> LIKE <span class=\"tag\">&lt;<span class=\"name\">字符串常量</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>属性名必须为字符型，字符串常量的字符可以包含如下两个特殊符号：<br>%：表示任意知长度的字符串；</p>\n<p>_：表示任意单个字符;</p>\n<p>[charlist]:字符列中的任何单一字符;</p>\n<p>[^charlist]或者[!charlist]:不在字符列中的任何单一字符。<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询所有姓张但不包含国或辽的教师的教师号和姓名。</span></span><br><span class=\"line\"><span class=\"keyword\">select</span>  * </span><br><span class=\"line\"> <span class=\"keyword\">from</span> S</span><br><span class=\"line\"><span class=\"keyword\">where</span> sname like <span class=\"string\">'张[^国辽]_'</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-空值查询\"><a href=\"#6-空值查询\" class=\"headerlink\" title=\"6.空值查询\"></a>6.空值查询</h4><p>某个字段没有值称之为具有空值（NULL）。空值不同于零和空格，它不占任何存储空间。</p>\n<p>例如，某些学生选课后没有参加考试，有选课记录，但没有考试成绩，考试成绩为空值，这与参加考试，成绩为零分的不同。<br><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> SNO, CNO</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> SC</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> SCORE <span class=\"keyword\">IS</span> <span class=\"literal\">NULL</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"常用库函数及统计汇总查询\"><a href=\"#常用库函数及统计汇总查询\" class=\"headerlink\" title=\"常用库函数及统计汇总查询\"></a>常用库函数及统计汇总查询</h3><table>\n<thead>\n<tr>\n<th>函数名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AVG</td>\n<td>按列计算平均值</td>\n</tr>\n<tr>\n<td>SUM</td>\n<td>按列计算值的总和</td>\n</tr>\n<tr>\n<td>MAX</td>\n<td>求一列中的最大值</td>\n</tr>\n<tr>\n<td>MIN</td>\n<td>求一列中的最小值</td>\n</tr>\n<tr>\n<td>COUNT</td>\n<td>按列值计个数</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//求学号为S1学生的总分和平均分。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">SUM</span>(SCORE) <span class=\"keyword\">AS</span> TotalScore, <span class=\"keyword\">AVG</span>(SCORE) <span class=\"keyword\">AS</span> AveScore</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> SC</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> (SNO = <span class=\"string\">'S1'</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">//求学校中共有多少个系</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> DEPT) <span class=\"keyword\">AS</span> DeptNum </span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br></pre></td></tr></table></figure>\n<p>注意：<br>函数SUM和AVG只能对数值型字段进行计算。</p>\n<p>COUNT函数对空值不计算，但对零进行计算。</p>\n<h3 id=\"分组查询\"><a href=\"#分组查询\" class=\"headerlink\" title=\"分组查询\"></a>分组查询</h3><p><code>GROUP BY</code>子句可以将查询结果按属性列或属性列组合在行的方向上进行分组，每组在属性列或属性列组合上具有相同的值。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询各位教师的教师号及其任课的门数。</span><br><span class=\"line\">SELECT TNO,COUNT(*) AS C_NUM</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">GROUP BY TNO</span><br></pre></td></tr></table></figure></p>\n<p>若在分组后还要按照一定的条件进行筛选，则需使用HAVING子句。<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> SNO,COUNT<span class=\"comment\">(*) AS SC_NUM </span></span><br><span class=\"line\"><span class=\"comment\">  FROM SC</span></span><br><span class=\"line\"><span class=\"comment\">GROUP BY SNO       </span></span><br><span class=\"line\"><span class=\"comment\">HAVING COUNT(*)</span>&gt;=<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>当在一个SQL查询中同时使用WHERE子句，<code>GROUP  BY</code>子句和<code>HAVING</code>子句时，其顺序是<code>WHERE－GROUP  BY－ HAVING</code>。</p>\n<p><strong><code>WHERE</code>与<code>HAVING</code>子句的根本区别在于作用对象不同。</strong></p>\n<p>WHERE子句作用于基本表或视图，从中选择满足条件的元组；<br>HAVING子句作用于组，选择满足条件的组，必须用于GROUP BY子句之后，但GROUP BY子句可没有HAVING子句。</p>\n<h3 id=\"查询排序\"><a href=\"#查询排序\" class=\"headerlink\" title=\"查询排序\"></a>查询排序</h3><p>当需要对查询结果排序时，应该使用ORDER BY子句<br>ORDER BY子句必须出现在其他子句之后<br>排序方式可以指定，DESC为降序，ASC为升序，缺省时为升序<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//查询选修C2、C3、C4或C5课程的学号、课程号和成绩，查询结果按学号升序排列，学号相同再按成绩降序排列。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SNO,CNO, SCORE </span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> SC</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> CNO <span class=\"keyword\">IN</span> (<span class=\"string\">'C2'</span> ,<span class=\"string\">'C3'</span>, <span class=\"string\">'C4'</span>,<span class=\"string\">'C5'</span>)</span><br><span class=\"line\">   <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> SNO,SCORE <span class=\"keyword\">DESC</span> </span><br><span class=\"line\">//求选课在三门以上且各门课程均及格的学生的学号及其总    成绩，查询结果按总成绩降序列出。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SNO,<span class=\"keyword\">SUM</span>(SCORE)<span class=\"keyword\">AS</span> TotalScore</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> SC</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> SCORE&gt;=<span class=\"number\">60</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> SNO</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> <span class=\"keyword\">COUNT</span>(*)&gt;=<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">SUM</span>(SCORE) <span class=\"keyword\">DESC</span></span><br></pre></td></tr></table></figure></p>\n<p>上述执行过程如下：取出SC，筛选SCORE&gt;=60 的元组，讲选出的元组按照SNO分组，筛选选课三门以上的分组，一剩下的组中提取学号和总成绩，将选取结果排序。</p>\n<p>另外，<code>ORDER BY SUM(SCORE) DESC</code>可以改写成<br><code>ORDER BY 2 DESC</code>,2 代表查询结果的第二列。 </p>\n<h3 id=\"INTO-子句\"><a href=\"#INTO-子句\" class=\"headerlink\" title=\"INTO 子句\"></a>INTO 子句</h3><p>在默认子段组中创建一个新表并将来自查询的结果行插入新表中。<br><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> *</span><br><span class=\"line\">     <span class=\"keyword\">INTO</span> new_Table</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> Sex = ‘男’</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"COMPUTE子句\"><a href=\"#COMPUTE子句\" class=\"headerlink\" title=\"COMPUTE子句\"></a>COMPUTE子句</h3><p>生成合计作为附加的汇总列出现在结果集的最后。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> s.s<span class=\"comment\">#,sname,age,sex,c#,grade </span></span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> s,sc</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> s.s<span class=\"comment\">#=sc.s# and</span></span><br><span class=\"line\">               s.s<span class=\"comment\">#='200203080101'</span></span><br><span class=\"line\"><span class=\"keyword\">COMPUTE</span> <span class=\"keyword\">sum</span>(sc.grade),<span class=\"keyword\">count</span>(s.s<span class=\"comment\">#)</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数据表连接及连接查询\"><a href=\"#数据表连接及连接查询\" class=\"headerlink\" title=\"数据表连接及连接查询\"></a>数据表连接及连接查询</h3><p>数据表之间的联系是通过表的字段值来体现的，这种字段称为连接字段。<br>连接操作的目的就是通过加在连接字段的条件将多个表连接起来，以便从多个表中查询数据。<br>前面的查询都是针对一个表进行的，当查询同时涉及两个以上的表时，称为连接查询。</p>\n<p>表的连接方法有两种：<br>1.表之间满足一定的条件的行进行连接，此时FROM子句中指明进行连接的表名，<code>WHERE</code>子句指明连接的列名及其连接条件。<br>2.利用关键字<code>JOIN</code>进行连接。</p>\n<p>具体分为下列几种：<br>1.INNER JOIN：现在符合条件的记录，此为默认值。<br>2.LEFT （OUTER） JOIN：显示符合条件的数据行以及左边表中不符合条件的数据行，此时右边数据行会以NULL来显示，此称为左连接。<br>3.RIGHT （OUTER） JOIN：显示符合条件的数据行以及右边表中不符合条件的数据行，此时左边数据行会以NULL来显示，此称为右连接。<br>4.FULL （OUTER） JOIN：显示符合条件的数据行以及左边表和右边表中不符合条件的数据行，此时缺乏数据的数据行会以NULL来显示。<br>5.CROSS JOIN：会将一个表的每一笔数据和另一表的每笔数据匹配成新的数据行。</p>\n<p>当将<code>JOIN</code>关键词放于FROM子句中时，应有关键词<code>ON</code>与之相对应，以表明连接的条件。</p>\n<h4 id=\"等值连接与非等值连接\"><a href=\"#等值连接与非等值连接\" class=\"headerlink\" title=\"等值连接与非等值连接\"></a>等值连接与非等值连接</h4><p>查询刘伟老师所讲授的课程。</p>\n<p>方法1：<br><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">SELECT</span> T.TNO ,TN,CNO</span><br><span class=\"line\">   FROM T,TC</span><br><span class=\"line\"><span class=\"built_in\">WHERE</span> (T.TNO = TC. TNO) <span class=\"keyword\">AND</span> (TN = ‘刘伟’)</span><br></pre></td></tr></table></figure></p>\n<p>上面的操作是将T表中的TNO 和TC表中的TNO相等的行连接，同时选取TN为“刘伟“的行，然后再在TN，CNO列上投影，这是连接、选取和投影的操作组合。</p>\n<p>这里，TN=‘刘伟’为查询条件，而T.TNO = TC.TNO 为连接条件，TNO为连接字段。连接条件的一般格式为：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"tag\">&lt;<span class=\"name\">表名1</span>&gt;</span>.] <span class=\"tag\">&lt;<span class=\"name\">列名1</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">比较运算符</span>&gt;</span> [<span class=\"tag\">&lt;<span class=\"name\">表名2</span>&gt;</span>.] <span class=\"tag\">&lt;<span class=\"name\">列名2</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>其中,比较运算符主要有：＝、＞、＜、＞＝、＜＝、！＝。<br>当比较运算符为“＝“时，称为等值连接，其他情况为非等值连接。</p>\n<p>当列名是唯一的，不需要加表名前缀。</p>\n<p>方法2：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T.TNO,TN,CNO</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> TC </span><br><span class=\"line\">    <span class=\"keyword\">ON</span> T.TNO=TC.TNO <span class=\"keyword\">AND</span> T.TN=<span class=\"string\">'刘伟'</span></span><br></pre></td></tr></table></figure></p>\n<p>方法3：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> R2.TNO,R2.TN, R1.CNO </span><br><span class=\"line\">   <span class=\"keyword\">FROM</span></span><br><span class=\"line\">      (<span class=\"keyword\">SELECT</span> TNO,CNO </span><br><span class=\"line\">          <span class=\"keyword\">FROM</span> TC ) <span class=\"keyword\">AS</span> R1</span><br><span class=\"line\">       <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> </span><br><span class=\"line\">       (<span class=\"keyword\">SELECT</span> TNO ,TN </span><br><span class=\"line\">            <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\">         <span class=\"keyword\">WHERE</span> TN=<span class=\"string\">'刘伟'</span>) <span class=\"keyword\">AS</span> R2</span><br><span class=\"line\">        <span class=\"keyword\">ON</span> R1.TNO=R2.TNO</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"自身连接\"><a href=\"#自身连接\" class=\"headerlink\" title=\"自身连接\"></a>自身连接</h4><p>查询所有比刘伟工资高的教师姓名、性别、工资和刘伟的工资。</p>\n<p>要查询的内容均在同一表T中，可以将表T分别取两个别名，一个是X，一个是Y。将X, Y 中满足比刘伟工资高的行连接起来。这实际上是同一表T的自身连接。<br>方法1：<br><figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">X</span>.TN,<span class=\"keyword\">X</span>.SAL AS SAL_a, <span class=\"keyword\">Y</span>.SAL AS SAL_b </span><br><span class=\"line\">   FROM T AS <span class=\"keyword\">X</span> ,T AS <span class=\"keyword\">Y</span> </span><br><span class=\"line\">WHERE <span class=\"keyword\">X</span>.SAL&gt;<span class=\"keyword\">Y</span>.SAL <span class=\"keyword\">AND</span> </span><br><span class=\"line\">    <span class=\"keyword\">Y</span>.TN=<span class=\"string\">'刘伟'</span></span><br></pre></td></tr></table></figure></p>\n<p>方法2：<br><figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">X</span>.TN, <span class=\"keyword\">X</span>.SAL,<span class=\"keyword\">Y</span>.SAL </span><br><span class=\"line\">   FROM T AS <span class=\"keyword\">X</span> INNER JOIN T AS <span class=\"keyword\">Y</span></span><br><span class=\"line\">      <span class=\"literal\">ON</span> <span class=\"keyword\">X</span>.SAL&gt;<span class=\"keyword\">Y</span>.SAL <span class=\"keyword\">AND</span> <span class=\"keyword\">Y</span>.TN=<span class=\"string\">'刘伟'</span></span><br></pre></td></tr></table></figure></p>\n<p>方法3：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> R1.TN,R1.SAL, R2.SAL </span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> </span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> TN,SAL </span><br><span class=\"line\">         <span class=\"keyword\">FROM</span> T ) <span class=\"keyword\">AS</span> R1</span><br><span class=\"line\">    <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> </span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> SAL </span><br><span class=\"line\">         <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\">      <span class=\"keyword\">WHERE</span> TN=<span class=\"string\">'刘伟'</span>) <span class=\"keyword\">AS</span> R2</span><br><span class=\"line\">     <span class=\"keyword\">ON</span> R1.SAL&gt;R2.SAL</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h4><p>在上面的连接操作中，不满足连接条件的元组不能作为查询结果输出。<br><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//查询所有学生的学号、姓名、选课名称及成绩。（没有选课的同学的选课信息显示为空）则应写成如下的SQL语句。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> S.SNO,SN,CN,SCORE</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br><span class=\"line\">       <span class=\"keyword\">LEFT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> SC</span><br><span class=\"line\">       <span class=\"keyword\">ON</span> S.SNO=SC.SNO</span><br><span class=\"line\">       <span class=\"keyword\">LEFT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> C</span><br><span class=\"line\">       <span class=\"keyword\">ON</span> C.CNO=SC.CNO</span><br></pre></td></tr></table></figure></p>\n<p>则查询结果只包括所有的学生，没有选课的同学的选课信息显示为空。</p>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><p>在WHERE子句中包含一个形如SELECT-FROM-WHERE的查询块，此查询块称为子查询或嵌套查询，包含子查询的语句称为父查询或外部查询。</p>\n<p>子查询的嵌套层次最多可达到255层，以层层嵌套的方式构造查询充分体现了SQL“结构化”的特点。</p>\n<p>嵌套查询在执行时由里向外处理，每个子查询是在上一级外部查询处理之前完成，父查询要用到子查询的结果。</p>\n<h4 id=\"返回一组值的子查询\"><a href=\"#返回一组值的子查询\" class=\"headerlink\" title=\"返回一组值的子查询\"></a>返回一组值的子查询</h4><p>如果子查询的返回值不止一个，而是一个集合时，则不能直接使用比较运算符，可以在比较运算符和子查询之间插入ANY或ALL。<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询讲授课程号为C5的教师姓名。</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TN</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> TNO=ANY</span><br><span class=\"line\">      (<span class=\"keyword\">SELECT</span> TNO </span><br><span class=\"line\">          <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">       <span class=\"keyword\">WHERE</span> CNO=<span class=\"string\">'C5'</span>)</span><br><span class=\"line\"><span class=\"comment\">//该例也可以使用前面所讲的连接操作来实现：</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TN</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T,TC</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T.TNO=TC.TNO <span class=\"keyword\">AND</span></span><br><span class=\"line\">               TC.CNO=<span class=\"string\">'C5‘</span></span><br></pre></td></tr></table></figure></p>\n<p>可见，对于同一查询可使用子查询和连接两种方法来解决，可根据习惯任意选用。 </p>\n<p>另外，还可以使用IN代替“=ANY”。<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TN</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> TNO <span class=\"keyword\">IN</span></span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> TNO </span><br><span class=\"line\">        <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">     <span class=\"keyword\">WHERE</span> CNO=<span class=\"string\">'C5'</span>)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> TN</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"string\">'C5'</span> !=<span class=\"keyword\">ALL</span></span><br><span class=\"line\">     ( <span class=\"keyword\">SELECT</span> CNO </span><br><span class=\"line\">           <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">        <span class=\"keyword\">WHERE</span> TNO=T.TNO)</span><br></pre></td></tr></table></figure>\n<p><code>!=ALL</code>的含义为不等于子查询结果中的任何一个值，也可使用<code>NOT IN</code>代替<code>!=ALL</code>。</p>\n<p>前面所讲的子查询均为普通子查询，而本例中子查询的查询条件引用了父查询表中的属性值（T表的TNO值），我们把这类查询称为相关子查询。</p>\n<p>二者的执行方式不同，相关子查询并不是先执行子查询，而是首先选取父查询表的第一行记录，内部的子查询利用此行中相关的属性值进行查询。<br>然后父查询根据子查询返回的结果判断此行是否满足查询条件。如果满足条件，则把该行放入父查询的查询结果集合中。重复执行这一过程，直到处理完父查询表中的每一行数据。</p>\n<p>如上行所述，表T中每一行都要执行一次子查询。<br>因此，相关子查询的执行次数是由父查询表的行数决定的。</p>\n<p>除了之前说的ALL,ANY,IN之外，还可以使用EXISTS来表示存在与否。带有EXISTS的子查询不返回任何实际数据，它只得到逻辑值“真”或“假”。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询讲授课程号为C5的教师姓名。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TN</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">EXISTS</span></span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> * </span><br><span class=\"line\">        <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">     <span class=\"keyword\">WHERE</span> TNO=T.TNO</span><br><span class=\"line\">    <span class=\"keyword\">AND</span> CNO=<span class=\"string\">'C5'</span>)</span><br></pre></td></tr></table></figure>\n<p>当子查询TC表存在一行记录满足其WHERE子句中的条件时，则父查询便得到一个TN值，重复执行以上过程，直到得出最后结果。</p>\n<h3 id=\"集合查询\"><a href=\"#集合查询\" class=\"headerlink\" title=\"集合查询\"></a>集合查询</h3><p>集合操作分为并操作UNION,交操作INTERSECT,差操作EXCEPT。</p>\n<p>参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同。<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> *</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> dept= <span class=\"string\">'CS'</span></span><br><span class=\"line\">  <span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> *</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> age&lt;=<span class=\"number\">19</span></span><br><span class=\"line\"><span class=\"comment\">//等于</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span>  *</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> dept= <span class=\"string\">'CS'</span>  <span class=\"keyword\">OR</span>  age&lt;=<span class=\"number\">19</span>；</span><br></pre></td></tr></table></figure></p>\n<p>UNION：将多个查询结果合并起来时，系统自动去掉重复元组。  <code>or</code><br>UNION ALL：将多个查询结果合并起来时，保留重复元组<br>INTERSECT：求两个结果的交集 <code>and</code><br>EXCEPT:差集</p>\n<h3 id=\"SQL数据更新\"><a href=\"#SQL数据更新\" class=\"headerlink\" title=\"SQL数据更新\"></a>SQL数据更新</h3><p>SQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。</p>\n<h4 id=\"插入数据记录\"><a href=\"#插入数据记录\" class=\"headerlink\" title=\"插入数据记录\"></a>插入数据记录</h4><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入单行记录</span></span><br><span class=\"line\">INSERT INTO <span class=\"params\">&lt;表名&gt;</span>[(<span class=\"params\">&lt;列名<span class=\"number\">1</span>&gt;</span>[,<span class=\"params\">&lt;列名<span class=\"number\">2</span>&gt;</span>…])] VALUES(<span class=\"params\">&lt;值&gt;</span>)</span><br><span class=\"line\"><span class=\"comment\">//插入多行记录</span></span><br><span class=\"line\">INSERT INTO <span class=\"params\">&lt;表名&gt;</span> [(<span class=\"params\">&lt;列名<span class=\"number\">1</span>&gt;</span>[,<span class=\"params\">&lt;列名<span class=\"number\">2</span>&gt;</span>…])] 子查询</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改数据记录\"><a href=\"#修改数据记录\" class=\"headerlink\" title=\"修改数据记录\"></a>修改数据记录</h4><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">UPDATE</span> &lt;表名&gt; <span class=\"keyword\">SET</span> &lt;列名&gt;=&lt;表达式&gt; [,&lt;列名&gt;=&lt;表达式&gt;] … [<span class=\"keyword\">WHERE</span> &lt;条件&gt;]</span><br><span class=\"line\">//利用子查询提供要修改的值</span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> T</span><br><span class=\"line\"><span class=\"keyword\">SET</span> SAL =</span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> <span class=\"number\">1.2</span>*<span class=\"built_in\">AVG</span>(SAL) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T)</span><br></pre></td></tr></table></figure>\n<p>当需要多行修改多行时，<br><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//多行修改多行</span></span><br><span class=\"line\">UPDATE <span class=\"params\">&lt;表<span class=\"number\">1</span>&gt;</span> a</span><br><span class=\"line\">inner join <span class=\"params\">&lt;表<span class=\"number\">2</span>&gt;</span> b ON <span class=\"params\">&lt;两表的关系&gt;</span></span><br><span class=\"line\">SET a.<span class=\"params\">&lt;列名&gt;</span>=b.<span class=\"params\">&lt;列名&gt;</span></span><br><span class=\"line\">WHERE</span><br><span class=\"line\"><span class=\"params\">&lt;条件&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//记得提交！</span></span><br><span class=\"line\">COMMIT;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"删除数据记录\"><a href=\"#删除数据记录\" class=\"headerlink\" title=\"删除数据记录\"></a>删除数据记录</h4><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> </span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> &lt;表名&gt;</span><br><span class=\"line\">[<span class=\"keyword\">WHERE</span> &lt;条件&gt;]</span><br><span class=\"line\">//利用子查询选择要删除的行</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span></span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> TC </span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> TNO=  </span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> TNO</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> TN=’ 刘伟’)</span><br></pre></td></tr></table></figure>\n<h3 id=\"正则匹配\"><a href=\"#正则匹配\" class=\"headerlink\" title=\"正则匹配\"></a>正则匹配</h3><p>MYSQL可以使用正则表达式进行匹配。使用的运算符是 REGEXP。</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>模式匹配对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^</td>\n<td>字符串的开始位置</td>\n</tr>\n<tr>\n<td>$</td>\n<td>字符串的结尾</td>\n</tr>\n<tr>\n<td>.</td>\n<td>单个字符</td>\n</tr>\n<tr>\n<td>[…]</td>\n<td>一对方括号之间的字符</td>\n</tr>\n<tr>\n<td>[^…]</td>\n<td>未在一对方括号之间的字符</td>\n</tr>\n<tr>\n<td>p1丨p2丨p3</td>\n<td>交替匹配模式1、模式2或模式3</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配前面元素的零个或多个实例</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面元素的一个或多个实例</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>匹配前面元素的n个实例</td>\n</tr>\n<tr>\n<td>{m,n}</td>\n<td>匹配前面元素的m~n个实例，m &lt;= n</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"大小写敏感\"><a href=\"#大小写敏感\" class=\"headerlink\" title=\"大小写敏感\"></a>大小写敏感</h3><p>要想让搜索对大小写敏感，可以如下例一般，使用 BINARY 关键字。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p_Name <span class=\"keyword\">name</span> <span class=\"keyword\">FROM</span> persons <span class=\"keyword\">WHERE</span> p_Name REGEXP <span class=\"built_in\">BINARY</span> <span class=\"string\">'j'</span>;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>此篇为上一篇的姊妹篇，感觉一不小心记的又臭又长了，不过内容确实不是一篇文章能说的清的。</p>","more":"<p>SELECT语句的一般格式为:<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//格式一</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span>〈列名〉[&#123;，〈列名〉&#125;]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span>〈表名或视图名〉[&#123;，〈表名或视图名〉&#125;]</span><br><span class=\"line\">[<span class=\"keyword\">WHERE</span>〈检索条件〉]</span><br><span class=\"line\">[<span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> &lt;列名<span class=\"number\">1</span>&gt;[<span class=\"keyword\">HAVING</span> &lt;条件表达式&gt;]]</span><br><span class=\"line\">[<span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> &lt;列名<span class=\"number\">2</span>&gt;[<span class=\"keyword\">ASC</span>|<span class=\"keyword\">DESC</span>]];</span><br><span class=\"line\">//格式二</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span>  [<span class=\"keyword\">ALL</span>|<span class=\"keyword\">DISTINCT</span>][TOP N [<span class=\"keyword\">PERCENT</span>][<span class=\"keyword\">WITH</span> <span class=\"keyword\">TIES</span>]]</span><br><span class=\"line\">   列名<span class=\"number\">1</span> [<span class=\"keyword\">AS</span> 别名<span class=\"number\">1</span>]</span><br><span class=\"line\">[, 列名<span class=\"number\">2</span> [ <span class=\"keyword\">AS</span> 别名<span class=\"number\">2</span>]…]</span><br><span class=\"line\">[<span class=\"keyword\">INTO</span> 新表名]</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> 表名 <span class=\"number\">1</span>[[<span class=\"keyword\">AS</span>] 表<span class=\"number\">1</span>别名]</span><br><span class=\"line\">[<span class=\"keyword\">INNER</span>|<span class=\"keyword\">RIGHT</span>|<span class=\"keyword\">FULL</span>|<span class=\"keyword\">OUTER</span>][<span class=\"keyword\">OUTER</span>]<span class=\"keyword\">JOIN</span></span><br><span class=\"line\">    表名<span class=\"number\">2</span> [[<span class=\"keyword\">AS</span>] 表<span class=\"number\">2</span>别名]</span><br><span class=\"line\"><span class=\"keyword\">ON</span> 条件</span><br></pre></td></tr></table></figure></p>\n<p>查询结束时仍然是一个表。</p>\n<p>SELECT语句的执行过程是:<br>根据WHERE子句的检索条件，从FROM子句指定的基本表或视图中选取满足条件的元组，再按照SELECT子句中指定的列，投影得到结果表。<br>如果有GROUP子句，则将查询结果按照&lt;列名1&gt;相同的值进行分组。<br>如果GROUP子句后有HAVING短语，则只输出满足HAVING条件的元组。<br>如果有ORDER子句，查询结果还要按照&lt;列名2&gt;的值进行排序。</p>\n<h3 id=\"投影查询\"><a href=\"#投影查询\" class=\"headerlink\" title=\"投影查询\"></a>投影查询</h3><p>在查询中不使用WHERE子句的无条件查询，也称投影查询。<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询选修了课程的学生号</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> SNO <span class=\"keyword\">FROM</span> SC</span><br></pre></td></tr></table></figure></p>\n<p>利用投影查询可控制列名的顺序，并可通过指定别名改变查询结果的列标题的名字。<br><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询全体学生的姓名、学号和年龄。</span></span><br><span class=\"line\"><span class=\"built_in\">SELECT</span> SNAME <span class=\"built_in\">NAME</span>, SNO, AGE <span class=\"keyword\">FROM</span> S</span><br></pre></td></tr></table></figure></p>\n<p>其中，NAME为SNAME的别名。</p>\n<h3 id=\"条件查询\"><a href=\"#条件查询\" class=\"headerlink\" title=\"条件查询\"></a>条件查询</h3><p>当要在表中找出满足某些条件的行时，则需使用WHERE子句指定查询条件。</p>\n<p>WHERE子句中，条件通常通过三部分来描述：<br>1.列名；<br>2.比较运算符；<br>3.列名、常数。</p>\n<p>比较运算符，除了常规的大于小于等于之外，还有下列这些常用的比较运算符：</p>\n<p>不等于(&lt;&gt;)；多重条件(and,or);BETWEEN AND(确定范围)；IN(确定集合)；LIKE(字符匹配)；IS NULL（空值）</p>\n<h4 id=\"1-比较大小\"><a href=\"#1-比较大小\" class=\"headerlink\" title=\"1.比较大小\"></a>1.比较大小</h4><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">SELECT</span> SNO,CNO,<span class=\"built_in\">SCORE</span> <span class=\"keyword\">FROM</span> SC WHERE <span class=\"built_in\">SCORE</span>&gt;<span class=\"number\">85</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2-多重条件查询\"><a href=\"#2-多重条件查询\" class=\"headerlink\" title=\"2.多重条件查询\"></a>2.多重条件查询</h4><p>当WHERE子句需要指定一个以上的查询条件时，则需要使用逻辑运算符AND、OR和NOT将其连结成复合的逻辑表达式。<br>其优先级由高到低为：NOT、AND、OR，用户可以使用括号改变优先级。<br><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询选修C1或C2且分数大于等于85分学生的的学号、课程号和成绩。</span></span><br><span class=\"line\"><span class=\"built_in\">SELECT</span> SNO，CNO，<span class=\"built_in\">SCORE</span></span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> SC</span><br><span class=\"line\">WHERE（CNO=’C1’ <span class=\"built_in\">OR</span> CNO=’C2’） <span class=\"built_in\">AND</span></span><br><span class=\"line\"> <span class=\"built_in\">SCORE</span>&gt;=<span class=\"number\">85</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"3-确定范围\"><a href=\"#3-确定范围\" class=\"headerlink\" title=\"3.确定范围\"></a>3.确定范围</h4><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询工资在1000至1500之间的教师的教师号、姓名及职称。</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TNO,TN,PROF</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> SAL BETWEEN <span class=\"number\">1000</span> <span class=\"keyword\">AND</span> <span class=\"number\">1500</span></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TNO,TN,PROF</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> SAL&gt;=<span class=\"number\">1000</span> <span class=\"keyword\">AND</span> SAL&lt;=<span class=\"number\">1500</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"4-确定集合\"><a href=\"#4-确定集合\" class=\"headerlink\" title=\"4.确定集合\"></a>4.确定集合</h4><p>利用“IN”操作可以查询属性值属于指定集合的元组。</p>\n<figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//查询选修C1或C2的学生的学号、课程号和成绩。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SNO, CNO, SCORE </span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> SC </span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> CNO <span class=\"keyword\">IN</span>(‘C1’, ‘C2’)</span><br><span class=\"line\">//此语句也可以使用逻辑运算符“<span class=\"keyword\">OR</span>”实现。</span><br><span class=\"line\">//利用“<span class=\"keyword\">NOT</span> <span class=\"keyword\">IN</span>”可以查询指定集合外的元组。</span><br></pre></td></tr></table></figure>\n<h4 id=\"5-部分匹配查询\"><a href=\"#5-部分匹配查询\" class=\"headerlink\" title=\"5.部分匹配查询\"></a>5.部分匹配查询</h4><p>上例均属于完全匹配查询，当不知道完全精确的値时，用户还可以使用LIKE或NOT LIKE进行部分匹配查询（也称模糊查询）。<br>LIKE定义的一般格式为：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">属性名</span>&gt;</span> LIKE <span class=\"tag\">&lt;<span class=\"name\">字符串常量</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>属性名必须为字符型，字符串常量的字符可以包含如下两个特殊符号：<br>%：表示任意知长度的字符串；</p>\n<p>_：表示任意单个字符;</p>\n<p>[charlist]:字符列中的任何单一字符;</p>\n<p>[^charlist]或者[!charlist]:不在字符列中的任何单一字符。<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询所有姓张但不包含国或辽的教师的教师号和姓名。</span></span><br><span class=\"line\"><span class=\"keyword\">select</span>  * </span><br><span class=\"line\"> <span class=\"keyword\">from</span> S</span><br><span class=\"line\"><span class=\"keyword\">where</span> sname like <span class=\"string\">'张[^国辽]_'</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"6-空值查询\"><a href=\"#6-空值查询\" class=\"headerlink\" title=\"6.空值查询\"></a>6.空值查询</h4><p>某个字段没有值称之为具有空值（NULL）。空值不同于零和空格，它不占任何存储空间。</p>\n<p>例如，某些学生选课后没有参加考试，有选课记录，但没有考试成绩，考试成绩为空值，这与参加考试，成绩为零分的不同。<br><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> SNO, CNO</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> SC</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> SCORE <span class=\"keyword\">IS</span> <span class=\"literal\">NULL</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"常用库函数及统计汇总查询\"><a href=\"#常用库函数及统计汇总查询\" class=\"headerlink\" title=\"常用库函数及统计汇总查询\"></a>常用库函数及统计汇总查询</h3><table>\n<thead>\n<tr>\n<th>函数名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>AVG</td>\n<td>按列计算平均值</td>\n</tr>\n<tr>\n<td>SUM</td>\n<td>按列计算值的总和</td>\n</tr>\n<tr>\n<td>MAX</td>\n<td>求一列中的最大值</td>\n</tr>\n<tr>\n<td>MIN</td>\n<td>求一列中的最小值</td>\n</tr>\n<tr>\n<td>COUNT</td>\n<td>按列值计个数</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//求学号为S1学生的总分和平均分。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">SUM</span>(SCORE) <span class=\"keyword\">AS</span> TotalScore, <span class=\"keyword\">AVG</span>(SCORE) <span class=\"keyword\">AS</span> AveScore</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> SC</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> (SNO = <span class=\"string\">'S1'</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">//求学校中共有多少个系</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">COUNT</span>(<span class=\"keyword\">DISTINCT</span> DEPT) <span class=\"keyword\">AS</span> DeptNum </span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br></pre></td></tr></table></figure>\n<p>注意：<br>函数SUM和AVG只能对数值型字段进行计算。</p>\n<p>COUNT函数对空值不计算，但对零进行计算。</p>\n<h3 id=\"分组查询\"><a href=\"#分组查询\" class=\"headerlink\" title=\"分组查询\"></a>分组查询</h3><p><code>GROUP BY</code>子句可以将查询结果按属性列或属性列组合在行的方向上进行分组，每组在属性列或属性列组合上具有相同的值。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询各位教师的教师号及其任课的门数。</span><br><span class=\"line\">SELECT TNO,COUNT(*) AS C_NUM</span><br><span class=\"line\">  <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">GROUP BY TNO</span><br></pre></td></tr></table></figure></p>\n<p>若在分组后还要按照一定的条件进行筛选，则需使用HAVING子句。<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> SNO,COUNT<span class=\"comment\">(*) AS SC_NUM </span></span><br><span class=\"line\"><span class=\"comment\">  FROM SC</span></span><br><span class=\"line\"><span class=\"comment\">GROUP BY SNO       </span></span><br><span class=\"line\"><span class=\"comment\">HAVING COUNT(*)</span>&gt;=<span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>当在一个SQL查询中同时使用WHERE子句，<code>GROUP  BY</code>子句和<code>HAVING</code>子句时，其顺序是<code>WHERE－GROUP  BY－ HAVING</code>。</p>\n<p><strong><code>WHERE</code>与<code>HAVING</code>子句的根本区别在于作用对象不同。</strong></p>\n<p>WHERE子句作用于基本表或视图，从中选择满足条件的元组；<br>HAVING子句作用于组，选择满足条件的组，必须用于GROUP BY子句之后，但GROUP BY子句可没有HAVING子句。</p>\n<h3 id=\"查询排序\"><a href=\"#查询排序\" class=\"headerlink\" title=\"查询排序\"></a>查询排序</h3><p>当需要对查询结果排序时，应该使用ORDER BY子句<br>ORDER BY子句必须出现在其他子句之后<br>排序方式可以指定，DESC为降序，ASC为升序，缺省时为升序<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//查询选修C2、C3、C4或C5课程的学号、课程号和成绩，查询结果按学号升序排列，学号相同再按成绩降序排列。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SNO,CNO, SCORE </span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> SC</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> CNO <span class=\"keyword\">IN</span> (<span class=\"string\">'C2'</span> ,<span class=\"string\">'C3'</span>, <span class=\"string\">'C4'</span>,<span class=\"string\">'C5'</span>)</span><br><span class=\"line\">   <span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> SNO,SCORE <span class=\"keyword\">DESC</span> </span><br><span class=\"line\">//求选课在三门以上且各门课程均及格的学生的学号及其总    成绩，查询结果按总成绩降序列出。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> SNO,<span class=\"keyword\">SUM</span>(SCORE)<span class=\"keyword\">AS</span> TotalScore</span><br><span class=\"line\"><span class=\"keyword\">FROM</span> SC</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> SCORE&gt;=<span class=\"number\">60</span></span><br><span class=\"line\"><span class=\"keyword\">GROUP</span> <span class=\"keyword\">BY</span> SNO</span><br><span class=\"line\"><span class=\"keyword\">HAVING</span> <span class=\"keyword\">COUNT</span>(*)&gt;=<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"keyword\">ORDER</span> <span class=\"keyword\">BY</span> <span class=\"keyword\">SUM</span>(SCORE) <span class=\"keyword\">DESC</span></span><br></pre></td></tr></table></figure></p>\n<p>上述执行过程如下：取出SC，筛选SCORE&gt;=60 的元组，讲选出的元组按照SNO分组，筛选选课三门以上的分组，一剩下的组中提取学号和总成绩，将选取结果排序。</p>\n<p>另外，<code>ORDER BY SUM(SCORE) DESC</code>可以改写成<br><code>ORDER BY 2 DESC</code>,2 代表查询结果的第二列。 </p>\n<h3 id=\"INTO-子句\"><a href=\"#INTO-子句\" class=\"headerlink\" title=\"INTO 子句\"></a>INTO 子句</h3><p>在默认子段组中创建一个新表并将来自查询的结果行插入新表中。<br><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> *</span><br><span class=\"line\">     <span class=\"keyword\">INTO</span> new_Table</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> Sex = ‘男’</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"COMPUTE子句\"><a href=\"#COMPUTE子句\" class=\"headerlink\" title=\"COMPUTE子句\"></a>COMPUTE子句</h3><p>生成合计作为附加的汇总列出现在结果集的最后。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> s.s<span class=\"comment\">#,sname,age,sex,c#,grade </span></span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> s,sc</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> s.s<span class=\"comment\">#=sc.s# and</span></span><br><span class=\"line\">               s.s<span class=\"comment\">#='200203080101'</span></span><br><span class=\"line\"><span class=\"keyword\">COMPUTE</span> <span class=\"keyword\">sum</span>(sc.grade),<span class=\"keyword\">count</span>(s.s<span class=\"comment\">#)</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"数据表连接及连接查询\"><a href=\"#数据表连接及连接查询\" class=\"headerlink\" title=\"数据表连接及连接查询\"></a>数据表连接及连接查询</h3><p>数据表之间的联系是通过表的字段值来体现的，这种字段称为连接字段。<br>连接操作的目的就是通过加在连接字段的条件将多个表连接起来，以便从多个表中查询数据。<br>前面的查询都是针对一个表进行的，当查询同时涉及两个以上的表时，称为连接查询。</p>\n<p>表的连接方法有两种：<br>1.表之间满足一定的条件的行进行连接，此时FROM子句中指明进行连接的表名，<code>WHERE</code>子句指明连接的列名及其连接条件。<br>2.利用关键字<code>JOIN</code>进行连接。</p>\n<p>具体分为下列几种：<br>1.INNER JOIN：现在符合条件的记录，此为默认值。<br>2.LEFT （OUTER） JOIN：显示符合条件的数据行以及左边表中不符合条件的数据行，此时右边数据行会以NULL来显示，此称为左连接。<br>3.RIGHT （OUTER） JOIN：显示符合条件的数据行以及右边表中不符合条件的数据行，此时左边数据行会以NULL来显示，此称为右连接。<br>4.FULL （OUTER） JOIN：显示符合条件的数据行以及左边表和右边表中不符合条件的数据行，此时缺乏数据的数据行会以NULL来显示。<br>5.CROSS JOIN：会将一个表的每一笔数据和另一表的每笔数据匹配成新的数据行。</p>\n<p>当将<code>JOIN</code>关键词放于FROM子句中时，应有关键词<code>ON</code>与之相对应，以表明连接的条件。</p>\n<h4 id=\"等值连接与非等值连接\"><a href=\"#等值连接与非等值连接\" class=\"headerlink\" title=\"等值连接与非等值连接\"></a>等值连接与非等值连接</h4><p>查询刘伟老师所讲授的课程。</p>\n<p>方法1：<br><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">SELECT</span> T.TNO ,TN,CNO</span><br><span class=\"line\">   FROM T,TC</span><br><span class=\"line\"><span class=\"built_in\">WHERE</span> (T.TNO = TC. TNO) <span class=\"keyword\">AND</span> (TN = ‘刘伟’)</span><br></pre></td></tr></table></figure></p>\n<p>上面的操作是将T表中的TNO 和TC表中的TNO相等的行连接，同时选取TN为“刘伟“的行，然后再在TN，CNO列上投影，这是连接、选取和投影的操作组合。</p>\n<p>这里，TN=‘刘伟’为查询条件，而T.TNO = TC.TNO 为连接条件，TNO为连接字段。连接条件的一般格式为：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"tag\">&lt;<span class=\"name\">表名1</span>&gt;</span>.] <span class=\"tag\">&lt;<span class=\"name\">列名1</span>&gt;</span> <span class=\"tag\">&lt;<span class=\"name\">比较运算符</span>&gt;</span> [<span class=\"tag\">&lt;<span class=\"name\">表名2</span>&gt;</span>.] <span class=\"tag\">&lt;<span class=\"name\">列名2</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>其中,比较运算符主要有：＝、＞、＜、＞＝、＜＝、！＝。<br>当比较运算符为“＝“时，称为等值连接，其他情况为非等值连接。</p>\n<p>当列名是唯一的，不需要加表名前缀。</p>\n<p>方法2：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> T.TNO,TN,CNO</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> TC </span><br><span class=\"line\">    <span class=\"keyword\">ON</span> T.TNO=TC.TNO <span class=\"keyword\">AND</span> T.TN=<span class=\"string\">'刘伟'</span></span><br></pre></td></tr></table></figure></p>\n<p>方法3：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> R2.TNO,R2.TN, R1.CNO </span><br><span class=\"line\">   <span class=\"keyword\">FROM</span></span><br><span class=\"line\">      (<span class=\"keyword\">SELECT</span> TNO,CNO </span><br><span class=\"line\">          <span class=\"keyword\">FROM</span> TC ) <span class=\"keyword\">AS</span> R1</span><br><span class=\"line\">       <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> </span><br><span class=\"line\">       (<span class=\"keyword\">SELECT</span> TNO ,TN </span><br><span class=\"line\">            <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\">         <span class=\"keyword\">WHERE</span> TN=<span class=\"string\">'刘伟'</span>) <span class=\"keyword\">AS</span> R2</span><br><span class=\"line\">        <span class=\"keyword\">ON</span> R1.TNO=R2.TNO</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"自身连接\"><a href=\"#自身连接\" class=\"headerlink\" title=\"自身连接\"></a>自身连接</h4><p>查询所有比刘伟工资高的教师姓名、性别、工资和刘伟的工资。</p>\n<p>要查询的内容均在同一表T中，可以将表T分别取两个别名，一个是X，一个是Y。将X, Y 中满足比刘伟工资高的行连接起来。这实际上是同一表T的自身连接。<br>方法1：<br><figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">X</span>.TN,<span class=\"keyword\">X</span>.SAL AS SAL_a, <span class=\"keyword\">Y</span>.SAL AS SAL_b </span><br><span class=\"line\">   FROM T AS <span class=\"keyword\">X</span> ,T AS <span class=\"keyword\">Y</span> </span><br><span class=\"line\">WHERE <span class=\"keyword\">X</span>.SAL&gt;<span class=\"keyword\">Y</span>.SAL <span class=\"keyword\">AND</span> </span><br><span class=\"line\">    <span class=\"keyword\">Y</span>.TN=<span class=\"string\">'刘伟'</span></span><br></pre></td></tr></table></figure></p>\n<p>方法2：<br><figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">X</span>.TN, <span class=\"keyword\">X</span>.SAL,<span class=\"keyword\">Y</span>.SAL </span><br><span class=\"line\">   FROM T AS <span class=\"keyword\">X</span> INNER JOIN T AS <span class=\"keyword\">Y</span></span><br><span class=\"line\">      <span class=\"literal\">ON</span> <span class=\"keyword\">X</span>.SAL&gt;<span class=\"keyword\">Y</span>.SAL <span class=\"keyword\">AND</span> <span class=\"keyword\">Y</span>.TN=<span class=\"string\">'刘伟'</span></span><br></pre></td></tr></table></figure></p>\n<p>方法3：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> R1.TN,R1.SAL, R2.SAL </span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> </span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> TN,SAL </span><br><span class=\"line\">         <span class=\"keyword\">FROM</span> T ) <span class=\"keyword\">AS</span> R1</span><br><span class=\"line\">    <span class=\"keyword\">INNER</span> <span class=\"keyword\">JOIN</span> </span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> SAL </span><br><span class=\"line\">         <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\">      <span class=\"keyword\">WHERE</span> TN=<span class=\"string\">'刘伟'</span>) <span class=\"keyword\">AS</span> R2</span><br><span class=\"line\">     <span class=\"keyword\">ON</span> R1.SAL&gt;R2.SAL</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"外连接\"><a href=\"#外连接\" class=\"headerlink\" title=\"外连接\"></a>外连接</h4><p>在上面的连接操作中，不满足连接条件的元组不能作为查询结果输出。<br><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//查询所有学生的学号、姓名、选课名称及成绩。（没有选课的同学的选课信息显示为空）则应写成如下的SQL语句。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> S.SNO,SN,CN,SCORE</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br><span class=\"line\">       <span class=\"keyword\">LEFT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> SC</span><br><span class=\"line\">       <span class=\"keyword\">ON</span> S.SNO=SC.SNO</span><br><span class=\"line\">       <span class=\"keyword\">LEFT</span> <span class=\"keyword\">OUTER</span> <span class=\"keyword\">JOIN</span> C</span><br><span class=\"line\">       <span class=\"keyword\">ON</span> C.CNO=SC.CNO</span><br></pre></td></tr></table></figure></p>\n<p>则查询结果只包括所有的学生，没有选课的同学的选课信息显示为空。</p>\n<h3 id=\"子查询\"><a href=\"#子查询\" class=\"headerlink\" title=\"子查询\"></a>子查询</h3><p>在WHERE子句中包含一个形如SELECT-FROM-WHERE的查询块，此查询块称为子查询或嵌套查询，包含子查询的语句称为父查询或外部查询。</p>\n<p>子查询的嵌套层次最多可达到255层，以层层嵌套的方式构造查询充分体现了SQL“结构化”的特点。</p>\n<p>嵌套查询在执行时由里向外处理，每个子查询是在上一级外部查询处理之前完成，父查询要用到子查询的结果。</p>\n<h4 id=\"返回一组值的子查询\"><a href=\"#返回一组值的子查询\" class=\"headerlink\" title=\"返回一组值的子查询\"></a>返回一组值的子查询</h4><p>如果子查询的返回值不止一个，而是一个集合时，则不能直接使用比较运算符，可以在比较运算符和子查询之间插入ANY或ALL。<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询讲授课程号为C5的教师姓名。</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TN</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> TNO=ANY</span><br><span class=\"line\">      (<span class=\"keyword\">SELECT</span> TNO </span><br><span class=\"line\">          <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">       <span class=\"keyword\">WHERE</span> CNO=<span class=\"string\">'C5'</span>)</span><br><span class=\"line\"><span class=\"comment\">//该例也可以使用前面所讲的连接操作来实现：</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TN</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T,TC</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> T.TNO=TC.TNO <span class=\"keyword\">AND</span></span><br><span class=\"line\">               TC.CNO=<span class=\"string\">'C5‘</span></span><br></pre></td></tr></table></figure></p>\n<p>可见，对于同一查询可使用子查询和连接两种方法来解决，可根据习惯任意选用。 </p>\n<p>另外，还可以使用IN代替“=ANY”。<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> TN</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> TNO <span class=\"keyword\">IN</span></span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> TNO </span><br><span class=\"line\">        <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">     <span class=\"keyword\">WHERE</span> CNO=<span class=\"string\">'C5'</span>)</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span> TN</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"string\">'C5'</span> !=<span class=\"keyword\">ALL</span></span><br><span class=\"line\">     ( <span class=\"keyword\">SELECT</span> CNO </span><br><span class=\"line\">           <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">        <span class=\"keyword\">WHERE</span> TNO=T.TNO)</span><br></pre></td></tr></table></figure>\n<p><code>!=ALL</code>的含义为不等于子查询结果中的任何一个值，也可使用<code>NOT IN</code>代替<code>!=ALL</code>。</p>\n<p>前面所讲的子查询均为普通子查询，而本例中子查询的查询条件引用了父查询表中的属性值（T表的TNO值），我们把这类查询称为相关子查询。</p>\n<p>二者的执行方式不同，相关子查询并不是先执行子查询，而是首先选取父查询表的第一行记录，内部的子查询利用此行中相关的属性值进行查询。<br>然后父查询根据子查询返回的结果判断此行是否满足查询条件。如果满足条件，则把该行放入父查询的查询结果集合中。重复执行这一过程，直到处理完父查询表中的每一行数据。</p>\n<p>如上行所述，表T中每一行都要执行一次子查询。<br>因此，相关子查询的执行次数是由父查询表的行数决定的。</p>\n<p>除了之前说的ALL,ANY,IN之外，还可以使用EXISTS来表示存在与否。带有EXISTS的子查询不返回任何实际数据，它只得到逻辑值“真”或“假”。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询讲授课程号为C5的教师姓名。</span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> TN</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> <span class=\"keyword\">EXISTS</span></span><br><span class=\"line\">    (<span class=\"keyword\">SELECT</span> * </span><br><span class=\"line\">        <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">     <span class=\"keyword\">WHERE</span> TNO=T.TNO</span><br><span class=\"line\">    <span class=\"keyword\">AND</span> CNO=<span class=\"string\">'C5'</span>)</span><br></pre></td></tr></table></figure>\n<p>当子查询TC表存在一行记录满足其WHERE子句中的条件时，则父查询便得到一个TN值，重复执行以上过程，直到得出最后结果。</p>\n<h3 id=\"集合查询\"><a href=\"#集合查询\" class=\"headerlink\" title=\"集合查询\"></a>集合查询</h3><p>集合操作分为并操作UNION,交操作INTERSECT,差操作EXCEPT。</p>\n<p>参加集合操作的各查询结果的列数必须相同；对应项的数据类型也必须相同。<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> *</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> dept= <span class=\"string\">'CS'</span></span><br><span class=\"line\">  <span class=\"keyword\">UNION</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> *</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> age&lt;=<span class=\"number\">19</span></span><br><span class=\"line\"><span class=\"comment\">//等于</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> <span class=\"keyword\">DISTINCT</span>  *</span><br><span class=\"line\">   <span class=\"keyword\">FROM</span> S</span><br><span class=\"line\"><span class=\"keyword\">WHERE</span> dept= <span class=\"string\">'CS'</span>  <span class=\"keyword\">OR</span>  age&lt;=<span class=\"number\">19</span>；</span><br></pre></td></tr></table></figure></p>\n<p>UNION：将多个查询结果合并起来时，系统自动去掉重复元组。  <code>or</code><br>UNION ALL：将多个查询结果合并起来时，保留重复元组<br>INTERSECT：求两个结果的交集 <code>and</code><br>EXCEPT:差集</p>\n<h3 id=\"SQL数据更新\"><a href=\"#SQL数据更新\" class=\"headerlink\" title=\"SQL数据更新\"></a>SQL数据更新</h3><p>SQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。</p>\n<h4 id=\"插入数据记录\"><a href=\"#插入数据记录\" class=\"headerlink\" title=\"插入数据记录\"></a>插入数据记录</h4><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//插入单行记录</span></span><br><span class=\"line\">INSERT INTO <span class=\"params\">&lt;表名&gt;</span>[(<span class=\"params\">&lt;列名<span class=\"number\">1</span>&gt;</span>[,<span class=\"params\">&lt;列名<span class=\"number\">2</span>&gt;</span>…])] VALUES(<span class=\"params\">&lt;值&gt;</span>)</span><br><span class=\"line\"><span class=\"comment\">//插入多行记录</span></span><br><span class=\"line\">INSERT INTO <span class=\"params\">&lt;表名&gt;</span> [(<span class=\"params\">&lt;列名<span class=\"number\">1</span>&gt;</span>[,<span class=\"params\">&lt;列名<span class=\"number\">2</span>&gt;</span>…])] 子查询</span><br></pre></td></tr></table></figure>\n<h4 id=\"修改数据记录\"><a href=\"#修改数据记录\" class=\"headerlink\" title=\"修改数据记录\"></a>修改数据记录</h4><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">UPDATE</span> &lt;表名&gt; <span class=\"keyword\">SET</span> &lt;列名&gt;=&lt;表达式&gt; [,&lt;列名&gt;=&lt;表达式&gt;] … [<span class=\"keyword\">WHERE</span> &lt;条件&gt;]</span><br><span class=\"line\">//利用子查询提供要修改的值</span><br><span class=\"line\"><span class=\"keyword\">UPDATE</span> T</span><br><span class=\"line\"><span class=\"keyword\">SET</span> SAL =</span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> <span class=\"number\">1.2</span>*<span class=\"built_in\">AVG</span>(SAL) </span><br><span class=\"line\"><span class=\"keyword\">FROM</span> T)</span><br></pre></td></tr></table></figure>\n<p>当需要多行修改多行时，<br><figure class=\"highlight dts\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//多行修改多行</span></span><br><span class=\"line\">UPDATE <span class=\"params\">&lt;表<span class=\"number\">1</span>&gt;</span> a</span><br><span class=\"line\">inner join <span class=\"params\">&lt;表<span class=\"number\">2</span>&gt;</span> b ON <span class=\"params\">&lt;两表的关系&gt;</span></span><br><span class=\"line\">SET a.<span class=\"params\">&lt;列名&gt;</span>=b.<span class=\"params\">&lt;列名&gt;</span></span><br><span class=\"line\">WHERE</span><br><span class=\"line\"><span class=\"params\">&lt;条件&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//记得提交！</span></span><br><span class=\"line\">COMMIT;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"删除数据记录\"><a href=\"#删除数据记录\" class=\"headerlink\" title=\"删除数据记录\"></a>删除数据记录</h4><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DELETE</span> </span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> &lt;表名&gt;</span><br><span class=\"line\">[<span class=\"keyword\">WHERE</span> &lt;条件&gt;]</span><br><span class=\"line\">//利用子查询选择要删除的行</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span></span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> TC </span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> TNO=  </span><br><span class=\"line\">(<span class=\"keyword\">SELECT</span> TNO</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> TN=’ 刘伟’)</span><br></pre></td></tr></table></figure>\n<h3 id=\"正则匹配\"><a href=\"#正则匹配\" class=\"headerlink\" title=\"正则匹配\"></a>正则匹配</h3><p>MYSQL可以使用正则表达式进行匹配。使用的运算符是 REGEXP。</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th>模式匹配对象</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>^</td>\n<td>字符串的开始位置</td>\n</tr>\n<tr>\n<td>$</td>\n<td>字符串的结尾</td>\n</tr>\n<tr>\n<td>.</td>\n<td>单个字符</td>\n</tr>\n<tr>\n<td>[…]</td>\n<td>一对方括号之间的字符</td>\n</tr>\n<tr>\n<td>[^…]</td>\n<td>未在一对方括号之间的字符</td>\n</tr>\n<tr>\n<td>p1丨p2丨p3</td>\n<td>交替匹配模式1、模式2或模式3</td>\n</tr>\n<tr>\n<td>*</td>\n<td>匹配前面元素的零个或多个实例</td>\n</tr>\n<tr>\n<td>+</td>\n<td>匹配前面元素的一个或多个实例</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td>匹配前面元素的n个实例</td>\n</tr>\n<tr>\n<td>{m,n}</td>\n<td>匹配前面元素的m~n个实例，m &lt;= n</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"大小写敏感\"><a href=\"#大小写敏感\" class=\"headerlink\" title=\"大小写敏感\"></a>大小写敏感</h3><p>要想让搜索对大小写敏感，可以如下例一般，使用 BINARY 关键字。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SELECT</span> p_Name <span class=\"keyword\">name</span> <span class=\"keyword\">FROM</span> persons <span class=\"keyword\">WHERE</span> p_Name REGEXP <span class=\"built_in\">BINARY</span> <span class=\"string\">'j'</span>;</span><br></pre></td></tr></table></figure></p>"},{"title":"存储过程学习小结","date":"2016-12-27T08:22:50.000Z","_content":"\n## 存储过程的概述\n是在大型数据库系统中，一组为了完成特定功能的SQL语句集，存储在`数据库`中，经过第一次编译后再次调用不需要再次编译。外部程序可以直接调用数据库里面定义好的存储过程，另外数据库内部的触发器(trigger)、或者其他存储过程也可以调用它。\n\n<!--more-->\n\n### 优点\n1.性能上的提高，减少了交互频率，提高了重用性。\n2.类似于接口的概念，提高了安全性。尽管无法直接访问，但可以通过存储过程进行处理。\n### 缺点\n1.存储过程会加大数据库占用的系统资源。\n2.无法编写复杂逻辑的存储过程，不容易调试。\n3.存储过程书写及维护难度都比较大。\n\n## 变量\n\n### 定义\n```\nDECLARE variable_name datatype(size) DEFAULT default_value; \n```\n多个变量可以这样定义：\n```\nDECLARE x, y INT DEFAULT 0 ;\n```\n### 变量的赋值\n可以通过`set`或者`select...into...`来进行赋值。\n```\nSET x =10;\nselect count(*) into x from usertabl;\n```\n\n### 变量的scope(作用范围)\n作用范围一般在begin和end之间。\n还有一种是会话变量(session variable)，也叫做用户定义的变量(user defined variable)。这种变量要在变量名称前面加上“@”符号，作用域是全局。这个变量可以在被调用的存储过程或者代码之间共享数据。\n\n## 参数\nMySql的参数分为三类:IN、OUT、INOUT。\n\nIN(默认)：这是个默认的类型，也就是如果参数没指定类型的话，那么默认就是IN类型了，这种参数主要是传递进去的值，这个值提供给存储过程使用，另外存储过程对其做的改变不会对传入的参数发生作用。\n\nOUT：这个主要是存储过程要传递出去的值，也就是存储过程给你将它改变，并且传回去给调用它的程序。\n\nINOUT：则把上面两个的特点合在一起了，即可以传递值给存储过程使用，同时存储过程也可以改变这个值在传给调用它的程序。\n\n### 参数的定义\n```\nMODE param_name param_type(param_size)；\n```\n这里的MODE指的就是以上的三类。\n\n## 逻辑判断和循环\n存储过程中也有对应的条件判断，功能类似于if、switch。在MySQL里面对应的是IF和CASE。MySQL的存储过程中可使用的循环有三种：WHILE、REPEAT、LOOP。\n### IF\n```\nIF expression THEN commands  \n   [ELSEIF expression THEN commands]  \n   [ELSE commands]  \n   END IF;  \n```\n\n### CASE\n```\nCASE  case_expression  \n   WHEN when_expression THEN commands  \n   WHEN when_expression THEN commands  \n   ...  \n   ELSE commands  \nEND CASE; \n```\n### WHILE\n```\nWHILE expression DO  \n   Statements  \nEND WHILE  \n```\n### REPEAT\n类似于`do...while...`\n```\nREPEAT  \nStatements;  \nUNTIL expression  \nEND REPEAT  \n```\n### LOOP 及 LEAVE、ITERATE\n这里LOOP用来标记循环；而LEAVE表示离开循环，好比编程里面的break一样；ITERATE则继续循环，类型与编程里面的continue。\n例.输出小于10的偶数：\n```\nloop_label:  LOOP  \n  IF  x > 10 THEN  \n   LEAVE  loop_label;  \n  END  IF;  \n  SET  x = x + 1;  \n  IF  (x mod 2) THEN  \n   ITERATE  loop_label;  \n  ELSE  \n   SET  str = CONCAT(str,x,',');  \n  END  IF;  \n  \nEND LOOP;  \nselect str;\n```\n## 游标\n游标的作用就是用于对查询数据库所返回的记录进行遍历，以便进行相应的操作。\n### 游标属性\n游标有下列属性：\na、游标是只读的，也就是不能更新它；\nb、游标是不能滚动的，也就是只能在一个方向上进行遍历，不能在记录之间随意进退，不能跳过某些记录；\nc、避免在已经打开游标的表上更新数据。\n\n### 游标的使用\na.首先用DECLARE语句声明一个游标\n ```\n DECLARE cursor_name CURSOR FOR SELECT_statement;  \n ```\n 上面这条语句就给我们执行的select语句返回的记录指定了一个游标。\n\nb.其次需要使用OPEN语句来打开上面你定义的游标\n ```\n OPEN cursor_name; \n ```\nc.接下来你可以用FETCH语句来获得下一行数据，并且游标也将移动到对应的记录上(这个就类似java里面的那个iterator)。\n ```\n FETCH cursor_name INTO variable list; \n ```\nd.然后最后当我们所需要进行的操作都结束后我们要把游标释放掉。\n ```\n CLOSE cursor_name;  \n ```\n在使用游标时需要注意的是，使用定义一个针对NOT FOUND的条件处理函数(condition handler)来避免出现“no data to fetch”这样的错误，条件处理函数就是当某种条件产生时所执行的代码，这里但我们游标指到记录的末尾时，便达到NOT FOUND这样条件，这个时候我们希望继续进行后面的操作，所以我们会加CONTINUE。然后判断`no_more_flag`标志位来进行进一步的操作。\n```\n DECLARE  CONTINUE HANDLER \n \tFOR NOT FOUND  \n \tSET  no_more_flag = 1;\n \t/*when \"not found\" occur,just continue*/ \n```\n接下来会解释一下上面这个用法的意思。\n\n## 条件处理 / 错误、异常处理\n在游标里面我们有简要的介绍了一个NOT FOUND这个条件处理（错误、异常处理）的情况，条件处理涉及到两个语句，一个是`DECLARE...CONDITION`，另一个是`DECLARE....HANDLER`。\n\n### 1、DECLARE....HANDLER语句\n这个语句用于但数据库出现某种情况的时候(condition，大部分指发生某种错误时)，来定义具体的处理办法(handler)；所以这里涉及到包括：a、就是个什么情况 b、如何处理它；下面是其格式。\n```\nDECLARE handler_action HANDLER  \n    FOR condition_value [, condition_value] ...  #可以包括多种情况\n    statement  \n #处理方法有： \nhandler_action:  \n    CONTINUE  \n  | EXIT  \n  | UNDO  \n #存在情况有：\ncondition_value:  \n    mysql_error_code  # MySQL的错误代码\n  | SQLSTATE [VALUE] sqlstate_value  # 一个5个字符组成的字符串的错误信息，同错误代码类似形成一一对应的关系 \n  | condition_name  # 这个是条件名称，它使用DECLARE...CONDITION语句来定义\n  | SQLWARNING  # 表示SQLTATE中的字符串以‘01’起始的那些错误\n  | NOT FOUND  # 表示SQLTATE中的字符串以‘02’起始的那些错误\n  | SQLEXCEPTION  # 表示SQLSTATE中的字符串不是以'00'、'01'、'02' 起始的那些错误，这里'00'起始的SQLSTATE其实表示的是成功执行而不是错误，另外两个就是上面的`NOT FOUND`和`SQLWARNING`的两种情况。\n```\n#### a.condition_value\n 上面的6种情况其实可以分为两类，一类就是比较明确的处理，就是对指定的错误情况进行处理，包括前三种方式；另一类是对对应类型的错误的处理，就是对某一群错误的处理，包括后三种方式另外还要注意的一个内容是MySQL在默认情况下(也就是我们没有定义处理错误的方法-handler)自己的错误处理机制：\n 1、对于SQLWARNING和NOT FOUND的处理方法就是无视错误继续执行，所以在游标的例子里面如果我们没有对repeat的条件判断的那个值做个no_more_products=1的handler来处理，那么循环就会一直下去。\n 2、对于SQLEXCEPTION的话，其默认的处理方法是在出现错误的地方就终止掉了。\n\n#### b.statement\n 这个比较简单就是当出现某种条件/错误时，我们要执行的语句，可以是简单的如 SET  var = value这样的简单的语句，也可以是复杂的多行的语句，多行的话可以使用BEGIN  .....  END这里把语句包括在里面(这个好比delphi里面的情况，注意到我们的存储过程也是多行的，所以也要BEGIN .... END)。\n\n#### c.handler_action\n 这个表示当执行完上面的statement后，希望执行怎样的动作，这里包括CONTINUE、EXIT、UNDO，表示继续、退出、撤销(暂时不支持)。\n CONTINUE就是一个是SQLWARNING和NOT FOUND的默认处理方法，而EXIT就是SQLEXCEPTION的默认处理方法。\n\n### 2、DECLARE...CONDITION语句\n这个语句其实是为了让我们的错误条件更加的清晰明了化的。例如，SQLSTATE '23000'并不清晰，要通过相应的文档去对应 。\n`DECLARE....CONDITION`可以对条件定义相对应的名称。我们可以这样写：\n```\nDECLARE duplicate_key CONDITION FOR SQLSTATE '23000';  \nDECLARE CONTINUE HANDLER FOR duplicate_key  \n  BEGIN  \n    -- body of handler  \n  END;  \n```\n这样更加直观清晰。\n","source":"_posts/mysql/存储过程学习小结.md","raw":"---\ntitle: 存储过程学习小结\ndate: 2016-12-27 16:22:50\ntags: \n- mysql\ncategories: 总结\n---\n\n## 存储过程的概述\n是在大型数据库系统中，一组为了完成特定功能的SQL语句集，存储在`数据库`中，经过第一次编译后再次调用不需要再次编译。外部程序可以直接调用数据库里面定义好的存储过程，另外数据库内部的触发器(trigger)、或者其他存储过程也可以调用它。\n\n<!--more-->\n\n### 优点\n1.性能上的提高，减少了交互频率，提高了重用性。\n2.类似于接口的概念，提高了安全性。尽管无法直接访问，但可以通过存储过程进行处理。\n### 缺点\n1.存储过程会加大数据库占用的系统资源。\n2.无法编写复杂逻辑的存储过程，不容易调试。\n3.存储过程书写及维护难度都比较大。\n\n## 变量\n\n### 定义\n```\nDECLARE variable_name datatype(size) DEFAULT default_value; \n```\n多个变量可以这样定义：\n```\nDECLARE x, y INT DEFAULT 0 ;\n```\n### 变量的赋值\n可以通过`set`或者`select...into...`来进行赋值。\n```\nSET x =10;\nselect count(*) into x from usertabl;\n```\n\n### 变量的scope(作用范围)\n作用范围一般在begin和end之间。\n还有一种是会话变量(session variable)，也叫做用户定义的变量(user defined variable)。这种变量要在变量名称前面加上“@”符号，作用域是全局。这个变量可以在被调用的存储过程或者代码之间共享数据。\n\n## 参数\nMySql的参数分为三类:IN、OUT、INOUT。\n\nIN(默认)：这是个默认的类型，也就是如果参数没指定类型的话，那么默认就是IN类型了，这种参数主要是传递进去的值，这个值提供给存储过程使用，另外存储过程对其做的改变不会对传入的参数发生作用。\n\nOUT：这个主要是存储过程要传递出去的值，也就是存储过程给你将它改变，并且传回去给调用它的程序。\n\nINOUT：则把上面两个的特点合在一起了，即可以传递值给存储过程使用，同时存储过程也可以改变这个值在传给调用它的程序。\n\n### 参数的定义\n```\nMODE param_name param_type(param_size)；\n```\n这里的MODE指的就是以上的三类。\n\n## 逻辑判断和循环\n存储过程中也有对应的条件判断，功能类似于if、switch。在MySQL里面对应的是IF和CASE。MySQL的存储过程中可使用的循环有三种：WHILE、REPEAT、LOOP。\n### IF\n```\nIF expression THEN commands  \n   [ELSEIF expression THEN commands]  \n   [ELSE commands]  \n   END IF;  \n```\n\n### CASE\n```\nCASE  case_expression  \n   WHEN when_expression THEN commands  \n   WHEN when_expression THEN commands  \n   ...  \n   ELSE commands  \nEND CASE; \n```\n### WHILE\n```\nWHILE expression DO  \n   Statements  \nEND WHILE  \n```\n### REPEAT\n类似于`do...while...`\n```\nREPEAT  \nStatements;  \nUNTIL expression  \nEND REPEAT  \n```\n### LOOP 及 LEAVE、ITERATE\n这里LOOP用来标记循环；而LEAVE表示离开循环，好比编程里面的break一样；ITERATE则继续循环，类型与编程里面的continue。\n例.输出小于10的偶数：\n```\nloop_label:  LOOP  \n  IF  x > 10 THEN  \n   LEAVE  loop_label;  \n  END  IF;  \n  SET  x = x + 1;  \n  IF  (x mod 2) THEN  \n   ITERATE  loop_label;  \n  ELSE  \n   SET  str = CONCAT(str,x,',');  \n  END  IF;  \n  \nEND LOOP;  \nselect str;\n```\n## 游标\n游标的作用就是用于对查询数据库所返回的记录进行遍历，以便进行相应的操作。\n### 游标属性\n游标有下列属性：\na、游标是只读的，也就是不能更新它；\nb、游标是不能滚动的，也就是只能在一个方向上进行遍历，不能在记录之间随意进退，不能跳过某些记录；\nc、避免在已经打开游标的表上更新数据。\n\n### 游标的使用\na.首先用DECLARE语句声明一个游标\n ```\n DECLARE cursor_name CURSOR FOR SELECT_statement;  \n ```\n 上面这条语句就给我们执行的select语句返回的记录指定了一个游标。\n\nb.其次需要使用OPEN语句来打开上面你定义的游标\n ```\n OPEN cursor_name; \n ```\nc.接下来你可以用FETCH语句来获得下一行数据，并且游标也将移动到对应的记录上(这个就类似java里面的那个iterator)。\n ```\n FETCH cursor_name INTO variable list; \n ```\nd.然后最后当我们所需要进行的操作都结束后我们要把游标释放掉。\n ```\n CLOSE cursor_name;  \n ```\n在使用游标时需要注意的是，使用定义一个针对NOT FOUND的条件处理函数(condition handler)来避免出现“no data to fetch”这样的错误，条件处理函数就是当某种条件产生时所执行的代码，这里但我们游标指到记录的末尾时，便达到NOT FOUND这样条件，这个时候我们希望继续进行后面的操作，所以我们会加CONTINUE。然后判断`no_more_flag`标志位来进行进一步的操作。\n```\n DECLARE  CONTINUE HANDLER \n \tFOR NOT FOUND  \n \tSET  no_more_flag = 1;\n \t/*when \"not found\" occur,just continue*/ \n```\n接下来会解释一下上面这个用法的意思。\n\n## 条件处理 / 错误、异常处理\n在游标里面我们有简要的介绍了一个NOT FOUND这个条件处理（错误、异常处理）的情况，条件处理涉及到两个语句，一个是`DECLARE...CONDITION`，另一个是`DECLARE....HANDLER`。\n\n### 1、DECLARE....HANDLER语句\n这个语句用于但数据库出现某种情况的时候(condition，大部分指发生某种错误时)，来定义具体的处理办法(handler)；所以这里涉及到包括：a、就是个什么情况 b、如何处理它；下面是其格式。\n```\nDECLARE handler_action HANDLER  \n    FOR condition_value [, condition_value] ...  #可以包括多种情况\n    statement  \n #处理方法有： \nhandler_action:  \n    CONTINUE  \n  | EXIT  \n  | UNDO  \n #存在情况有：\ncondition_value:  \n    mysql_error_code  # MySQL的错误代码\n  | SQLSTATE [VALUE] sqlstate_value  # 一个5个字符组成的字符串的错误信息，同错误代码类似形成一一对应的关系 \n  | condition_name  # 这个是条件名称，它使用DECLARE...CONDITION语句来定义\n  | SQLWARNING  # 表示SQLTATE中的字符串以‘01’起始的那些错误\n  | NOT FOUND  # 表示SQLTATE中的字符串以‘02’起始的那些错误\n  | SQLEXCEPTION  # 表示SQLSTATE中的字符串不是以'00'、'01'、'02' 起始的那些错误，这里'00'起始的SQLSTATE其实表示的是成功执行而不是错误，另外两个就是上面的`NOT FOUND`和`SQLWARNING`的两种情况。\n```\n#### a.condition_value\n 上面的6种情况其实可以分为两类，一类就是比较明确的处理，就是对指定的错误情况进行处理，包括前三种方式；另一类是对对应类型的错误的处理，就是对某一群错误的处理，包括后三种方式另外还要注意的一个内容是MySQL在默认情况下(也就是我们没有定义处理错误的方法-handler)自己的错误处理机制：\n 1、对于SQLWARNING和NOT FOUND的处理方法就是无视错误继续执行，所以在游标的例子里面如果我们没有对repeat的条件判断的那个值做个no_more_products=1的handler来处理，那么循环就会一直下去。\n 2、对于SQLEXCEPTION的话，其默认的处理方法是在出现错误的地方就终止掉了。\n\n#### b.statement\n 这个比较简单就是当出现某种条件/错误时，我们要执行的语句，可以是简单的如 SET  var = value这样的简单的语句，也可以是复杂的多行的语句，多行的话可以使用BEGIN  .....  END这里把语句包括在里面(这个好比delphi里面的情况，注意到我们的存储过程也是多行的，所以也要BEGIN .... END)。\n\n#### c.handler_action\n 这个表示当执行完上面的statement后，希望执行怎样的动作，这里包括CONTINUE、EXIT、UNDO，表示继续、退出、撤销(暂时不支持)。\n CONTINUE就是一个是SQLWARNING和NOT FOUND的默认处理方法，而EXIT就是SQLEXCEPTION的默认处理方法。\n\n### 2、DECLARE...CONDITION语句\n这个语句其实是为了让我们的错误条件更加的清晰明了化的。例如，SQLSTATE '23000'并不清晰，要通过相应的文档去对应 。\n`DECLARE....CONDITION`可以对条件定义相对应的名称。我们可以这样写：\n```\nDECLARE duplicate_key CONDITION FOR SQLSTATE '23000';  \nDECLARE CONTINUE HANDLER FOR duplicate_key  \n  BEGIN  \n    -- body of handler  \n  END;  \n```\n这样更加直观清晰。\n","slug":"mysql/存储过程学习小结","published":1,"updated":"2019-03-22T14:44:36.727Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0g009e4l3netjp79ff","content":"<h2 id=\"存储过程的概述\"><a href=\"#存储过程的概述\" class=\"headerlink\" title=\"存储过程的概述\"></a>存储过程的概述</h2><p>是在大型数据库系统中，一组为了完成特定功能的SQL语句集，存储在<code>数据库</code>中，经过第一次编译后再次调用不需要再次编译。外部程序可以直接调用数据库里面定义好的存储过程，另外数据库内部的触发器(trigger)、或者其他存储过程也可以调用它。</p>\n<a id=\"more\"></a>\n<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1.性能上的提高，减少了交互频率，提高了重用性。<br>2.类似于接口的概念，提高了安全性。尽管无法直接访问，但可以通过存储过程进行处理。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1.存储过程会加大数据库占用的系统资源。<br>2.无法编写复杂逻辑的存储过程，不容易调试。<br>3.存储过程书写及维护难度都比较大。</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DECLARE variable_name datatype(size)<span class=\"built_in\"> DEFAULT </span>default_value;</span><br></pre></td></tr></table></figure>\n<p>多个变量可以这样定义：<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DECLARE x, y INT<span class=\"built_in\"> DEFAULT </span>0 ;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"变量的赋值\"><a href=\"#变量的赋值\" class=\"headerlink\" title=\"变量的赋值\"></a>变量的赋值</h3><p>可以通过<code>set</code>或者<code>select...into...</code>来进行赋值。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> x =<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">count</span>(*) <span class=\"keyword\">into</span> x <span class=\"keyword\">from</span> usertabl;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"变量的scope-作用范围\"><a href=\"#变量的scope-作用范围\" class=\"headerlink\" title=\"变量的scope(作用范围)\"></a>变量的scope(作用范围)</h3><p>作用范围一般在begin和end之间。<br>还有一种是会话变量(session variable)，也叫做用户定义的变量(user defined variable)。这种变量要在变量名称前面加上“@”符号，作用域是全局。这个变量可以在被调用的存储过程或者代码之间共享数据。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>MySql的参数分为三类:IN、OUT、INOUT。</p>\n<p>IN(默认)：这是个默认的类型，也就是如果参数没指定类型的话，那么默认就是IN类型了，这种参数主要是传递进去的值，这个值提供给存储过程使用，另外存储过程对其做的改变不会对传入的参数发生作用。</p>\n<p>OUT：这个主要是存储过程要传递出去的值，也就是存储过程给你将它改变，并且传回去给调用它的程序。</p>\n<p>INOUT：则把上面两个的特点合在一起了，即可以传递值给存储过程使用，同时存储过程也可以改变这个值在传给调用它的程序。</p>\n<h3 id=\"参数的定义\"><a href=\"#参数的定义\" class=\"headerlink\" title=\"参数的定义\"></a>参数的定义</h3><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MODE</span> param_name param_<span class=\"keyword\">type</span>(param_size)；</span><br></pre></td></tr></table></figure>\n<p>这里的MODE指的就是以上的三类。</p>\n<h2 id=\"逻辑判断和循环\"><a href=\"#逻辑判断和循环\" class=\"headerlink\" title=\"逻辑判断和循环\"></a>逻辑判断和循环</h2><p>存储过程中也有对应的条件判断，功能类似于if、switch。在MySQL里面对应的是IF和CASE。MySQL的存储过程中可使用的循环有三种：WHILE、REPEAT、LOOP。</p>\n<h3 id=\"IF\"><a href=\"#IF\" class=\"headerlink\" title=\"IF\"></a>IF</h3><figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">IF</span> expression <span class=\"keyword\">THEN</span> commands  </span><br><span class=\"line\">   [<span class=\"keyword\">ELSEIF</span> expression <span class=\"keyword\">THEN</span> commands]  </span><br><span class=\"line\">   [<span class=\"keyword\">ELSE</span> commands]  </span><br><span class=\"line\">   <span class=\"keyword\">END</span> <span class=\"keyword\">IF</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CASE\"><a href=\"#CASE\" class=\"headerlink\" title=\"CASE\"></a>CASE</h3><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CASE</span>  case_expression  </span><br><span class=\"line\">   <span class=\"keyword\">WHEN</span> when_expression <span class=\"keyword\">THEN</span> commands  </span><br><span class=\"line\">   <span class=\"keyword\">WHEN</span> when_expression <span class=\"keyword\">THEN</span> commands  </span><br><span class=\"line\">   ...  </span><br><span class=\"line\">   <span class=\"keyword\">ELSE</span> commands  </span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">CASE</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"WHILE\"><a href=\"#WHILE\" class=\"headerlink\" title=\"WHILE\"></a>WHILE</h3><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WHILE</span> expression <span class=\"keyword\">DO</span>  </span><br><span class=\"line\">   <span class=\"built_in\">Statements</span>  </span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">WHILE</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"REPEAT\"><a href=\"#REPEAT\" class=\"headerlink\" title=\"REPEAT\"></a>REPEAT</h3><p>类似于<code>do...while...</code><br><figure class=\"highlight cal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">REPEAT</span>  </span><br><span class=\"line\">Statements;  </span><br><span class=\"line\"><span class=\"keyword\">UNTIL</span> expression  </span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">REPEAT</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"LOOP-及-LEAVE、ITERATE\"><a href=\"#LOOP-及-LEAVE、ITERATE\" class=\"headerlink\" title=\"LOOP 及 LEAVE、ITERATE\"></a>LOOP 及 LEAVE、ITERATE</h3><p>这里LOOP用来标记循环；而LEAVE表示离开循环，好比编程里面的break一样；ITERATE则继续循环，类型与编程里面的continue。<br>例.输出小于10的偶数：<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop_label:  <span class=\"keyword\">LOOP</span>  </span><br><span class=\"line\">  <span class=\"keyword\">IF</span>  x &gt; <span class=\"number\">10</span> <span class=\"keyword\">THEN</span>  </span><br><span class=\"line\">   LEAVE  loop_label;  </span><br><span class=\"line\">  <span class=\"keyword\">END</span>  <span class=\"keyword\">IF</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">SET</span>  x = x + <span class=\"number\">1</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">IF</span>  (x <span class=\"keyword\">mod</span> <span class=\"number\">2</span>) <span class=\"keyword\">THEN</span>  </span><br><span class=\"line\">   ITERATE  loop_label;  </span><br><span class=\"line\">  <span class=\"keyword\">ELSE</span>  </span><br><span class=\"line\">   <span class=\"keyword\">SET</span>  str = <span class=\"keyword\">CONCAT</span>(str,x,<span class=\"string\">','</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">END</span>  <span class=\"keyword\">IF</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">LOOP</span>;  </span><br><span class=\"line\"><span class=\"keyword\">select</span> str;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"游标\"><a href=\"#游标\" class=\"headerlink\" title=\"游标\"></a>游标</h2><p>游标的作用就是用于对查询数据库所返回的记录进行遍历，以便进行相应的操作。</p>\n<h3 id=\"游标属性\"><a href=\"#游标属性\" class=\"headerlink\" title=\"游标属性\"></a>游标属性</h3><p>游标有下列属性：<br>a、游标是只读的，也就是不能更新它；<br>b、游标是不能滚动的，也就是只能在一个方向上进行遍历，不能在记录之间随意进退，不能跳过某些记录；<br>c、避免在已经打开游标的表上更新数据。</p>\n<h3 id=\"游标的使用\"><a href=\"#游标的使用\" class=\"headerlink\" title=\"游标的使用\"></a>游标的使用</h3><p>a.首先用DECLARE语句声明一个游标<br> <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> cursor_name <span class=\"keyword\">CURSOR</span> <span class=\"keyword\">FOR</span> SELECT_statement;</span><br></pre></td></tr></table></figure></p>\n<p> 上面这条语句就给我们执行的select语句返回的记录指定了一个游标。</p>\n<p>b.其次需要使用OPEN语句来打开上面你定义的游标<br> <figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPEN cursor_name<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>c.接下来你可以用FETCH语句来获得下一行数据，并且游标也将移动到对应的记录上(这个就类似java里面的那个iterator)。<br> <figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FETCH cursor_name <span class=\"keyword\">INTO</span> <span class=\"built_in\">variable</span> <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure></p>\n<p>d.然后最后当我们所需要进行的操作都结束后我们要把游标释放掉。<br> <figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CLOSE </span>cursor_name<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>在使用游标时需要注意的是，使用定义一个针对NOT FOUND的条件处理函数(condition handler)来避免出现“no data to fetch”这样的错误，条件处理函数就是当某种条件产生时所执行的代码，这里但我们游标指到记录的末尾时，便达到NOT FOUND这样条件，这个时候我们希望继续进行后面的操作，所以我们会加CONTINUE。然后判断<code>no_more_flag</code>标志位来进行进一步的操作。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span>  CONTINUE <span class=\"keyword\">HANDLER</span> </span><br><span class=\"line\">\t<span class=\"keyword\">FOR</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">FOUND</span>  </span><br><span class=\"line\">\t<span class=\"keyword\">SET</span>  no_more_flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">/*when \"not found\" occur,just continue*/</span></span><br></pre></td></tr></table></figure></p>\n<p>接下来会解释一下上面这个用法的意思。</p>\n<h2 id=\"条件处理-错误、异常处理\"><a href=\"#条件处理-错误、异常处理\" class=\"headerlink\" title=\"条件处理 / 错误、异常处理\"></a>条件处理 / 错误、异常处理</h2><p>在游标里面我们有简要的介绍了一个NOT FOUND这个条件处理（错误、异常处理）的情况，条件处理涉及到两个语句，一个是<code>DECLARE...CONDITION</code>，另一个是<code>DECLARE....HANDLER</code>。</p>\n<h3 id=\"1、DECLARE…-HANDLER语句\"><a href=\"#1、DECLARE…-HANDLER语句\" class=\"headerlink\" title=\"1、DECLARE….HANDLER语句\"></a>1、DECLARE….HANDLER语句</h3><p>这个语句用于但数据库出现某种情况的时候(condition，大部分指发生某种错误时)，来定义具体的处理办法(handler)；所以这里涉及到包括：a、就是个什么情况 b、如何处理它；下面是其格式。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> handler_action <span class=\"keyword\">HANDLER</span>  </span><br><span class=\"line\">    <span class=\"keyword\">FOR</span> condition_value [, condition_value] ...  <span class=\"comment\">#可以包括多种情况</span></span><br><span class=\"line\">    <span class=\"keyword\">statement</span>  </span><br><span class=\"line\"> <span class=\"comment\">#处理方法有： </span></span><br><span class=\"line\">handler_action:  </span><br><span class=\"line\">    CONTINUE  </span><br><span class=\"line\">  | <span class=\"keyword\">EXIT</span>  </span><br><span class=\"line\">  | <span class=\"keyword\">UNDO</span>  </span><br><span class=\"line\"> <span class=\"comment\">#存在情况有：</span></span><br><span class=\"line\">condition_value:  </span><br><span class=\"line\">    mysql_error_code  <span class=\"comment\"># MySQL的错误代码</span></span><br><span class=\"line\">  | <span class=\"keyword\">SQLSTATE</span> [<span class=\"keyword\">VALUE</span>] sqlstate_value  <span class=\"comment\"># 一个5个字符组成的字符串的错误信息，同错误代码类似形成一一对应的关系 </span></span><br><span class=\"line\">  | condition_name  <span class=\"comment\"># 这个是条件名称，它使用DECLARE...CONDITION语句来定义</span></span><br><span class=\"line\">  | SQLWARNING  <span class=\"comment\"># 表示SQLTATE中的字符串以‘01’起始的那些错误</span></span><br><span class=\"line\">  | <span class=\"keyword\">NOT</span> <span class=\"keyword\">FOUND</span>  <span class=\"comment\"># 表示SQLTATE中的字符串以‘02’起始的那些错误</span></span><br><span class=\"line\">  | SQLEXCEPTION  <span class=\"comment\"># 表示SQLSTATE中的字符串不是以'00'、'01'、'02' 起始的那些错误，这里'00'起始的SQLSTATE其实表示的是成功执行而不是错误，另外两个就是上面的`NOT FOUND`和`SQLWARNING`的两种情况。</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"a-condition-value\"><a href=\"#a-condition-value\" class=\"headerlink\" title=\"a.condition_value\"></a>a.condition_value</h4><p> 上面的6种情况其实可以分为两类，一类就是比较明确的处理，就是对指定的错误情况进行处理，包括前三种方式；另一类是对对应类型的错误的处理，就是对某一群错误的处理，包括后三种方式另外还要注意的一个内容是MySQL在默认情况下(也就是我们没有定义处理错误的方法-handler)自己的错误处理机制：<br> 1、对于SQLWARNING和NOT FOUND的处理方法就是无视错误继续执行，所以在游标的例子里面如果我们没有对repeat的条件判断的那个值做个no_more_products=1的handler来处理，那么循环就会一直下去。<br> 2、对于SQLEXCEPTION的话，其默认的处理方法是在出现错误的地方就终止掉了。</p>\n<h4 id=\"b-statement\"><a href=\"#b-statement\" class=\"headerlink\" title=\"b.statement\"></a>b.statement</h4><p> 这个比较简单就是当出现某种条件/错误时，我们要执行的语句，可以是简单的如 SET  var = value这样的简单的语句，也可以是复杂的多行的语句，多行的话可以使用BEGIN  …..  END这里把语句包括在里面(这个好比delphi里面的情况，注意到我们的存储过程也是多行的，所以也要BEGIN …. END)。</p>\n<h4 id=\"c-handler-action\"><a href=\"#c-handler-action\" class=\"headerlink\" title=\"c.handler_action\"></a>c.handler_action</h4><p> 这个表示当执行完上面的statement后，希望执行怎样的动作，这里包括CONTINUE、EXIT、UNDO，表示继续、退出、撤销(暂时不支持)。<br> CONTINUE就是一个是SQLWARNING和NOT FOUND的默认处理方法，而EXIT就是SQLEXCEPTION的默认处理方法。</p>\n<h3 id=\"2、DECLARE…CONDITION语句\"><a href=\"#2、DECLARE…CONDITION语句\" class=\"headerlink\" title=\"2、DECLARE…CONDITION语句\"></a>2、DECLARE…CONDITION语句</h3><p>这个语句其实是为了让我们的错误条件更加的清晰明了化的。例如，SQLSTATE ‘23000’并不清晰，要通过相应的文档去对应 。<br><code>DECLARE....CONDITION</code>可以对条件定义相对应的名称。我们可以这样写：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> duplicate_key CONDITION <span class=\"keyword\">FOR</span> <span class=\"keyword\">SQLSTATE</span> <span class=\"string\">'23000'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> CONTINUE <span class=\"keyword\">HANDLER</span> <span class=\"keyword\">FOR</span> duplicate_key  </span><br><span class=\"line\">  <span class=\"keyword\">BEGIN</span>  </span><br><span class=\"line\">    <span class=\"comment\">-- body of handler  </span></span><br><span class=\"line\">  <span class=\"keyword\">END</span>;</span><br></pre></td></tr></table></figure></p>\n<p>这样更加直观清晰。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"存储过程的概述\"><a href=\"#存储过程的概述\" class=\"headerlink\" title=\"存储过程的概述\"></a>存储过程的概述</h2><p>是在大型数据库系统中，一组为了完成特定功能的SQL语句集，存储在<code>数据库</code>中，经过第一次编译后再次调用不需要再次编译。外部程序可以直接调用数据库里面定义好的存储过程，另外数据库内部的触发器(trigger)、或者其他存储过程也可以调用它。</p>","more":"<h3 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点\"></a>优点</h3><p>1.性能上的提高，减少了交互频率，提高了重用性。<br>2.类似于接口的概念，提高了安全性。尽管无法直接访问，但可以通过存储过程进行处理。</p>\n<h3 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h3><p>1.存储过程会加大数据库占用的系统资源。<br>2.无法编写复杂逻辑的存储过程，不容易调试。<br>3.存储过程书写及维护难度都比较大。</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DECLARE variable_name datatype(size)<span class=\"built_in\"> DEFAULT </span>default_value;</span><br></pre></td></tr></table></figure>\n<p>多个变量可以这样定义：<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DECLARE x, y INT<span class=\"built_in\"> DEFAULT </span>0 ;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"变量的赋值\"><a href=\"#变量的赋值\" class=\"headerlink\" title=\"变量的赋值\"></a>变量的赋值</h3><p>可以通过<code>set</code>或者<code>select...into...</code>来进行赋值。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">SET</span> x =<span class=\"number\">10</span>;</span><br><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">count</span>(*) <span class=\"keyword\">into</span> x <span class=\"keyword\">from</span> usertabl;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"变量的scope-作用范围\"><a href=\"#变量的scope-作用范围\" class=\"headerlink\" title=\"变量的scope(作用范围)\"></a>变量的scope(作用范围)</h3><p>作用范围一般在begin和end之间。<br>还有一种是会话变量(session variable)，也叫做用户定义的变量(user defined variable)。这种变量要在变量名称前面加上“@”符号，作用域是全局。这个变量可以在被调用的存储过程或者代码之间共享数据。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><p>MySql的参数分为三类:IN、OUT、INOUT。</p>\n<p>IN(默认)：这是个默认的类型，也就是如果参数没指定类型的话，那么默认就是IN类型了，这种参数主要是传递进去的值，这个值提供给存储过程使用，另外存储过程对其做的改变不会对传入的参数发生作用。</p>\n<p>OUT：这个主要是存储过程要传递出去的值，也就是存储过程给你将它改变，并且传回去给调用它的程序。</p>\n<p>INOUT：则把上面两个的特点合在一起了，即可以传递值给存储过程使用，同时存储过程也可以改变这个值在传给调用它的程序。</p>\n<h3 id=\"参数的定义\"><a href=\"#参数的定义\" class=\"headerlink\" title=\"参数的定义\"></a>参数的定义</h3><figure class=\"highlight elm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">MODE</span> param_name param_<span class=\"keyword\">type</span>(param_size)；</span><br></pre></td></tr></table></figure>\n<p>这里的MODE指的就是以上的三类。</p>\n<h2 id=\"逻辑判断和循环\"><a href=\"#逻辑判断和循环\" class=\"headerlink\" title=\"逻辑判断和循环\"></a>逻辑判断和循环</h2><p>存储过程中也有对应的条件判断，功能类似于if、switch。在MySQL里面对应的是IF和CASE。MySQL的存储过程中可使用的循环有三种：WHILE、REPEAT、LOOP。</p>\n<h3 id=\"IF\"><a href=\"#IF\" class=\"headerlink\" title=\"IF\"></a>IF</h3><figure class=\"highlight monkey\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">IF</span> expression <span class=\"keyword\">THEN</span> commands  </span><br><span class=\"line\">   [<span class=\"keyword\">ELSEIF</span> expression <span class=\"keyword\">THEN</span> commands]  </span><br><span class=\"line\">   [<span class=\"keyword\">ELSE</span> commands]  </span><br><span class=\"line\">   <span class=\"keyword\">END</span> <span class=\"keyword\">IF</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"CASE\"><a href=\"#CASE\" class=\"headerlink\" title=\"CASE\"></a>CASE</h3><figure class=\"highlight ada\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CASE</span>  case_expression  </span><br><span class=\"line\">   <span class=\"keyword\">WHEN</span> when_expression <span class=\"keyword\">THEN</span> commands  </span><br><span class=\"line\">   <span class=\"keyword\">WHEN</span> when_expression <span class=\"keyword\">THEN</span> commands  </span><br><span class=\"line\">   ...  </span><br><span class=\"line\">   <span class=\"keyword\">ELSE</span> commands  </span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">CASE</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"WHILE\"><a href=\"#WHILE\" class=\"headerlink\" title=\"WHILE\"></a>WHILE</h3><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WHILE</span> expression <span class=\"keyword\">DO</span>  </span><br><span class=\"line\">   <span class=\"built_in\">Statements</span>  </span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">WHILE</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"REPEAT\"><a href=\"#REPEAT\" class=\"headerlink\" title=\"REPEAT\"></a>REPEAT</h3><p>类似于<code>do...while...</code><br><figure class=\"highlight cal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">REPEAT</span>  </span><br><span class=\"line\">Statements;  </span><br><span class=\"line\"><span class=\"keyword\">UNTIL</span> expression  </span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">REPEAT</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"LOOP-及-LEAVE、ITERATE\"><a href=\"#LOOP-及-LEAVE、ITERATE\" class=\"headerlink\" title=\"LOOP 及 LEAVE、ITERATE\"></a>LOOP 及 LEAVE、ITERATE</h3><p>这里LOOP用来标记循环；而LEAVE表示离开循环，好比编程里面的break一样；ITERATE则继续循环，类型与编程里面的continue。<br>例.输出小于10的偶数：<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">loop_label:  <span class=\"keyword\">LOOP</span>  </span><br><span class=\"line\">  <span class=\"keyword\">IF</span>  x &gt; <span class=\"number\">10</span> <span class=\"keyword\">THEN</span>  </span><br><span class=\"line\">   LEAVE  loop_label;  </span><br><span class=\"line\">  <span class=\"keyword\">END</span>  <span class=\"keyword\">IF</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">SET</span>  x = x + <span class=\"number\">1</span>;  </span><br><span class=\"line\">  <span class=\"keyword\">IF</span>  (x <span class=\"keyword\">mod</span> <span class=\"number\">2</span>) <span class=\"keyword\">THEN</span>  </span><br><span class=\"line\">   ITERATE  loop_label;  </span><br><span class=\"line\">  <span class=\"keyword\">ELSE</span>  </span><br><span class=\"line\">   <span class=\"keyword\">SET</span>  str = <span class=\"keyword\">CONCAT</span>(str,x,<span class=\"string\">','</span>);  </span><br><span class=\"line\">  <span class=\"keyword\">END</span>  <span class=\"keyword\">IF</span>;  </span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"keyword\">END</span> <span class=\"keyword\">LOOP</span>;  </span><br><span class=\"line\"><span class=\"keyword\">select</span> str;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"游标\"><a href=\"#游标\" class=\"headerlink\" title=\"游标\"></a>游标</h2><p>游标的作用就是用于对查询数据库所返回的记录进行遍历，以便进行相应的操作。</p>\n<h3 id=\"游标属性\"><a href=\"#游标属性\" class=\"headerlink\" title=\"游标属性\"></a>游标属性</h3><p>游标有下列属性：<br>a、游标是只读的，也就是不能更新它；<br>b、游标是不能滚动的，也就是只能在一个方向上进行遍历，不能在记录之间随意进退，不能跳过某些记录；<br>c、避免在已经打开游标的表上更新数据。</p>\n<h3 id=\"游标的使用\"><a href=\"#游标的使用\" class=\"headerlink\" title=\"游标的使用\"></a>游标的使用</h3><p>a.首先用DECLARE语句声明一个游标<br> <figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> cursor_name <span class=\"keyword\">CURSOR</span> <span class=\"keyword\">FOR</span> SELECT_statement;</span><br></pre></td></tr></table></figure></p>\n<p> 上面这条语句就给我们执行的select语句返回的记录指定了一个游标。</p>\n<p>b.其次需要使用OPEN语句来打开上面你定义的游标<br> <figure class=\"highlight abnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OPEN cursor_name<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>c.接下来你可以用FETCH语句来获得下一行数据，并且游标也将移动到对应的记录上(这个就类似java里面的那个iterator)。<br> <figure class=\"highlight lasso\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FETCH cursor_name <span class=\"keyword\">INTO</span> <span class=\"built_in\">variable</span> <span class=\"built_in\">list</span>;</span><br></pre></td></tr></table></figure></p>\n<p>d.然后最后当我们所需要进行的操作都结束后我们要把游标释放掉。<br> <figure class=\"highlight mipsasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CLOSE </span>cursor_name<span class=\"comment\">;</span></span><br></pre></td></tr></table></figure></p>\n<p>在使用游标时需要注意的是，使用定义一个针对NOT FOUND的条件处理函数(condition handler)来避免出现“no data to fetch”这样的错误，条件处理函数就是当某种条件产生时所执行的代码，这里但我们游标指到记录的末尾时，便达到NOT FOUND这样条件，这个时候我们希望继续进行后面的操作，所以我们会加CONTINUE。然后判断<code>no_more_flag</code>标志位来进行进一步的操作。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span>  CONTINUE <span class=\"keyword\">HANDLER</span> </span><br><span class=\"line\">\t<span class=\"keyword\">FOR</span> <span class=\"keyword\">NOT</span> <span class=\"keyword\">FOUND</span>  </span><br><span class=\"line\">\t<span class=\"keyword\">SET</span>  no_more_flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"comment\">/*when \"not found\" occur,just continue*/</span></span><br></pre></td></tr></table></figure></p>\n<p>接下来会解释一下上面这个用法的意思。</p>\n<h2 id=\"条件处理-错误、异常处理\"><a href=\"#条件处理-错误、异常处理\" class=\"headerlink\" title=\"条件处理 / 错误、异常处理\"></a>条件处理 / 错误、异常处理</h2><p>在游标里面我们有简要的介绍了一个NOT FOUND这个条件处理（错误、异常处理）的情况，条件处理涉及到两个语句，一个是<code>DECLARE...CONDITION</code>，另一个是<code>DECLARE....HANDLER</code>。</p>\n<h3 id=\"1、DECLARE…-HANDLER语句\"><a href=\"#1、DECLARE…-HANDLER语句\" class=\"headerlink\" title=\"1、DECLARE….HANDLER语句\"></a>1、DECLARE….HANDLER语句</h3><p>这个语句用于但数据库出现某种情况的时候(condition，大部分指发生某种错误时)，来定义具体的处理办法(handler)；所以这里涉及到包括：a、就是个什么情况 b、如何处理它；下面是其格式。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> handler_action <span class=\"keyword\">HANDLER</span>  </span><br><span class=\"line\">    <span class=\"keyword\">FOR</span> condition_value [, condition_value] ...  <span class=\"comment\">#可以包括多种情况</span></span><br><span class=\"line\">    <span class=\"keyword\">statement</span>  </span><br><span class=\"line\"> <span class=\"comment\">#处理方法有： </span></span><br><span class=\"line\">handler_action:  </span><br><span class=\"line\">    CONTINUE  </span><br><span class=\"line\">  | <span class=\"keyword\">EXIT</span>  </span><br><span class=\"line\">  | <span class=\"keyword\">UNDO</span>  </span><br><span class=\"line\"> <span class=\"comment\">#存在情况有：</span></span><br><span class=\"line\">condition_value:  </span><br><span class=\"line\">    mysql_error_code  <span class=\"comment\"># MySQL的错误代码</span></span><br><span class=\"line\">  | <span class=\"keyword\">SQLSTATE</span> [<span class=\"keyword\">VALUE</span>] sqlstate_value  <span class=\"comment\"># 一个5个字符组成的字符串的错误信息，同错误代码类似形成一一对应的关系 </span></span><br><span class=\"line\">  | condition_name  <span class=\"comment\"># 这个是条件名称，它使用DECLARE...CONDITION语句来定义</span></span><br><span class=\"line\">  | SQLWARNING  <span class=\"comment\"># 表示SQLTATE中的字符串以‘01’起始的那些错误</span></span><br><span class=\"line\">  | <span class=\"keyword\">NOT</span> <span class=\"keyword\">FOUND</span>  <span class=\"comment\"># 表示SQLTATE中的字符串以‘02’起始的那些错误</span></span><br><span class=\"line\">  | SQLEXCEPTION  <span class=\"comment\"># 表示SQLSTATE中的字符串不是以'00'、'01'、'02' 起始的那些错误，这里'00'起始的SQLSTATE其实表示的是成功执行而不是错误，另外两个就是上面的`NOT FOUND`和`SQLWARNING`的两种情况。</span></span><br></pre></td></tr></table></figure></p>\n<h4 id=\"a-condition-value\"><a href=\"#a-condition-value\" class=\"headerlink\" title=\"a.condition_value\"></a>a.condition_value</h4><p> 上面的6种情况其实可以分为两类，一类就是比较明确的处理，就是对指定的错误情况进行处理，包括前三种方式；另一类是对对应类型的错误的处理，就是对某一群错误的处理，包括后三种方式另外还要注意的一个内容是MySQL在默认情况下(也就是我们没有定义处理错误的方法-handler)自己的错误处理机制：<br> 1、对于SQLWARNING和NOT FOUND的处理方法就是无视错误继续执行，所以在游标的例子里面如果我们没有对repeat的条件判断的那个值做个no_more_products=1的handler来处理，那么循环就会一直下去。<br> 2、对于SQLEXCEPTION的话，其默认的处理方法是在出现错误的地方就终止掉了。</p>\n<h4 id=\"b-statement\"><a href=\"#b-statement\" class=\"headerlink\" title=\"b.statement\"></a>b.statement</h4><p> 这个比较简单就是当出现某种条件/错误时，我们要执行的语句，可以是简单的如 SET  var = value这样的简单的语句，也可以是复杂的多行的语句，多行的话可以使用BEGIN  …..  END这里把语句包括在里面(这个好比delphi里面的情况，注意到我们的存储过程也是多行的，所以也要BEGIN …. END)。</p>\n<h4 id=\"c-handler-action\"><a href=\"#c-handler-action\" class=\"headerlink\" title=\"c.handler_action\"></a>c.handler_action</h4><p> 这个表示当执行完上面的statement后，希望执行怎样的动作，这里包括CONTINUE、EXIT、UNDO，表示继续、退出、撤销(暂时不支持)。<br> CONTINUE就是一个是SQLWARNING和NOT FOUND的默认处理方法，而EXIT就是SQLEXCEPTION的默认处理方法。</p>\n<h3 id=\"2、DECLARE…CONDITION语句\"><a href=\"#2、DECLARE…CONDITION语句\" class=\"headerlink\" title=\"2、DECLARE…CONDITION语句\"></a>2、DECLARE…CONDITION语句</h3><p>这个语句其实是为了让我们的错误条件更加的清晰明了化的。例如，SQLSTATE ‘23000’并不清晰，要通过相应的文档去对应 。<br><code>DECLARE....CONDITION</code>可以对条件定义相对应的名称。我们可以这样写：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">DECLARE</span> duplicate_key CONDITION <span class=\"keyword\">FOR</span> <span class=\"keyword\">SQLSTATE</span> <span class=\"string\">'23000'</span>;  </span><br><span class=\"line\"><span class=\"keyword\">DECLARE</span> CONTINUE <span class=\"keyword\">HANDLER</span> <span class=\"keyword\">FOR</span> duplicate_key  </span><br><span class=\"line\">  <span class=\"keyword\">BEGIN</span>  </span><br><span class=\"line\">    <span class=\"comment\">-- body of handler  </span></span><br><span class=\"line\">  <span class=\"keyword\">END</span>;</span><br></pre></td></tr></table></figure></p>\n<p>这样更加直观清晰。</p>"},{"title":"数据库杂记","date":"2016-10-21T13:22:50.000Z","_content":"\n最近面试面到数据结构的题有点爆炸。基本都忘光了，记录一下基础的东西吧。\n\n<!--more-->\n\n## SQL语言的基本概念\n数据(Data)是数据库中存储的基本对象。\n\n数据库(DataBase，简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。\n\n\n数据库管理系统(DBMS，Database Management System)\n位于用户与操作系统之间的一层数据管理软件。\n是基础软件，是一个大型复杂的软件系统。\n\n数据库系统(DBS，DataBase System)在计算机系统中引入数据库后的系统构成，包括硬件、软件、数据和人员。\n\n### SQL语言的主要特点\n1.SQL语言是一种非过程语言，即用户只要提出“干什么”即可，不必管具体操作过程，也不必了解数据的存取路径，只要指明所需的数据即可。\n\n2.SQL语言是一种面向集合的语言，每个命令的操作对象是一个或多个关系，结果也是一个关系。\n\n3.SQL语言既是自含式语言，又是嵌入式语言。可独立使用交互命令，适用于终端用户、应用程序员和DBA；也可嵌入在高级语言中使用，供应用程序员开发应用程序。\n\nSQL语言具有:\n数据定义（DEFINITION）(CREATE,DROP,ALTER)，\n数据查询（QUERY）(SELECT)，\n数据操纵（MANIPULATION）(INSERT,UPDATE,DELETE)，\n数据控制（CONTROL）(GRANT,REVOKE)。\n\n基本表（BASE TABLE）：是独立存在的表，不是由其它的表导出的表。一个关系对应一个基本表，一个或多个基本表对应一个存储文件。\n\n视图（VIEW）：\n是一个虚拟的表，是从一个或几个基本表导出的表。它本身不独立存在于数据库中，数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。\n当基本表中的数据发生变化时，从视图中查询出来的数据也随之改变。\n\n在用户看来，视图是通过不同路径去看一个实际表，就象一个窗口一样，我们通过窗户去看外面的高楼，可以看到高楼的不同部分，而透过视图可以看到数据库中自己感兴趣的内容。\n\n索引（INDEX）：是一种和表格或视图有关的结构，可以加快从表格或视图中获得数据行。表格索引可以是群集的，也可以是非群集的。群集指数据在物理上是基于索引关键字的顺序存放的。\n\n关键字：是众多列中一列或组，它唯一识别一行（主关键字），定义两个表格之间的关系（外关键字），或者用于构建一个索引\n\n存储过程：是一种Transact-SQL语句，它们被编译成一个执行计划。该过程用于性能优化和控制访问。\n\n约束：定义了有关列中允许的值的规则，是加强数据完整性的标准机制。\n\n触发器：存储过程的一个特殊类，用于当对一个表格或视图发出update、insert 或delete语句时，能自动执行。\n\n\n### 三级模式结构\nSQL语言支持数据库的三级模式结构，如图所示。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。\n\n![三级模式结构](http://p1.bqimg.com/567571/405330844246062d.png)\n\n\n\n## 基本表的操作\n### 创建基本表\n创建一个数据表时主要包括以下几个组成部分：\n\n（1）字段名（列名）：字段名可长达128个字符。字段名可包含中文、英文字母、下划线、#号、货币符号（￥）及AT符号(@)。同一表中不许有重名列；\n\n（2）字段数据类型；\n\n（3）字段的长度、精度和小数位数；\n\n（4）NULL值与DEFAULT值：DEFAULT值表示某一字段的默认值，当没有输入数据时，则使用此默认的值。\n\n 在SQL语言中，使用语句CREATE TABLE创建数据表，其基本语法格式为：\n ```\nCREATE TABLE [ database_name . [ schema_name ] . | schema_name . ] <表名>\n  (     <列定义>[{，<列定义>|<表约束>}][,\n        [CONSTRAINT 主键约束] PRIMARY KY （属性名）][,\n        [CONSTRAINT 检查约束] CHECK（逻辑表达式）][,\n        [CONSTRAINT 外键约束] REFRENCES 参照表（参照属性）[,…n]]\n  )\n  [ON {文件组|默认文件组}]\n```    \n### 定义完整性约束\n在SQL SERVER中可以定义五种类型的完整性约束。\n#### NULL/NOT NULL\n是否允许该字段的值为NULL。表示“不知道”、“不确定”或“没有数据”的意思。\n如主键列就不允许出现空值，否则就失去了唯一标识一条记录的作用\n#### UNIQUE约束\n用于指明基本表在某一列或多个列的组合上的取值必须唯一。\n\n定义了UNIQUE约束的那些列称为唯一键，系统自动为唯一键建立唯一索引，从而保证了唯一键的唯一性。\n#### PRIMARY KEY约束\nPRIMARY KEY约束用于定义基本表的主键，起唯一标识作用，其值不能为NULL，也不能重复，以此来保证实体的完整性。\nPRIMARY KEY与UNIQUE的区别：\n1.在一个基本表中只能定义一个PRIMARY KEY约束，但可定义多个UNIQUE约束；\n2.对于指定为PRIMARY KEY的一个列或多个列的组合，其中任何一个列都不能出现空值，而对于UNIQUE所约束的唯一键，则允许为空。\n#### FOREIGN KEY约束\nFOREIGN KEY约束指定某一个列或一组列作为外部键，其中，包含外部键的表称为从表，包含外部键所引用的主键或唯一键的表称主表。\n#### CHECK约束\nCHECK约束用来检查字段值所允许的范围，如，一个字段只能输入整数，而且限定在0-100的整数，以此来保证域的完整性。\n\n\n\n### 修改基本表\n由于应用环境和应用需求的变化，经常需要修改基本表的结构，比如，增加新列和完整性约束、修改原有的列定义和完整性约束等。\n#### ADD方式\n用于增加新列和完整性约束。\n\n定义方式同`CREATE TABLE`语句中的定义方式相同，其语法格式为：\n```\n//ALTER TABLE <表名> ADD <列定义> | <完整性约束定义>\nALTER TABLE Student ADD   RegisterDate DATETIME,\n```\n#### ALTER方式\n\n用于修改某些列，其语法格式为：\n```\n//ALTER TABLE<表名> ALTER COLUMN <列名><数据类型>[NULL|NOT NULL]\nALTER TABLE Student ALTER COLUMN Sage SMALEINT NULL\n```\n要求：\n1.不能改变列名；\n2.不能将含有空值的列的定义修改为NOT NULL约束；\n3.若列中已有数据，则不能减少该列的宽度，也不能改变其数据类型；\n4.只能修改NULL|NOT NULL约束，其它类型的约束在修改之前必须先删除，然后再重新添加修改过的约束定义。\n\n#### DROP方式\n删除完整性约束定义，其语法格式为：\n```\n//ALTER TABLE<表名> DROP CONSTRAINT <约束名>\nALTER TABLE Student DROP  UNIQUE(SNAME)\n```\n\n### 删除基本表\n```\nDROP TABLE <表名>\n```\n## 数据库表的基本操作\nSQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。\n\n### 插入数据记录\n有两种方式，一种是向具体记录插入常量数据；另一种是把子查询的结果输入到另一个表中去。前者智能插入一条数据，后者一次可以插入多条。\n#### 插入一行新记录\n```\n//INSERT INTO <表名>[(<列名1>[,<列名2>…])] VALUES(<值>)\n\nINSERT INTO  S VALUES  ('s7','小刚','男',21,'计算机')\n\n```\n注意：\n\n必须用逗号将各个数据分开，字符型数据要用单引号括起来。\n\nINTO子句中没有指定列名，则新插入的记录必须在每个属性列上均有值，且VALUES子句中值的排列顺序要和表中各属性列的排列顺序一致。\n#### 插入一行部分数据\n在SC表中插入一条选课记录（’S7’,’C1’）。\n```\nINSERT INTO SC (SNO,CNO)\n         VALUES ('s7',‘c1')\n```\n注意：\n\n将VALUES子句中的值按照INTO子句中指定列名的顺序插入到表中。\n\n对于INTO子句中没有出现的列，则新插入的记录在这些列上将取空值，如上例的SCORE即赋空值。\n但在表定义时有NOT NULL约束的属性列不能取空值。      \n#### 插入多行记录\n1.\n```\nINSERT INTO `userTable` (`user_id`, `user_name`) VALUES\n(1, 'dsf'),\n(2, 'fgy'),\n(3, 'faad');\n```\n这样只需执行一次SQL查询，即可插入多行记录，大大提高了效率，使用php编程的时候，可以使用字符串连接的方式连接sql语句即可:\n```\n$a = 1;\nwhile (5 == $a)\n{\n    if (1 == $a)\n        $sql = \"INSERT INTO tbl_name (col1,col2) VALUES ($a,$b)\";\n    else\n        $sql .= \",($a,$b)\";\n\n    $a++;\n    $b++;\n}\n```\nmysql_query($sql);\n用于表间的拷贝，将一个表中的数据抽取数行插入另一表中，可以通过子查询来实现。\n```\n///INSERT INTO <表名> [(<列名1>[,<列名2>…])] 子查询\nINSERT INTO MySalesReason\n    SELECT SalesReasonID, Name, ModifiedDate\n    FROM AdventureWorks2008R2.Sales.SalesReason\n    WHERE ReasonType = N'Marketing';\n```\n### 修改数据记录\n```\n//UPDATE <表名> SET <列名>=<表达式> [,<列名>=<表达式>]…[WHERE <条件>]\n//修改一行\n\nUPDATE T \n    SET DEPT='信息' \n  WHERE TN='刘伟'\n\n//用子查询选择要修改的行\nUPDATE T \n\tSET COMN=COMN+100\n WHERE TNO IN \n\t (SELECT T.TNO \n\t\tFROM T,TC\n\t   WHERE T.TNO=TC.TNO\n\t\t\tAND TC.CNO='C5')\n//用子查询提供要修改的值\n\nUPDATE T\n\tSET SAL =\n\t\t(SELECT 1.2*AVG(SAL) \n\t\tFROM T)\n```\n### 删除数据记录\n```\n//DELETE FROM <表名> [WHERE <条件>]\n//删除一行\nDELETE \n    FROM T \n WHERE TN=’刘伟’\n//删除多行\nDELETE \n    FROM TC\n//利用子查询选择要删除的行\nDELETE\n    FROM TC \n WHERE TNO=  \n     (SELECT TNO\n          FROM T\n       WHERE TN=’ 刘伟’)\n```\n\n\n## 索引\n索引的作用：\n1. 加快查询速度；\n2. 保证行的唯一性。\n### 索引的分类\n按照索引记录的存放位置分类：\n\n聚集索引：按照索引的字段排列记录，并且依照排好的顺序将记录存储在表中。\n\n非聚集索引：按照索引的字段排列记录，但是排列的结果并不会存储在表中，而是另外存储。\n\n### 唯一索引\n唯一索引表示表中每一个索引值只对应唯一的数据记录，\n这与表的PRIMARY KEY的特性类似，因此唯一性索引常用于PRIMARY KEY的字段上，以区别每一笔记录。\n\n当表中有被设置为UNIQUE的字段时，SQL SERVER会自动建立一个非聚集的唯一性索引。\n\n而当表中有PRIMARY KEY的字段时，SQL SERVER会在PRIMARY KEY字段建立一个非聚集索引。\n\n### 建立索引\n```\n//CREATE [UNIQUE] [CLUSTERED|NONCLUSTERED] INDEX <索引名> ON <表名>  (<列名> [次序] [{,<列名>}] [次序]…)\n//在agent表中建立一个索引aidx，保证每一行都有唯一的aid值。\ncreate unique index aidx on agents(aid);\n```\n次序用来指定索引值的排列顺序，可为ASC（升序）或DESC（降序），缺省值为ASC。\n```\nUSE STUDENT\nCREATE UNIQUE INDEX SCI ON SC(SNO,CNO)\n```\n执行此命令后，为SC表建立一个索引名为SCI的唯一索引\n此索引为SNO和CNO两列的复合索引，即对SC表中的行先按SNO的递增顺序索引，对于相同的SNO，又按CNO的递增顺序索引。\n### 删除索引\n建立索引是为了提高查询速度，但随着索引的增多，数据更新时，系统会花费许多时间来维护索引。这时，应删除不必要的索引。\n```\n//DROP INDEX 数据表名.索引名\n//删除表SC的索引SCI。\t\t\nDROP INDEX SC.SCI\n```\n### 查看索引\n#### 查看索引信息\n报告有关表或视图上索引的信息，当前数据库中表或视图的名称的数据类型为nvarchar(776)。\n```\n//sp_helpindex [ @objname = ] '表或视图的名称'\nUse  eduDB\nGO\nsp_helpindex  \n```\n#### 查看索引的空间信息\n显示行数、保留的磁盘空间以及当前数据库中的表所使用的磁盘空间，或显示由整个数据库保留和使用的磁盘空间\n\n```\nsp_spaceused ['表的名称']\n```\n\n### 事务\n数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。\n\n1.原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n2.一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。\n\n3.隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。\n\n4.持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n\ndrop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始。delete删除表中数据，可以加where字句。\n\n\n### ER图\n\n在ER图中有如下四个成分：\n矩形框：表示实体，在框中记入实体名。\n菱形框：表示联系，在框中记入联系名。\n椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。\n连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)\n\n### 冗余字段\n冗余字段，是设计数据的时候常用的一种手段。优点是，可以在很大程度上避免数据库的关联查询，不使用join提升查询速度。缺点是，数据一致性维护成本高，需要维护冗余字段的一致性。\n\n### 存储过程与触发器的区别\n\n触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。\n\n两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。","source":"_posts/mysql/数据库杂记.md","raw":"---\ntitle: 数据库杂记\ndate: 2016-10-21 21:22:50\ntags: \n- 数据库\ncategories: 总结\n---\n\n最近面试面到数据结构的题有点爆炸。基本都忘光了，记录一下基础的东西吧。\n\n<!--more-->\n\n## SQL语言的基本概念\n数据(Data)是数据库中存储的基本对象。\n\n数据库(DataBase，简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。\n\n\n数据库管理系统(DBMS，Database Management System)\n位于用户与操作系统之间的一层数据管理软件。\n是基础软件，是一个大型复杂的软件系统。\n\n数据库系统(DBS，DataBase System)在计算机系统中引入数据库后的系统构成，包括硬件、软件、数据和人员。\n\n### SQL语言的主要特点\n1.SQL语言是一种非过程语言，即用户只要提出“干什么”即可，不必管具体操作过程，也不必了解数据的存取路径，只要指明所需的数据即可。\n\n2.SQL语言是一种面向集合的语言，每个命令的操作对象是一个或多个关系，结果也是一个关系。\n\n3.SQL语言既是自含式语言，又是嵌入式语言。可独立使用交互命令，适用于终端用户、应用程序员和DBA；也可嵌入在高级语言中使用，供应用程序员开发应用程序。\n\nSQL语言具有:\n数据定义（DEFINITION）(CREATE,DROP,ALTER)，\n数据查询（QUERY）(SELECT)，\n数据操纵（MANIPULATION）(INSERT,UPDATE,DELETE)，\n数据控制（CONTROL）(GRANT,REVOKE)。\n\n基本表（BASE TABLE）：是独立存在的表，不是由其它的表导出的表。一个关系对应一个基本表，一个或多个基本表对应一个存储文件。\n\n视图（VIEW）：\n是一个虚拟的表，是从一个或几个基本表导出的表。它本身不独立存在于数据库中，数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。\n当基本表中的数据发生变化时，从视图中查询出来的数据也随之改变。\n\n在用户看来，视图是通过不同路径去看一个实际表，就象一个窗口一样，我们通过窗户去看外面的高楼，可以看到高楼的不同部分，而透过视图可以看到数据库中自己感兴趣的内容。\n\n索引（INDEX）：是一种和表格或视图有关的结构，可以加快从表格或视图中获得数据行。表格索引可以是群集的，也可以是非群集的。群集指数据在物理上是基于索引关键字的顺序存放的。\n\n关键字：是众多列中一列或组，它唯一识别一行（主关键字），定义两个表格之间的关系（外关键字），或者用于构建一个索引\n\n存储过程：是一种Transact-SQL语句，它们被编译成一个执行计划。该过程用于性能优化和控制访问。\n\n约束：定义了有关列中允许的值的规则，是加强数据完整性的标准机制。\n\n触发器：存储过程的一个特殊类，用于当对一个表格或视图发出update、insert 或delete语句时，能自动执行。\n\n\n### 三级模式结构\nSQL语言支持数据库的三级模式结构，如图所示。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。\n\n![三级模式结构](http://p1.bqimg.com/567571/405330844246062d.png)\n\n\n\n## 基本表的操作\n### 创建基本表\n创建一个数据表时主要包括以下几个组成部分：\n\n（1）字段名（列名）：字段名可长达128个字符。字段名可包含中文、英文字母、下划线、#号、货币符号（￥）及AT符号(@)。同一表中不许有重名列；\n\n（2）字段数据类型；\n\n（3）字段的长度、精度和小数位数；\n\n（4）NULL值与DEFAULT值：DEFAULT值表示某一字段的默认值，当没有输入数据时，则使用此默认的值。\n\n 在SQL语言中，使用语句CREATE TABLE创建数据表，其基本语法格式为：\n ```\nCREATE TABLE [ database_name . [ schema_name ] . | schema_name . ] <表名>\n  (     <列定义>[{，<列定义>|<表约束>}][,\n        [CONSTRAINT 主键约束] PRIMARY KY （属性名）][,\n        [CONSTRAINT 检查约束] CHECK（逻辑表达式）][,\n        [CONSTRAINT 外键约束] REFRENCES 参照表（参照属性）[,…n]]\n  )\n  [ON {文件组|默认文件组}]\n```    \n### 定义完整性约束\n在SQL SERVER中可以定义五种类型的完整性约束。\n#### NULL/NOT NULL\n是否允许该字段的值为NULL。表示“不知道”、“不确定”或“没有数据”的意思。\n如主键列就不允许出现空值，否则就失去了唯一标识一条记录的作用\n#### UNIQUE约束\n用于指明基本表在某一列或多个列的组合上的取值必须唯一。\n\n定义了UNIQUE约束的那些列称为唯一键，系统自动为唯一键建立唯一索引，从而保证了唯一键的唯一性。\n#### PRIMARY KEY约束\nPRIMARY KEY约束用于定义基本表的主键，起唯一标识作用，其值不能为NULL，也不能重复，以此来保证实体的完整性。\nPRIMARY KEY与UNIQUE的区别：\n1.在一个基本表中只能定义一个PRIMARY KEY约束，但可定义多个UNIQUE约束；\n2.对于指定为PRIMARY KEY的一个列或多个列的组合，其中任何一个列都不能出现空值，而对于UNIQUE所约束的唯一键，则允许为空。\n#### FOREIGN KEY约束\nFOREIGN KEY约束指定某一个列或一组列作为外部键，其中，包含外部键的表称为从表，包含外部键所引用的主键或唯一键的表称主表。\n#### CHECK约束\nCHECK约束用来检查字段值所允许的范围，如，一个字段只能输入整数，而且限定在0-100的整数，以此来保证域的完整性。\n\n\n\n### 修改基本表\n由于应用环境和应用需求的变化，经常需要修改基本表的结构，比如，增加新列和完整性约束、修改原有的列定义和完整性约束等。\n#### ADD方式\n用于增加新列和完整性约束。\n\n定义方式同`CREATE TABLE`语句中的定义方式相同，其语法格式为：\n```\n//ALTER TABLE <表名> ADD <列定义> | <完整性约束定义>\nALTER TABLE Student ADD   RegisterDate DATETIME,\n```\n#### ALTER方式\n\n用于修改某些列，其语法格式为：\n```\n//ALTER TABLE<表名> ALTER COLUMN <列名><数据类型>[NULL|NOT NULL]\nALTER TABLE Student ALTER COLUMN Sage SMALEINT NULL\n```\n要求：\n1.不能改变列名；\n2.不能将含有空值的列的定义修改为NOT NULL约束；\n3.若列中已有数据，则不能减少该列的宽度，也不能改变其数据类型；\n4.只能修改NULL|NOT NULL约束，其它类型的约束在修改之前必须先删除，然后再重新添加修改过的约束定义。\n\n#### DROP方式\n删除完整性约束定义，其语法格式为：\n```\n//ALTER TABLE<表名> DROP CONSTRAINT <约束名>\nALTER TABLE Student DROP  UNIQUE(SNAME)\n```\n\n### 删除基本表\n```\nDROP TABLE <表名>\n```\n## 数据库表的基本操作\nSQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。\n\n### 插入数据记录\n有两种方式，一种是向具体记录插入常量数据；另一种是把子查询的结果输入到另一个表中去。前者智能插入一条数据，后者一次可以插入多条。\n#### 插入一行新记录\n```\n//INSERT INTO <表名>[(<列名1>[,<列名2>…])] VALUES(<值>)\n\nINSERT INTO  S VALUES  ('s7','小刚','男',21,'计算机')\n\n```\n注意：\n\n必须用逗号将各个数据分开，字符型数据要用单引号括起来。\n\nINTO子句中没有指定列名，则新插入的记录必须在每个属性列上均有值，且VALUES子句中值的排列顺序要和表中各属性列的排列顺序一致。\n#### 插入一行部分数据\n在SC表中插入一条选课记录（’S7’,’C1’）。\n```\nINSERT INTO SC (SNO,CNO)\n         VALUES ('s7',‘c1')\n```\n注意：\n\n将VALUES子句中的值按照INTO子句中指定列名的顺序插入到表中。\n\n对于INTO子句中没有出现的列，则新插入的记录在这些列上将取空值，如上例的SCORE即赋空值。\n但在表定义时有NOT NULL约束的属性列不能取空值。      \n#### 插入多行记录\n1.\n```\nINSERT INTO `userTable` (`user_id`, `user_name`) VALUES\n(1, 'dsf'),\n(2, 'fgy'),\n(3, 'faad');\n```\n这样只需执行一次SQL查询，即可插入多行记录，大大提高了效率，使用php编程的时候，可以使用字符串连接的方式连接sql语句即可:\n```\n$a = 1;\nwhile (5 == $a)\n{\n    if (1 == $a)\n        $sql = \"INSERT INTO tbl_name (col1,col2) VALUES ($a,$b)\";\n    else\n        $sql .= \",($a,$b)\";\n\n    $a++;\n    $b++;\n}\n```\nmysql_query($sql);\n用于表间的拷贝，将一个表中的数据抽取数行插入另一表中，可以通过子查询来实现。\n```\n///INSERT INTO <表名> [(<列名1>[,<列名2>…])] 子查询\nINSERT INTO MySalesReason\n    SELECT SalesReasonID, Name, ModifiedDate\n    FROM AdventureWorks2008R2.Sales.SalesReason\n    WHERE ReasonType = N'Marketing';\n```\n### 修改数据记录\n```\n//UPDATE <表名> SET <列名>=<表达式> [,<列名>=<表达式>]…[WHERE <条件>]\n//修改一行\n\nUPDATE T \n    SET DEPT='信息' \n  WHERE TN='刘伟'\n\n//用子查询选择要修改的行\nUPDATE T \n\tSET COMN=COMN+100\n WHERE TNO IN \n\t (SELECT T.TNO \n\t\tFROM T,TC\n\t   WHERE T.TNO=TC.TNO\n\t\t\tAND TC.CNO='C5')\n//用子查询提供要修改的值\n\nUPDATE T\n\tSET SAL =\n\t\t(SELECT 1.2*AVG(SAL) \n\t\tFROM T)\n```\n### 删除数据记录\n```\n//DELETE FROM <表名> [WHERE <条件>]\n//删除一行\nDELETE \n    FROM T \n WHERE TN=’刘伟’\n//删除多行\nDELETE \n    FROM TC\n//利用子查询选择要删除的行\nDELETE\n    FROM TC \n WHERE TNO=  \n     (SELECT TNO\n          FROM T\n       WHERE TN=’ 刘伟’)\n```\n\n\n## 索引\n索引的作用：\n1. 加快查询速度；\n2. 保证行的唯一性。\n### 索引的分类\n按照索引记录的存放位置分类：\n\n聚集索引：按照索引的字段排列记录，并且依照排好的顺序将记录存储在表中。\n\n非聚集索引：按照索引的字段排列记录，但是排列的结果并不会存储在表中，而是另外存储。\n\n### 唯一索引\n唯一索引表示表中每一个索引值只对应唯一的数据记录，\n这与表的PRIMARY KEY的特性类似，因此唯一性索引常用于PRIMARY KEY的字段上，以区别每一笔记录。\n\n当表中有被设置为UNIQUE的字段时，SQL SERVER会自动建立一个非聚集的唯一性索引。\n\n而当表中有PRIMARY KEY的字段时，SQL SERVER会在PRIMARY KEY字段建立一个非聚集索引。\n\n### 建立索引\n```\n//CREATE [UNIQUE] [CLUSTERED|NONCLUSTERED] INDEX <索引名> ON <表名>  (<列名> [次序] [{,<列名>}] [次序]…)\n//在agent表中建立一个索引aidx，保证每一行都有唯一的aid值。\ncreate unique index aidx on agents(aid);\n```\n次序用来指定索引值的排列顺序，可为ASC（升序）或DESC（降序），缺省值为ASC。\n```\nUSE STUDENT\nCREATE UNIQUE INDEX SCI ON SC(SNO,CNO)\n```\n执行此命令后，为SC表建立一个索引名为SCI的唯一索引\n此索引为SNO和CNO两列的复合索引，即对SC表中的行先按SNO的递增顺序索引，对于相同的SNO，又按CNO的递增顺序索引。\n### 删除索引\n建立索引是为了提高查询速度，但随着索引的增多，数据更新时，系统会花费许多时间来维护索引。这时，应删除不必要的索引。\n```\n//DROP INDEX 数据表名.索引名\n//删除表SC的索引SCI。\t\t\nDROP INDEX SC.SCI\n```\n### 查看索引\n#### 查看索引信息\n报告有关表或视图上索引的信息，当前数据库中表或视图的名称的数据类型为nvarchar(776)。\n```\n//sp_helpindex [ @objname = ] '表或视图的名称'\nUse  eduDB\nGO\nsp_helpindex  \n```\n#### 查看索引的空间信息\n显示行数、保留的磁盘空间以及当前数据库中的表所使用的磁盘空间，或显示由整个数据库保留和使用的磁盘空间\n\n```\nsp_spaceused ['表的名称']\n```\n\n### 事务\n数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。\n\n1.原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n2.一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。\n\n3.隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。\n\n4.持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n\ndrop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始。delete删除表中数据，可以加where字句。\n\n\n### ER图\n\n在ER图中有如下四个成分：\n矩形框：表示实体，在框中记入实体名。\n菱形框：表示联系，在框中记入联系名。\n椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。\n连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)\n\n### 冗余字段\n冗余字段，是设计数据的时候常用的一种手段。优点是，可以在很大程度上避免数据库的关联查询，不使用join提升查询速度。缺点是，数据一致性维护成本高，需要维护冗余字段的一致性。\n\n### 存储过程与触发器的区别\n\n触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。\n\n两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。","slug":"mysql/数据库杂记","published":1,"updated":"2019-03-22T14:44:36.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0i009h4l3nd021wacz","content":"<p>最近面试面到数据结构的题有点爆炸。基本都忘光了，记录一下基础的东西吧。</p>\n<a id=\"more\"></a>\n<h2 id=\"SQL语言的基本概念\"><a href=\"#SQL语言的基本概念\" class=\"headerlink\" title=\"SQL语言的基本概念\"></a>SQL语言的基本概念</h2><p>数据(Data)是数据库中存储的基本对象。</p>\n<p>数据库(DataBase，简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p>\n<p>数据库管理系统(DBMS，Database Management System)<br>位于用户与操作系统之间的一层数据管理软件。<br>是基础软件，是一个大型复杂的软件系统。</p>\n<p>数据库系统(DBS，DataBase System)在计算机系统中引入数据库后的系统构成，包括硬件、软件、数据和人员。</p>\n<h3 id=\"SQL语言的主要特点\"><a href=\"#SQL语言的主要特点\" class=\"headerlink\" title=\"SQL语言的主要特点\"></a>SQL语言的主要特点</h3><p>1.SQL语言是一种非过程语言，即用户只要提出“干什么”即可，不必管具体操作过程，也不必了解数据的存取路径，只要指明所需的数据即可。</p>\n<p>2.SQL语言是一种面向集合的语言，每个命令的操作对象是一个或多个关系，结果也是一个关系。</p>\n<p>3.SQL语言既是自含式语言，又是嵌入式语言。可独立使用交互命令，适用于终端用户、应用程序员和DBA；也可嵌入在高级语言中使用，供应用程序员开发应用程序。</p>\n<p>SQL语言具有:<br>数据定义（DEFINITION）(CREATE,DROP,ALTER)，<br>数据查询（QUERY）(SELECT)，<br>数据操纵（MANIPULATION）(INSERT,UPDATE,DELETE)，<br>数据控制（CONTROL）(GRANT,REVOKE)。</p>\n<p>基本表（BASE TABLE）：是独立存在的表，不是由其它的表导出的表。一个关系对应一个基本表，一个或多个基本表对应一个存储文件。</p>\n<p>视图（VIEW）：<br>是一个虚拟的表，是从一个或几个基本表导出的表。它本身不独立存在于数据库中，数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。<br>当基本表中的数据发生变化时，从视图中查询出来的数据也随之改变。</p>\n<p>在用户看来，视图是通过不同路径去看一个实际表，就象一个窗口一样，我们通过窗户去看外面的高楼，可以看到高楼的不同部分，而透过视图可以看到数据库中自己感兴趣的内容。</p>\n<p>索引（INDEX）：是一种和表格或视图有关的结构，可以加快从表格或视图中获得数据行。表格索引可以是群集的，也可以是非群集的。群集指数据在物理上是基于索引关键字的顺序存放的。</p>\n<p>关键字：是众多列中一列或组，它唯一识别一行（主关键字），定义两个表格之间的关系（外关键字），或者用于构建一个索引</p>\n<p>存储过程：是一种Transact-SQL语句，它们被编译成一个执行计划。该过程用于性能优化和控制访问。</p>\n<p>约束：定义了有关列中允许的值的规则，是加强数据完整性的标准机制。</p>\n<p>触发器：存储过程的一个特殊类，用于当对一个表格或视图发出update、insert 或delete语句时，能自动执行。</p>\n<h3 id=\"三级模式结构\"><a href=\"#三级模式结构\" class=\"headerlink\" title=\"三级模式结构\"></a>三级模式结构</h3><p>SQL语言支持数据库的三级模式结构，如图所示。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。</p>\n<p><img src=\"http://p1.bqimg.com/567571/405330844246062d.png\" alt=\"三级模式结构\"></p>\n<h2 id=\"基本表的操作\"><a href=\"#基本表的操作\" class=\"headerlink\" title=\"基本表的操作\"></a>基本表的操作</h2><h3 id=\"创建基本表\"><a href=\"#创建基本表\" class=\"headerlink\" title=\"创建基本表\"></a>创建基本表</h3><p>创建一个数据表时主要包括以下几个组成部分：</p>\n<p>（1）字段名（列名）：字段名可长达128个字符。字段名可包含中文、英文字母、下划线、#号、货币符号（￥）及AT符号(@)。同一表中不许有重名列；</p>\n<p>（2）字段数据类型；</p>\n<p>（3）字段的长度、精度和小数位数；</p>\n<p>（4）NULL值与DEFAULT值：DEFAULT值表示某一字段的默认值，当没有输入数据时，则使用此默认的值。</p>\n<p> 在SQL语言中，使用语句CREATE TABLE创建数据表，其基本语法格式为：<br> <figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE [ database_name . [ schema_name ] . | schema_name . ] &lt;表名&gt;</span><br><span class=\"line\">  (     &lt;列定义&gt;[&#123;，&lt;列定义&gt;|&lt;表约束&gt;&#125;][,</span><br><span class=\"line\">        [CONSTRAINT 主键约束] PRIMARY KY （属性名）][,</span><br><span class=\"line\">        [CONSTRAINT 检查约束] CHECK（逻辑表达式）][,</span><br><span class=\"line\">        [CONSTRAINT 外键约束] REFRENCES 参照表（参照属性）[,…n]]</span><br><span class=\"line\">  )</span><br><span class=\"line\">  [ON &#123;文件组|默认文件组&#125;]</span><br><span class=\"line\">```    </span><br><span class=\"line\">### 定义完整性约束</span><br><span class=\"line\">在SQL SERVER中可以定义五种类型的完整性约束。</span><br><span class=\"line\">#### NULL/NOT NULL</span><br><span class=\"line\">是否允许该字段的值为NULL。表示“不知道”、“不确定”或“没有数据”的意思。</span><br><span class=\"line\">如主键列就不允许出现空值，否则就失去了唯一标识一条记录的作用</span><br><span class=\"line\">#### UNIQUE约束</span><br><span class=\"line\">用于指明基本表在某一列或多个列的组合上的取值必须唯一。</span><br><span class=\"line\"></span><br><span class=\"line\">定义了UNIQUE约束的那些列称为唯一键，系统自动为唯一键建立唯一索引，从而保证了唯一键的唯一性。</span><br><span class=\"line\">#### PRIMARY KEY约束</span><br><span class=\"line\">PRIMARY KEY约束用于定义基本表的主键，起唯一标识作用，其值不能为NULL，也不能重复，以此来保证实体的完整性。</span><br><span class=\"line\">PRIMARY KEY与UNIQUE的区别：</span><br><span class=\"line\"><span class=\"number\">1.</span>在一个基本表中只能定义一个PRIMARY KEY约束，但可定义多个UNIQUE约束；</span><br><span class=\"line\"><span class=\"number\">2.</span>对于指定为PRIMARY KEY的一个列或多个列的组合，其中任何一个列都不能出现空值，而对于UNIQUE所约束的唯一键，则允许为空。</span><br><span class=\"line\">#### FOREIGN KEY约束</span><br><span class=\"line\">FOREIGN KEY约束指定某一个列或一组列作为外部键，其中，包含外部键的表称为从表，包含外部键所引用的主键或唯一键的表称主表。</span><br><span class=\"line\">#### CHECK约束</span><br><span class=\"line\">CHECK约束用来检查字段值所允许的范围，如，一个字段只能输入整数，而且限定在<span class=\"number\">0</span><span class=\"number\">-100</span>的整数，以此来保证域的完整性。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 修改基本表</span><br><span class=\"line\">由于应用环境和应用需求的变化，经常需要修改基本表的结构，比如，增加新列和完整性约束、修改原有的列定义和完整性约束等。</span><br><span class=\"line\">#### ADD方式</span><br><span class=\"line\">用于增加新列和完整性约束。</span><br><span class=\"line\"></span><br><span class=\"line\">定义方式同`CREATE TABLE`语句中的定义方式相同，其语法格式为：</span><br></pre></td></tr></table></figure></p>\n<p>//ALTER TABLE &lt;表名&gt; ADD &lt;列定义&gt; | &lt;完整性约束定义&gt;<br>ALTER TABLE Student ADD   RegisterDate DATETIME,<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### ALTER方式</span><br><span class=\"line\"></span><br><span class=\"line\">用于修改某些列，其语法格式为：</span><br></pre></td></tr></table></figure></p>\n<p>//ALTER TABLE&lt;表名&gt; ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt;[NULL|NOT NULL]<br>ALTER TABLE Student ALTER COLUMN Sage SMALEINT NULL<br><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">要求：</span><br><span class=\"line\"><span class=\"number\">1.</span>不能改变列名；</span><br><span class=\"line\"><span class=\"number\">2.</span>不能将含有空值的列的定义修改为<span class=\"literal\">NOT</span> <span class=\"literal\">NULL</span>约束；</span><br><span class=\"line\"><span class=\"number\">3.</span>若列中已有数据，则不能减少该列的宽度，也不能改变其数据类型；</span><br><span class=\"line\"><span class=\"number\">4.</span>只能修改<span class=\"literal\">NULL</span>|<span class=\"literal\">NOT</span> <span class=\"literal\">NULL</span>约束，其它类型的约束在修改之前必须先删除，然后再重新添加修改过的约束定义。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#### DROP方式</span></span><br><span class=\"line\">删除完整性约束定义，其语法格式为：</span><br></pre></td></tr></table></figure></p>\n<p>//ALTER TABLE&lt;表名&gt; DROP CONSTRAINT &lt;约束名&gt;<br>ALTER TABLE Student DROP  UNIQUE(SNAME)<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 删除基本表</span><br></pre></td></tr></table></figure></p>\n<p>DROP TABLE &lt;表名&gt;<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 数据库表的基本操作</span><br><span class=\"line\">SQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。</span><br><span class=\"line\"></span><br><span class=\"line\">### 插入数据记录</span><br><span class=\"line\">有两种方式，一种是向具体记录插入常量数据；另一种是把子查询的结果输入到另一个表中去。前者智能插入一条数据，后者一次可以插入多条。</span><br><span class=\"line\">#### 插入一行新记录</span><br></pre></td></tr></table></figure></p>\n<p>//INSERT INTO &lt;表名&gt;[(&lt;列名1&gt;[,&lt;列名2&gt;…])] VALUES(&lt;值&gt;)</p>\n<p>INSERT INTO  S VALUES  (‘s7’,’小刚’,’男’,21,’计算机’)</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意：</span><br><span class=\"line\"></span><br><span class=\"line\">必须用逗号将各个数据分开，字符型数据要用单引号括起来。</span><br><span class=\"line\"></span><br><span class=\"line\">INTO子句中没有指定列名，则新插入的记录必须在每个属性列上均有值，且VALUES子句中值的排列顺序要和表中各属性列的排列顺序一致。</span><br><span class=\"line\">#### 插入一行部分数据</span><br><span class=\"line\">在SC表中插入一条选课记录（’S7’,’C1’）。</span><br></pre></td></tr></table></figure>\n<p>INSERT INTO SC (SNO,CNO)<br>         VALUES (‘s7’,‘c1’)<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意：</span><br><span class=\"line\"></span><br><span class=\"line\">将<span class=\"keyword\">VALUES</span>子句中的值按照<span class=\"keyword\">INTO</span>子句中指定列名的顺序插入到表中。</span><br><span class=\"line\"></span><br><span class=\"line\">对于<span class=\"keyword\">INTO</span>子句中没有出现的列，则新插入的记录在这些列上将取空值，如上例的SCORE即赋空值。</span><br><span class=\"line\">但在表定义时有<span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>约束的属性列不能取空值。      </span><br><span class=\"line\"><span class=\"comment\">#### 插入多行记录</span></span><br><span class=\"line\"><span class=\"number\">1.</span></span><br></pre></td></tr></table></figure></p>\n<p>INSERT INTO <code>userTable</code> (<code>user_id</code>, <code>user_name</code>) VALUES<br>(1, ‘dsf’),<br>(2, ‘fgy’),<br>(3, ‘faad’);<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">这样只需执行一次SQL查询，即可插入多行记录，大大提高了效率，使用php编程的时候，可以使用字符串连接的方式连接sql语句即可:</span></span><br></pre></td></tr></table></figure></p>\n<p>$a = 1;<br>while (5 == $a)<br>{<br>    if (1 == $a)<br>        $sql = “INSERT INTO tbl_name (col1,col2) VALUES ($a,$b)”;<br>    else<br>        $sql .= “,($a,$b)”;</p>\n<pre><code>$a++;\n$b++;\n</code></pre><p>}<br><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql_query($sql)<span class=\"comment\">;</span></span><br><span class=\"line\">用于表间的拷贝，将一个表中的数据抽取数行插入另一表中，可以通过子查询来实现。</span><br></pre></td></tr></table></figure></p>\n<p>///INSERT INTO &lt;表名&gt; [(&lt;列名1&gt;[,&lt;列名2&gt;…])] 子查询<br>INSERT INTO MySalesReason<br>    SELECT SalesReasonID, Name, ModifiedDate<br>    FROM AdventureWorks2008R2.Sales.SalesReason<br>    WHERE ReasonType = N’Marketing’;<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 修改数据记录</span><br></pre></td></tr></table></figure></p>\n<p>//UPDATE &lt;表名&gt; SET &lt;列名&gt;=&lt;表达式&gt; [,&lt;列名&gt;=&lt;表达式&gt;]…[WHERE &lt;条件&gt;]<br>//修改一行</p>\n<p>UPDATE T<br>    SET DEPT=’信息’<br>  WHERE TN=’刘伟’</p>\n<p>//用子查询选择要修改的行<br>UPDATE T<br>    SET COMN=COMN+100<br> WHERE TNO IN<br>     (SELECT T.TNO<br>        FROM T,TC<br>       WHERE T.TNO=TC.TNO<br>            AND TC.CNO=’C5’)<br>//用子查询提供要修改的值</p>\n<p>UPDATE T<br>    SET SAL =<br>        (SELECT 1.2*AVG(SAL)<br>        FROM T)<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 删除数据记录</span><br></pre></td></tr></table></figure></p>\n<p>//DELETE FROM &lt;表名&gt; [WHERE &lt;条件&gt;]<br>//删除一行<br>DELETE<br>    FROM T<br> WHERE TN=’刘伟’<br>//删除多行<br>DELETE<br>    FROM TC<br>//利用子查询选择要删除的行<br>DELETE<br>    FROM TC<br> WHERE TNO=<br>     (SELECT TNO<br>          FROM T<br>       WHERE TN=’ 刘伟’)<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 索引</span><br><span class=\"line\">索引的作用：</span><br><span class=\"line\">1. 加快查询速度；</span><br><span class=\"line\">2. 保证行的唯一性。</span><br><span class=\"line\">### 索引的分类</span><br><span class=\"line\">按照索引记录的存放位置分类：</span><br><span class=\"line\"></span><br><span class=\"line\">聚集索引：按照索引的字段排列记录，并且依照排好的顺序将记录存储在表中。</span><br><span class=\"line\"></span><br><span class=\"line\">非聚集索引：按照索引的字段排列记录，但是排列的结果并不会存储在表中，而是另外存储。</span><br><span class=\"line\"></span><br><span class=\"line\">### 唯一索引</span><br><span class=\"line\">唯一索引表示表中每一个索引值只对应唯一的数据记录，</span><br><span class=\"line\">这与表的PRIMARY KEY的特性类似，因此唯一性索引常用于PRIMARY KEY的字段上，以区别每一笔记录。</span><br><span class=\"line\"></span><br><span class=\"line\">当表中有被设置为UNIQUE的字段时，SQL SERVER会自动建立一个非聚集的唯一性索引。</span><br><span class=\"line\"></span><br><span class=\"line\">而当表中有PRIMARY KEY的字段时，SQL SERVER会在PRIMARY KEY字段建立一个非聚集索引。</span><br><span class=\"line\"></span><br><span class=\"line\">### 建立索引</span><br></pre></td></tr></table></figure></p>\n<p>//CREATE [UNIQUE] [CLUSTERED|NONCLUSTERED] INDEX &lt;索引名&gt; ON &lt;表名&gt;  (&lt;列名&gt; [次序] [{,&lt;列名&gt;}] [次序]…)<br>//在agent表中建立一个索引aidx，保证每一行都有唯一的aid值。<br>create unique index aidx on agents(aid);<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">次序用来指定索引值的排列顺序，可为<span class=\"keyword\">ASC</span>（升序）或<span class=\"keyword\">DESC</span>（降序），缺省值为<span class=\"keyword\">ASC</span>。</span><br></pre></td></tr></table></figure></p>\n<p>USE STUDENT<br>CREATE UNIQUE INDEX SCI ON SC(SNO,CNO)<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行此命令后，为SC表建立一个索引名为SCI的唯一索引</span><br><span class=\"line\">此索引为SNO和CNO两列的复合索引，即对SC表中的行先按SNO的递增顺序索引，对于相同的SNO，又按CNO的递增顺序索引。</span><br><span class=\"line\">### 删除索引</span><br><span class=\"line\">建立索引是为了提高查询速度，但随着索引的增多，数据更新时，系统会花费许多时间来维护索引。这时，应删除不必要的索引。</span><br></pre></td></tr></table></figure></p>\n<p>//DROP INDEX 数据表名.索引名<br>//删除表SC的索引SCI。<br>DROP INDEX SC.SCI<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 查看索引</span><br><span class=\"line\">#### 查看索引信息</span><br><span class=\"line\">报告有关表或视图上索引的信息，当前数据库中表或视图的名称的数据类型为nvarchar(<span class=\"number\">776</span>)。</span><br></pre></td></tr></table></figure></p>\n<p>//sp_helpindex [ @objname = ] ‘表或视图的名称’<br>Use  eduDB<br>GO<br>sp_helpindex<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 查看索引的空间信息</span><br><span class=\"line\">显示行数、保留的磁盘空间以及当前数据库中的表所使用的磁盘空间，或显示由整个数据库保留和使用的磁盘空间</span><br></pre></td></tr></table></figure></p>\n<p>sp_spaceused [‘表的名称’]<br><code>`</code></p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。</p>\n<p>1.原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>\n<p>2.一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>\n<p>3.隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。</p>\n<p>4.持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>\n<p>drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始。delete删除表中数据，可以加where字句。</p>\n<h3 id=\"ER图\"><a href=\"#ER图\" class=\"headerlink\" title=\"ER图\"></a>ER图</h3><p>在ER图中有如下四个成分：<br>矩形框：表示实体，在框中记入实体名。<br>菱形框：表示联系，在框中记入联系名。<br>椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。<br>连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)</p>\n<h3 id=\"冗余字段\"><a href=\"#冗余字段\" class=\"headerlink\" title=\"冗余字段\"></a>冗余字段</h3><p>冗余字段，是设计数据的时候常用的一种手段。优点是，可以在很大程度上避免数据库的关联查询，不使用join提升查询速度。缺点是，数据一致性维护成本高，需要维护冗余字段的一致性。</p>\n<h3 id=\"存储过程与触发器的区别\"><a href=\"#存储过程与触发器的区别\" class=\"headerlink\" title=\"存储过程与触发器的区别\"></a>存储过程与触发器的区别</h3><p>触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。</p>\n<p>两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。</p>\n","site":{"data":{}},"excerpt":"<p>最近面试面到数据结构的题有点爆炸。基本都忘光了，记录一下基础的东西吧。</p>","more":"<h2 id=\"SQL语言的基本概念\"><a href=\"#SQL语言的基本概念\" class=\"headerlink\" title=\"SQL语言的基本概念\"></a>SQL语言的基本概念</h2><p>数据(Data)是数据库中存储的基本对象。</p>\n<p>数据库(DataBase，简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p>\n<p>数据库管理系统(DBMS，Database Management System)<br>位于用户与操作系统之间的一层数据管理软件。<br>是基础软件，是一个大型复杂的软件系统。</p>\n<p>数据库系统(DBS，DataBase System)在计算机系统中引入数据库后的系统构成，包括硬件、软件、数据和人员。</p>\n<h3 id=\"SQL语言的主要特点\"><a href=\"#SQL语言的主要特点\" class=\"headerlink\" title=\"SQL语言的主要特点\"></a>SQL语言的主要特点</h3><p>1.SQL语言是一种非过程语言，即用户只要提出“干什么”即可，不必管具体操作过程，也不必了解数据的存取路径，只要指明所需的数据即可。</p>\n<p>2.SQL语言是一种面向集合的语言，每个命令的操作对象是一个或多个关系，结果也是一个关系。</p>\n<p>3.SQL语言既是自含式语言，又是嵌入式语言。可独立使用交互命令，适用于终端用户、应用程序员和DBA；也可嵌入在高级语言中使用，供应用程序员开发应用程序。</p>\n<p>SQL语言具有:<br>数据定义（DEFINITION）(CREATE,DROP,ALTER)，<br>数据查询（QUERY）(SELECT)，<br>数据操纵（MANIPULATION）(INSERT,UPDATE,DELETE)，<br>数据控制（CONTROL）(GRANT,REVOKE)。</p>\n<p>基本表（BASE TABLE）：是独立存在的表，不是由其它的表导出的表。一个关系对应一个基本表，一个或多个基本表对应一个存储文件。</p>\n<p>视图（VIEW）：<br>是一个虚拟的表，是从一个或几个基本表导出的表。它本身不独立存在于数据库中，数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。<br>当基本表中的数据发生变化时，从视图中查询出来的数据也随之改变。</p>\n<p>在用户看来，视图是通过不同路径去看一个实际表，就象一个窗口一样，我们通过窗户去看外面的高楼，可以看到高楼的不同部分，而透过视图可以看到数据库中自己感兴趣的内容。</p>\n<p>索引（INDEX）：是一种和表格或视图有关的结构，可以加快从表格或视图中获得数据行。表格索引可以是群集的，也可以是非群集的。群集指数据在物理上是基于索引关键字的顺序存放的。</p>\n<p>关键字：是众多列中一列或组，它唯一识别一行（主关键字），定义两个表格之间的关系（外关键字），或者用于构建一个索引</p>\n<p>存储过程：是一种Transact-SQL语句，它们被编译成一个执行计划。该过程用于性能优化和控制访问。</p>\n<p>约束：定义了有关列中允许的值的规则，是加强数据完整性的标准机制。</p>\n<p>触发器：存储过程的一个特殊类，用于当对一个表格或视图发出update、insert 或delete语句时，能自动执行。</p>\n<h3 id=\"三级模式结构\"><a href=\"#三级模式结构\" class=\"headerlink\" title=\"三级模式结构\"></a>三级模式结构</h3><p>SQL语言支持数据库的三级模式结构，如图所示。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。</p>\n<p><img src=\"http://p1.bqimg.com/567571/405330844246062d.png\" alt=\"三级模式结构\"></p>\n<h2 id=\"基本表的操作\"><a href=\"#基本表的操作\" class=\"headerlink\" title=\"基本表的操作\"></a>基本表的操作</h2><h3 id=\"创建基本表\"><a href=\"#创建基本表\" class=\"headerlink\" title=\"创建基本表\"></a>创建基本表</h3><p>创建一个数据表时主要包括以下几个组成部分：</p>\n<p>（1）字段名（列名）：字段名可长达128个字符。字段名可包含中文、英文字母、下划线、#号、货币符号（￥）及AT符号(@)。同一表中不许有重名列；</p>\n<p>（2）字段数据类型；</p>\n<p>（3）字段的长度、精度和小数位数；</p>\n<p>（4）NULL值与DEFAULT值：DEFAULT值表示某一字段的默认值，当没有输入数据时，则使用此默认的值。</p>\n<p> 在SQL语言中，使用语句CREATE TABLE创建数据表，其基本语法格式为：<br> <figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE [ database_name . [ schema_name ] . | schema_name . ] &lt;表名&gt;</span><br><span class=\"line\">  (     &lt;列定义&gt;[&#123;，&lt;列定义&gt;|&lt;表约束&gt;&#125;][,</span><br><span class=\"line\">        [CONSTRAINT 主键约束] PRIMARY KY （属性名）][,</span><br><span class=\"line\">        [CONSTRAINT 检查约束] CHECK（逻辑表达式）][,</span><br><span class=\"line\">        [CONSTRAINT 外键约束] REFRENCES 参照表（参照属性）[,…n]]</span><br><span class=\"line\">  )</span><br><span class=\"line\">  [ON &#123;文件组|默认文件组&#125;]</span><br><span class=\"line\">```    </span><br><span class=\"line\">### 定义完整性约束</span><br><span class=\"line\">在SQL SERVER中可以定义五种类型的完整性约束。</span><br><span class=\"line\">#### NULL/NOT NULL</span><br><span class=\"line\">是否允许该字段的值为NULL。表示“不知道”、“不确定”或“没有数据”的意思。</span><br><span class=\"line\">如主键列就不允许出现空值，否则就失去了唯一标识一条记录的作用</span><br><span class=\"line\">#### UNIQUE约束</span><br><span class=\"line\">用于指明基本表在某一列或多个列的组合上的取值必须唯一。</span><br><span class=\"line\"></span><br><span class=\"line\">定义了UNIQUE约束的那些列称为唯一键，系统自动为唯一键建立唯一索引，从而保证了唯一键的唯一性。</span><br><span class=\"line\">#### PRIMARY KEY约束</span><br><span class=\"line\">PRIMARY KEY约束用于定义基本表的主键，起唯一标识作用，其值不能为NULL，也不能重复，以此来保证实体的完整性。</span><br><span class=\"line\">PRIMARY KEY与UNIQUE的区别：</span><br><span class=\"line\"><span class=\"number\">1.</span>在一个基本表中只能定义一个PRIMARY KEY约束，但可定义多个UNIQUE约束；</span><br><span class=\"line\"><span class=\"number\">2.</span>对于指定为PRIMARY KEY的一个列或多个列的组合，其中任何一个列都不能出现空值，而对于UNIQUE所约束的唯一键，则允许为空。</span><br><span class=\"line\">#### FOREIGN KEY约束</span><br><span class=\"line\">FOREIGN KEY约束指定某一个列或一组列作为外部键，其中，包含外部键的表称为从表，包含外部键所引用的主键或唯一键的表称主表。</span><br><span class=\"line\">#### CHECK约束</span><br><span class=\"line\">CHECK约束用来检查字段值所允许的范围，如，一个字段只能输入整数，而且限定在<span class=\"number\">0</span><span class=\"number\">-100</span>的整数，以此来保证域的完整性。</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">### 修改基本表</span><br><span class=\"line\">由于应用环境和应用需求的变化，经常需要修改基本表的结构，比如，增加新列和完整性约束、修改原有的列定义和完整性约束等。</span><br><span class=\"line\">#### ADD方式</span><br><span class=\"line\">用于增加新列和完整性约束。</span><br><span class=\"line\"></span><br><span class=\"line\">定义方式同`CREATE TABLE`语句中的定义方式相同，其语法格式为：</span><br></pre></td></tr></table></figure></p>\n<p>//ALTER TABLE &lt;表名&gt; ADD &lt;列定义&gt; | &lt;完整性约束定义&gt;<br>ALTER TABLE Student ADD   RegisterDate DATETIME,<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### ALTER方式</span><br><span class=\"line\"></span><br><span class=\"line\">用于修改某些列，其语法格式为：</span><br></pre></td></tr></table></figure></p>\n<p>//ALTER TABLE&lt;表名&gt; ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt;[NULL|NOT NULL]<br>ALTER TABLE Student ALTER COLUMN Sage SMALEINT NULL<br><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">要求：</span><br><span class=\"line\"><span class=\"number\">1.</span>不能改变列名；</span><br><span class=\"line\"><span class=\"number\">2.</span>不能将含有空值的列的定义修改为<span class=\"literal\">NOT</span> <span class=\"literal\">NULL</span>约束；</span><br><span class=\"line\"><span class=\"number\">3.</span>若列中已有数据，则不能减少该列的宽度，也不能改变其数据类型；</span><br><span class=\"line\"><span class=\"number\">4.</span>只能修改<span class=\"literal\">NULL</span>|<span class=\"literal\">NOT</span> <span class=\"literal\">NULL</span>约束，其它类型的约束在修改之前必须先删除，然后再重新添加修改过的约束定义。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#### DROP方式</span></span><br><span class=\"line\">删除完整性约束定义，其语法格式为：</span><br></pre></td></tr></table></figure></p>\n<p>//ALTER TABLE&lt;表名&gt; DROP CONSTRAINT &lt;约束名&gt;<br>ALTER TABLE Student DROP  UNIQUE(SNAME)<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">### 删除基本表</span><br></pre></td></tr></table></figure></p>\n<p>DROP TABLE &lt;表名&gt;<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## 数据库表的基本操作</span><br><span class=\"line\">SQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。</span><br><span class=\"line\"></span><br><span class=\"line\">### 插入数据记录</span><br><span class=\"line\">有两种方式，一种是向具体记录插入常量数据；另一种是把子查询的结果输入到另一个表中去。前者智能插入一条数据，后者一次可以插入多条。</span><br><span class=\"line\">#### 插入一行新记录</span><br></pre></td></tr></table></figure></p>\n<p>//INSERT INTO &lt;表名&gt;[(&lt;列名1&gt;[,&lt;列名2&gt;…])] VALUES(&lt;值&gt;)</p>\n<p>INSERT INTO  S VALUES  (‘s7’,’小刚’,’男’,21,’计算机’)</p>\n<figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意：</span><br><span class=\"line\"></span><br><span class=\"line\">必须用逗号将各个数据分开，字符型数据要用单引号括起来。</span><br><span class=\"line\"></span><br><span class=\"line\">INTO子句中没有指定列名，则新插入的记录必须在每个属性列上均有值，且VALUES子句中值的排列顺序要和表中各属性列的排列顺序一致。</span><br><span class=\"line\">#### 插入一行部分数据</span><br><span class=\"line\">在SC表中插入一条选课记录（’S7’,’C1’）。</span><br></pre></td></tr></table></figure>\n<p>INSERT INTO SC (SNO,CNO)<br>         VALUES (‘s7’,‘c1’)<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">注意：</span><br><span class=\"line\"></span><br><span class=\"line\">将<span class=\"keyword\">VALUES</span>子句中的值按照<span class=\"keyword\">INTO</span>子句中指定列名的顺序插入到表中。</span><br><span class=\"line\"></span><br><span class=\"line\">对于<span class=\"keyword\">INTO</span>子句中没有出现的列，则新插入的记录在这些列上将取空值，如上例的SCORE即赋空值。</span><br><span class=\"line\">但在表定义时有<span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>约束的属性列不能取空值。      </span><br><span class=\"line\"><span class=\"comment\">#### 插入多行记录</span></span><br><span class=\"line\"><span class=\"number\">1.</span></span><br></pre></td></tr></table></figure></p>\n<p>INSERT INTO <code>userTable</code> (<code>user_id</code>, <code>user_name</code>) VALUES<br>(1, ‘dsf’),<br>(2, ‘fgy’),<br>(3, ‘faad’);<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"section\">这样只需执行一次SQL查询，即可插入多行记录，大大提高了效率，使用php编程的时候，可以使用字符串连接的方式连接sql语句即可:</span></span><br></pre></td></tr></table></figure></p>\n<p>$a = 1;<br>while (5 == $a)<br>{<br>    if (1 == $a)<br>        $sql = “INSERT INTO tbl_name (col1,col2) VALUES ($a,$b)”;<br>    else<br>        $sql .= “,($a,$b)”;</p>\n<pre><code>$a++;\n$b++;\n</code></pre><p>}<br><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql_query($sql)<span class=\"comment\">;</span></span><br><span class=\"line\">用于表间的拷贝，将一个表中的数据抽取数行插入另一表中，可以通过子查询来实现。</span><br></pre></td></tr></table></figure></p>\n<p>///INSERT INTO &lt;表名&gt; [(&lt;列名1&gt;[,&lt;列名2&gt;…])] 子查询<br>INSERT INTO MySalesReason<br>    SELECT SalesReasonID, Name, ModifiedDate<br>    FROM AdventureWorks2008R2.Sales.SalesReason<br>    WHERE ReasonType = N’Marketing’;<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 修改数据记录</span><br></pre></td></tr></table></figure></p>\n<p>//UPDATE &lt;表名&gt; SET &lt;列名&gt;=&lt;表达式&gt; [,&lt;列名&gt;=&lt;表达式&gt;]…[WHERE &lt;条件&gt;]<br>//修改一行</p>\n<p>UPDATE T<br>    SET DEPT=’信息’<br>  WHERE TN=’刘伟’</p>\n<p>//用子查询选择要修改的行<br>UPDATE T<br>    SET COMN=COMN+100<br> WHERE TNO IN<br>     (SELECT T.TNO<br>        FROM T,TC<br>       WHERE T.TNO=TC.TNO<br>            AND TC.CNO=’C5’)<br>//用子查询提供要修改的值</p>\n<p>UPDATE T<br>    SET SAL =<br>        (SELECT 1.2*AVG(SAL)<br>        FROM T)<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 删除数据记录</span><br></pre></td></tr></table></figure></p>\n<p>//DELETE FROM &lt;表名&gt; [WHERE &lt;条件&gt;]<br>//删除一行<br>DELETE<br>    FROM T<br> WHERE TN=’刘伟’<br>//删除多行<br>DELETE<br>    FROM TC<br>//利用子查询选择要删除的行<br>DELETE<br>    FROM TC<br> WHERE TNO=<br>     (SELECT TNO<br>          FROM T<br>       WHERE TN=’ 刘伟’)<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">## 索引</span><br><span class=\"line\">索引的作用：</span><br><span class=\"line\">1. 加快查询速度；</span><br><span class=\"line\">2. 保证行的唯一性。</span><br><span class=\"line\">### 索引的分类</span><br><span class=\"line\">按照索引记录的存放位置分类：</span><br><span class=\"line\"></span><br><span class=\"line\">聚集索引：按照索引的字段排列记录，并且依照排好的顺序将记录存储在表中。</span><br><span class=\"line\"></span><br><span class=\"line\">非聚集索引：按照索引的字段排列记录，但是排列的结果并不会存储在表中，而是另外存储。</span><br><span class=\"line\"></span><br><span class=\"line\">### 唯一索引</span><br><span class=\"line\">唯一索引表示表中每一个索引值只对应唯一的数据记录，</span><br><span class=\"line\">这与表的PRIMARY KEY的特性类似，因此唯一性索引常用于PRIMARY KEY的字段上，以区别每一笔记录。</span><br><span class=\"line\"></span><br><span class=\"line\">当表中有被设置为UNIQUE的字段时，SQL SERVER会自动建立一个非聚集的唯一性索引。</span><br><span class=\"line\"></span><br><span class=\"line\">而当表中有PRIMARY KEY的字段时，SQL SERVER会在PRIMARY KEY字段建立一个非聚集索引。</span><br><span class=\"line\"></span><br><span class=\"line\">### 建立索引</span><br></pre></td></tr></table></figure></p>\n<p>//CREATE [UNIQUE] [CLUSTERED|NONCLUSTERED] INDEX &lt;索引名&gt; ON &lt;表名&gt;  (&lt;列名&gt; [次序] [{,&lt;列名&gt;}] [次序]…)<br>//在agent表中建立一个索引aidx，保证每一行都有唯一的aid值。<br>create unique index aidx on agents(aid);<br><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">次序用来指定索引值的排列顺序，可为<span class=\"keyword\">ASC</span>（升序）或<span class=\"keyword\">DESC</span>（降序），缺省值为<span class=\"keyword\">ASC</span>。</span><br></pre></td></tr></table></figure></p>\n<p>USE STUDENT<br>CREATE UNIQUE INDEX SCI ON SC(SNO,CNO)<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行此命令后，为SC表建立一个索引名为SCI的唯一索引</span><br><span class=\"line\">此索引为SNO和CNO两列的复合索引，即对SC表中的行先按SNO的递增顺序索引，对于相同的SNO，又按CNO的递增顺序索引。</span><br><span class=\"line\">### 删除索引</span><br><span class=\"line\">建立索引是为了提高查询速度，但随着索引的增多，数据更新时，系统会花费许多时间来维护索引。这时，应删除不必要的索引。</span><br></pre></td></tr></table></figure></p>\n<p>//DROP INDEX 数据表名.索引名<br>//删除表SC的索引SCI。<br>DROP INDEX SC.SCI<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 查看索引</span><br><span class=\"line\">#### 查看索引信息</span><br><span class=\"line\">报告有关表或视图上索引的信息，当前数据库中表或视图的名称的数据类型为nvarchar(<span class=\"number\">776</span>)。</span><br></pre></td></tr></table></figure></p>\n<p>//sp_helpindex [ @objname = ] ‘表或视图的名称’<br>Use  eduDB<br>GO<br>sp_helpindex<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 查看索引的空间信息</span><br><span class=\"line\">显示行数、保留的磁盘空间以及当前数据库中的表所使用的磁盘空间，或显示由整个数据库保留和使用的磁盘空间</span><br></pre></td></tr></table></figure></p>\n<p>sp_spaceused [‘表的名称’]<br><code>`</code></p>\n<h3 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h3><p>数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。</p>\n<p>1.原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>\n<p>2.一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>\n<p>3.隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。</p>\n<p>4.持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>\n<p>drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始。delete删除表中数据，可以加where字句。</p>\n<h3 id=\"ER图\"><a href=\"#ER图\" class=\"headerlink\" title=\"ER图\"></a>ER图</h3><p>在ER图中有如下四个成分：<br>矩形框：表示实体，在框中记入实体名。<br>菱形框：表示联系，在框中记入联系名。<br>椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。<br>连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)</p>\n<h3 id=\"冗余字段\"><a href=\"#冗余字段\" class=\"headerlink\" title=\"冗余字段\"></a>冗余字段</h3><p>冗余字段，是设计数据的时候常用的一种手段。优点是，可以在很大程度上避免数据库的关联查询，不使用join提升查询速度。缺点是，数据一致性维护成本高，需要维护冗余字段的一致性。</p>\n<h3 id=\"存储过程与触发器的区别\"><a href=\"#存储过程与触发器的区别\" class=\"headerlink\" title=\"存储过程与触发器的区别\"></a>存储过程与触发器的区别</h3><p>触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。</p>\n<p>两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。</p>"},{"title":"python大闯关(0-4)","date":"2016-10-18T12:51:02.000Z","_content":"\n最近在找python对应的学习实例时,看到了一个古老的游戏,方便大家边玩边学：\n\n当当当当，**python challenge**！\n\n[入口](http://www.pythonchallenge.com/)\n\n当然，他是有规则的。\nGeneral tips:\n* Use the hints. They are helpful, most of the times.\n* Investigate the data given to you.\n* Avoid looking for spoilers.\n<!--more-->\n\n谜一样的游戏，相当有趣，试试看自己能闯几关吧。\n\n\n[repo](https://github.com/zjbao123/python_challenge_solution)\n## 第0关\n![第0关](http://www.pythonchallenge.com/pc/def/calc.jpg)\n根据图片，就可以知道，2的38次方。\n```\nprint (2**38)\n```\n计算得到结果,274877906944,输入即可到下一关。\n\n## 第1关\n\n![第1关](http://www.pythonchallenge.com/pc/def/map.jpg)\n\n下面有一句提示：`everybody thinks twice before solving this.`\n然后一堆乱码：\n\ng fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.\n\n从图中可以看出，每个字母都向后移了两位得到那个数字。这估计就是关键所在了。\n\n思路是这样的：\n\n首先，将26个字母的ASCII码表示出来，转换为对应的数字。a~z对应为97~122\n将对应的数字移位解码输出，如ASCII码不在此范围则直接输出。\n\nASCII码对应的转化函数为：`chr(65) ord('a')`\n```\ndef findLetter(s):\n    sum =''\n    for i in s:\n\n        if 120>=ord(i)>=97:\n             sum +=chr(ord(i)+2)\n        elif 122>=ord(i)>=121:\n            sum += chr(ord(i)-24)\n        else:\n            sum += i\n    return sum\nl = \"g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj\"\nprint findLetter(l)\n```\n\n解码结果为：\n\ni hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that's why this text is so long. using string.maketrans() is recommended. now apply on the url\n\n这边解码之后，又告诉我了另一个解码的方式，通过映射表来编码解码(怪自己知道的太少)：\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport string\n\n__author__ = 'zjbao123'\nintab = 'abcdefghijklmnopqrstuvwxyz'\nouttab = 'cdefghijklmnopqrstuvwxyzab'\ntrantab = string.maketrans(intab, outtab)\n\nl = \"map\"\nprint l.translate(trantab)\n```\n\n输出结果一致。然后应用在map上，得到`equality`,进入第2关。\n\n### 官方解答\n只要将网址中的pc改为pcc即可看到官方解答.(第三关会告诉你这个秘密)\n\n```\ntable = string.maketrans(string.ascii_lowercase,string.ascii_lowercase[2:]+string.ascii_lowercase[:2])\nprint string.translate(text,table)\n```\n尽管自己写的也挺简洁，但是有些方法还是不知道啊。\n\n看样子手册这个东西是常用常新的。\n```\nfor x in s:\n    if ord(x)>=ord('a') and ord(x)<=ord('z'):\n        o+=chr((ord(x)+2-ord('a'))%26+ord('a'))\n    else:\n        o+=x\nprint o\n```\n用笨办法也是写的非常简洁。\n## 第2关\n![第2关](http://www.pythonchallenge.com/pc/def/ocr.jpg)\n\nrecognize the characters. maybe they are in the book, \nbut MAYBE they are in the page source.\n\n题目看的不是很懂。查了一下对应的意思，答案应该是在源代码里，结果`F12`一看，一大段的乱码,开头有一句：\n\n`find rare characters in the mess below:`\n\n估计要爬网页了。\n\n\n正好这几天在学爬虫，拿来练练手。有些投机取巧吧，猜到是数字或者字母了，写的惨不忍睹。\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\n\nimport urllib2, re\n\nurl = 'http://www.pythonchallenge.com/pc/def/ocr.html'\nresponse = urllib2.urlopen(url)\ncontent = response.read().decode('utf-8')\npattern = re.compile('-->(.*?)-->', re.S)\nmatch = pattern.search(content)\nresult = match.group()\npattern2 = re.compile('\\n')\nresult = pattern2.sub('', result)\npattern2 = re.compile('[a-zA-Z0-9]')\nstr = ('').join(pattern2.findall(result))\n\nprint str\n```\n最后输出：`equality`。\n当然，删除回车，直接`replace(\"\\n\",\"\")`也行，不用向我这么愚。\n\n在得知是字母之后，源代码可以改良很多：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\n\nimport urllib2, re\n\nurl = 'http://www.pythonchallenge.com/pc/def/ocr.html'\nresponse = urllib2.urlopen(url)\ncontent = response.read().decode('utf-8')\npattern = re.compile('<!--(.*?)-->', re.S)\nmatch = pattern.findall(content)\na = [i for i in match[1] if i.isalpha()]\nprint(a) \n```\n\n在得出正确答案之后，便去找了好一点的解法。一查发现，各种解法都有，唉，都怪自己学艺不精，连`count()`都没想到。在原基础上进行了改进。\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\n\nimport urllib2, re\n\nurl = 'http://www.pythonchallenge.com/pc/def/ocr.html'\nresponse = urllib2.urlopen(url)\ncontent = response.read().decode('utf-8')\npattern = re.compile('<!--(.*?)-->', re.S)\nmatch = pattern.findall(content)\n\nstr = []\nfor i in match[1]:\n    if i in str:\n        pass\n    else:\n        str.append(i)\n        print i + ' ', match[1].count(i)\nprint \"\".join(ch for ch in guts if d[ch] == 1)\n```\n这个问题在于没有直接输出答案，而且之前还觉得不错的`count()`效率并不高，就是根据题目意思来了，真的记了一个数，不过我觉得我之前的代码也没有太大问题，本来问题就没有唯一解。\n\n### 官方解答\n再来看看官方解答：\n```\nRare characters = less frequent than average\n```\n一句话就说的很明白，就是找到低于平均数的值。\n```\ns = ''.join([line.rstrip() for line in open('ocr.txt')])    \nOCCURRENCES = {}\nfor c in s: OCCURRENCES[c] = OCCURRENCES.get(c, 0) + 1\navgOC = len(s) // len(OCCURRENCES) #除法，四舍五入\nprint ''.join([c for c in s if OCCURRENCES[c] < avgOC])   \n```\n通过字典来获取值，这里用到了字典的一个方法：\n* `D.get(k[,d])` \n D[k] if k in D, else d.  d defaults to None.\n\n另外，列表生成式可以用一行语句代替循环生成所需的list，作为python的一大高级特性应该好好利用。\n\n这边官方给出了更进一步的解答：\n```\ndata = ''.join([line.rstrip() for line in open('ocr.txt')])    \nOCCURRENCES = collections.OrderedDict()\nfor c in data: OCCURRENCES[c] = OCCURRENCES.get(c, 0) + 1\navgOC = len(data) // len(OCCURRENCES)\nprint ''.join([c for c in OCCURRENCES if OCCURRENCES[c] < avgOC]) \n```\n通过有序序列，使得结果有序输出，并且最后写列表生成式的时候循环次数明显减少，优化了这个过程。\n\n在知道是字母之后，还有更加简单的写法，只需两行：\n```\nimport string\n\ntext = ''.join([line.rstrip() for line in open('ocr.txt')])\nprint filter(lambda x: x in string.letters, text)\n```\n巧妙地用了匿名函数和过滤器，很python的程序。6的不行。自己还没活用到这种程度真的都不好意思说自己会python。\n\n还有利用只出现一次这个特征来查找的，这个比之前网上找到的list方法好在巧用了字典和列表生成式。\n```\nguts = open(\"ocr.txt\").read()\nd = {}\nfor ch in guts:\n    d[ch] = d.get(ch, 0) + 1\nprint \"\".join(ch for ch in guts if d[ch] == 1)\n```\n在之后也附上了一些网友的评价：\n`count()`尽管效率不高O(n^2)但是还是运行的挺快，可读性强。需要在count之前加以判断，通过`has_key()`来进行优化。\n```\ntext = ...   # the long string found in the source code of the page\noutput = \"\" # empty string\ncounts = {}\nfor c in text:\n  if counts.has_key(c):\n    continue\n  counts[c] = text.count(c)\n  if counts[c] < 100:  # guess that rare characters will occur less than 100 times\n    output += c\n\nprint output\n```\n\n在之后的浏览中，又发现了一个很妙的写法。利用`set`这个无序，无重复的交集。\n```\n print set(\"\"\"<- lots of text ->\"\"\")\n```\n问题就在于无序，还是只找到了字母，没有连成单词。\n```\nguts = open(\"ocr.txt\").read()\nnb = set(guts)\nd = dict()\nfor c in nb:\n    d[c] = guts.count(c)\nprint ''.join( [c for c in guts if d[c] == 1 ] )\n```\n\nWho says python has only one way to do things?\n\n\n接下来到了第3关。\n##第3关\n\n![第3关](http://www.pythonchallenge.com/pc/def/bodyguard.jpg)\nOne small letter, surrounded by EXACTLY three big bodyguards on each of its sides.\n\n看完题目不知所云，好像是在说图上的蜡烛。但肯定不是，看了下源代码果然又要用正则。\n\n不过看懂也就简单了，三个大写字母夹的那个小写字母(另外三个大写的两边要是小写)，就是所需的。两次正则就可以得到结果。\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\n\nimport urllib2, re\n\nresponse = urllib2.urlopen('http://www.pythonchallenge.com/pc/def/equality.html')\ncontent = response.read()\npattern = re.compile('<!--(.*?)-->', re.S)\nmatch = pattern.findall(content)\nwith open('e.txt', 'w') as f:\n    f.write(match[0])\n\npattern = re.compile('[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]')\ncontent =''.join((line.strip() for line in open('e.txt','r')))\nmatch = pattern.findall(content)\nprint ''.join(i for i in match)\n```\n答案就是`linkedlist`\n### 官方解答\n利用列表生成式和递归的思想，简明扼要，\n```\n# text is in t2\nmarkers = ''.join( [ '0' if c in string.lowercase else '1' for c in t2 ] )\ndef f( res, t2, markers ):\n    n = len(markers.partition('011101110')[0])\n    return f( res+t2[n+4], t2[n+9:], markers[n+9:] ) if n != len(markers) else res\nprint f( '', t2, markers )\n```\n上述例子还有一点要说明的是：当出现`HHHoHHHoHHHoHHHoHHH`时，只能匹配到第二个。因为第一个明显不符合规定，由于在开头，一开始就不是小写。之后的也因为位移过多而错过判断的值。因此我们需要对其进行改进。\n```\ndef level_3(t1):\n    # 因为没有用正则，我们需要伪装一下边界\n    pad = \"x\"\n    t1 = pad + t1 + pad\n    # 检查是否为大写还是小写\n    markers = \"\".join([ '1' if c in string.uppercase else '0' for c in t1])\n    pattern = \"011101110\"\n    def f(res, t2, markers):\n        n = len(markers.partition(pattern)[0])\n        # 出于性能考虑，我们本应该把这个lambda函数放在嵌套外，但出于可读性考虑，我觉得还是放在这吧\n        end_of_string = lambda res, t2, markers: markers == pattern and res+t2[4] or res\n        return f(res+t2[n+4], t2[n+4:], markers[n+4:]) if n != len(markers) else end_of_string(res, t2, markers)\n    return f('', t1, markers)\n```\n或者不用lambda:\n```\nimport string\ndef level_3(t1):\n    # the second x ensures that the last match will never be in the last portion of the split after calling string.partition\n    pad = \"xx\"\n    t1 = pad + t1 + pad\n    markers = \"\".join([ '1' if c in string.uppercase else '0' for c in t1])\n    pattern = \"011101110\"\n    def f(res, t2, markers):\n        n = len(markers.partition(pattern)[0]\n        return f(res+t2[n+4], t2[n+4:], markers[n+4:]) if n != len(markers) else res\n    return f('', t1, markers)\n```\n另外，官方还介绍正则的用法。\n一句话解决。\n\n运用到了`(?:pattern)`来匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。\n```\n .join(re.findall('(?:^|[^A-Z])[A-Z]{3}([a-z])[A-Z]{3}(?:[^A-Z]|$)',text))\n```\n还有利用前瞻和后顾的：\n```\n .join(re.findall(\"(?<=[^A-Z][A-Z]{3})[a-z](?=[A-Z]{3}[^A-Z])\",text))\n```\n当然也有反向前瞻和后顾的：\n```\npattern = re.compile(r'(?<\\![A-Z])[A-Z]{3}([a-z])(?=[A-Z]{3}(?![A-Z]))') # !前没有斜杠\n```\n\n还有更吊的，直接把不匹配的变黑，需要的变白。这边只记录一下输出。\n\n```\nnormal = '\\033[0m'\nblack  = '\\033[30;1m'\nwhite  = '\\033[37;1m'\nfor match in matches:\n   print black + match[1:4] + white + match[4] + black + match[5:8] + normal\n```\n\n\n## 第4关\n点击图片，显示`and the next nothing is 44827`，又修改源代码，发现只是数字不同而已。\n\n这关比较简单，只要写一个循环就行。\n```\n__author__ = 'zjbao123'\nimport urllib2, re\n\nurl = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing='\ntail = '37278'\nwhile True:\n    result = urllib2.urlopen(url + tail)\n    str = result.read()\n    pattern = re.compile(\"\\d+\")\n    tail = pattern.search(str).group()\n    print tail\n```\n稍等片刻，不过期间还是有点意思的，还搞了一些分岔路和一些误导的值，当然还需要自己手动判断一下。\n最后得到答案：`peak.html`\n\n\n\n## 小结\n本来冲着过关来的，后来发现了“世外桃源”，官方写法才表现出了python的真正用法，不仅提供了python版，各个版本都有。自己写的轮子真的粗糙不堪，感觉自己的动力来自于看官方文档了呢。\n\n\n好的，本期闯关先存个档，小伙伴们，我们下期见哈哈哈","source":"_posts/python/python大闯关(0-4).md","raw":"---\ntitle: python大闯关(0-4)\ndate: 2016-10-18 20:51:02\ntags:\n- python\ncategories: 总结/\n---\n\n最近在找python对应的学习实例时,看到了一个古老的游戏,方便大家边玩边学：\n\n当当当当，**python challenge**！\n\n[入口](http://www.pythonchallenge.com/)\n\n当然，他是有规则的。\nGeneral tips:\n* Use the hints. They are helpful, most of the times.\n* Investigate the data given to you.\n* Avoid looking for spoilers.\n<!--more-->\n\n谜一样的游戏，相当有趣，试试看自己能闯几关吧。\n\n\n[repo](https://github.com/zjbao123/python_challenge_solution)\n## 第0关\n![第0关](http://www.pythonchallenge.com/pc/def/calc.jpg)\n根据图片，就可以知道，2的38次方。\n```\nprint (2**38)\n```\n计算得到结果,274877906944,输入即可到下一关。\n\n## 第1关\n\n![第1关](http://www.pythonchallenge.com/pc/def/map.jpg)\n\n下面有一句提示：`everybody thinks twice before solving this.`\n然后一堆乱码：\n\ng fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.\n\n从图中可以看出，每个字母都向后移了两位得到那个数字。这估计就是关键所在了。\n\n思路是这样的：\n\n首先，将26个字母的ASCII码表示出来，转换为对应的数字。a~z对应为97~122\n将对应的数字移位解码输出，如ASCII码不在此范围则直接输出。\n\nASCII码对应的转化函数为：`chr(65) ord('a')`\n```\ndef findLetter(s):\n    sum =''\n    for i in s:\n\n        if 120>=ord(i)>=97:\n             sum +=chr(ord(i)+2)\n        elif 122>=ord(i)>=121:\n            sum += chr(ord(i)-24)\n        else:\n            sum += i\n    return sum\nl = \"g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj\"\nprint findLetter(l)\n```\n\n解码结果为：\n\ni hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that's why this text is so long. using string.maketrans() is recommended. now apply on the url\n\n这边解码之后，又告诉我了另一个解码的方式，通过映射表来编码解码(怪自己知道的太少)：\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport string\n\n__author__ = 'zjbao123'\nintab = 'abcdefghijklmnopqrstuvwxyz'\nouttab = 'cdefghijklmnopqrstuvwxyzab'\ntrantab = string.maketrans(intab, outtab)\n\nl = \"map\"\nprint l.translate(trantab)\n```\n\n输出结果一致。然后应用在map上，得到`equality`,进入第2关。\n\n### 官方解答\n只要将网址中的pc改为pcc即可看到官方解答.(第三关会告诉你这个秘密)\n\n```\ntable = string.maketrans(string.ascii_lowercase,string.ascii_lowercase[2:]+string.ascii_lowercase[:2])\nprint string.translate(text,table)\n```\n尽管自己写的也挺简洁，但是有些方法还是不知道啊。\n\n看样子手册这个东西是常用常新的。\n```\nfor x in s:\n    if ord(x)>=ord('a') and ord(x)<=ord('z'):\n        o+=chr((ord(x)+2-ord('a'))%26+ord('a'))\n    else:\n        o+=x\nprint o\n```\n用笨办法也是写的非常简洁。\n## 第2关\n![第2关](http://www.pythonchallenge.com/pc/def/ocr.jpg)\n\nrecognize the characters. maybe they are in the book, \nbut MAYBE they are in the page source.\n\n题目看的不是很懂。查了一下对应的意思，答案应该是在源代码里，结果`F12`一看，一大段的乱码,开头有一句：\n\n`find rare characters in the mess below:`\n\n估计要爬网页了。\n\n\n正好这几天在学爬虫，拿来练练手。有些投机取巧吧，猜到是数字或者字母了，写的惨不忍睹。\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\n\nimport urllib2, re\n\nurl = 'http://www.pythonchallenge.com/pc/def/ocr.html'\nresponse = urllib2.urlopen(url)\ncontent = response.read().decode('utf-8')\npattern = re.compile('-->(.*?)-->', re.S)\nmatch = pattern.search(content)\nresult = match.group()\npattern2 = re.compile('\\n')\nresult = pattern2.sub('', result)\npattern2 = re.compile('[a-zA-Z0-9]')\nstr = ('').join(pattern2.findall(result))\n\nprint str\n```\n最后输出：`equality`。\n当然，删除回车，直接`replace(\"\\n\",\"\")`也行，不用向我这么愚。\n\n在得知是字母之后，源代码可以改良很多：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\n\nimport urllib2, re\n\nurl = 'http://www.pythonchallenge.com/pc/def/ocr.html'\nresponse = urllib2.urlopen(url)\ncontent = response.read().decode('utf-8')\npattern = re.compile('<!--(.*?)-->', re.S)\nmatch = pattern.findall(content)\na = [i for i in match[1] if i.isalpha()]\nprint(a) \n```\n\n在得出正确答案之后，便去找了好一点的解法。一查发现，各种解法都有，唉，都怪自己学艺不精，连`count()`都没想到。在原基础上进行了改进。\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\n\nimport urllib2, re\n\nurl = 'http://www.pythonchallenge.com/pc/def/ocr.html'\nresponse = urllib2.urlopen(url)\ncontent = response.read().decode('utf-8')\npattern = re.compile('<!--(.*?)-->', re.S)\nmatch = pattern.findall(content)\n\nstr = []\nfor i in match[1]:\n    if i in str:\n        pass\n    else:\n        str.append(i)\n        print i + ' ', match[1].count(i)\nprint \"\".join(ch for ch in guts if d[ch] == 1)\n```\n这个问题在于没有直接输出答案，而且之前还觉得不错的`count()`效率并不高，就是根据题目意思来了，真的记了一个数，不过我觉得我之前的代码也没有太大问题，本来问题就没有唯一解。\n\n### 官方解答\n再来看看官方解答：\n```\nRare characters = less frequent than average\n```\n一句话就说的很明白，就是找到低于平均数的值。\n```\ns = ''.join([line.rstrip() for line in open('ocr.txt')])    \nOCCURRENCES = {}\nfor c in s: OCCURRENCES[c] = OCCURRENCES.get(c, 0) + 1\navgOC = len(s) // len(OCCURRENCES) #除法，四舍五入\nprint ''.join([c for c in s if OCCURRENCES[c] < avgOC])   \n```\n通过字典来获取值，这里用到了字典的一个方法：\n* `D.get(k[,d])` \n D[k] if k in D, else d.  d defaults to None.\n\n另外，列表生成式可以用一行语句代替循环生成所需的list，作为python的一大高级特性应该好好利用。\n\n这边官方给出了更进一步的解答：\n```\ndata = ''.join([line.rstrip() for line in open('ocr.txt')])    \nOCCURRENCES = collections.OrderedDict()\nfor c in data: OCCURRENCES[c] = OCCURRENCES.get(c, 0) + 1\navgOC = len(data) // len(OCCURRENCES)\nprint ''.join([c for c in OCCURRENCES if OCCURRENCES[c] < avgOC]) \n```\n通过有序序列，使得结果有序输出，并且最后写列表生成式的时候循环次数明显减少，优化了这个过程。\n\n在知道是字母之后，还有更加简单的写法，只需两行：\n```\nimport string\n\ntext = ''.join([line.rstrip() for line in open('ocr.txt')])\nprint filter(lambda x: x in string.letters, text)\n```\n巧妙地用了匿名函数和过滤器，很python的程序。6的不行。自己还没活用到这种程度真的都不好意思说自己会python。\n\n还有利用只出现一次这个特征来查找的，这个比之前网上找到的list方法好在巧用了字典和列表生成式。\n```\nguts = open(\"ocr.txt\").read()\nd = {}\nfor ch in guts:\n    d[ch] = d.get(ch, 0) + 1\nprint \"\".join(ch for ch in guts if d[ch] == 1)\n```\n在之后也附上了一些网友的评价：\n`count()`尽管效率不高O(n^2)但是还是运行的挺快，可读性强。需要在count之前加以判断，通过`has_key()`来进行优化。\n```\ntext = ...   # the long string found in the source code of the page\noutput = \"\" # empty string\ncounts = {}\nfor c in text:\n  if counts.has_key(c):\n    continue\n  counts[c] = text.count(c)\n  if counts[c] < 100:  # guess that rare characters will occur less than 100 times\n    output += c\n\nprint output\n```\n\n在之后的浏览中，又发现了一个很妙的写法。利用`set`这个无序，无重复的交集。\n```\n print set(\"\"\"<- lots of text ->\"\"\")\n```\n问题就在于无序，还是只找到了字母，没有连成单词。\n```\nguts = open(\"ocr.txt\").read()\nnb = set(guts)\nd = dict()\nfor c in nb:\n    d[c] = guts.count(c)\nprint ''.join( [c for c in guts if d[c] == 1 ] )\n```\n\nWho says python has only one way to do things?\n\n\n接下来到了第3关。\n##第3关\n\n![第3关](http://www.pythonchallenge.com/pc/def/bodyguard.jpg)\nOne small letter, surrounded by EXACTLY three big bodyguards on each of its sides.\n\n看完题目不知所云，好像是在说图上的蜡烛。但肯定不是，看了下源代码果然又要用正则。\n\n不过看懂也就简单了，三个大写字母夹的那个小写字母(另外三个大写的两边要是小写)，就是所需的。两次正则就可以得到结果。\n\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\n\nimport urllib2, re\n\nresponse = urllib2.urlopen('http://www.pythonchallenge.com/pc/def/equality.html')\ncontent = response.read()\npattern = re.compile('<!--(.*?)-->', re.S)\nmatch = pattern.findall(content)\nwith open('e.txt', 'w') as f:\n    f.write(match[0])\n\npattern = re.compile('[^A-Z][A-Z]{3}([a-z])[A-Z]{3}[^A-Z]')\ncontent =''.join((line.strip() for line in open('e.txt','r')))\nmatch = pattern.findall(content)\nprint ''.join(i for i in match)\n```\n答案就是`linkedlist`\n### 官方解答\n利用列表生成式和递归的思想，简明扼要，\n```\n# text is in t2\nmarkers = ''.join( [ '0' if c in string.lowercase else '1' for c in t2 ] )\ndef f( res, t2, markers ):\n    n = len(markers.partition('011101110')[0])\n    return f( res+t2[n+4], t2[n+9:], markers[n+9:] ) if n != len(markers) else res\nprint f( '', t2, markers )\n```\n上述例子还有一点要说明的是：当出现`HHHoHHHoHHHoHHHoHHH`时，只能匹配到第二个。因为第一个明显不符合规定，由于在开头，一开始就不是小写。之后的也因为位移过多而错过判断的值。因此我们需要对其进行改进。\n```\ndef level_3(t1):\n    # 因为没有用正则，我们需要伪装一下边界\n    pad = \"x\"\n    t1 = pad + t1 + pad\n    # 检查是否为大写还是小写\n    markers = \"\".join([ '1' if c in string.uppercase else '0' for c in t1])\n    pattern = \"011101110\"\n    def f(res, t2, markers):\n        n = len(markers.partition(pattern)[0])\n        # 出于性能考虑，我们本应该把这个lambda函数放在嵌套外，但出于可读性考虑，我觉得还是放在这吧\n        end_of_string = lambda res, t2, markers: markers == pattern and res+t2[4] or res\n        return f(res+t2[n+4], t2[n+4:], markers[n+4:]) if n != len(markers) else end_of_string(res, t2, markers)\n    return f('', t1, markers)\n```\n或者不用lambda:\n```\nimport string\ndef level_3(t1):\n    # the second x ensures that the last match will never be in the last portion of the split after calling string.partition\n    pad = \"xx\"\n    t1 = pad + t1 + pad\n    markers = \"\".join([ '1' if c in string.uppercase else '0' for c in t1])\n    pattern = \"011101110\"\n    def f(res, t2, markers):\n        n = len(markers.partition(pattern)[0]\n        return f(res+t2[n+4], t2[n+4:], markers[n+4:]) if n != len(markers) else res\n    return f('', t1, markers)\n```\n另外，官方还介绍正则的用法。\n一句话解决。\n\n运用到了`(?:pattern)`来匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。\n```\n .join(re.findall('(?:^|[^A-Z])[A-Z]{3}([a-z])[A-Z]{3}(?:[^A-Z]|$)',text))\n```\n还有利用前瞻和后顾的：\n```\n .join(re.findall(\"(?<=[^A-Z][A-Z]{3})[a-z](?=[A-Z]{3}[^A-Z])\",text))\n```\n当然也有反向前瞻和后顾的：\n```\npattern = re.compile(r'(?<\\![A-Z])[A-Z]{3}([a-z])(?=[A-Z]{3}(?![A-Z]))') # !前没有斜杠\n```\n\n还有更吊的，直接把不匹配的变黑，需要的变白。这边只记录一下输出。\n\n```\nnormal = '\\033[0m'\nblack  = '\\033[30;1m'\nwhite  = '\\033[37;1m'\nfor match in matches:\n   print black + match[1:4] + white + match[4] + black + match[5:8] + normal\n```\n\n\n## 第4关\n点击图片，显示`and the next nothing is 44827`，又修改源代码，发现只是数字不同而已。\n\n这关比较简单，只要写一个循环就行。\n```\n__author__ = 'zjbao123'\nimport urllib2, re\n\nurl = 'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing='\ntail = '37278'\nwhile True:\n    result = urllib2.urlopen(url + tail)\n    str = result.read()\n    pattern = re.compile(\"\\d+\")\n    tail = pattern.search(str).group()\n    print tail\n```\n稍等片刻，不过期间还是有点意思的，还搞了一些分岔路和一些误导的值，当然还需要自己手动判断一下。\n最后得到答案：`peak.html`\n\n\n\n## 小结\n本来冲着过关来的，后来发现了“世外桃源”，官方写法才表现出了python的真正用法，不仅提供了python版，各个版本都有。自己写的轮子真的粗糙不堪，感觉自己的动力来自于看官方文档了呢。\n\n\n好的，本期闯关先存个档，小伙伴们，我们下期见哈哈哈","slug":"python/python大闯关(0-4)","published":1,"updated":"2019-03-22T14:44:36.728Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0k009k4l3nllp8sjcw","content":"<p>最近在找python对应的学习实例时,看到了一个古老的游戏,方便大家边玩边学：</p>\n<p>当当当当，<strong>python challenge</strong>！</p>\n<p><a href=\"http://www.pythonchallenge.com/\" target=\"_blank\" rel=\"noopener\">入口</a></p>\n<p>当然，他是有规则的。<br>General tips:</p>\n<ul>\n<li>Use the hints. They are helpful, most of the times.</li>\n<li>Investigate the data given to you.</li>\n<li>Avoid looking for spoilers.<a id=\"more\"></a>\n</li>\n</ul>\n<p>谜一样的游戏，相当有趣，试试看自己能闯几关吧。</p>\n<p><a href=\"https://github.com/zjbao123/python_challenge_solution\" target=\"_blank\" rel=\"noopener\">repo</a></p>\n<h2 id=\"第0关\"><a href=\"#第0关\" class=\"headerlink\" title=\"第0关\"></a>第0关</h2><p><img src=\"http://www.pythonchallenge.com/pc/def/calc.jpg\" alt=\"第0关\"><br>根据图片，就可以知道，2的38次方。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"builtin-name\">print</span> (2*<span class=\"number\">*38</span>)</span><br></pre></td></tr></table></figure></p>\n<p>计算得到结果,274877906944,输入即可到下一关。</p>\n<h2 id=\"第1关\"><a href=\"#第1关\" class=\"headerlink\" title=\"第1关\"></a>第1关</h2><p><img src=\"http://www.pythonchallenge.com/pc/def/map.jpg\" alt=\"第1关\"></p>\n<p>下面有一句提示：<code>everybody thinks twice before solving this.</code><br>然后一堆乱码：</p>\n<p>g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr’q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.</p>\n<p>从图中可以看出，每个字母都向后移了两位得到那个数字。这估计就是关键所在了。</p>\n<p>思路是这样的：</p>\n<p>首先，将26个字母的ASCII码表示出来，转换为对应的数字。a~z对应为97~122<br>将对应的数字移位解码输出，如ASCII码不在此范围则直接输出。</p>\n<p>ASCII码对应的转化函数为：<code>chr(65) ord(&#39;a&#39;)</code><br><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def findLetter(s):</span><br><span class=\"line\">    <span class=\"keyword\">sum</span> =<span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i in s:</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">120</span>&gt;=<span class=\"keyword\">ord</span>(i)&gt;=<span class=\"number\">97</span>:</span><br><span class=\"line\">             <span class=\"keyword\">sum</span> +=chr(<span class=\"keyword\">ord</span>(i)+<span class=\"number\">2</span>)</span><br><span class=\"line\">        elif <span class=\"number\">122</span>&gt;=<span class=\"keyword\">ord</span>(i)&gt;=<span class=\"number\">121</span>:</span><br><span class=\"line\">            <span class=\"keyword\">sum</span> += chr(<span class=\"keyword\">ord</span>(i)<span class=\"number\">-24</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">sum</span> += i</span><br><span class=\"line\">    return <span class=\"keyword\">sum</span></span><br><span class=\"line\">l = <span class=\"string\">\"g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj\"</span></span><br><span class=\"line\">print findLetter(l)</span><br></pre></td></tr></table></figure></p>\n<p>解码结果为：</p>\n<p>i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that’s why this text is so long. using string.maketrans() is recommended. now apply on the url</p>\n<p>这边解码之后，又告诉我了另一个解码的方式，通过映射表来编码解码(怪自己知道的太少)：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">import string</span><br><span class=\"line\"></span><br><span class=\"line\">__author__ = 'zjbao123'</span><br><span class=\"line\">intab = 'abcdefghijklmnopqrstuvwxyz'</span><br><span class=\"line\">outtab = 'cdefghijklmnopqrstuvwxyzab'</span><br><span class=\"line\">trantab = string.maketrans(intab, outtab)</span><br><span class=\"line\"></span><br><span class=\"line\">l = <span class=\"string\">\"map\"</span></span><br><span class=\"line\">print l.translate(trantab)</span><br></pre></td></tr></table></figure>\n<p>输出结果一致。然后应用在map上，得到<code>equality</code>,进入第2关。</p>\n<h3 id=\"官方解答\"><a href=\"#官方解答\" class=\"headerlink\" title=\"官方解答\"></a>官方解答</h3><p>只要将网址中的pc改为pcc即可看到官方解答.(第三关会告诉你这个秘密)</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">table</span> = <span class=\"built_in\">string</span>.maketrans(<span class=\"built_in\">string</span>.ascii_lowercase,<span class=\"built_in\">string</span>.ascii_lowercase[<span class=\"number\">2</span>:]+<span class=\"built_in\">string</span>.ascii_lowercase[:<span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">string</span>.translate(text,<span class=\"built_in\">table</span>)</span><br></pre></td></tr></table></figure>\n<p>尽管自己写的也挺简洁，但是有些方法还是不知道啊。</p>\n<p>看样子手册这个东西是常用常新的。<br><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">x</span> in <span class=\"keyword\">s</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">ord</span>(<span class=\"keyword\">x</span>)&gt;=<span class=\"keyword\">ord</span>(<span class=\"string\">'a'</span>) <span class=\"keyword\">and</span> <span class=\"keyword\">ord</span>(<span class=\"keyword\">x</span>)&lt;=<span class=\"keyword\">ord</span>(<span class=\"string\">'z'</span>):</span><br><span class=\"line\">        o+=<span class=\"keyword\">chr</span>((<span class=\"keyword\">ord</span>(<span class=\"keyword\">x</span>)+<span class=\"number\">2</span>-<span class=\"keyword\">ord</span>(<span class=\"string\">'a'</span>))%26+<span class=\"keyword\">ord</span>(<span class=\"string\">'a'</span>))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        o+=<span class=\"keyword\">x</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> o</span><br></pre></td></tr></table></figure></p>\n<p>用笨办法也是写的非常简洁。</p>\n<h2 id=\"第2关\"><a href=\"#第2关\" class=\"headerlink\" title=\"第2关\"></a>第2关</h2><p><img src=\"http://www.pythonchallenge.com/pc/def/ocr.jpg\" alt=\"第2关\"></p>\n<p>recognize the characters. maybe they are in the book,<br>but MAYBE they are in the page source.</p>\n<p>题目看的不是很懂。查了一下对应的意思，答案应该是在源代码里，结果<code>F12</code>一看，一大段的乱码,开头有一句：</p>\n<p><code>find rare characters in the mess below:</code></p>\n<p>估计要爬网页了。</p>\n<p>正好这几天在学爬虫，拿来练练手。有些投机取巧吧，猜到是数字或者字母了，写的惨不忍睹。<br><figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib2, re</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">'http://www.pythonchallenge.com/pc/def/ocr.html'</span></span><br><span class=\"line\">response = urllib2.urlopen(url)</span><br><span class=\"line\">content = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">pattern = re.compile<span class=\"function\"><span class=\"params\">(<span class=\"string\">'--&gt;(.*?)--&gt;'</span>, re.S)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">match</span> = <span class=\"title\">pattern</span>.<span class=\"title\">search</span><span class=\"params\">(content)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">result</span> = <span class=\"title\">match</span>.<span class=\"title\">group</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">pattern2</span> = <span class=\"title\">re</span>.<span class=\"title\">compile</span><span class=\"params\">(<span class=\"string\">'\\n'</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">result</span> = <span class=\"title\">pattern2</span>.<span class=\"title\">sub</span><span class=\"params\">(<span class=\"string\">''</span>, result)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">pattern2</span> = <span class=\"title\">re</span>.<span class=\"title\">compile</span><span class=\"params\">(<span class=\"string\">'[a-zA-Z0-9]'</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">str</span> = <span class=\"params\">(<span class=\"string\">''</span>)</span>.<span class=\"title\">join</span><span class=\"params\">(pattern2.findall(result))</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span> <span class=\"title\">str</span></span></span><br></pre></td></tr></table></figure></p>\n<p>最后输出：<code>equality</code>。<br>当然，删除回车，直接<code>replace(&quot;\\n&quot;,&quot;&quot;)</code>也行，不用向我这么愚。</p>\n<p>在得知是字母之后，源代码可以改良很多：<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = 'zjbao123'</span><br><span class=\"line\"></span><br><span class=\"line\">import urllib2, re</span><br><span class=\"line\"></span><br><span class=\"line\">url = 'http://www.pythonchallenge.com/pc/def/ocr.html'</span><br><span class=\"line\">response = urllib2.urlopen(url)</span><br><span class=\"line\">content = response.read().decode('utf-8')</span><br><span class=\"line\">pattern = re.compile('&lt;!--(.*?)--&gt;', re.S)</span><br><span class=\"line\">match = pattern.findall(content)</span><br><span class=\"line\">a = [i for i in match[1] if i.isalpha()]</span><br><span class=\"line\">print(a)</span><br></pre></td></tr></table></figure></p>\n<p>在得出正确答案之后，便去找了好一点的解法。一查发现，各种解法都有，唉，都怪自己学艺不精，连<code>count()</code>都没想到。在原基础上进行了改进。<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># -*- coding: utf<span class=\"number\">-8</span> -*-</span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib2, re</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">'http://www.pythonchallenge.com/pc/def/ocr.html'</span></span><br><span class=\"line\">response = urllib2.urlopen(url)</span><br><span class=\"line\">content = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">pattern = re.compile(<span class=\"string\">'&lt;!--(.*?)--&gt;'</span>, re.S)</span><br><span class=\"line\"><span class=\"built_in\">match</span> = pattern.findall(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">str</span> = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i in <span class=\"built_in\">match</span>[<span class=\"number\">1</span>]:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i in <span class=\"built_in\">str</span>:</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">str</span>.<span class=\"built_in\">append</span>(i)</span><br><span class=\"line\">        <span class=\"built_in\">print</span> i + <span class=\"string\">' '</span>, <span class=\"built_in\">match</span>[<span class=\"number\">1</span>].count(i)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">\"\"</span>.<span class=\"built_in\">join</span>(ch <span class=\"keyword\">for</span> ch in guts <span class=\"keyword\">if</span> d[ch] == <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这个问题在于没有直接输出答案，而且之前还觉得不错的<code>count()</code>效率并不高，就是根据题目意思来了，真的记了一个数，不过我觉得我之前的代码也没有太大问题，本来问题就没有唯一解。</p>\n<h3 id=\"官方解答-1\"><a href=\"#官方解答-1\" class=\"headerlink\" title=\"官方解答\"></a>官方解答</h3><p>再来看看官方解答：<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rare <span class=\"keyword\">characters</span> = less frequent than <span class=\"built_in\">average</span></span><br></pre></td></tr></table></figure></p>\n<p>一句话就说的很明白，就是找到低于平均数的值。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = ''.<span class=\"built_in\">join</span>([line.rstrip() <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> <span class=\"keyword\">open</span>('ocr.txt')])    </span><br><span class=\"line\"><span class=\"type\">OCCURRENCES</span> = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> s: <span class=\"type\">OCCURRENCES</span>[<span class=\"built_in\">c</span>] = <span class=\"type\">OCCURRENCES</span>.<span class=\"keyword\">get</span>(<span class=\"built_in\">c</span>, <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">avgOC = len(s) <span class=\"comment\">// len(OCCURRENCES) #除法，四舍五入</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> ''.<span class=\"built_in\">join</span>([<span class=\"built_in\">c</span> <span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> s <span class=\"keyword\">if</span> <span class=\"type\">OCCURRENCES</span>[<span class=\"built_in\">c</span>] &lt; avgOC])</span><br></pre></td></tr></table></figure></p>\n<p>通过字典来获取值，这里用到了字典的一个方法：</p>\n<ul>\n<li><code>D.get(k[,d])</code><br>D[k] if k in D, else d.  d defaults to None.</li>\n</ul>\n<p>另外，列表生成式可以用一行语句代替循环生成所需的list，作为python的一大高级特性应该好好利用。</p>\n<p>这边官方给出了更进一步的解答：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = ''.<span class=\"built_in\">join</span>([line.rstrip() <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> <span class=\"keyword\">open</span>('ocr.txt')])    </span><br><span class=\"line\"><span class=\"type\">OCCURRENCES</span> = collections.<span class=\"type\">OrderedDict</span>()</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> data: <span class=\"type\">OCCURRENCES</span>[<span class=\"built_in\">c</span>] = <span class=\"type\">OCCURRENCES</span>.<span class=\"keyword\">get</span>(<span class=\"built_in\">c</span>, <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">avgOC = len(data) <span class=\"comment\">// len(OCCURRENCES)</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> ''.<span class=\"built_in\">join</span>([<span class=\"built_in\">c</span> <span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> <span class=\"type\">OCCURRENCES</span> <span class=\"keyword\">if</span> <span class=\"type\">OCCURRENCES</span>[<span class=\"built_in\">c</span>] &lt; avgOC])</span><br></pre></td></tr></table></figure></p>\n<p>通过有序序列，使得结果有序输出，并且最后写列表生成式的时候循环次数明显减少，优化了这个过程。</p>\n<p>在知道是字母之后，还有更加简单的写法，只需两行：<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">text</span> = <span class=\"string\">''</span>.join([<span class=\"built_in\">line</span>.rstrip() <span class=\"keyword\">for</span> <span class=\"built_in\">line</span> <span class=\"keyword\">in</span> <span class=\"built_in\">open</span>(<span class=\"string\">'ocr.txt'</span>)])</span><br><span class=\"line\">print <span class=\"built_in\">filter</span>(lambda x: x <span class=\"keyword\">in</span> <span class=\"keyword\">string</span>.letters, <span class=\"keyword\">text</span>)</span><br></pre></td></tr></table></figure></p>\n<p>巧妙地用了匿名函数和过滤器，很python的程序。6的不行。自己还没活用到这种程度真的都不好意思说自己会python。</p>\n<p>还有利用只出现一次这个特征来查找的，这个比之前网上找到的list方法好在巧用了字典和列表生成式。<br><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">guts = open(<span class=\"string\">\"ocr.txt\"</span>).<span class=\"built_in\">read</span>()</span><br><span class=\"line\">d = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> guts:</span><br><span class=\"line\">    d[ch] = d.<span class=\"built_in\">get</span>(ch, <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">\"\"</span>.<span class=\"built_in\">join</span>(ch <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> guts <span class=\"keyword\">if</span> d[ch] == <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在之后也附上了一些网友的评价：<br><code>count()</code>尽管效率不高O(n^2)但是还是运行的挺快，可读性强。需要在count之前加以判断，通过<code>has_key()</code>来进行优化。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text = <span class=\"built_in\">..</span>.   # the long string found <span class=\"keyword\">in</span> the source code of the page</span><br><span class=\"line\">output = <span class=\"string\">\"\"</span> # empty string</span><br><span class=\"line\">counts = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> text:</span><br><span class=\"line\">  <span class=\"keyword\">if</span> counts.has_key(c):</span><br><span class=\"line\">    continue</span><br><span class=\"line\">  counts[c] = text.count(c)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> counts[c] &lt; 100:  # guess that rare characters will occur less than 100 times</span><br><span class=\"line\">    output += c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"builtin-name\">print</span> output</span><br></pre></td></tr></table></figure></p>\n<p>在之后的浏览中，又发现了一个很妙的写法。利用<code>set</code>这个无序，无重复的交集。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">print</span> set(<span class=\"string\">\"\"\"&lt;- lots of text -&gt;\"\"\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>问题就在于无序，还是只找到了字母，没有连成单词。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">guts = <span class=\"keyword\">open</span>(<span class=\"string\">\"ocr.txt\"</span>).read()</span><br><span class=\"line\">nb = <span class=\"keyword\">set</span>(guts)</span><br><span class=\"line\">d = dict()</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> nb:</span><br><span class=\"line\">    d[<span class=\"built_in\">c</span>] = guts.<span class=\"built_in\">count</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> ''.<span class=\"built_in\">join</span>( [<span class=\"built_in\">c</span> <span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> guts <span class=\"keyword\">if</span> d[<span class=\"built_in\">c</span>] == <span class=\"number\">1</span> ] )</span><br></pre></td></tr></table></figure></p>\n<p>Who says python has only one way to do things?</p>\n<p>接下来到了第3关。</p>\n<p>##第3关</p>\n<p><img src=\"http://www.pythonchallenge.com/pc/def/bodyguard.jpg\" alt=\"第3关\"><br>One small letter, surrounded by EXACTLY three big bodyguards on each of its sides.</p>\n<p>看完题目不知所云，好像是在说图上的蜡烛。但肯定不是，看了下源代码果然又要用正则。</p>\n<p>不过看懂也就简单了，三个大写字母夹的那个小写字母(另外三个大写的两边要是小写)，就是所需的。两次正则就可以得到结果。</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib2, re</span><br><span class=\"line\"></span><br><span class=\"line\">response = urllib2.urlopen(<span class=\"string\">'http://www.pythonchallenge.com/pc/def/equality.html'</span>)</span><br><span class=\"line\">content = response.read()</span><br><span class=\"line\">pattern = re.compile<span class=\"function\"><span class=\"params\">(<span class=\"string\">'&lt;!--(.*?)--&gt;'</span>, re.S)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">match</span> = <span class=\"title\">pattern</span>.<span class=\"title\">findall</span><span class=\"params\">(content)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">with</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"string\">'e.txt'</span>, <span class=\"string\">'w'</span>)</span> <span class=\"title\">as</span> <span class=\"title\">f</span>:</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">f</span>.<span class=\"title\">write</span><span class=\"params\">(match[<span class=\"number\">0</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">pattern</span> = <span class=\"title\">re</span>.<span class=\"title\">compile</span><span class=\"params\">(<span class=\"string\">'[^A-Z][A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;[^A-Z]'</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">content</span> =''.<span class=\"title\">join</span><span class=\"params\">((line.strip() <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> open(<span class=\"string\">'e.txt'</span>,<span class=\"string\">'r'</span>)))</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">match</span> = <span class=\"title\">pattern</span>.<span class=\"title\">findall</span><span class=\"params\">(content)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span> ''.<span class=\"title\">join</span><span class=\"params\">(i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> match)</span></span></span><br></pre></td></tr></table></figure>\n<p>答案就是<code>linkedlist</code></p>\n<h3 id=\"官方解答-2\"><a href=\"#官方解答-2\" class=\"headerlink\" title=\"官方解答\"></a>官方解答</h3><p>利用列表生成式和递归的思想，简明扼要，<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># text <span class=\"keyword\">is</span> in t2</span><br><span class=\"line\">markers = <span class=\"string\">''</span>.<span class=\"keyword\">join</span>( [ <span class=\"string\">'0'</span> <span class=\"keyword\">if</span> <span class=\"keyword\">c</span> in <span class=\"built_in\">string</span>.lowercase <span class=\"keyword\">else</span> <span class=\"string\">'1'</span> <span class=\"keyword\">for</span> <span class=\"keyword\">c</span> in t2 ] )</span><br><span class=\"line\">def <span class=\"keyword\">f</span>( <span class=\"keyword\">res</span>, t2, markers ):</span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(markers.partition(<span class=\"string\">'011101110'</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">f</span>( <span class=\"keyword\">res</span>+t2[n+<span class=\"number\">4</span>], t2[n+<span class=\"number\">9</span>:], markers[n+<span class=\"number\">9</span>:] ) <span class=\"keyword\">if</span> n != <span class=\"built_in\">len</span>(markers) <span class=\"keyword\">else</span> <span class=\"keyword\">res</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"keyword\">f</span>( <span class=\"string\">''</span>, t2, markers )</span><br></pre></td></tr></table></figure></p>\n<p>上述例子还有一点要说明的是：当出现<code>HHHoHHHoHHHoHHHoHHH</code>时，只能匹配到第二个。因为第一个明显不符合规定，由于在开头，一开始就不是小写。之后的也因为位移过多而错过判断的值。因此我们需要对其进行改进。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">level_3</span><span class=\"params\">(t1)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 因为没有用正则，我们需要伪装一下边界</span></span><br><span class=\"line\">    pad = <span class=\"string\">\"x\"</span></span><br><span class=\"line\">    t1 = pad + t1 + pad</span><br><span class=\"line\">    <span class=\"comment\"># 检查是否为大写还是小写</span></span><br><span class=\"line\">    markers = <span class=\"string\">\"\"</span>.join([ <span class=\"string\">'1'</span> <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> string.uppercase <span class=\"keyword\">else</span> <span class=\"string\">'0'</span> <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> t1])</span><br><span class=\"line\">    pattern = <span class=\"string\">\"011101110\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(res, t2, markers)</span>:</span></span><br><span class=\"line\">        n = len(markers.partition(pattern)[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"comment\"># 出于性能考虑，我们本应该把这个lambda函数放在嵌套外，但出于可读性考虑，我觉得还是放在这吧</span></span><br><span class=\"line\">        end_of_string = <span class=\"keyword\">lambda</span> res, t2, markers: markers == pattern <span class=\"keyword\">and</span> res+t2[<span class=\"number\">4</span>] <span class=\"keyword\">or</span> res</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f(res+t2[n+<span class=\"number\">4</span>], t2[n+<span class=\"number\">4</span>:], markers[n+<span class=\"number\">4</span>:]) <span class=\"keyword\">if</span> n != len(markers) <span class=\"keyword\">else</span> end_of_string(res, t2, markers)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(<span class=\"string\">''</span>, t1, markers)</span><br></pre></td></tr></table></figure></p>\n<p>或者不用lambda:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">level_3</span><span class=\"params\">(t1)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># the second x ensures that the last match will never be in the last portion of the split after calling string.partition</span></span><br><span class=\"line\">    pad = <span class=\"string\">\"xx\"</span></span><br><span class=\"line\">    t1 = pad + t1 + pad</span><br><span class=\"line\">    markers = <span class=\"string\">\"\"</span>.join([ <span class=\"string\">'1'</span> <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> string.uppercase <span class=\"keyword\">else</span> <span class=\"string\">'0'</span> <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> t1])</span><br><span class=\"line\">    pattern = <span class=\"string\">\"011101110\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(res, t2, markers)</span>:</span></span><br><span class=\"line\">        n = len(markers.partition(pattern)[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f(res+t2[n+<span class=\"number\">4</span>], t2[n+<span class=\"number\">4</span>:], markers[n+<span class=\"number\">4</span>:]) <span class=\"keyword\">if</span> n != len(markers) <span class=\"keyword\">else</span> res</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(<span class=\"string\">''</span>, t1, markers)</span><br></pre></td></tr></table></figure></p>\n<p>另外，官方还介绍正则的用法。<br>一句话解决。</p>\n<p>运用到了<code>(?:pattern)</code>来匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"keyword\">join</span>(re.findall(<span class=\"comment\">'(?:^|[^A-Z])[A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;(?:[^A-Z]|$)',text))</span></span><br></pre></td></tr></table></figure></p>\n<p>还有利用前瞻和后顾的：<br><figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.join(re.findall(<span class=\"string\">\"(?&lt;=<span class=\"subst\">[^A-Z]</span><span class=\"subst\">[A-Z]</span>&#123;3&#125;)<span class=\"subst\">[a-z]</span>(?=<span class=\"subst\">[A-Z]</span>&#123;3&#125;<span class=\"subst\">[^A-Z]</span>)\"</span>,text))</span><br></pre></td></tr></table></figure></p>\n<p>当然也有反向前瞻和后顾的：<br><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pattern = re.compile(<span class=\"string\">r'(?&lt;\\![A-Z])[A-Z]&#123;3&#125;([a-z])(?=[A-Z]&#123;3&#125;(?![A-Z]))'</span>) <span class=\"comment\"># !前没有斜杠</span></span><br></pre></td></tr></table></figure></p>\n<p>还有更吊的，直接把不匹配的变黑，需要的变白。这边只记录一下输出。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">normal</span> = <span class=\"string\">'\\033[0m'</span></span><br><span class=\"line\">black  = <span class=\"string\">'\\033[30;1m'</span></span><br><span class=\"line\">white  = <span class=\"string\">'\\033[37;1m'</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">match</span> in matche<span class=\"variable\">s:</span></span><br><span class=\"line\">   <span class=\"keyword\">print</span> black + <span class=\"keyword\">match</span>[<span class=\"number\">1</span>:<span class=\"number\">4</span>] + white + <span class=\"keyword\">match</span>[<span class=\"number\">4</span>] + black + <span class=\"keyword\">match</span>[<span class=\"number\">5</span>:<span class=\"number\">8</span>] + <span class=\"keyword\">normal</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"第4关\"><a href=\"#第4关\" class=\"headerlink\" title=\"第4关\"></a>第4关</h2><p>点击图片，显示<code>and the next nothing is 44827</code>，又修改源代码，发现只是数字不同而已。</p>\n<p>这关比较简单，只要写一个循环就行。<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib2, re</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing='</span></span><br><span class=\"line\">tail = <span class=\"string\">'37278'</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    result = urllib2.urlopen(url + tail)</span><br><span class=\"line\">    str = result.<span class=\"keyword\">read</span>()</span><br><span class=\"line\">    pattern = re.<span class=\"keyword\">compile</span>(<span class=\"string\">\"\\d+\"</span>)</span><br><span class=\"line\">    tail = pattern.search(str).<span class=\"keyword\">group</span>()</span><br><span class=\"line\">    <span class=\"keyword\">print</span> tail</span><br></pre></td></tr></table></figure></p>\n<p>稍等片刻，不过期间还是有点意思的，还搞了一些分岔路和一些误导的值，当然还需要自己手动判断一下。<br>最后得到答案：<code>peak.html</code></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本来冲着过关来的，后来发现了“世外桃源”，官方写法才表现出了python的真正用法，不仅提供了python版，各个版本都有。自己写的轮子真的粗糙不堪，感觉自己的动力来自于看官方文档了呢。</p>\n<p>好的，本期闯关先存个档，小伙伴们，我们下期见哈哈哈</p>\n","site":{"data":{}},"excerpt":"<p>最近在找python对应的学习实例时,看到了一个古老的游戏,方便大家边玩边学：</p>\n<p>当当当当，<strong>python challenge</strong>！</p>\n<p><a href=\"http://www.pythonchallenge.com/\" target=\"_blank\" rel=\"noopener\">入口</a></p>\n<p>当然，他是有规则的。<br>General tips:</p>\n<ul>\n<li>Use the hints. They are helpful, most of the times.</li>\n<li>Investigate the data given to you.</li>\n<li>Avoid looking for spoilers.</li></ul>","more":"\n\n<p>谜一样的游戏，相当有趣，试试看自己能闯几关吧。</p>\n<p><a href=\"https://github.com/zjbao123/python_challenge_solution\" target=\"_blank\" rel=\"noopener\">repo</a></p>\n<h2 id=\"第0关\"><a href=\"#第0关\" class=\"headerlink\" title=\"第0关\"></a>第0关</h2><p><img src=\"http://www.pythonchallenge.com/pc/def/calc.jpg\" alt=\"第0关\"><br>根据图片，就可以知道，2的38次方。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"builtin-name\">print</span> (2*<span class=\"number\">*38</span>)</span><br></pre></td></tr></table></figure></p>\n<p>计算得到结果,274877906944,输入即可到下一关。</p>\n<h2 id=\"第1关\"><a href=\"#第1关\" class=\"headerlink\" title=\"第1关\"></a>第1关</h2><p><img src=\"http://www.pythonchallenge.com/pc/def/map.jpg\" alt=\"第1关\"></p>\n<p>下面有一句提示：<code>everybody thinks twice before solving this.</code><br>然后一堆乱码：</p>\n<p>g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr’q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj.</p>\n<p>从图中可以看出，每个字母都向后移了两位得到那个数字。这估计就是关键所在了。</p>\n<p>思路是这样的：</p>\n<p>首先，将26个字母的ASCII码表示出来，转换为对应的数字。a~z对应为97~122<br>将对应的数字移位解码输出，如ASCII码不在此范围则直接输出。</p>\n<p>ASCII码对应的转化函数为：<code>chr(65) ord(&#39;a&#39;)</code><br><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def findLetter(s):</span><br><span class=\"line\">    <span class=\"keyword\">sum</span> =<span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i in s:</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">120</span>&gt;=<span class=\"keyword\">ord</span>(i)&gt;=<span class=\"number\">97</span>:</span><br><span class=\"line\">             <span class=\"keyword\">sum</span> +=chr(<span class=\"keyword\">ord</span>(i)+<span class=\"number\">2</span>)</span><br><span class=\"line\">        elif <span class=\"number\">122</span>&gt;=<span class=\"keyword\">ord</span>(i)&gt;=<span class=\"number\">121</span>:</span><br><span class=\"line\">            <span class=\"keyword\">sum</span> += chr(<span class=\"keyword\">ord</span>(i)<span class=\"number\">-24</span>)</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">sum</span> += i</span><br><span class=\"line\">    return <span class=\"keyword\">sum</span></span><br><span class=\"line\">l = <span class=\"string\">\"g fmnc wms bgblr rpylqjyrc gr zw fylb. rfyrq ufyr amknsrcpq ypc dmp. bmgle gr gl zw fylb gq glcddgagclr ylb rfyr'q ufw rfgq rcvr gq qm jmle. sqgle qrpgle.kyicrpylq() gq pcamkkclbcb. lmu ynnjw ml rfc spj\"</span></span><br><span class=\"line\">print findLetter(l)</span><br></pre></td></tr></table></figure></p>\n<p>解码结果为：</p>\n<p>i hope you didnt translate it by hand. thats what computers are for. doing it in by hand is inefficient and that’s why this text is so long. using string.maketrans() is recommended. now apply on the url</p>\n<p>这边解码之后，又告诉我了另一个解码的方式，通过映射表来编码解码(怪自己知道的太少)：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">import string</span><br><span class=\"line\"></span><br><span class=\"line\">__author__ = 'zjbao123'</span><br><span class=\"line\">intab = 'abcdefghijklmnopqrstuvwxyz'</span><br><span class=\"line\">outtab = 'cdefghijklmnopqrstuvwxyzab'</span><br><span class=\"line\">trantab = string.maketrans(intab, outtab)</span><br><span class=\"line\"></span><br><span class=\"line\">l = <span class=\"string\">\"map\"</span></span><br><span class=\"line\">print l.translate(trantab)</span><br></pre></td></tr></table></figure>\n<p>输出结果一致。然后应用在map上，得到<code>equality</code>,进入第2关。</p>\n<h3 id=\"官方解答\"><a href=\"#官方解答\" class=\"headerlink\" title=\"官方解答\"></a>官方解答</h3><p>只要将网址中的pc改为pcc即可看到官方解答.(第三关会告诉你这个秘密)</p>\n<figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">table</span> = <span class=\"built_in\">string</span>.maketrans(<span class=\"built_in\">string</span>.ascii_lowercase,<span class=\"built_in\">string</span>.ascii_lowercase[<span class=\"number\">2</span>:]+<span class=\"built_in\">string</span>.ascii_lowercase[:<span class=\"number\">2</span>])</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">string</span>.translate(text,<span class=\"built_in\">table</span>)</span><br></pre></td></tr></table></figure>\n<p>尽管自己写的也挺简洁，但是有些方法还是不知道啊。</p>\n<p>看样子手册这个东西是常用常新的。<br><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">x</span> in <span class=\"keyword\">s</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">ord</span>(<span class=\"keyword\">x</span>)&gt;=<span class=\"keyword\">ord</span>(<span class=\"string\">'a'</span>) <span class=\"keyword\">and</span> <span class=\"keyword\">ord</span>(<span class=\"keyword\">x</span>)&lt;=<span class=\"keyword\">ord</span>(<span class=\"string\">'z'</span>):</span><br><span class=\"line\">        o+=<span class=\"keyword\">chr</span>((<span class=\"keyword\">ord</span>(<span class=\"keyword\">x</span>)+<span class=\"number\">2</span>-<span class=\"keyword\">ord</span>(<span class=\"string\">'a'</span>))%26+<span class=\"keyword\">ord</span>(<span class=\"string\">'a'</span>))</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        o+=<span class=\"keyword\">x</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> o</span><br></pre></td></tr></table></figure></p>\n<p>用笨办法也是写的非常简洁。</p>\n<h2 id=\"第2关\"><a href=\"#第2关\" class=\"headerlink\" title=\"第2关\"></a>第2关</h2><p><img src=\"http://www.pythonchallenge.com/pc/def/ocr.jpg\" alt=\"第2关\"></p>\n<p>recognize the characters. maybe they are in the book,<br>but MAYBE they are in the page source.</p>\n<p>题目看的不是很懂。查了一下对应的意思，答案应该是在源代码里，结果<code>F12</code>一看，一大段的乱码,开头有一句：</p>\n<p><code>find rare characters in the mess below:</code></p>\n<p>估计要爬网页了。</p>\n<p>正好这几天在学爬虫，拿来练练手。有些投机取巧吧，猜到是数字或者字母了，写的惨不忍睹。<br><figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib2, re</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">'http://www.pythonchallenge.com/pc/def/ocr.html'</span></span><br><span class=\"line\">response = urllib2.urlopen(url)</span><br><span class=\"line\">content = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">pattern = re.compile<span class=\"function\"><span class=\"params\">(<span class=\"string\">'--&gt;(.*?)--&gt;'</span>, re.S)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">match</span> = <span class=\"title\">pattern</span>.<span class=\"title\">search</span><span class=\"params\">(content)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">result</span> = <span class=\"title\">match</span>.<span class=\"title\">group</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">pattern2</span> = <span class=\"title\">re</span>.<span class=\"title\">compile</span><span class=\"params\">(<span class=\"string\">'\\n'</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">result</span> = <span class=\"title\">pattern2</span>.<span class=\"title\">sub</span><span class=\"params\">(<span class=\"string\">''</span>, result)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">pattern2</span> = <span class=\"title\">re</span>.<span class=\"title\">compile</span><span class=\"params\">(<span class=\"string\">'[a-zA-Z0-9]'</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">str</span> = <span class=\"params\">(<span class=\"string\">''</span>)</span>.<span class=\"title\">join</span><span class=\"params\">(pattern2.findall(result))</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span> <span class=\"title\">str</span></span></span><br></pre></td></tr></table></figure></p>\n<p>最后输出：<code>equality</code>。<br>当然，删除回车，直接<code>replace(&quot;\\n&quot;,&quot;&quot;)</code>也行，不用向我这么愚。</p>\n<p>在得知是字母之后，源代码可以改良很多：<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = 'zjbao123'</span><br><span class=\"line\"></span><br><span class=\"line\">import urllib2, re</span><br><span class=\"line\"></span><br><span class=\"line\">url = 'http://www.pythonchallenge.com/pc/def/ocr.html'</span><br><span class=\"line\">response = urllib2.urlopen(url)</span><br><span class=\"line\">content = response.read().decode('utf-8')</span><br><span class=\"line\">pattern = re.compile('&lt;!--(.*?)--&gt;', re.S)</span><br><span class=\"line\">match = pattern.findall(content)</span><br><span class=\"line\">a = [i for i in match[1] if i.isalpha()]</span><br><span class=\"line\">print(a)</span><br></pre></td></tr></table></figure></p>\n<p>在得出正确答案之后，便去找了好一点的解法。一查发现，各种解法都有，唉，都怪自己学艺不精，连<code>count()</code>都没想到。在原基础上进行了改进。<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/env python</span><br><span class=\"line\"># -*- coding: utf<span class=\"number\">-8</span> -*-</span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib2, re</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">'http://www.pythonchallenge.com/pc/def/ocr.html'</span></span><br><span class=\"line\">response = urllib2.urlopen(url)</span><br><span class=\"line\">content = response.read().decode(<span class=\"string\">'utf-8'</span>)</span><br><span class=\"line\">pattern = re.compile(<span class=\"string\">'&lt;!--(.*?)--&gt;'</span>, re.S)</span><br><span class=\"line\"><span class=\"built_in\">match</span> = pattern.findall(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">str</span> = []</span><br><span class=\"line\"><span class=\"keyword\">for</span> i in <span class=\"built_in\">match</span>[<span class=\"number\">1</span>]:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> i in <span class=\"built_in\">str</span>:</span><br><span class=\"line\">        pass</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"built_in\">str</span>.<span class=\"built_in\">append</span>(i)</span><br><span class=\"line\">        <span class=\"built_in\">print</span> i + <span class=\"string\">' '</span>, <span class=\"built_in\">match</span>[<span class=\"number\">1</span>].count(i)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">\"\"</span>.<span class=\"built_in\">join</span>(ch <span class=\"keyword\">for</span> ch in guts <span class=\"keyword\">if</span> d[ch] == <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<p>这个问题在于没有直接输出答案，而且之前还觉得不错的<code>count()</code>效率并不高，就是根据题目意思来了，真的记了一个数，不过我觉得我之前的代码也没有太大问题，本来问题就没有唯一解。</p>\n<h3 id=\"官方解答-1\"><a href=\"#官方解答-1\" class=\"headerlink\" title=\"官方解答\"></a>官方解答</h3><p>再来看看官方解答：<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rare <span class=\"keyword\">characters</span> = less frequent than <span class=\"built_in\">average</span></span><br></pre></td></tr></table></figure></p>\n<p>一句话就说的很明白，就是找到低于平均数的值。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">s = ''.<span class=\"built_in\">join</span>([line.rstrip() <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> <span class=\"keyword\">open</span>('ocr.txt')])    </span><br><span class=\"line\"><span class=\"type\">OCCURRENCES</span> = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> s: <span class=\"type\">OCCURRENCES</span>[<span class=\"built_in\">c</span>] = <span class=\"type\">OCCURRENCES</span>.<span class=\"keyword\">get</span>(<span class=\"built_in\">c</span>, <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">avgOC = len(s) <span class=\"comment\">// len(OCCURRENCES) #除法，四舍五入</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> ''.<span class=\"built_in\">join</span>([<span class=\"built_in\">c</span> <span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> s <span class=\"keyword\">if</span> <span class=\"type\">OCCURRENCES</span>[<span class=\"built_in\">c</span>] &lt; avgOC])</span><br></pre></td></tr></table></figure></p>\n<p>通过字典来获取值，这里用到了字典的一个方法：</p>\n<ul>\n<li><code>D.get(k[,d])</code><br>D[k] if k in D, else d.  d defaults to None.</li>\n</ul>\n<p>另外，列表生成式可以用一行语句代替循环生成所需的list，作为python的一大高级特性应该好好利用。</p>\n<p>这边官方给出了更进一步的解答：<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">data = ''.<span class=\"built_in\">join</span>([line.rstrip() <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> <span class=\"keyword\">open</span>('ocr.txt')])    </span><br><span class=\"line\"><span class=\"type\">OCCURRENCES</span> = collections.<span class=\"type\">OrderedDict</span>()</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> data: <span class=\"type\">OCCURRENCES</span>[<span class=\"built_in\">c</span>] = <span class=\"type\">OCCURRENCES</span>.<span class=\"keyword\">get</span>(<span class=\"built_in\">c</span>, <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\">avgOC = len(data) <span class=\"comment\">// len(OCCURRENCES)</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> ''.<span class=\"built_in\">join</span>([<span class=\"built_in\">c</span> <span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> <span class=\"type\">OCCURRENCES</span> <span class=\"keyword\">if</span> <span class=\"type\">OCCURRENCES</span>[<span class=\"built_in\">c</span>] &lt; avgOC])</span><br></pre></td></tr></table></figure></p>\n<p>通过有序序列，使得结果有序输出，并且最后写列表生成式的时候循环次数明显减少，优化了这个过程。</p>\n<p>在知道是字母之后，还有更加简单的写法，只需两行：<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import <span class=\"keyword\">string</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">text</span> = <span class=\"string\">''</span>.join([<span class=\"built_in\">line</span>.rstrip() <span class=\"keyword\">for</span> <span class=\"built_in\">line</span> <span class=\"keyword\">in</span> <span class=\"built_in\">open</span>(<span class=\"string\">'ocr.txt'</span>)])</span><br><span class=\"line\">print <span class=\"built_in\">filter</span>(lambda x: x <span class=\"keyword\">in</span> <span class=\"keyword\">string</span>.letters, <span class=\"keyword\">text</span>)</span><br></pre></td></tr></table></figure></p>\n<p>巧妙地用了匿名函数和过滤器，很python的程序。6的不行。自己还没活用到这种程度真的都不好意思说自己会python。</p>\n<p>还有利用只出现一次这个特征来查找的，这个比之前网上找到的list方法好在巧用了字典和列表生成式。<br><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">guts = open(<span class=\"string\">\"ocr.txt\"</span>).<span class=\"built_in\">read</span>()</span><br><span class=\"line\">d = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> guts:</span><br><span class=\"line\">    d[ch] = d.<span class=\"built_in\">get</span>(ch, <span class=\"number\">0</span>) + <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">\"\"</span>.<span class=\"built_in\">join</span>(ch <span class=\"keyword\">for</span> ch <span class=\"keyword\">in</span> guts <span class=\"keyword\">if</span> d[ch] == <span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在之后也附上了一些网友的评价：<br><code>count()</code>尽管效率不高O(n^2)但是还是运行的挺快，可读性强。需要在count之前加以判断，通过<code>has_key()</code>来进行优化。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text = <span class=\"built_in\">..</span>.   # the long string found <span class=\"keyword\">in</span> the source code of the page</span><br><span class=\"line\">output = <span class=\"string\">\"\"</span> # empty string</span><br><span class=\"line\">counts = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> text:</span><br><span class=\"line\">  <span class=\"keyword\">if</span> counts.has_key(c):</span><br><span class=\"line\">    continue</span><br><span class=\"line\">  counts[c] = text.count(c)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> counts[c] &lt; 100:  # guess that rare characters will occur less than 100 times</span><br><span class=\"line\">    output += c</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"builtin-name\">print</span> output</span><br></pre></td></tr></table></figure></p>\n<p>在之后的浏览中，又发现了一个很妙的写法。利用<code>set</code>这个无序，无重复的交集。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">print</span> set(<span class=\"string\">\"\"\"&lt;- lots of text -&gt;\"\"\"</span>)</span><br></pre></td></tr></table></figure></p>\n<p>问题就在于无序，还是只找到了字母，没有连成单词。<br><figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">guts = <span class=\"keyword\">open</span>(<span class=\"string\">\"ocr.txt\"</span>).read()</span><br><span class=\"line\">nb = <span class=\"keyword\">set</span>(guts)</span><br><span class=\"line\">d = dict()</span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> nb:</span><br><span class=\"line\">    d[<span class=\"built_in\">c</span>] = guts.<span class=\"built_in\">count</span>(<span class=\"built_in\">c</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> ''.<span class=\"built_in\">join</span>( [<span class=\"built_in\">c</span> <span class=\"keyword\">for</span> <span class=\"built_in\">c</span> <span class=\"keyword\">in</span> guts <span class=\"keyword\">if</span> d[<span class=\"built_in\">c</span>] == <span class=\"number\">1</span> ] )</span><br></pre></td></tr></table></figure></p>\n<p>Who says python has only one way to do things?</p>\n<p>接下来到了第3关。</p>\n<p>##第3关</p>\n<p><img src=\"http://www.pythonchallenge.com/pc/def/bodyguard.jpg\" alt=\"第3关\"><br>One small letter, surrounded by EXACTLY three big bodyguards on each of its sides.</p>\n<p>看完题目不知所云，好像是在说图上的蜡烛。但肯定不是，看了下源代码果然又要用正则。</p>\n<p>不过看懂也就简单了，三个大写字母夹的那个小写字母(另外三个大写的两边要是小写)，就是所需的。两次正则就可以得到结果。</p>\n<figure class=\"highlight livescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib2, re</span><br><span class=\"line\"></span><br><span class=\"line\">response = urllib2.urlopen(<span class=\"string\">'http://www.pythonchallenge.com/pc/def/equality.html'</span>)</span><br><span class=\"line\">content = response.read()</span><br><span class=\"line\">pattern = re.compile<span class=\"function\"><span class=\"params\">(<span class=\"string\">'&lt;!--(.*?)--&gt;'</span>, re.S)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">match</span> = <span class=\"title\">pattern</span>.<span class=\"title\">findall</span><span class=\"params\">(content)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">with</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"string\">'e.txt'</span>, <span class=\"string\">'w'</span>)</span> <span class=\"title\">as</span> <span class=\"title\">f</span>:</span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">f</span>.<span class=\"title\">write</span><span class=\"params\">(match[<span class=\"number\">0</span>])</span></span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">pattern</span> = <span class=\"title\">re</span>.<span class=\"title\">compile</span><span class=\"params\">(<span class=\"string\">'[^A-Z][A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;[^A-Z]'</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">content</span> =''.<span class=\"title\">join</span><span class=\"params\">((line.strip() <span class=\"keyword\">for</span> line <span class=\"keyword\">in</span> open(<span class=\"string\">'e.txt'</span>,<span class=\"string\">'r'</span>)))</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">match</span> = <span class=\"title\">pattern</span>.<span class=\"title\">findall</span><span class=\"params\">(content)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">print</span> ''.<span class=\"title\">join</span><span class=\"params\">(i <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> match)</span></span></span><br></pre></td></tr></table></figure>\n<p>答案就是<code>linkedlist</code></p>\n<h3 id=\"官方解答-2\"><a href=\"#官方解答-2\" class=\"headerlink\" title=\"官方解答\"></a>官方解答</h3><p>利用列表生成式和递归的思想，简明扼要，<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># text <span class=\"keyword\">is</span> in t2</span><br><span class=\"line\">markers = <span class=\"string\">''</span>.<span class=\"keyword\">join</span>( [ <span class=\"string\">'0'</span> <span class=\"keyword\">if</span> <span class=\"keyword\">c</span> in <span class=\"built_in\">string</span>.lowercase <span class=\"keyword\">else</span> <span class=\"string\">'1'</span> <span class=\"keyword\">for</span> <span class=\"keyword\">c</span> in t2 ] )</span><br><span class=\"line\">def <span class=\"keyword\">f</span>( <span class=\"keyword\">res</span>, t2, markers ):</span><br><span class=\"line\">    n = <span class=\"built_in\">len</span>(markers.partition(<span class=\"string\">'011101110'</span>)[<span class=\"number\">0</span>])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">f</span>( <span class=\"keyword\">res</span>+t2[n+<span class=\"number\">4</span>], t2[n+<span class=\"number\">9</span>:], markers[n+<span class=\"number\">9</span>:] ) <span class=\"keyword\">if</span> n != <span class=\"built_in\">len</span>(markers) <span class=\"keyword\">else</span> <span class=\"keyword\">res</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"keyword\">f</span>( <span class=\"string\">''</span>, t2, markers )</span><br></pre></td></tr></table></figure></p>\n<p>上述例子还有一点要说明的是：当出现<code>HHHoHHHoHHHoHHHoHHH</code>时，只能匹配到第二个。因为第一个明显不符合规定，由于在开头，一开始就不是小写。之后的也因为位移过多而错过判断的值。因此我们需要对其进行改进。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">level_3</span><span class=\"params\">(t1)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 因为没有用正则，我们需要伪装一下边界</span></span><br><span class=\"line\">    pad = <span class=\"string\">\"x\"</span></span><br><span class=\"line\">    t1 = pad + t1 + pad</span><br><span class=\"line\">    <span class=\"comment\"># 检查是否为大写还是小写</span></span><br><span class=\"line\">    markers = <span class=\"string\">\"\"</span>.join([ <span class=\"string\">'1'</span> <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> string.uppercase <span class=\"keyword\">else</span> <span class=\"string\">'0'</span> <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> t1])</span><br><span class=\"line\">    pattern = <span class=\"string\">\"011101110\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(res, t2, markers)</span>:</span></span><br><span class=\"line\">        n = len(markers.partition(pattern)[<span class=\"number\">0</span>])</span><br><span class=\"line\">        <span class=\"comment\"># 出于性能考虑，我们本应该把这个lambda函数放在嵌套外，但出于可读性考虑，我觉得还是放在这吧</span></span><br><span class=\"line\">        end_of_string = <span class=\"keyword\">lambda</span> res, t2, markers: markers == pattern <span class=\"keyword\">and</span> res+t2[<span class=\"number\">4</span>] <span class=\"keyword\">or</span> res</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f(res+t2[n+<span class=\"number\">4</span>], t2[n+<span class=\"number\">4</span>:], markers[n+<span class=\"number\">4</span>:]) <span class=\"keyword\">if</span> n != len(markers) <span class=\"keyword\">else</span> end_of_string(res, t2, markers)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(<span class=\"string\">''</span>, t1, markers)</span><br></pre></td></tr></table></figure></p>\n<p>或者不用lambda:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> string</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">level_3</span><span class=\"params\">(t1)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># the second x ensures that the last match will never be in the last portion of the split after calling string.partition</span></span><br><span class=\"line\">    pad = <span class=\"string\">\"xx\"</span></span><br><span class=\"line\">    t1 = pad + t1 + pad</span><br><span class=\"line\">    markers = <span class=\"string\">\"\"</span>.join([ <span class=\"string\">'1'</span> <span class=\"keyword\">if</span> c <span class=\"keyword\">in</span> string.uppercase <span class=\"keyword\">else</span> <span class=\"string\">'0'</span> <span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> t1])</span><br><span class=\"line\">    pattern = <span class=\"string\">\"011101110\"</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(res, t2, markers)</span>:</span></span><br><span class=\"line\">        n = len(markers.partition(pattern)[<span class=\"number\">0</span>]</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f(res+t2[n+<span class=\"number\">4</span>], t2[n+<span class=\"number\">4</span>:], markers[n+<span class=\"number\">4</span>:]) <span class=\"keyword\">if</span> n != len(markers) <span class=\"keyword\">else</span> res</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(<span class=\"string\">''</span>, t1, markers)</span><br></pre></td></tr></table></figure></p>\n<p>另外，官方还介绍正则的用法。<br>一句话解决。</p>\n<p>运用到了<code>(?:pattern)</code>来匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.<span class=\"keyword\">join</span>(re.findall(<span class=\"comment\">'(?:^|[^A-Z])[A-Z]&#123;3&#125;([a-z])[A-Z]&#123;3&#125;(?:[^A-Z]|$)',text))</span></span><br></pre></td></tr></table></figure></p>\n<p>还有利用前瞻和后顾的：<br><figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.join(re.findall(<span class=\"string\">\"(?&lt;=<span class=\"subst\">[^A-Z]</span><span class=\"subst\">[A-Z]</span>&#123;3&#125;)<span class=\"subst\">[a-z]</span>(?=<span class=\"subst\">[A-Z]</span>&#123;3&#125;<span class=\"subst\">[^A-Z]</span>)\"</span>,text))</span><br></pre></td></tr></table></figure></p>\n<p>当然也有反向前瞻和后顾的：<br><figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pattern = re.compile(<span class=\"string\">r'(?&lt;\\![A-Z])[A-Z]&#123;3&#125;([a-z])(?=[A-Z]&#123;3&#125;(?![A-Z]))'</span>) <span class=\"comment\"># !前没有斜杠</span></span><br></pre></td></tr></table></figure></p>\n<p>还有更吊的，直接把不匹配的变黑，需要的变白。这边只记录一下输出。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">normal</span> = <span class=\"string\">'\\033[0m'</span></span><br><span class=\"line\">black  = <span class=\"string\">'\\033[30;1m'</span></span><br><span class=\"line\">white  = <span class=\"string\">'\\033[37;1m'</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">match</span> in matche<span class=\"variable\">s:</span></span><br><span class=\"line\">   <span class=\"keyword\">print</span> black + <span class=\"keyword\">match</span>[<span class=\"number\">1</span>:<span class=\"number\">4</span>] + white + <span class=\"keyword\">match</span>[<span class=\"number\">4</span>] + black + <span class=\"keyword\">match</span>[<span class=\"number\">5</span>:<span class=\"number\">8</span>] + <span class=\"keyword\">normal</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"第4关\"><a href=\"#第4关\" class=\"headerlink\" title=\"第4关\"></a>第4关</h2><p>点击图片，显示<code>and the next nothing is 44827</code>，又修改源代码，发现只是数字不同而已。</p>\n<p>这关比较简单，只要写一个循环就行。<br><figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib2, re</span><br><span class=\"line\"></span><br><span class=\"line\">url = <span class=\"string\">'http://www.pythonchallenge.com/pc/def/linkedlist.php?nothing='</span></span><br><span class=\"line\">tail = <span class=\"string\">'37278'</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"keyword\">True</span>:</span><br><span class=\"line\">    result = urllib2.urlopen(url + tail)</span><br><span class=\"line\">    str = result.<span class=\"keyword\">read</span>()</span><br><span class=\"line\">    pattern = re.<span class=\"keyword\">compile</span>(<span class=\"string\">\"\\d+\"</span>)</span><br><span class=\"line\">    tail = pattern.search(str).<span class=\"keyword\">group</span>()</span><br><span class=\"line\">    <span class=\"keyword\">print</span> tail</span><br></pre></td></tr></table></figure></p>\n<p>稍等片刻，不过期间还是有点意思的，还搞了一些分岔路和一些误导的值，当然还需要自己手动判断一下。<br>最后得到答案：<code>peak.html</code></p>\n<h2 id=\"小结\"><a href=\"#小结\" class=\"headerlink\" title=\"小结\"></a>小结</h2><p>本来冲着过关来的，后来发现了“世外桃源”，官方写法才表现出了python的真正用法，不仅提供了python版，各个版本都有。自己写的轮子真的粗糙不堪，感觉自己的动力来自于看官方文档了呢。</p>\n<p>好的，本期闯关先存个档，小伙伴们，我们下期见哈哈哈</p>"},{"title":"python爬虫入门(2)","date":"2016-10-16T08:40:02.000Z","_content":"\n## 异常处理\n\n这里主要说的是URLError还有HTTPError，以及对它们的一些处理。\n\n### URLError\n首先解释下URLError可能产生的原因：\n\n* 网络无连接，即本机无法上网\n* 连接不到特定的服务器\n* 服务器不存在\n\n<!-- more -->\n```\nimport urllib2\n \nrequset = urllib2.Request('http://www.xxxxx.com')\ntry:\n    urllib2.urlopen(request)\nexcept urllib2.URLError, e:\n    print e.reason\n```\n当我们打开一个不存在的网址时，就会报错：`[Errno 11004] getaddrinfo failed`\n\n### HTTPError\n`HTTPError`是`URLError`的子类，在你利用`urlopen`方法发出一个请求时，服务器上都会对应一个应答对象`response`，其中它包含一个数字”状态码”。举个例子，假如`response`是一个”重定向”，需定位到别的地址获取文档，`urllib2`将对此进行处理。\n\n其他不能处理的，`urlopen`会产生一个`HTTPError`，对应相应的状态吗，HTTP状态码表示HTTP协议所返回的响应的状态。下面将状态码归结如下：\n\n>100：继续  客户端应当继续发送请求。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。\n101： 转换协议  在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。\n102：继续处理   由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。\n200：请求成功      处理方式：获得响应的内容，进行处理\n201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到    处理方式：爬虫中不会遇到\n202：请求被接受，但处理尚未完成    处理方式：阻塞等待\n204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。    处理方式：丢弃\n300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。    处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃\n301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源    处理方式：重定向到分配的URL\n302：请求到的资源在一个不同的URL处临时保存     处理方式：重定向到临时的URL\n304：请求的资源未更新     处理方式：丢弃\n400：非法请求     处理方式：丢弃\n401：未授权     处理方式：丢弃\n403：禁止     处理方式：丢弃\n404：没有找到     处理方式：丢弃\n500：服务器内部错误  服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。\n501：服务器无法识别  服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。\n502：错误网关  作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\n503：服务出错   由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。\n\nHTTPError实例产生后会有一个code属性，这就是是服务器发送的相关错误号。\n因为urllib2可以为你处理重定向，也就是3开头的代号可以被处理，并且100-299范围的号码指示成功，所以你只能看到400-599的错误号码。\n\n下面我们写一个例子来感受一下，捕获的异常是HTTPError，它会带有一个code属性，就是错误代号，根据编程经验，父类的异常应当写到子类异常的后面，如果子类捕获不到，那么可以捕获父类的异常,还可以加入 hasattr属性提前对属性进行判断:\n```\nimport urllib2\n \nreq = urllib2.Request('http://blog.csdn.net/cqcre')\ntry:\n    urllib2.urlopen(req)\nexcept urllib2.URLError, e:\n    if hasattr(e,\"code\"):\n        print e.code\n    if hasattr(e,\"reason\"):\n        print e.reason\nelse:\n    print \"OK\"\n```\n\n## Cookie\n\nCookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。\n\n比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容是不允许的。那么我们可以利用Urllib2库保存我们登录的Cookie，然后再抓取其他页面就达到目的了。\n\n在此之前，先介绍Opener。\n### Opener\n\nOpener是urllib2.OpenerDirector的实例，在前面，我们都是使用的默认的opener，也就是urlopen。它是一个特殊的opener，可以理解成opener的一个特殊实例，传入的参数仅仅是url，data，timeout。\n\n如果我们需要用到Cookie，只用这个opener是不能达到目的的，所以我们需要创建更一般的opener来实现对Cookie的设置。\n\n\n### Cookielib\n\ncookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。Cookielib模块非常强大，我们可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。\n\n它们的关系：`CookieJar —-派生—->FileCookieJar  —-派生—–>MozillaCookieJar和LWPCookieJar`\n\n\n#### 1)获取Cookie保存到变量\n```\nimport urllib2\nimport cookielib\n#声明一个CookieJar对象实例来保存cookie\ncookie = cookielib.CookieJar()\n#利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器\nhandler = urllib2.HTTPCookieProcessor(cookie)\n#通过handler来构建opener\nopener = urllib2.build_opener(handler)\n#创建一个请求，原理同urllib2的urlopen\nresponse = opener.open('http://www.baidu.com')\n\nfor item in cookie:\n    print 'Name = ' + item.name\n    print 'Value = '+ item.value\n```\n\n#### 2）保存Cookie到文件\n\n在上面的方法中，我们将cookie保存到了cookie这个变量中，如果我们想将cookie保存到文件中该怎么做呢？这时，我们就要用到\nFileCookieJar这个对象了，在这里我们使用它的子类MozillaCookieJar来实现Cookie的保存。\n```\nimport urllib2\nimport cookielib\n#设置保存cookie的文件，同级目录下的cookie.txt\nfilename = 'cookie.txt'\n#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件\ncookie = cookielib.MozillaCookieJar(filename)\n#利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器\nhandler = urllib2.HTTPCookieProcessor(cookie)\n#通过handler来构建opener\nopener = urllib2.build_opener(handler)\n#此处的open方法同urllib2的urlopen方法，也可以传入request\nresponse = opener.open('http://www.baidu.com')\n\ncookie.save(ignore_discard=True, ignore_expires=True)\n\n```\n>ignore_discard: save even cookies set to be discarded. \nignore_expires: save even cookies that have expiredThe file is overwritten if it already exists\n\n\ngnore_discard:即使cookies将被丢弃也将它保存下来。\n\nignore_expires：如果在该文件中cookies已经存在，则覆盖原文件写入。\n\n在这里，我们将这两个全部设置为True。\n\n#### 3)从文件中获取Cookie并访问\n```\n#创建MozillaCookieJar实例对象\ncookie = cookielib.MozillaCookieJar()\n#从文件中读取cookie内容到变量\ncookie.load('cookie.txt', ignore_discard=True, ignore_expires=True)\n#创建请求的request\nreq = urllib2.Request(\"http://www.baidu.com\")\n#利用urllib2的build_opener方法创建一个opener\nopener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))\nresponse = opener.open(req)\nprint response.read()\n```\n#### 4)利用cookie模拟网站登录\n```\nimport urllib\nimport urllib2\nimport cookielib\n \nfilename = 'cookie.txt'\n#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件\ncookie = cookielib.MozillaCookieJar(filename)\nopener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))\npostdata = urllib.urlencode({\n            'stuid':'201200131012',\n            'pwd':'23342321'\n        })\n#登录教务系统的URL\nloginUrl = 'http://jwxt.sdu.edu.cn:7890/pls/wwwbks/bks_login2.login'\n#模拟登录，并把cookie保存到变量\nresult = opener.open(loginUrl,postdata)\n#保存cookie到cookie.txt中\ncookie.save(ignore_discard=True, ignore_expires=True)\n#利用cookie请求访问另一个网址，此网址是成绩查询网址\ngradeUrl = 'http://jwxt.sdu.edu.cn:7890/pls/wwwbks/bkscjcx.curscopre'\n#请求访问成绩查询网址\nresult = opener.open(gradeUrl)\nprint result.read()\n```\n\n创建一个带有cookie的opener，在访问登录的URL时，将登录后的cookie保存下来，然后利用这个cookie来访问其他网址。\n\n\n\n\n\n\n------------------------------------------------------------\n\n## 参考\n\n[如何入门 Python 爬虫？-知乎](https://www.zhihu.com/question/20899988)\n\n[Python爬虫学习系列教程](http://cuiqingcai.com/1052.html)\n","source":"_posts/python/python爬虫入门(2).md","raw":"---\ntitle: python爬虫入门(2)\ndate: 2016-10-16 16:40:02\ntags:\n- python\n- 爬虫\ncategories: 总结\n---\n\n## 异常处理\n\n这里主要说的是URLError还有HTTPError，以及对它们的一些处理。\n\n### URLError\n首先解释下URLError可能产生的原因：\n\n* 网络无连接，即本机无法上网\n* 连接不到特定的服务器\n* 服务器不存在\n\n<!-- more -->\n```\nimport urllib2\n \nrequset = urllib2.Request('http://www.xxxxx.com')\ntry:\n    urllib2.urlopen(request)\nexcept urllib2.URLError, e:\n    print e.reason\n```\n当我们打开一个不存在的网址时，就会报错：`[Errno 11004] getaddrinfo failed`\n\n### HTTPError\n`HTTPError`是`URLError`的子类，在你利用`urlopen`方法发出一个请求时，服务器上都会对应一个应答对象`response`，其中它包含一个数字”状态码”。举个例子，假如`response`是一个”重定向”，需定位到别的地址获取文档，`urllib2`将对此进行处理。\n\n其他不能处理的，`urlopen`会产生一个`HTTPError`，对应相应的状态吗，HTTP状态码表示HTTP协议所返回的响应的状态。下面将状态码归结如下：\n\n>100：继续  客户端应当继续发送请求。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。\n101： 转换协议  在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。\n102：继续处理   由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。\n200：请求成功      处理方式：获得响应的内容，进行处理\n201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到    处理方式：爬虫中不会遇到\n202：请求被接受，但处理尚未完成    处理方式：阻塞等待\n204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。    处理方式：丢弃\n300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。    处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃\n301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源    处理方式：重定向到分配的URL\n302：请求到的资源在一个不同的URL处临时保存     处理方式：重定向到临时的URL\n304：请求的资源未更新     处理方式：丢弃\n400：非法请求     处理方式：丢弃\n401：未授权     处理方式：丢弃\n403：禁止     处理方式：丢弃\n404：没有找到     处理方式：丢弃\n500：服务器内部错误  服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。\n501：服务器无法识别  服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。\n502：错误网关  作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。\n503：服务出错   由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。\n\nHTTPError实例产生后会有一个code属性，这就是是服务器发送的相关错误号。\n因为urllib2可以为你处理重定向，也就是3开头的代号可以被处理，并且100-299范围的号码指示成功，所以你只能看到400-599的错误号码。\n\n下面我们写一个例子来感受一下，捕获的异常是HTTPError，它会带有一个code属性，就是错误代号，根据编程经验，父类的异常应当写到子类异常的后面，如果子类捕获不到，那么可以捕获父类的异常,还可以加入 hasattr属性提前对属性进行判断:\n```\nimport urllib2\n \nreq = urllib2.Request('http://blog.csdn.net/cqcre')\ntry:\n    urllib2.urlopen(req)\nexcept urllib2.URLError, e:\n    if hasattr(e,\"code\"):\n        print e.code\n    if hasattr(e,\"reason\"):\n        print e.reason\nelse:\n    print \"OK\"\n```\n\n## Cookie\n\nCookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。\n\n比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容是不允许的。那么我们可以利用Urllib2库保存我们登录的Cookie，然后再抓取其他页面就达到目的了。\n\n在此之前，先介绍Opener。\n### Opener\n\nOpener是urllib2.OpenerDirector的实例，在前面，我们都是使用的默认的opener，也就是urlopen。它是一个特殊的opener，可以理解成opener的一个特殊实例，传入的参数仅仅是url，data，timeout。\n\n如果我们需要用到Cookie，只用这个opener是不能达到目的的，所以我们需要创建更一般的opener来实现对Cookie的设置。\n\n\n### Cookielib\n\ncookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。Cookielib模块非常强大，我们可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。\n\n它们的关系：`CookieJar —-派生—->FileCookieJar  —-派生—–>MozillaCookieJar和LWPCookieJar`\n\n\n#### 1)获取Cookie保存到变量\n```\nimport urllib2\nimport cookielib\n#声明一个CookieJar对象实例来保存cookie\ncookie = cookielib.CookieJar()\n#利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器\nhandler = urllib2.HTTPCookieProcessor(cookie)\n#通过handler来构建opener\nopener = urllib2.build_opener(handler)\n#创建一个请求，原理同urllib2的urlopen\nresponse = opener.open('http://www.baidu.com')\n\nfor item in cookie:\n    print 'Name = ' + item.name\n    print 'Value = '+ item.value\n```\n\n#### 2）保存Cookie到文件\n\n在上面的方法中，我们将cookie保存到了cookie这个变量中，如果我们想将cookie保存到文件中该怎么做呢？这时，我们就要用到\nFileCookieJar这个对象了，在这里我们使用它的子类MozillaCookieJar来实现Cookie的保存。\n```\nimport urllib2\nimport cookielib\n#设置保存cookie的文件，同级目录下的cookie.txt\nfilename = 'cookie.txt'\n#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件\ncookie = cookielib.MozillaCookieJar(filename)\n#利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器\nhandler = urllib2.HTTPCookieProcessor(cookie)\n#通过handler来构建opener\nopener = urllib2.build_opener(handler)\n#此处的open方法同urllib2的urlopen方法，也可以传入request\nresponse = opener.open('http://www.baidu.com')\n\ncookie.save(ignore_discard=True, ignore_expires=True)\n\n```\n>ignore_discard: save even cookies set to be discarded. \nignore_expires: save even cookies that have expiredThe file is overwritten if it already exists\n\n\ngnore_discard:即使cookies将被丢弃也将它保存下来。\n\nignore_expires：如果在该文件中cookies已经存在，则覆盖原文件写入。\n\n在这里，我们将这两个全部设置为True。\n\n#### 3)从文件中获取Cookie并访问\n```\n#创建MozillaCookieJar实例对象\ncookie = cookielib.MozillaCookieJar()\n#从文件中读取cookie内容到变量\ncookie.load('cookie.txt', ignore_discard=True, ignore_expires=True)\n#创建请求的request\nreq = urllib2.Request(\"http://www.baidu.com\")\n#利用urllib2的build_opener方法创建一个opener\nopener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))\nresponse = opener.open(req)\nprint response.read()\n```\n#### 4)利用cookie模拟网站登录\n```\nimport urllib\nimport urllib2\nimport cookielib\n \nfilename = 'cookie.txt'\n#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件\ncookie = cookielib.MozillaCookieJar(filename)\nopener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))\npostdata = urllib.urlencode({\n            'stuid':'201200131012',\n            'pwd':'23342321'\n        })\n#登录教务系统的URL\nloginUrl = 'http://jwxt.sdu.edu.cn:7890/pls/wwwbks/bks_login2.login'\n#模拟登录，并把cookie保存到变量\nresult = opener.open(loginUrl,postdata)\n#保存cookie到cookie.txt中\ncookie.save(ignore_discard=True, ignore_expires=True)\n#利用cookie请求访问另一个网址，此网址是成绩查询网址\ngradeUrl = 'http://jwxt.sdu.edu.cn:7890/pls/wwwbks/bkscjcx.curscopre'\n#请求访问成绩查询网址\nresult = opener.open(gradeUrl)\nprint result.read()\n```\n\n创建一个带有cookie的opener，在访问登录的URL时，将登录后的cookie保存下来，然后利用这个cookie来访问其他网址。\n\n\n\n\n\n\n------------------------------------------------------------\n\n## 参考\n\n[如何入门 Python 爬虫？-知乎](https://www.zhihu.com/question/20899988)\n\n[Python爬虫学习系列教程](http://cuiqingcai.com/1052.html)\n","slug":"python/python爬虫入门(2)","published":1,"updated":"2019-03-22T14:44:36.729Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0l009n4l3nvh6j2wv0","content":"<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>这里主要说的是URLError还有HTTPError，以及对它们的一些处理。</p>\n<h3 id=\"URLError\"><a href=\"#URLError\" class=\"headerlink\" title=\"URLError\"></a>URLError</h3><p>首先解释下URLError可能产生的原因：</p>\n<ul>\n<li>网络无连接，即本机无法上网</li>\n<li>连接不到特定的服务器</li>\n<li>服务器不存在</li>\n</ul>\n<a id=\"more\"></a>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> urllib2</span><br><span class=\"line\"> </span><br><span class=\"line\">requset = urllib2.Request(<span class=\"string\">'http://www.xxxxx.com'</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    urllib2.urlopen(request)</span><br><span class=\"line\"><span class=\"keyword\">except</span> urllib2.URLError, e:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> e.reason</span><br></pre></td></tr></table></figure>\n<p>当我们打开一个不存在的网址时，就会报错：<code>[Errno 11004] getaddrinfo failed</code></p>\n<h3 id=\"HTTPError\"><a href=\"#HTTPError\" class=\"headerlink\" title=\"HTTPError\"></a>HTTPError</h3><p><code>HTTPError</code>是<code>URLError</code>的子类，在你利用<code>urlopen</code>方法发出一个请求时，服务器上都会对应一个应答对象<code>response</code>，其中它包含一个数字”状态码”。举个例子，假如<code>response</code>是一个”重定向”，需定位到别的地址获取文档，<code>urllib2</code>将对此进行处理。</p>\n<p>其他不能处理的，<code>urlopen</code>会产生一个<code>HTTPError</code>，对应相应的状态吗，HTTP状态码表示HTTP协议所返回的响应的状态。下面将状态码归结如下：</p>\n<blockquote>\n<p>100：继续  客户端应当继续发送请求。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。<br>101： 转换协议  在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。<br>102：继续处理   由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。<br>200：请求成功      处理方式：获得响应的内容，进行处理<br>201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到    处理方式：爬虫中不会遇到<br>202：请求被接受，但处理尚未完成    处理方式：阻塞等待<br>204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。    处理方式：丢弃<br>300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。    处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃<br>301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源    处理方式：重定向到分配的URL<br>302：请求到的资源在一个不同的URL处临时保存     处理方式：重定向到临时的URL<br>304：请求的资源未更新     处理方式：丢弃<br>400：非法请求     处理方式：丢弃<br>401：未授权     处理方式：丢弃<br>403：禁止     处理方式：丢弃<br>404：没有找到     处理方式：丢弃<br>500：服务器内部错误  服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。<br>501：服务器无法识别  服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。<br>502：错误网关  作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>503：服务出错   由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。</p>\n</blockquote>\n<p>HTTPError实例产生后会有一个code属性，这就是是服务器发送的相关错误号。<br>因为urllib2可以为你处理重定向，也就是3开头的代号可以被处理，并且100-299范围的号码指示成功，所以你只能看到400-599的错误号码。</p>\n<p>下面我们写一个例子来感受一下，捕获的异常是HTTPError，它会带有一个code属性，就是错误代号，根据编程经验，父类的异常应当写到子类异常的后面，如果子类捕获不到，那么可以捕获父类的异常,还可以加入 hasattr属性提前对属性进行判断:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> urllib2</span><br><span class=\"line\"> </span><br><span class=\"line\">req = urllib2.Request(<span class=\"string\">'http://blog.csdn.net/cqcre'</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    urllib2.urlopen(req)</span><br><span class=\"line\"><span class=\"keyword\">except</span> urllib2.URLError, e:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hasattr(e,<span class=\"string\">\"code\"</span>):</span><br><span class=\"line\">        <span class=\"keyword\">print</span> e.code</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hasattr(e,<span class=\"string\">\"reason\"</span>):</span><br><span class=\"line\">        <span class=\"keyword\">print</span> e.reason</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"OK\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><p>Cookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。</p>\n<p>比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容是不允许的。那么我们可以利用Urllib2库保存我们登录的Cookie，然后再抓取其他页面就达到目的了。</p>\n<p>在此之前，先介绍Opener。</p>\n<h3 id=\"Opener\"><a href=\"#Opener\" class=\"headerlink\" title=\"Opener\"></a>Opener</h3><p>Opener是urllib2.OpenerDirector的实例，在前面，我们都是使用的默认的opener，也就是urlopen。它是一个特殊的opener，可以理解成opener的一个特殊实例，传入的参数仅仅是url，data，timeout。</p>\n<p>如果我们需要用到Cookie，只用这个opener是不能达到目的的，所以我们需要创建更一般的opener来实现对Cookie的设置。</p>\n<h3 id=\"Cookielib\"><a href=\"#Cookielib\" class=\"headerlink\" title=\"Cookielib\"></a>Cookielib</h3><p>cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。Cookielib模块非常强大，我们可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。</p>\n<p>它们的关系：<code>CookieJar —-派生—-&gt;FileCookieJar  —-派生—–&gt;MozillaCookieJar和LWPCookieJar</code></p>\n<h4 id=\"1-获取Cookie保存到变量\"><a href=\"#1-获取Cookie保存到变量\" class=\"headerlink\" title=\"1)获取Cookie保存到变量\"></a>1)获取Cookie保存到变量</h4><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib2</span><br><span class=\"line\">import cookielib</span><br><span class=\"line\"><span class=\"comment\">#声明一个CookieJar对象实例来保存cookie</span></span><br><span class=\"line\">cookie = cookielib.CookieJar()</span><br><span class=\"line\"><span class=\"comment\">#利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器</span></span><br><span class=\"line\">handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class=\"line\"><span class=\"comment\">#通过handler来构建opener</span></span><br><span class=\"line\">opener = urllib2.build_opener(handler)</span><br><span class=\"line\"><span class=\"comment\">#创建一个请求，原理同urllib2的urlopen</span></span><br><span class=\"line\">response = opener.<span class=\"built_in\">open</span>(<span class=\"string\">'http://www.baidu.com'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">item</span> <span class=\"keyword\">in</span> cookie:</span><br><span class=\"line\">    print <span class=\"string\">'Name = '</span> + <span class=\"keyword\">item</span>.name</span><br><span class=\"line\">    print <span class=\"string\">'Value = '</span>+ <span class=\"keyword\">item</span>.<span class=\"built_in\">value</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2）保存Cookie到文件\"><a href=\"#2）保存Cookie到文件\" class=\"headerlink\" title=\"2）保存Cookie到文件\"></a>2）保存Cookie到文件</h4><p>在上面的方法中，我们将cookie保存到了cookie这个变量中，如果我们想将cookie保存到文件中该怎么做呢？这时，我们就要用到<br>FileCookieJar这个对象了，在这里我们使用它的子类MozillaCookieJar来实现Cookie的保存。<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib2</span><br><span class=\"line\">import cookielib</span><br><span class=\"line\"><span class=\"comment\">#设置保存cookie的文件，同级目录下的cookie.txt</span></span><br><span class=\"line\">filename = 'cookie.txt'</span><br><span class=\"line\"><span class=\"comment\">#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件</span></span><br><span class=\"line\">cookie = cookielib.MozillaCookieJar(filename)</span><br><span class=\"line\"><span class=\"comment\">#利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器</span></span><br><span class=\"line\">handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class=\"line\"><span class=\"comment\">#通过handler来构建opener</span></span><br><span class=\"line\">opener = urllib2.build_opener(handler)</span><br><span class=\"line\"><span class=\"comment\">#此处的open方法同urllib2的urlopen方法，也可以传入request</span></span><br><span class=\"line\">response = opener.open('http://www.baidu.com')</span><br><span class=\"line\"></span><br><span class=\"line\">cookie.save(ignore_discard=True, ignore_expires=True)</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>ignore_discard: save even cookies set to be discarded.<br>ignore_expires: save even cookies that have expiredThe file is overwritten if it already exists</p>\n</blockquote>\n<p>gnore_discard:即使cookies将被丢弃也将它保存下来。</p>\n<p>ignore_expires：如果在该文件中cookies已经存在，则覆盖原文件写入。</p>\n<p>在这里，我们将这两个全部设置为True。</p>\n<h4 id=\"3-从文件中获取Cookie并访问\"><a href=\"#3-从文件中获取Cookie并访问\" class=\"headerlink\" title=\"3)从文件中获取Cookie并访问\"></a>3)从文件中获取Cookie并访问</h4><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#创建MozillaCookieJar实例对象</span></span><br><span class=\"line\">cookie = cookielib.MozillaCookieJar()</span><br><span class=\"line\"><span class=\"comment\">#从文件中读取cookie内容到变量</span></span><br><span class=\"line\">cookie.load('cookie.txt', ignore_discard=True, ignore_expires=True)</span><br><span class=\"line\"><span class=\"comment\">#创建请求的request</span></span><br><span class=\"line\">req = urllib2.Request(<span class=\"string\">\"http://www.baidu.com\"</span>)</span><br><span class=\"line\"><span class=\"comment\">#利用urllib2的build_opener方法创建一个opener</span></span><br><span class=\"line\">opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))</span><br><span class=\"line\">response = opener.open(req)</span><br><span class=\"line\">print response.read()</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-利用cookie模拟网站登录\"><a href=\"#4-利用cookie模拟网站登录\" class=\"headerlink\" title=\"4)利用cookie模拟网站登录\"></a>4)利用cookie模拟网站登录</h4><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib</span><br><span class=\"line\">import urllib2</span><br><span class=\"line\">import cookielib</span><br><span class=\"line\"> </span><br><span class=\"line\">filename = 'cookie.txt'</span><br><span class=\"line\"><span class=\"comment\">#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件</span></span><br><span class=\"line\">cookie = cookielib.MozillaCookieJar(filename)</span><br><span class=\"line\">opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))</span><br><span class=\"line\">postdata = urllib.urlencode(&#123;</span><br><span class=\"line\">            'stuid':'201200131012',</span><br><span class=\"line\">            'pwd':'23342321'</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"><span class=\"comment\">#登录教务系统的URL</span></span><br><span class=\"line\">loginUrl = 'http://jwxt.sdu.edu.cn:7890/pls/wwwbks/bks_login2.login'</span><br><span class=\"line\"><span class=\"comment\">#模拟登录，并把cookie保存到变量</span></span><br><span class=\"line\">result = opener.open(loginUrl,postdata)</span><br><span class=\"line\"><span class=\"comment\">#保存cookie到cookie.txt中</span></span><br><span class=\"line\">cookie.save(ignore_discard=True, ignore_expires=True)</span><br><span class=\"line\"><span class=\"comment\">#利用cookie请求访问另一个网址，此网址是成绩查询网址</span></span><br><span class=\"line\">gradeUrl = 'http://jwxt.sdu.edu.cn:7890/pls/wwwbks/bkscjcx.curscopre'</span><br><span class=\"line\"><span class=\"comment\">#请求访问成绩查询网址</span></span><br><span class=\"line\">result = opener.open(gradeUrl)</span><br><span class=\"line\">print result.read()</span><br></pre></td></tr></table></figure>\n<p>创建一个带有cookie的opener，在访问登录的URL时，将登录后的cookie保存下来，然后利用这个cookie来访问其他网址。</p>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.zhihu.com/question/20899988\" target=\"_blank\" rel=\"noopener\">如何入门 Python 爬虫？-知乎</a></p>\n<p><a href=\"http://cuiqingcai.com/1052.html\" target=\"_blank\" rel=\"noopener\">Python爬虫学习系列教程</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><p>这里主要说的是URLError还有HTTPError，以及对它们的一些处理。</p>\n<h3 id=\"URLError\"><a href=\"#URLError\" class=\"headerlink\" title=\"URLError\"></a>URLError</h3><p>首先解释下URLError可能产生的原因：</p>\n<ul>\n<li>网络无连接，即本机无法上网</li>\n<li>连接不到特定的服务器</li>\n<li>服务器不存在</li>\n</ul>","more":"<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> urllib2</span><br><span class=\"line\"> </span><br><span class=\"line\">requset = urllib2.Request(<span class=\"string\">'http://www.xxxxx.com'</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    urllib2.urlopen(request)</span><br><span class=\"line\"><span class=\"keyword\">except</span> urllib2.URLError, e:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> e.reason</span><br></pre></td></tr></table></figure>\n<p>当我们打开一个不存在的网址时，就会报错：<code>[Errno 11004] getaddrinfo failed</code></p>\n<h3 id=\"HTTPError\"><a href=\"#HTTPError\" class=\"headerlink\" title=\"HTTPError\"></a>HTTPError</h3><p><code>HTTPError</code>是<code>URLError</code>的子类，在你利用<code>urlopen</code>方法发出一个请求时，服务器上都会对应一个应答对象<code>response</code>，其中它包含一个数字”状态码”。举个例子，假如<code>response</code>是一个”重定向”，需定位到别的地址获取文档，<code>urllib2</code>将对此进行处理。</p>\n<p>其他不能处理的，<code>urlopen</code>会产生一个<code>HTTPError</code>，对应相应的状态吗，HTTP状态码表示HTTP协议所返回的响应的状态。下面将状态码归结如下：</p>\n<blockquote>\n<p>100：继续  客户端应当继续发送请求。客户端应当继续发送请求的剩余部分，或者如果请求已经完成，忽略这个响应。<br>101： 转换协议  在发送完这个响应最后的空行后，服务器将会切换到在Upgrade 消息头中定义的那些协议。只有在切换新的协议更有好处的时候才应该采取类似措施。<br>102：继续处理   由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。<br>200：请求成功      处理方式：获得响应的内容，进行处理<br>201：请求完成，结果是创建了新资源。新创建资源的URI可在响应的实体中得到    处理方式：爬虫中不会遇到<br>202：请求被接受，但处理尚未完成    处理方式：阻塞等待<br>204：服务器端已经实现了请求，但是没有返回新的信 息。如果客户是用户代理，则无须为此更新自身的文档视图。    处理方式：丢弃<br>300：该状态码不被HTTP/1.0的应用程序直接使用， 只是作为3XX类型回应的默认解释。存在多个可用的被请求资源。    处理方式：若程序中能够处理，则进行进一步处理，如果程序中不能处理，则丢弃<br>301：请求到的资源都会分配一个永久的URL，这样就可以在将来通过该URL来访问此资源    处理方式：重定向到分配的URL<br>302：请求到的资源在一个不同的URL处临时保存     处理方式：重定向到临时的URL<br>304：请求的资源未更新     处理方式：丢弃<br>400：非法请求     处理方式：丢弃<br>401：未授权     处理方式：丢弃<br>403：禁止     处理方式：丢弃<br>404：没有找到     处理方式：丢弃<br>500：服务器内部错误  服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。<br>501：服务器无法识别  服务器不支持当前请求所需要的某个功能。当服务器无法识别请求的方法，并且无法支持其对任何资源的请求。<br>502：错误网关  作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。<br>503：服务出错   由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。</p>\n</blockquote>\n<p>HTTPError实例产生后会有一个code属性，这就是是服务器发送的相关错误号。<br>因为urllib2可以为你处理重定向，也就是3开头的代号可以被处理，并且100-299范围的号码指示成功，所以你只能看到400-599的错误号码。</p>\n<p>下面我们写一个例子来感受一下，捕获的异常是HTTPError，它会带有一个code属性，就是错误代号，根据编程经验，父类的异常应当写到子类异常的后面，如果子类捕获不到，那么可以捕获父类的异常,还可以加入 hasattr属性提前对属性进行判断:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> urllib2</span><br><span class=\"line\"> </span><br><span class=\"line\">req = urllib2.Request(<span class=\"string\">'http://blog.csdn.net/cqcre'</span>)</span><br><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    urllib2.urlopen(req)</span><br><span class=\"line\"><span class=\"keyword\">except</span> urllib2.URLError, e:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hasattr(e,<span class=\"string\">\"code\"</span>):</span><br><span class=\"line\">        <span class=\"keyword\">print</span> e.code</span><br><span class=\"line\">    <span class=\"keyword\">if</span> hasattr(e,<span class=\"string\">\"reason\"</span>):</span><br><span class=\"line\">        <span class=\"keyword\">print</span> e.reason</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"OK\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h2><p>Cookie，指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。</p>\n<p>比如说有些网站需要登录后才能访问某个页面，在登录之前，你想抓取某个页面内容是不允许的。那么我们可以利用Urllib2库保存我们登录的Cookie，然后再抓取其他页面就达到目的了。</p>\n<p>在此之前，先介绍Opener。</p>\n<h3 id=\"Opener\"><a href=\"#Opener\" class=\"headerlink\" title=\"Opener\"></a>Opener</h3><p>Opener是urllib2.OpenerDirector的实例，在前面，我们都是使用的默认的opener，也就是urlopen。它是一个特殊的opener，可以理解成opener的一个特殊实例，传入的参数仅仅是url，data，timeout。</p>\n<p>如果我们需要用到Cookie，只用这个opener是不能达到目的的，所以我们需要创建更一般的opener来实现对Cookie的设置。</p>\n<h3 id=\"Cookielib\"><a href=\"#Cookielib\" class=\"headerlink\" title=\"Cookielib\"></a>Cookielib</h3><p>cookielib模块的主要作用是提供可存储cookie的对象，以便于与urllib2模块配合使用来访问Internet资源。Cookielib模块非常强大，我们可以利用本模块的CookieJar类的对象来捕获cookie并在后续连接请求时重新发送，比如可以实现模拟登录功能。该模块主要的对象有CookieJar、FileCookieJar、MozillaCookieJar、LWPCookieJar。</p>\n<p>它们的关系：<code>CookieJar —-派生—-&gt;FileCookieJar  —-派生—–&gt;MozillaCookieJar和LWPCookieJar</code></p>\n<h4 id=\"1-获取Cookie保存到变量\"><a href=\"#1-获取Cookie保存到变量\" class=\"headerlink\" title=\"1)获取Cookie保存到变量\"></a>1)获取Cookie保存到变量</h4><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib2</span><br><span class=\"line\">import cookielib</span><br><span class=\"line\"><span class=\"comment\">#声明一个CookieJar对象实例来保存cookie</span></span><br><span class=\"line\">cookie = cookielib.CookieJar()</span><br><span class=\"line\"><span class=\"comment\">#利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器</span></span><br><span class=\"line\">handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class=\"line\"><span class=\"comment\">#通过handler来构建opener</span></span><br><span class=\"line\">opener = urllib2.build_opener(handler)</span><br><span class=\"line\"><span class=\"comment\">#创建一个请求，原理同urllib2的urlopen</span></span><br><span class=\"line\">response = opener.<span class=\"built_in\">open</span>(<span class=\"string\">'http://www.baidu.com'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">item</span> <span class=\"keyword\">in</span> cookie:</span><br><span class=\"line\">    print <span class=\"string\">'Name = '</span> + <span class=\"keyword\">item</span>.name</span><br><span class=\"line\">    print <span class=\"string\">'Value = '</span>+ <span class=\"keyword\">item</span>.<span class=\"built_in\">value</span></span><br></pre></td></tr></table></figure>\n<h4 id=\"2）保存Cookie到文件\"><a href=\"#2）保存Cookie到文件\" class=\"headerlink\" title=\"2）保存Cookie到文件\"></a>2）保存Cookie到文件</h4><p>在上面的方法中，我们将cookie保存到了cookie这个变量中，如果我们想将cookie保存到文件中该怎么做呢？这时，我们就要用到<br>FileCookieJar这个对象了，在这里我们使用它的子类MozillaCookieJar来实现Cookie的保存。<br><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib2</span><br><span class=\"line\">import cookielib</span><br><span class=\"line\"><span class=\"comment\">#设置保存cookie的文件，同级目录下的cookie.txt</span></span><br><span class=\"line\">filename = 'cookie.txt'</span><br><span class=\"line\"><span class=\"comment\">#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件</span></span><br><span class=\"line\">cookie = cookielib.MozillaCookieJar(filename)</span><br><span class=\"line\"><span class=\"comment\">#利用urllib2库的HTTPCookieProcessor对象来创建cookie处理器</span></span><br><span class=\"line\">handler = urllib2.HTTPCookieProcessor(cookie)</span><br><span class=\"line\"><span class=\"comment\">#通过handler来构建opener</span></span><br><span class=\"line\">opener = urllib2.build_opener(handler)</span><br><span class=\"line\"><span class=\"comment\">#此处的open方法同urllib2的urlopen方法，也可以传入request</span></span><br><span class=\"line\">response = opener.open('http://www.baidu.com')</span><br><span class=\"line\"></span><br><span class=\"line\">cookie.save(ignore_discard=True, ignore_expires=True)</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>ignore_discard: save even cookies set to be discarded.<br>ignore_expires: save even cookies that have expiredThe file is overwritten if it already exists</p>\n</blockquote>\n<p>gnore_discard:即使cookies将被丢弃也将它保存下来。</p>\n<p>ignore_expires：如果在该文件中cookies已经存在，则覆盖原文件写入。</p>\n<p>在这里，我们将这两个全部设置为True。</p>\n<h4 id=\"3-从文件中获取Cookie并访问\"><a href=\"#3-从文件中获取Cookie并访问\" class=\"headerlink\" title=\"3)从文件中获取Cookie并访问\"></a>3)从文件中获取Cookie并访问</h4><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#创建MozillaCookieJar实例对象</span></span><br><span class=\"line\">cookie = cookielib.MozillaCookieJar()</span><br><span class=\"line\"><span class=\"comment\">#从文件中读取cookie内容到变量</span></span><br><span class=\"line\">cookie.load('cookie.txt', ignore_discard=True, ignore_expires=True)</span><br><span class=\"line\"><span class=\"comment\">#创建请求的request</span></span><br><span class=\"line\">req = urllib2.Request(<span class=\"string\">\"http://www.baidu.com\"</span>)</span><br><span class=\"line\"><span class=\"comment\">#利用urllib2的build_opener方法创建一个opener</span></span><br><span class=\"line\">opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))</span><br><span class=\"line\">response = opener.open(req)</span><br><span class=\"line\">print response.read()</span><br></pre></td></tr></table></figure>\n<h4 id=\"4-利用cookie模拟网站登录\"><a href=\"#4-利用cookie模拟网站登录\" class=\"headerlink\" title=\"4)利用cookie模拟网站登录\"></a>4)利用cookie模拟网站登录</h4><figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import urllib</span><br><span class=\"line\">import urllib2</span><br><span class=\"line\">import cookielib</span><br><span class=\"line\"> </span><br><span class=\"line\">filename = 'cookie.txt'</span><br><span class=\"line\"><span class=\"comment\">#声明一个MozillaCookieJar对象实例来保存cookie，之后写入文件</span></span><br><span class=\"line\">cookie = cookielib.MozillaCookieJar(filename)</span><br><span class=\"line\">opener = urllib2.build_opener(urllib2.HTTPCookieProcessor(cookie))</span><br><span class=\"line\">postdata = urllib.urlencode(&#123;</span><br><span class=\"line\">            'stuid':'201200131012',</span><br><span class=\"line\">            'pwd':'23342321'</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"><span class=\"comment\">#登录教务系统的URL</span></span><br><span class=\"line\">loginUrl = 'http://jwxt.sdu.edu.cn:7890/pls/wwwbks/bks_login2.login'</span><br><span class=\"line\"><span class=\"comment\">#模拟登录，并把cookie保存到变量</span></span><br><span class=\"line\">result = opener.open(loginUrl,postdata)</span><br><span class=\"line\"><span class=\"comment\">#保存cookie到cookie.txt中</span></span><br><span class=\"line\">cookie.save(ignore_discard=True, ignore_expires=True)</span><br><span class=\"line\"><span class=\"comment\">#利用cookie请求访问另一个网址，此网址是成绩查询网址</span></span><br><span class=\"line\">gradeUrl = 'http://jwxt.sdu.edu.cn:7890/pls/wwwbks/bkscjcx.curscopre'</span><br><span class=\"line\"><span class=\"comment\">#请求访问成绩查询网址</span></span><br><span class=\"line\">result = opener.open(gradeUrl)</span><br><span class=\"line\">print result.read()</span><br></pre></td></tr></table></figure>\n<p>创建一个带有cookie的opener，在访问登录的URL时，将登录后的cookie保存下来，然后利用这个cookie来访问其他网址。</p>\n<hr>\n<h2 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h2><p><a href=\"https://www.zhihu.com/question/20899988\" target=\"_blank\" rel=\"noopener\">如何入门 Python 爬虫？-知乎</a></p>\n<p><a href=\"http://cuiqingcai.com/1052.html\" target=\"_blank\" rel=\"noopener\">Python爬虫学习系列教程</a></p>"},{"title":"初探python(4)函数式编程","date":"2016-09-26T12:14:50.000Z","_content":"\n\n我们首先要搞明白计算机（Computer）和计算（Compute）的概念。\n\n在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。\n\n而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。\n<!-- more -->\n函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。\n\n函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！\n\nPython对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。\n\n## 高阶函数(Higher-order function）\n\n### 变量可以指向函数\n```\nf = abs\nf\n<built-in function abs>\n```\n函数本身也可以赋值给变量，即：变量可以指向函数。\n\n### 函数名也是变量\n\n对于`abs()`这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数。那如果把abs指向其他对象，就无法通过`abs(-10)`调用该函数了！\n\n这里是为了说明函数名也是变量，实际代码绝对不能这么写。如要恢复abs函数，请重启Python交互环境。\n\n注：由于abs函数实际上是定义在`__builtin__`模块中的，所以要让修改abs变量的指向在其它模块也生效，要用`__builtin__.abs = 10`。\n\n### 传入函数\n既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。\n\n```\ndef add(x, y, f):\n    return f(x) + f(y)\n```\n当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，计算结果就为11。\n\n### map/reduce\n如果你读过Google的那篇大名鼎鼎的论文:[MapReduce: Simplified Data Processing on Large Clusters](http://research.google.com/archive/mapreduce.html),你就能大概明白map/reduce的概念。\nPython内建了`map()`和`reduce()`函数。\n\n#### map\n\nmap()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。\n\n#### reduce\nreduce把一个函数作用在一个序列[x1, x2, x3...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。原理就是：\n```\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n```\n#### 练习\n1.利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']。\n写法一：\n```\ndef f(x):\n    return x.capitalize()\nprint map(f,['adam', 'LISA', 'barT'])\n```\n写法二：\n```\ndef f(x):\n    return x[0].upper() + x[1:].lower()\nmap(f,['adam', 'LISA', 'barT'])\n\n```\n2.Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积。\n```\ndef f(x,y):\n    return x*y\nL=range(1,5)\nprint reduce(f,L)\n```\n\n### filter\n\n正如名字所说的那样，Python内建的`filter()`函数用于过滤序列。\n\n`filter()`也也接收一个函数和一个序列。filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\n\n#### 练习\n\n请尝试用filter()删除1~100的素数。\n\n解：首先，1不是素数。其次，一个数m，如果m不能被2~√m间任一整数整除，m必定是素数。\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\nimport math\nL=range(101)\ndef f(x):\n    if x==1:\n        return 1\n    else:\n        for i in range(2,int(math.sqrt(x))+1):\n            if x%i==0:\n                return 1\n\nprint (filter(f,L))\n```\n### sorted\nPython内置的sorted()函数就可以对list进行排序。\n\n此外，sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x < y，则返回-1，如果认为x == y，则返回0，如果认为x > y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。\n\n比如，如果要倒序排序，我们就可以自定义一个reversed_cmp函数:\n```\ndef reversed_cmp(x, y):\n    if x > y:\n        return -1\n    if x < y:\n        return 1\n    return 0\n```\n传入自定义的比较函数reversed_cmp，就可以实现倒序排序:\n```\nsorted([36, 5, 12, 9, 21], reversed_cmp)\n#[36, 21, 12, 9, 5]\n```\n注意区别sort(),是可变对象(字典、列表)的方法，无参数，无返回值，sort()会改变可变对象，因此无需返回值。sort()方法是可变对象独有的方法或者属性，而作为不可变对象如元组、字符串是不具有这些方法的，如果调用将会返回一个异常。\n\n### zip()\n```\n>>> help(zip)\nHelp on built-in function zip in module __builtin__:\n \nzip(...)\n     zip(seq1 [, seq2 [...]]) -> [(seq1[0], seq2[0] ...), (...)]\n     \n     Return a list of tuples, where each tuple contains the i-th element\n     from each of the argument sequences.  The returned list is truncated\n     in length to the length of the shortest argument sequence.\n\n```\nzip([seql, ...])接受一系列可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。若传入参数的长度不等，则返回列表的长度和参数中长度最短的对象相同。\n\n```\nname = {\"bob\", 'alice', 'hello'}\nage = {12, 3, 45}\nfor n in zip(name, age):\n    print n\n\n#('bob', 3)\n#('hello', 12)\n#('alice', 45)\n```\nzip()配合*号操作符,可以将已经zip过的列表对象解压。\n```\nn=zip(name, age)\nprint zip(*n)\n#[('bob', 'hello', 'alice'), (3, 12, 45)]\n```\n利用zip()配合*这个特性，我们可以用来反转矩阵。\n```\na = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint zip(*a)\n\n#[(1, 4, 7), (2, 5, 8), (3, 6, 9)]\n```\n使用zip合并相邻的列表项,两个iter(a)指向同一对象,因此每对zip都是对同一对象迭代两次。\n```\na = [1, 2, 3, 4, 5, 6]\nprint zip(*([iter(a)] * 2))\n#[(1, 2), (3, 4), (5, 6)]\n```\n### enumerate\n先来看看官方说明：\n```\nReturn an enumerate object.  iterable must be another object that supports\niteration.  The enumerate object yields pairs containing a count (from\nstart, which defaults to zero) and a value yielded by the iterable argument.\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...\n```\n返回一个枚举类型，可迭代的对象，enumerate将其组成一个索引序列，利用它可以同时获得索引和值。通常用于计数。\n\n在统计文件行数时，按照老方法写，文件大的时候可能会停止工作：\n```\nprint len(open(\"seq.txt\").readlines())\n```\n有了枚举，可以这样写：\n```\ncount = -1 \nfor index, line in enumerate(open(filepath,'r'))： \n    count += 1\n```\n### reversed()\n```\nreverse iterator over values of the sequence\n```\n反转函数,无论传递什么参数，都将返回一个以列表为容器的返回值，如果是字典将返回键的列表。\n\n注意区别revers(),是可变对象(字典、列表)的方法，无参数，无返回值，sort()会改变可变对象，因此无需返回值。sort()方法是可变对象独有的方法或者属性，而作为不可变对象如元组、字符串是不具有这些方法的，如果调用将会返回一个异常。\n```\nmylist=[5,4,3,2,1]\nmylist.reverse()\nprint mylist\n```\n##[::-1]\n通过序列的切片也可以达到“逆转”的效果。这也是一种`slice`的特殊写法。\n## 返回函数\n高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\n\n我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：\n```\ndef calc_sum(*args):#有序列表\n    ax = 0\n    for n in args:\n        ax = ax + n\n    return ax\n```\n如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！\n```\ndef lazy_sum(*args):\n    def sum():\n        ax = 0\n        for n in args:\n            ax = ax + n\n        return ax\n    return sum\n```\n\n```\nf = lazy_sum(1, 3, 5, 7, 9)\n>>> f\n<function sum at 0x10452f668>\n>>> f()\n25\n\n```\n\n只有真的调用这个函数，才会真正计算出结果。\n\n当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。\n```\nf1=lazy_sum(1, 3, 5, 7, 9)\nf2=lazy_sum(1, 3, 5, 7, 9)\n```\n当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数，f1()和f2()的调用结果互不影响。\n\n### 闭包\n要注意的是，返回的函数并没有立刻执行，而是直到调用了f()才执行。\n```\ndef count():\n    fs = []\n    for i in range(1, 4):\n        def f():\n             return i*i\n        fs.append(f)\n    return fs\n\nf1, f2, f3 = count()\n\n>>> f1()\n9\n>>> f2()\n9\n>>> f3()\n9\n\n```\n原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。\n\n返回闭包时牢记的一点就是：**返回函数不要引用任何循环变量，或者后续会发生变化的变量。**\n\n如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。\n```\ndef count():\n     fs = []\n    for i in range(1, 4):\n        def f(j):\n            def g():\n                return j*j\n            return g\n        fs.append(f(i))\n    return fs\n \n>>> f1, f2, f3 = count()\n>>> f1()\n1\n>>> f2()\n4\n>>> f3()\n9\n\n```\n最重要的是要理解f1, f2, f3 = count()这句话。\n\ncount()的返回值是一个list，list里面存的是执行for i in range(1, 4)后返回的3个fs函数\nf1, f2, f3 = count()将这3个fs函数依次赋值给f1, f2, f3；同时赋值的还有变量j。因为j=i让j和当前的i绑定起来了，所以f1, f2, f3得到的j值分别是1,2,3\n\n最后在计算f1()的时候，用的是之前传过来的j=1，而不是变化后的i=3，所以f1()=1。 f2(),f3(),依次类推。\n\n## 匿名函数\n```\n map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n关键字lambda表示匿名函数，冒号前面的x表示函数参数。\n\n匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。\n\n用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。\n\n同样，也可以把匿名函数作为返回值返回,\n```\ndef build(x, y):\n    return lambda a,b: x * a + y * b\n\nprint build(1,2)(3,4)\n\n```\n\nPython对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。\n\n## 装饰器\n\n假设我们要增强函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。\n\n装饰器实则是一个返回函数的高阶函数。假如，我们要定义一个能打印日志的decorator，可以定义如下：\n```\ndef log(func):\n    def wrapper(*args, **kw):\n        print 'call %s():' % func.__name__\n        return func(*args, **kw)\n    return wrapper\n\n```\n观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：\n```\n@log\ndef now():\n    print '2013-12-25'\n```\n把@log放到now()函数的定义处，相当于执行了语句：\n```\nnow = log(now)\n\n```\nwrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。\n\n如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：\n```\ndef log(text):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print '%s %s():' % (text, func.__name__)\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@log('execute')\ndef now():\n    print '2016-09-25'\n\n\n>>> now()\nexecute now():\n2016-09-25\n\n```\n3层嵌套的效果是这样的:\n```\nnow = log('execute')(now)\n```\n我们来剖析上面的语句，首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。\n\n以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'。\n\n因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。\n\n因此，可以通过Python内置的functools.wraps来它保留原有函数的名称和docstring。\n\n\n### 练习\n\n1.请编写一个decorator，能在函数调用的前后打印出'begin call'和'end call'的日志。\n\n解答如下：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\nimport functools\ndef decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args,**kwargs):\n        print \"begin call %s\" % func.__name__\n        m=func(*args,**kwargs)\n        print \"end call %s\" % func.__name__\n        return m\n    return wrapper\n\n@decorator\ndef new():\n\n    print \"2016-09-25\"\n\nnew()\n```\n\n2.再思考一下能否写出一个@log的decorator，使它既支持：\n```\n@log\ndef f():\n    pass\n```\n又支持：\n```\n@log('execute')\ndef f():\n    pass\n```\n\n解：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\nimport functools\ndef log(txt=\"hello\"):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args,**kwargs):\n            print \"%s begin call %s\" % (txt,func.__name__)\n            m=func(*args,**kwargs)\n            print \"%s end call %s\" % (txt,func.__name__)\n            return m\n        return wrapper\n    return decorator\n@log('execute')\ndef f():\n   pass\n\nf()\n\n@log()\ndef f():\n    pass\n\nf()\n\n```\n\n## 偏函数\n上面提到了`·functools`模块，它有很多功能，其中之一就是偏函数。要注意，这里的偏函数和数学意义上的偏函数不一样。\n\n`functools.partial`就是帮助我们创建一个偏函数的，不需要我们自己定义`int2()`，可以直接使用下面的代码创建一个新的函数`int2`：\n```\nimport functools\nint2 = functools.partial(int, base=2)\n```\n当函数的参数个数太多，需要简化时，使用`functools.partial`可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。\n\n调用方法就是：`functools.partial(函数名，要固定的参数名并赋值)`\n\n所以先要通过`help()`函数来找到参数名，再进行固定。\n\n然而，这个函数仅仅是把默认值进行了修改，人为调用的时候，还是可以赋值。\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)和官方文档的一个学习内容的总结。以便于自己后的学习和整理。","source":"_posts/python/初探python(4)函数式编程.md","raw":"---\ntitle: 初探python(4)函数式编程\ndate: 2016-09-26 20:14:50\ntags: \n- python\n- python教程\ncategories: 总结\n---\n\n\n我们首先要搞明白计算机（Computer）和计算（Compute）的概念。\n\n在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。\n\n而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。\n<!-- more -->\n函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。\n\n函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！\n\nPython对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。\n\n## 高阶函数(Higher-order function）\n\n### 变量可以指向函数\n```\nf = abs\nf\n<built-in function abs>\n```\n函数本身也可以赋值给变量，即：变量可以指向函数。\n\n### 函数名也是变量\n\n对于`abs()`这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数。那如果把abs指向其他对象，就无法通过`abs(-10)`调用该函数了！\n\n这里是为了说明函数名也是变量，实际代码绝对不能这么写。如要恢复abs函数，请重启Python交互环境。\n\n注：由于abs函数实际上是定义在`__builtin__`模块中的，所以要让修改abs变量的指向在其它模块也生效，要用`__builtin__.abs = 10`。\n\n### 传入函数\n既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。\n\n```\ndef add(x, y, f):\n    return f(x) + f(y)\n```\n当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，计算结果就为11。\n\n### map/reduce\n如果你读过Google的那篇大名鼎鼎的论文:[MapReduce: Simplified Data Processing on Large Clusters](http://research.google.com/archive/mapreduce.html),你就能大概明白map/reduce的概念。\nPython内建了`map()`和`reduce()`函数。\n\n#### map\n\nmap()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。\n\n#### reduce\nreduce把一个函数作用在一个序列[x1, x2, x3...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。原理就是：\n```\nreduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)\n```\n#### 练习\n1.利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：['adam', 'LISA', 'barT']，输出：['Adam', 'Lisa', 'Bart']。\n写法一：\n```\ndef f(x):\n    return x.capitalize()\nprint map(f,['adam', 'LISA', 'barT'])\n```\n写法二：\n```\ndef f(x):\n    return x[0].upper() + x[1:].lower()\nmap(f,['adam', 'LISA', 'barT'])\n\n```\n2.Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积。\n```\ndef f(x,y):\n    return x*y\nL=range(1,5)\nprint reduce(f,L)\n```\n\n### filter\n\n正如名字所说的那样，Python内建的`filter()`函数用于过滤序列。\n\n`filter()`也也接收一个函数和一个序列。filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。\n\n#### 练习\n\n请尝试用filter()删除1~100的素数。\n\n解：首先，1不是素数。其次，一个数m，如果m不能被2~√m间任一整数整除，m必定是素数。\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\nimport math\nL=range(101)\ndef f(x):\n    if x==1:\n        return 1\n    else:\n        for i in range(2,int(math.sqrt(x))+1):\n            if x%i==0:\n                return 1\n\nprint (filter(f,L))\n```\n### sorted\nPython内置的sorted()函数就可以对list进行排序。\n\n此外，sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x < y，则返回-1，如果认为x == y，则返回0，如果认为x > y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。\n\n比如，如果要倒序排序，我们就可以自定义一个reversed_cmp函数:\n```\ndef reversed_cmp(x, y):\n    if x > y:\n        return -1\n    if x < y:\n        return 1\n    return 0\n```\n传入自定义的比较函数reversed_cmp，就可以实现倒序排序:\n```\nsorted([36, 5, 12, 9, 21], reversed_cmp)\n#[36, 21, 12, 9, 5]\n```\n注意区别sort(),是可变对象(字典、列表)的方法，无参数，无返回值，sort()会改变可变对象，因此无需返回值。sort()方法是可变对象独有的方法或者属性，而作为不可变对象如元组、字符串是不具有这些方法的，如果调用将会返回一个异常。\n\n### zip()\n```\n>>> help(zip)\nHelp on built-in function zip in module __builtin__:\n \nzip(...)\n     zip(seq1 [, seq2 [...]]) -> [(seq1[0], seq2[0] ...), (...)]\n     \n     Return a list of tuples, where each tuple contains the i-th element\n     from each of the argument sequences.  The returned list is truncated\n     in length to the length of the shortest argument sequence.\n\n```\nzip([seql, ...])接受一系列可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。若传入参数的长度不等，则返回列表的长度和参数中长度最短的对象相同。\n\n```\nname = {\"bob\", 'alice', 'hello'}\nage = {12, 3, 45}\nfor n in zip(name, age):\n    print n\n\n#('bob', 3)\n#('hello', 12)\n#('alice', 45)\n```\nzip()配合*号操作符,可以将已经zip过的列表对象解压。\n```\nn=zip(name, age)\nprint zip(*n)\n#[('bob', 'hello', 'alice'), (3, 12, 45)]\n```\n利用zip()配合*这个特性，我们可以用来反转矩阵。\n```\na = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nprint zip(*a)\n\n#[(1, 4, 7), (2, 5, 8), (3, 6, 9)]\n```\n使用zip合并相邻的列表项,两个iter(a)指向同一对象,因此每对zip都是对同一对象迭代两次。\n```\na = [1, 2, 3, 4, 5, 6]\nprint zip(*([iter(a)] * 2))\n#[(1, 2), (3, 4), (5, 6)]\n```\n### enumerate\n先来看看官方说明：\n```\nReturn an enumerate object.  iterable must be another object that supports\niteration.  The enumerate object yields pairs containing a count (from\nstart, which defaults to zero) and a value yielded by the iterable argument.\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...\n```\n返回一个枚举类型，可迭代的对象，enumerate将其组成一个索引序列，利用它可以同时获得索引和值。通常用于计数。\n\n在统计文件行数时，按照老方法写，文件大的时候可能会停止工作：\n```\nprint len(open(\"seq.txt\").readlines())\n```\n有了枚举，可以这样写：\n```\ncount = -1 \nfor index, line in enumerate(open(filepath,'r'))： \n    count += 1\n```\n### reversed()\n```\nreverse iterator over values of the sequence\n```\n反转函数,无论传递什么参数，都将返回一个以列表为容器的返回值，如果是字典将返回键的列表。\n\n注意区别revers(),是可变对象(字典、列表)的方法，无参数，无返回值，sort()会改变可变对象，因此无需返回值。sort()方法是可变对象独有的方法或者属性，而作为不可变对象如元组、字符串是不具有这些方法的，如果调用将会返回一个异常。\n```\nmylist=[5,4,3,2,1]\nmylist.reverse()\nprint mylist\n```\n##[::-1]\n通过序列的切片也可以达到“逆转”的效果。这也是一种`slice`的特殊写法。\n## 返回函数\n高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。\n\n我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：\n```\ndef calc_sum(*args):#有序列表\n    ax = 0\n    for n in args:\n        ax = ax + n\n    return ax\n```\n如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！\n```\ndef lazy_sum(*args):\n    def sum():\n        ax = 0\n        for n in args:\n            ax = ax + n\n        return ax\n    return sum\n```\n\n```\nf = lazy_sum(1, 3, 5, 7, 9)\n>>> f\n<function sum at 0x10452f668>\n>>> f()\n25\n\n```\n\n只有真的调用这个函数，才会真正计算出结果。\n\n当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。\n```\nf1=lazy_sum(1, 3, 5, 7, 9)\nf2=lazy_sum(1, 3, 5, 7, 9)\n```\n当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数，f1()和f2()的调用结果互不影响。\n\n### 闭包\n要注意的是，返回的函数并没有立刻执行，而是直到调用了f()才执行。\n```\ndef count():\n    fs = []\n    for i in range(1, 4):\n        def f():\n             return i*i\n        fs.append(f)\n    return fs\n\nf1, f2, f3 = count()\n\n>>> f1()\n9\n>>> f2()\n9\n>>> f3()\n9\n\n```\n原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。\n\n返回闭包时牢记的一点就是：**返回函数不要引用任何循环变量，或者后续会发生变化的变量。**\n\n如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。\n```\ndef count():\n     fs = []\n    for i in range(1, 4):\n        def f(j):\n            def g():\n                return j*j\n            return g\n        fs.append(f(i))\n    return fs\n \n>>> f1, f2, f3 = count()\n>>> f1()\n1\n>>> f2()\n4\n>>> f3()\n9\n\n```\n最重要的是要理解f1, f2, f3 = count()这句话。\n\ncount()的返回值是一个list，list里面存的是执行for i in range(1, 4)后返回的3个fs函数\nf1, f2, f3 = count()将这3个fs函数依次赋值给f1, f2, f3；同时赋值的还有变量j。因为j=i让j和当前的i绑定起来了，所以f1, f2, f3得到的j值分别是1,2,3\n\n最后在计算f1()的时候，用的是之前传过来的j=1，而不是变化后的i=3，所以f1()=1。 f2(),f3(),依次类推。\n\n## 匿名函数\n```\n map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n关键字lambda表示匿名函数，冒号前面的x表示函数参数。\n\n匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。\n\n用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。\n\n同样，也可以把匿名函数作为返回值返回,\n```\ndef build(x, y):\n    return lambda a,b: x * a + y * b\n\nprint build(1,2)(3,4)\n\n```\n\nPython对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。\n\n## 装饰器\n\n假设我们要增强函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。\n\n装饰器实则是一个返回函数的高阶函数。假如，我们要定义一个能打印日志的decorator，可以定义如下：\n```\ndef log(func):\n    def wrapper(*args, **kw):\n        print 'call %s():' % func.__name__\n        return func(*args, **kw)\n    return wrapper\n\n```\n观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：\n```\n@log\ndef now():\n    print '2013-12-25'\n```\n把@log放到now()函数的定义处，相当于执行了语句：\n```\nnow = log(now)\n\n```\nwrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。\n\n如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：\n```\ndef log(text):\n    def decorator(func):\n        def wrapper(*args, **kw):\n            print '%s %s():' % (text, func.__name__)\n            return func(*args, **kw)\n        return wrapper\n    return decorator\n\n@log('execute')\ndef now():\n    print '2016-09-25'\n\n\n>>> now()\nexecute now():\n2016-09-25\n\n```\n3层嵌套的效果是这样的:\n```\nnow = log('execute')(now)\n```\n我们来剖析上面的语句，首先执行log('execute')，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。\n\n以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的'now'变成了'wrapper'。\n\n因为返回的那个wrapper()函数名字就是'wrapper'，所以，需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。\n\n因此，可以通过Python内置的functools.wraps来它保留原有函数的名称和docstring。\n\n\n### 练习\n\n1.请编写一个decorator，能在函数调用的前后打印出'begin call'和'end call'的日志。\n\n解答如下：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\nimport functools\ndef decorator(func):\n    @functools.wraps(func)\n    def wrapper(*args,**kwargs):\n        print \"begin call %s\" % func.__name__\n        m=func(*args,**kwargs)\n        print \"end call %s\" % func.__name__\n        return m\n    return wrapper\n\n@decorator\ndef new():\n\n    print \"2016-09-25\"\n\nnew()\n```\n\n2.再思考一下能否写出一个@log的decorator，使它既支持：\n```\n@log\ndef f():\n    pass\n```\n又支持：\n```\n@log('execute')\ndef f():\n    pass\n```\n\n解：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n__author__ = 'zjbao123'\nimport functools\ndef log(txt=\"hello\"):\n    def decorator(func):\n        @functools.wraps(func)\n        def wrapper(*args,**kwargs):\n            print \"%s begin call %s\" % (txt,func.__name__)\n            m=func(*args,**kwargs)\n            print \"%s end call %s\" % (txt,func.__name__)\n            return m\n        return wrapper\n    return decorator\n@log('execute')\ndef f():\n   pass\n\nf()\n\n@log()\ndef f():\n    pass\n\nf()\n\n```\n\n## 偏函数\n上面提到了`·functools`模块，它有很多功能，其中之一就是偏函数。要注意，这里的偏函数和数学意义上的偏函数不一样。\n\n`functools.partial`就是帮助我们创建一个偏函数的，不需要我们自己定义`int2()`，可以直接使用下面的代码创建一个新的函数`int2`：\n```\nimport functools\nint2 = functools.partial(int, base=2)\n```\n当函数的参数个数太多，需要简化时，使用`functools.partial`可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。\n\n调用方法就是：`functools.partial(函数名，要固定的参数名并赋值)`\n\n所以先要通过`help()`函数来找到参数名，再进行固定。\n\n然而，这个函数仅仅是把默认值进行了修改，人为调用的时候，还是可以赋值。\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)和官方文档的一个学习内容的总结。以便于自己后的学习和整理。","slug":"python/初探python(4)函数式编程","published":1,"updated":"2019-03-22T14:44:36.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0n009r4l3nld07uo67","content":"<p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。</p>\n<p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>\n<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。<br><a id=\"more\"></a><br>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>\n<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>\n<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>\n<h2 id=\"高阶函数-Higher-order-function）\"><a href=\"#高阶函数-Higher-order-function）\" class=\"headerlink\" title=\"高阶函数(Higher-order function）\"></a>高阶函数(Higher-order function）</h2><h3 id=\"变量可以指向函数\"><a href=\"#变量可以指向函数\" class=\"headerlink\" title=\"变量可以指向函数\"></a>变量可以指向函数</h3><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = <span class=\"built_in\">abs</span></span><br><span class=\"line\">f</span><br><span class=\"line\">&lt;built-<span class=\"keyword\">in</span> <span class=\"function\"><span class=\"keyword\">function</span></span> <span class=\"built_in\">abs</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>函数本身也可以赋值给变量，即：变量可以指向函数。</p>\n<h3 id=\"函数名也是变量\"><a href=\"#函数名也是变量\" class=\"headerlink\" title=\"函数名也是变量\"></a>函数名也是变量</h3><p>对于<code>abs()</code>这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数。那如果把abs指向其他对象，就无法通过<code>abs(-10)</code>调用该函数了！</p>\n<p>这里是为了说明函数名也是变量，实际代码绝对不能这么写。如要恢复abs函数，请重启Python交互环境。</p>\n<p>注：由于abs函数实际上是定义在<code>__builtin__</code>模块中的，所以要让修改abs变量的指向在其它模块也生效，要用<code>__builtin__.abs = 10</code>。</p>\n<h3 id=\"传入函数\"><a href=\"#传入函数\" class=\"headerlink\" title=\"传入函数\"></a>传入函数</h3><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y, f)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(x) + f(y)</span><br></pre></td></tr></table></figure>\n<p>当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，计算结果就为11。</p>\n<h3 id=\"map-reduce\"><a href=\"#map-reduce\" class=\"headerlink\" title=\"map/reduce\"></a>map/reduce</h3><p>如果你读过Google的那篇大名鼎鼎的论文:<a href=\"http://research.google.com/archive/mapreduce.html\" target=\"_blank\" rel=\"noopener\">MapReduce: Simplified Data Processing on Large Clusters</a>,你就能大概明白map/reduce的概念。<br>Python内建了<code>map()</code>和<code>reduce()</code>函数。</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。</p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p>reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。原理就是：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reduce(<span class=\"name\">f</span>, [x1, x2, x3, x4]) = f(<span class=\"name\">f</span>(<span class=\"name\">f</span>(<span class=\"name\">x1</span>, x2), x3), x4)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h4><p>1.利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]。<br>写法一：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.capitalize()</span><br><span class=\"line\"><span class=\"keyword\">print</span> map(f,[<span class=\"string\">'adam'</span>, <span class=\"string\">'LISA'</span>, <span class=\"string\">'barT'</span>])</span><br></pre></td></tr></table></figure></p>\n<p>写法二：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">def</span> <span class=\"selector-tag\">f</span>(x):</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">x</span><span class=\"selector-attr\">[0]</span><span class=\"selector-class\">.upper</span>() + <span class=\"selector-tag\">x</span><span class=\"selector-attr\">[1:]</span><span class=\"selector-class\">.lower</span>()</span><br><span class=\"line\"><span class=\"selector-tag\">map</span>(f,[<span class=\"string\">'adam'</span>, <span class=\"string\">'LISA'</span>, <span class=\"string\">'barT'</span>])</span><br></pre></td></tr></table></figure></p>\n<p>2.Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x,y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x*y</span><br><span class=\"line\">L=range(<span class=\"number\">1</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> reduce(f,L)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p>正如名字所说的那样，Python内建的<code>filter()</code>函数用于过滤序列。</p>\n<p><code>filter()</code>也也接收一个函数和一个序列。filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>\n<h4 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h4><p>请尝试用filter()删除1~100的素数。</p>\n<p>解：首先，1不是素数。其次，一个数m，如果m不能被2~√m间任一整数整除，m必定是素数。<br><figure class=\"highlight mel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/<span class=\"keyword\">env</span> <span class=\"keyword\">python</span></span><br><span class=\"line\"># -*- coding: utf<span class=\"number\">-8</span> -*-</span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\">import math</span><br><span class=\"line\">L=range(<span class=\"number\">101</span>)</span><br><span class=\"line\">def f(x):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x==<span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,<span class=\"keyword\">int</span>(math.<span class=\"keyword\">sqrt</span>(x))+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x%i==<span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> (<span class=\"keyword\">filter</span>(f,L))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted\"></a>sorted</h3><p>Python内置的sorted()函数就可以对list进行排序。</p>\n<p>此外，sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。</p>\n<p>比如，如果要倒序排序，我们就可以自定义一个reversed_cmp函数:<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reversed_cmp</span><span class=\"params\">(x, y)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt; <span class=\"symbol\">y:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &lt; <span class=\"symbol\">y:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></p>\n<p>传入自定义的比较函数reversed_cmp，就可以实现倒序排序:<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sorted([<span class=\"number\">36</span>, <span class=\"number\">5</span>, <span class=\"number\">12</span>, <span class=\"number\">9</span>, <span class=\"number\">21</span>], reversed_cmp)</span><br><span class=\"line\">#[<span class=\"number\">36</span>, <span class=\"number\">21</span>, <span class=\"number\">12</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure></p>\n<p>注意区别sort(),是可变对象(字典、列表)的方法，无参数，无返回值，sort()会改变可变对象，因此无需返回值。sort()方法是可变对象独有的方法或者属性，而作为不可变对象如元组、字符串是不具有这些方法的，如果调用将会返回一个异常。</p>\n<h3 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip()\"></a>zip()</h3><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; help(zip)</span><br><span class=\"line\">Help <span class=\"keyword\">on</span> <span class=\"title\">built-in</span> <span class=\"title\">function</span> <span class=\"title\">zip</span> <span class=\"title\">in</span> <span class=\"title\">module</span> <span class=\"title\">__builtin__</span>:</span><br><span class=\"line\"> </span><br><span class=\"line\">zip(...)</span><br><span class=\"line\">     zip(seq1 [, seq2 [...]]) -&gt; [(seq1[<span class=\"number\">0</span>], seq2[<span class=\"number\">0</span>] ...), (...)]</span><br><span class=\"line\">     </span><br><span class=\"line\">     Return <span class=\"keyword\">a</span> list <span class=\"keyword\">of</span> tuples, where <span class=\"keyword\">each</span> tuple <span class=\"keyword\">contains</span> <span class=\"keyword\">the</span> i-th <span class=\"keyword\">element</span></span><br><span class=\"line\">     <span class=\"built_in\">from</span> <span class=\"keyword\">each</span> <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> argument sequences.  The returned list is truncated</span><br><span class=\"line\">     <span class=\"keyword\">in</span> <span class=\"built_in\">length</span> <span class=\"built_in\">to</span> <span class=\"keyword\">the</span> <span class=\"built_in\">length</span> <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> shortest argument sequence.</span><br></pre></td></tr></table></figure>\n<p>zip([seql, …])接受一系列可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。若传入参数的长度不等，则返回列表的长度和参数中长度最短的对象相同。</p>\n<figure class=\"highlight leaf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = &#123;\"bob\", 'alice', 'hello'&#125;</span><br><span class=\"line\">age = &#123;12, 3, 45&#125;</span><br><span class=\"line\">for n in zip(name, age):</span><br><span class=\"line\">    print n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">#</span><span class=\"params\">('<span class=\"variable\">bob</span>', 3)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">#</span><span class=\"params\">('<span class=\"variable\">hello</span>', 12)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">#</span><span class=\"params\">('<span class=\"variable\">alice</span>', 45)</span></span></span><br></pre></td></tr></table></figure>\n<p>zip()配合*号操作符,可以将已经zip过的列表对象解压。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">n</span>=zip(name, age)</span><br><span class=\"line\"><span class=\"builtin-name\">print</span> zip(*n)</span><br><span class=\"line\"><span class=\"comment\">#[('bob', 'hello', 'alice'), (3, 12, 45)]</span></span><br></pre></td></tr></table></figure></p>\n<p>利用zip()配合*这个特性，我们可以用来反转矩阵。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]]</span><br><span class=\"line\">print zip(*a)</span><br><span class=\"line\"></span><br><span class=\"line\">#[(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>), (<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>), (<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>)]</span><br></pre></td></tr></table></figure></p>\n<p>使用zip合并相邻的列表项,两个iter(a)指向同一对象,因此每对zip都是对同一对象迭代两次。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\">print zip(*([iter(a)] * <span class=\"number\">2</span>))</span><br><span class=\"line\">#[(<span class=\"number\">1</span>, <span class=\"number\">2</span>), (<span class=\"number\">3</span>, <span class=\"number\">4</span>), (<span class=\"number\">5</span>, <span class=\"number\">6</span>)]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"enumerate\"><a href=\"#enumerate\" class=\"headerlink\" title=\"enumerate\"></a>enumerate</h3><p>先来看看官方说明：<br><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Return an enumerate object.  iterable must be another object that supports</span><br><span class=\"line\">iteration.  The enumerate object yields pairs containing a count (from</span><br><span class=\"line\">start, which defaults to zero) <span class=\"keyword\">and</span> a value yielded by the iterable argument.</span><br><span class=\"line\">enumerate is useful <span class=\"keyword\">for</span> obtaining an indexed list:</span><br><span class=\"line\">    (<span class=\"number\">0</span>, se<span class=\"string\">q[0]</span>), (<span class=\"number\">1</span>, se<span class=\"string\">q[1]</span>), (<span class=\"number\">2</span>, se<span class=\"string\">q[2]</span>), ...</span><br></pre></td></tr></table></figure></p>\n<p>返回一个枚举类型，可迭代的对象，enumerate将其组成一个索引序列，利用它可以同时获得索引和值。通常用于计数。</p>\n<p>在统计文件行数时，按照老方法写，文件大的时候可能会停止工作：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print len(<span class=\"name\">open</span>(<span class=\"string\">\"seq.txt\"</span>).readlines())</span><br></pre></td></tr></table></figure></p>\n<p>有了枚举，可以这样写：<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">count</span> = -<span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">index</span>, <span class=\"built_in\">line</span> in enumerate(<span class=\"keyword\">open</span>(filepath,<span class=\"string\">'r'</span>))： </span><br><span class=\"line\">    <span class=\"built_in\">count</span> += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"reversed\"><a href=\"#reversed\" class=\"headerlink\" title=\"reversed()\"></a>reversed()</h3><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reverse</span> <span class=\"keyword\">iterator</span> over values <span class=\"keyword\">of</span> the <span class=\"keyword\">sequence</span></span><br></pre></td></tr></table></figure>\n<p>反转函数,无论传递什么参数，都将返回一个以列表为容器的返回值，如果是字典将返回键的列表。</p>\n<p>注意区别revers(),是可变对象(字典、列表)的方法，无参数，无返回值，sort()会改变可变对象，因此无需返回值。sort()方法是可变对象独有的方法或者属性，而作为不可变对象如元组、字符串是不具有这些方法的，如果调用将会返回一个异常。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mylist=[<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">mylist.reverse()</span><br><span class=\"line\">print mylist</span><br></pre></td></tr></table></figure></p>\n<p>##[::-1]<br>通过序列的切片也可以达到“逆转”的效果。这也是一种<code>slice</code>的特殊写法。</p>\n<h2 id=\"返回函数\"><a href=\"#返回函数\" class=\"headerlink\" title=\"返回函数\"></a>返回函数</h2><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>\n<p>我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc_sum</span><span class=\"params\">(*args)</span></span><span class=\"symbol\">:</span><span class=\"comment\">#有序列表</span></span><br><span class=\"line\">    ax = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> <span class=\"symbol\">args:</span></span><br><span class=\"line\">        ax = ax + n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ax</span><br></pre></td></tr></table></figure></p>\n<p>如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lazy_sum</span><span class=\"params\">(*args)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        ax = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> <span class=\"symbol\">args:</span></span><br><span class=\"line\">            ax = ax + n</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ax</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = lazy_sum(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">&gt;&gt;&gt; f</span><br><span class=\"line\">&lt;function sum at <span class=\"number\">0x10452f668</span>&gt;</span><br><span class=\"line\">&gt;&gt;&gt; f()</span><br><span class=\"line\"><span class=\"number\">25</span></span><br></pre></td></tr></table></figure>\n<p>只有真的调用这个函数，才会真正计算出结果。</p>\n<p>当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1=lazy_sum(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">f2=lazy_sum(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>)</span><br></pre></td></tr></table></figure></p>\n<p>当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数，f1()和f2()的调用结果互不影响。</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>要注意的是，返回的函数并没有立刻执行，而是直到调用了f()才执行。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    fs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>)<span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">             <span class=\"keyword\">return</span> i*i</span><br><span class=\"line\">        fs.append(f)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs</span><br><span class=\"line\"></span><br><span class=\"line\">f1, f2, f3 = count()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f1()</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f2()</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f3()</span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure></p>\n<p>原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。</p>\n<p>返回闭包时牢记的一点就是：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>\n<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">     fs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>)<span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(j)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">g</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> j*j</span><br><span class=\"line\">            <span class=\"keyword\">return</span> g</span><br><span class=\"line\">        fs.append(f(i))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f1, f2, f3 = count()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f1()</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f2()</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f3()</span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure></p>\n<p>最重要的是要理解f1, f2, f3 = count()这句话。</p>\n<p>count()的返回值是一个list，list里面存的是执行for i in range(1, 4)后返回的3个fs函数<br>f1, f2, f3 = count()将这3个fs函数依次赋值给f1, f2, f3；同时赋值的还有变量j。因为j=i让j和当前的i绑定起来了，所以f1, f2, f3得到的j值分别是1,2,3</p>\n<p>最后在计算f1()的时候，用的是之前传过来的j=1，而不是变化后的i=3，所以f1()=1。 f2(),f3(),依次类推。</p>\n<h2 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h2><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"selector-tag\">map</span>(lambda <span class=\"attribute\">x</span>: x * x, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>])</span><br><span class=\"line\"><span class=\"selector-attr\">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>\n<p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。</p>\n<p>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p>\n<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。</p>\n<p>同样，也可以把匿名函数作为返回值返回,<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> a,b: x * a + y * b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> build(<span class=\"number\">1</span>,<span class=\"number\">2</span>)(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure></p>\n<p>Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。</p>\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h2><p>假设我们要增强函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p>\n<p>装饰器实则是一个返回函数的高阶函数。假如，我们要定义一个能打印日志的decorator，可以定义如下：<br><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def <span class=\"built_in\">log</span>(<span class=\"function\"><span class=\"keyword\">func</span>):</span></span><br><span class=\"line\">    def wrapper(*args, **kw):</span><br><span class=\"line\">        print <span class=\"string\">'call %s():'</span> % <span class=\"function\"><span class=\"keyword\">func</span>.<span class=\"title\">__name__</span></span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*args, **kw)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br></pre></td></tr></table></figure></p>\n<p>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@log</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'2013-12-25'</span></span><br></pre></td></tr></table></figure></p>\n<p>把@log放到now()函数的定义处，相当于执行了语句：<br><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">now</span> = <span class=\"built_in\">log</span>(<span class=\"built_in\">now</span>)</span><br></pre></td></tr></table></figure></p>\n<p>wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p>\n<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(text)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">            print <span class=\"string\">'%s %s():'</span> % (text, func.__name_<span class=\"number\">_</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\">@log(<span class=\"string\">'execute'</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    print <span class=\"string\">'2016-09-25'</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; now()</span><br><span class=\"line\">execute now()<span class=\"symbol\">:</span></span><br><span class=\"line\"><span class=\"number\">2016</span>-09-<span class=\"number\">25</span></span><br></pre></td></tr></table></figure></p>\n<p>3层嵌套的效果是这样的:<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">now = log('execute')(<span class=\"name\">now</span>)</span><br></pre></td></tr></table></figure></p>\n<p>我们来剖析上面的语句，首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。</p>\n<p>以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有<strong>name</strong>等属性，但你去看经过decorator装饰之后的函数，它们的<strong>name</strong>已经从原来的’now’变成了’wrapper’。</p>\n<p>因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的<strong>name</strong>等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。</p>\n<p>因此，可以通过Python内置的functools.wraps来它保留原有函数的名称和docstring。</p>\n<h3 id=\"练习-2\"><a href=\"#练习-2\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>1.请编写一个decorator，能在函数调用的前后打印出’begin call’和’end call’的日志。</p>\n<p>解答如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args,**kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"begin call %s\"</span> % func.__name__</span><br><span class=\"line\">        m=func(*args,**kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"end call %s\"</span> % func.__name__</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">new</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"2016-09-25\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">new()</span><br></pre></td></tr></table></figure></p>\n<p>2.再思考一下能否写出一个@log的decorator，使它既支持：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@log</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>又支持：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@log(<span class=\"string\">'execute'</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure></p>\n<p>解：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(txt=<span class=\"string\">\"hello\"</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">        @functools.wraps(func)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args,**kwargs)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"%s begin call %s\"</span> % (txt,func.__name__)</span><br><span class=\"line\">            m=func(*args,**kwargs)</span><br><span class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"%s end call %s\"</span> % (txt,func.__name__)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"><span class=\"meta\">@log('execute')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">   <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"偏函数\"><a href=\"#偏函数\" class=\"headerlink\" title=\"偏函数\"></a>偏函数</h2><p>上面提到了<code>·functools</code>模块，它有很多功能，其中之一就是偏函数。要注意，这里的偏函数和数学意义上的偏函数不一样。</p>\n<p><code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import functools</span><br><span class=\"line\">int2 = functools.<span class=\"keyword\">partial</span>(<span class=\"keyword\">int</span>, <span class=\"keyword\">base</span>=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<p>当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>\n<p>调用方法就是：<code>functools.partial(函数名，要固定的参数名并赋值)</code></p>\n<p>所以先要通过<code>help()</code>函数来找到参数名，再进行固定。</p>\n<p>然而，这个函数仅仅是把默认值进行了修改，人为调用的时候，还是可以赋值。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>和官方文档的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>我们首先要搞明白计算机（Computer）和计算（Compute）的概念。</p>\n<p>在计算机的层次上，CPU执行的是加减乘除的指令代码，以及各种条件判断和跳转指令，所以，汇编语言是最贴近计算机的语言。</p>\n<p>而计算则指数学意义上的计算，越是抽象的计算，离计算机硬件越远。<br></p>","more":"<br>函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。<p></p>\n<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数！</p>\n<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>\n<h2 id=\"高阶函数-Higher-order-function）\"><a href=\"#高阶函数-Higher-order-function）\" class=\"headerlink\" title=\"高阶函数(Higher-order function）\"></a>高阶函数(Higher-order function）</h2><h3 id=\"变量可以指向函数\"><a href=\"#变量可以指向函数\" class=\"headerlink\" title=\"变量可以指向函数\"></a>变量可以指向函数</h3><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = <span class=\"built_in\">abs</span></span><br><span class=\"line\">f</span><br><span class=\"line\">&lt;built-<span class=\"keyword\">in</span> <span class=\"function\"><span class=\"keyword\">function</span></span> <span class=\"built_in\">abs</span>&gt;</span><br></pre></td></tr></table></figure>\n<p>函数本身也可以赋值给变量，即：变量可以指向函数。</p>\n<h3 id=\"函数名也是变量\"><a href=\"#函数名也是变量\" class=\"headerlink\" title=\"函数名也是变量\"></a>函数名也是变量</h3><p>对于<code>abs()</code>这个函数，完全可以把函数名abs看成变量，它指向一个可以计算绝对值的函数。那如果把abs指向其他对象，就无法通过<code>abs(-10)</code>调用该函数了！</p>\n<p>这里是为了说明函数名也是变量，实际代码绝对不能这么写。如要恢复abs函数，请重启Python交互环境。</p>\n<p>注：由于abs函数实际上是定义在<code>__builtin__</code>模块中的，所以要让修改abs变量的指向在其它模块也生效，要用<code>__builtin__.abs = 10</code>。</p>\n<h3 id=\"传入函数\"><a href=\"#传入函数\" class=\"headerlink\" title=\"传入函数\"></a>传入函数</h3><p>既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称之为高阶函数。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">add</span><span class=\"params\">(x, y, f)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> f(x) + f(y)</span><br></pre></td></tr></table></figure>\n<p>当我们调用add(-5, 6, abs)时，参数x，y和f分别接收-5，6和abs，根据函数定义，计算结果就为11。</p>\n<h3 id=\"map-reduce\"><a href=\"#map-reduce\" class=\"headerlink\" title=\"map/reduce\"></a>map/reduce</h3><p>如果你读过Google的那篇大名鼎鼎的论文:<a href=\"http://research.google.com/archive/mapreduce.html\" target=\"_blank\" rel=\"noopener\">MapReduce: Simplified Data Processing on Large Clusters</a>,你就能大概明白map/reduce的概念。<br>Python内建了<code>map()</code>和<code>reduce()</code>函数。</p>\n<h4 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h4><p>map()函数接收两个参数，一个是函数，一个是序列，map将传入的函数依次作用到序列的每个元素，并把结果作为新的list返回。</p>\n<h4 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h4><p>reduce把一个函数作用在一个序列[x1, x2, x3…]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算。原理就是：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reduce(<span class=\"name\">f</span>, [x1, x2, x3, x4]) = f(<span class=\"name\">f</span>(<span class=\"name\">f</span>(<span class=\"name\">x1</span>, x2), x3), x4)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h4><p>1.利用map()函数，把用户输入的不规范的英文名字，变为首字母大写，其他小写的规范名字。输入：[‘adam’, ‘LISA’, ‘barT’]，输出：[‘Adam’, ‘Lisa’, ‘Bart’]。<br>写法一：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x.capitalize()</span><br><span class=\"line\"><span class=\"keyword\">print</span> map(f,[<span class=\"string\">'adam'</span>, <span class=\"string\">'LISA'</span>, <span class=\"string\">'barT'</span>])</span><br></pre></td></tr></table></figure></p>\n<p>写法二：<br><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"selector-tag\">def</span> <span class=\"selector-tag\">f</span>(x):</span><br><span class=\"line\">    <span class=\"selector-tag\">return</span> <span class=\"selector-tag\">x</span><span class=\"selector-attr\">[0]</span><span class=\"selector-class\">.upper</span>() + <span class=\"selector-tag\">x</span><span class=\"selector-attr\">[1:]</span><span class=\"selector-class\">.lower</span>()</span><br><span class=\"line\"><span class=\"selector-tag\">map</span>(f,[<span class=\"string\">'adam'</span>, <span class=\"string\">'LISA'</span>, <span class=\"string\">'barT'</span>])</span><br></pre></td></tr></table></figure></p>\n<p>2.Python提供的sum()函数可以接受一个list并求和，请编写一个prod()函数，可以接受一个list并利用reduce()求积。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(x,y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> x*y</span><br><span class=\"line\">L=range(<span class=\"number\">1</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> reduce(f,L)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h3><p>正如名字所说的那样，Python内建的<code>filter()</code>函数用于过滤序列。</p>\n<p><code>filter()</code>也也接收一个函数和一个序列。filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。</p>\n<h4 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h4><p>请尝试用filter()删除1~100的素数。</p>\n<p>解：首先，1不是素数。其次，一个数m，如果m不能被2~√m间任一整数整除，m必定是素数。<br><figure class=\"highlight mel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/usr/bin/<span class=\"keyword\">env</span> <span class=\"keyword\">python</span></span><br><span class=\"line\"># -*- coding: utf<span class=\"number\">-8</span> -*-</span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\">import math</span><br><span class=\"line\">L=range(<span class=\"number\">101</span>)</span><br><span class=\"line\">def f(x):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> x==<span class=\"number\">1</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,<span class=\"keyword\">int</span>(math.<span class=\"keyword\">sqrt</span>(x))+<span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> x%i==<span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> (<span class=\"keyword\">filter</span>(f,L))</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"sorted\"><a href=\"#sorted\" class=\"headerlink\" title=\"sorted\"></a>sorted</h3><p>Python内置的sorted()函数就可以对list进行排序。</p>\n<p>此外，sorted()函数也是一个高阶函数，它还可以接收一个比较函数来实现自定义的排序。比较的过程必须通过函数抽象出来。通常规定，对于两个元素x和y，如果认为x &lt; y，则返回-1，如果认为x == y，则返回0，如果认为x &gt; y，则返回1，这样，排序算法就不用关心具体的比较过程，而是根据比较结果直接排序。</p>\n<p>比如，如果要倒序排序，我们就可以自定义一个reversed_cmp函数:<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">reversed_cmp</span><span class=\"params\">(x, y)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &gt; <span class=\"symbol\">y:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> -<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> x &lt; <span class=\"symbol\">y:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br></pre></td></tr></table></figure></p>\n<p>传入自定义的比较函数reversed_cmp，就可以实现倒序排序:<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sorted([<span class=\"number\">36</span>, <span class=\"number\">5</span>, <span class=\"number\">12</span>, <span class=\"number\">9</span>, <span class=\"number\">21</span>], reversed_cmp)</span><br><span class=\"line\">#[<span class=\"number\">36</span>, <span class=\"number\">21</span>, <span class=\"number\">12</span>, <span class=\"number\">9</span>, <span class=\"number\">5</span>]</span><br></pre></td></tr></table></figure></p>\n<p>注意区别sort(),是可变对象(字典、列表)的方法，无参数，无返回值，sort()会改变可变对象，因此无需返回值。sort()方法是可变对象独有的方法或者属性，而作为不可变对象如元组、字符串是不具有这些方法的，如果调用将会返回一个异常。</p>\n<h3 id=\"zip\"><a href=\"#zip\" class=\"headerlink\" title=\"zip()\"></a>zip()</h3><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt;&gt;&gt; help(zip)</span><br><span class=\"line\">Help <span class=\"keyword\">on</span> <span class=\"title\">built-in</span> <span class=\"title\">function</span> <span class=\"title\">zip</span> <span class=\"title\">in</span> <span class=\"title\">module</span> <span class=\"title\">__builtin__</span>:</span><br><span class=\"line\"> </span><br><span class=\"line\">zip(...)</span><br><span class=\"line\">     zip(seq1 [, seq2 [...]]) -&gt; [(seq1[<span class=\"number\">0</span>], seq2[<span class=\"number\">0</span>] ...), (...)]</span><br><span class=\"line\">     </span><br><span class=\"line\">     Return <span class=\"keyword\">a</span> list <span class=\"keyword\">of</span> tuples, where <span class=\"keyword\">each</span> tuple <span class=\"keyword\">contains</span> <span class=\"keyword\">the</span> i-th <span class=\"keyword\">element</span></span><br><span class=\"line\">     <span class=\"built_in\">from</span> <span class=\"keyword\">each</span> <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> argument sequences.  The returned list is truncated</span><br><span class=\"line\">     <span class=\"keyword\">in</span> <span class=\"built_in\">length</span> <span class=\"built_in\">to</span> <span class=\"keyword\">the</span> <span class=\"built_in\">length</span> <span class=\"keyword\">of</span> <span class=\"keyword\">the</span> shortest argument sequence.</span><br></pre></td></tr></table></figure>\n<p>zip([seql, …])接受一系列可迭代对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。若传入参数的长度不等，则返回列表的长度和参数中长度最短的对象相同。</p>\n<figure class=\"highlight leaf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = &#123;\"bob\", 'alice', 'hello'&#125;</span><br><span class=\"line\">age = &#123;12, 3, 45&#125;</span><br><span class=\"line\">for n in zip(name, age):</span><br><span class=\"line\">    print n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">#</span><span class=\"params\">('<span class=\"variable\">bob</span>', 3)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">#</span><span class=\"params\">('<span class=\"variable\">hello</span>', 12)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">#</span><span class=\"params\">('<span class=\"variable\">alice</span>', 45)</span></span></span><br></pre></td></tr></table></figure>\n<p>zip()配合*号操作符,可以将已经zip过的列表对象解压。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">n</span>=zip(name, age)</span><br><span class=\"line\"><span class=\"builtin-name\">print</span> zip(*n)</span><br><span class=\"line\"><span class=\"comment\">#[('bob', 'hello', 'alice'), (3, 12, 45)]</span></span><br></pre></td></tr></table></figure></p>\n<p>利用zip()配合*这个特性，我们可以用来反转矩阵。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [[<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>], [<span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>], [<span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>]]</span><br><span class=\"line\">print zip(*a)</span><br><span class=\"line\"></span><br><span class=\"line\">#[(<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">7</span>), (<span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>), (<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">9</span>)]</span><br></pre></td></tr></table></figure></p>\n<p>使用zip合并相邻的列表项,两个iter(a)指向同一对象,因此每对zip都是对同一对象迭代两次。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>]</span><br><span class=\"line\">print zip(*([iter(a)] * <span class=\"number\">2</span>))</span><br><span class=\"line\">#[(<span class=\"number\">1</span>, <span class=\"number\">2</span>), (<span class=\"number\">3</span>, <span class=\"number\">4</span>), (<span class=\"number\">5</span>, <span class=\"number\">6</span>)]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"enumerate\"><a href=\"#enumerate\" class=\"headerlink\" title=\"enumerate\"></a>enumerate</h3><p>先来看看官方说明：<br><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Return an enumerate object.  iterable must be another object that supports</span><br><span class=\"line\">iteration.  The enumerate object yields pairs containing a count (from</span><br><span class=\"line\">start, which defaults to zero) <span class=\"keyword\">and</span> a value yielded by the iterable argument.</span><br><span class=\"line\">enumerate is useful <span class=\"keyword\">for</span> obtaining an indexed list:</span><br><span class=\"line\">    (<span class=\"number\">0</span>, se<span class=\"string\">q[0]</span>), (<span class=\"number\">1</span>, se<span class=\"string\">q[1]</span>), (<span class=\"number\">2</span>, se<span class=\"string\">q[2]</span>), ...</span><br></pre></td></tr></table></figure></p>\n<p>返回一个枚举类型，可迭代的对象，enumerate将其组成一个索引序列，利用它可以同时获得索引和值。通常用于计数。</p>\n<p>在统计文件行数时，按照老方法写，文件大的时候可能会停止工作：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print len(<span class=\"name\">open</span>(<span class=\"string\">\"seq.txt\"</span>).readlines())</span><br></pre></td></tr></table></figure></p>\n<p>有了枚举，可以这样写：<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">count</span> = -<span class=\"number\">1</span> </span><br><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"built_in\">index</span>, <span class=\"built_in\">line</span> in enumerate(<span class=\"keyword\">open</span>(filepath,<span class=\"string\">'r'</span>))： </span><br><span class=\"line\">    <span class=\"built_in\">count</span> += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"reversed\"><a href=\"#reversed\" class=\"headerlink\" title=\"reversed()\"></a>reversed()</h3><figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">reverse</span> <span class=\"keyword\">iterator</span> over values <span class=\"keyword\">of</span> the <span class=\"keyword\">sequence</span></span><br></pre></td></tr></table></figure>\n<p>反转函数,无论传递什么参数，都将返回一个以列表为容器的返回值，如果是字典将返回键的列表。</p>\n<p>注意区别revers(),是可变对象(字典、列表)的方法，无参数，无返回值，sort()会改变可变对象，因此无需返回值。sort()方法是可变对象独有的方法或者属性，而作为不可变对象如元组、字符串是不具有这些方法的，如果调用将会返回一个异常。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mylist=[<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">mylist.reverse()</span><br><span class=\"line\">print mylist</span><br></pre></td></tr></table></figure></p>\n<p>##[::-1]<br>通过序列的切片也可以达到“逆转”的效果。这也是一种<code>slice</code>的特殊写法。</p>\n<h2 id=\"返回函数\"><a href=\"#返回函数\" class=\"headerlink\" title=\"返回函数\"></a>返回函数</h2><p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>\n<p>我们来实现一个可变参数的求和。通常情况下，求和的函数是这样定义的：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc_sum</span><span class=\"params\">(*args)</span></span><span class=\"symbol\">:</span><span class=\"comment\">#有序列表</span></span><br><span class=\"line\">    ax = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> <span class=\"symbol\">args:</span></span><br><span class=\"line\">        ax = ax + n</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ax</span><br></pre></td></tr></table></figure></p>\n<p>如果不需要立刻求和，而是在后面的代码中，根据需要再计算怎么办？可以不返回求和的结果，而是返回求和的函数！<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">lazy_sum</span><span class=\"params\">(*args)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">sum</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        ax = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> <span class=\"symbol\">args:</span></span><br><span class=\"line\">            ax = ax + n</span><br><span class=\"line\">        <span class=\"keyword\">return</span> ax</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sum</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = lazy_sum(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">&gt;&gt;&gt; f</span><br><span class=\"line\">&lt;function sum at <span class=\"number\">0x10452f668</span>&gt;</span><br><span class=\"line\">&gt;&gt;&gt; f()</span><br><span class=\"line\"><span class=\"number\">25</span></span><br></pre></td></tr></table></figure>\n<p>只有真的调用这个函数，才会真正计算出结果。</p>\n<p>当lazy_sum返回函数sum时，相关参数和变量都保存在返回的函数中，这种称为“闭包（Closure）”的程序结构拥有极大的威力。<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1=lazy_sum(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>)</span><br><span class=\"line\">f2=lazy_sum(<span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>)</span><br></pre></td></tr></table></figure></p>\n<p>当我们调用lazy_sum()时，每次调用都会返回一个新的函数，即使传入相同的参数，f1()和f2()的调用结果互不影响。</p>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>要注意的是，返回的函数并没有立刻执行，而是直到调用了f()才执行。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    fs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>)<span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">             <span class=\"keyword\">return</span> i*i</span><br><span class=\"line\">        fs.append(f)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs</span><br><span class=\"line\"></span><br><span class=\"line\">f1, f2, f3 = count()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f1()</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f2()</span><br><span class=\"line\"><span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f3()</span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure></p>\n<p>原因就在于返回的函数引用了变量i，但它并非立刻执行。等到3个函数都返回时，它们所引用的变量i已经变成了3，因此最终结果为9。</p>\n<p>返回闭包时牢记的一点就是：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>\n<p>如果一定要引用循环变量怎么办？方法是再创建一个函数，用该函数的参数绑定循环变量当前的值，无论该循环变量后续如何更改，已绑定到函数参数的值不变。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">count</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">     fs = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, <span class=\"number\">4</span>)<span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">(j)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">g</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> j*j</span><br><span class=\"line\">            <span class=\"keyword\">return</span> g</span><br><span class=\"line\">        fs.append(f(i))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fs</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f1, f2, f3 = count()</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f1()</span><br><span class=\"line\"><span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f2()</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; f3()</span><br><span class=\"line\"><span class=\"number\">9</span></span><br></pre></td></tr></table></figure></p>\n<p>最重要的是要理解f1, f2, f3 = count()这句话。</p>\n<p>count()的返回值是一个list，list里面存的是执行for i in range(1, 4)后返回的3个fs函数<br>f1, f2, f3 = count()将这3个fs函数依次赋值给f1, f2, f3；同时赋值的还有变量j。因为j=i让j和当前的i绑定起来了，所以f1, f2, f3得到的j值分别是1,2,3</p>\n<p>最后在计算f1()的时候，用的是之前传过来的j=1，而不是变化后的i=3，所以f1()=1。 f2(),f3(),依次类推。</p>\n<h2 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h2><figure class=\"highlight less\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"selector-tag\">map</span>(lambda <span class=\"attribute\">x</span>: x * x, [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">8</span>, <span class=\"number\">9</span>])</span><br><span class=\"line\"><span class=\"selector-attr\">[1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>\n<p>关键字lambda表示匿名函数，冒号前面的x表示函数参数。</p>\n<p>匿名函数有个限制，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。</p>\n<p>用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数。</p>\n<p>同样，也可以把匿名函数作为返回值返回,<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">build</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">lambda</span> a,b: x * a + y * b</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> build(<span class=\"number\">1</span>,<span class=\"number\">2</span>)(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br></pre></td></tr></table></figure></p>\n<p>Python对匿名函数的支持有限，只有一些简单的情况下可以使用匿名函数。</p>\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h2><p>假设我们要增强函数的功能，比如，在函数调用前后自动打印日志，但又不希望修改函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p>\n<p>装饰器实则是一个返回函数的高阶函数。假如，我们要定义一个能打印日志的decorator，可以定义如下：<br><figure class=\"highlight autoit\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def <span class=\"built_in\">log</span>(<span class=\"function\"><span class=\"keyword\">func</span>):</span></span><br><span class=\"line\">    def wrapper(*args, **kw):</span><br><span class=\"line\">        print <span class=\"string\">'call %s():'</span> % <span class=\"function\"><span class=\"keyword\">func</span>.<span class=\"title\">__name__</span></span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(*args, **kw)</span></span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br></pre></td></tr></table></figure></p>\n<p>观察上面的log，因为它是一个decorator，所以接受一个函数作为参数，并返回一个函数。我们要借助Python的@语法，把decorator置于函数的定义处：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@log</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'2013-12-25'</span></span><br></pre></td></tr></table></figure></p>\n<p>把@log放到now()函数的定义处，相当于执行了语句：<br><figure class=\"highlight excel\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">now</span> = <span class=\"built_in\">log</span>(<span class=\"built_in\">now</span>)</span><br></pre></td></tr></table></figure></p>\n<p>wrapper()函数的参数定义是(*args, **kw)，因此，wrapper()函数可以接受任意参数的调用。在wrapper()函数内，首先打印日志，再紧接着调用原始函数。</p>\n<p>如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(text)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args, **kw)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">            print <span class=\"string\">'%s %s():'</span> % (text, func.__name_<span class=\"number\">_</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> func(*args, **kw)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"></span><br><span class=\"line\">@log(<span class=\"string\">'execute'</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">now</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    print <span class=\"string\">'2016-09-25'</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; now()</span><br><span class=\"line\">execute now()<span class=\"symbol\">:</span></span><br><span class=\"line\"><span class=\"number\">2016</span>-09-<span class=\"number\">25</span></span><br></pre></td></tr></table></figure></p>\n<p>3层嵌套的效果是这样的:<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">now = log('execute')(<span class=\"name\">now</span>)</span><br></pre></td></tr></table></figure></p>\n<p>我们来剖析上面的语句，首先执行log(‘execute’)，返回的是decorator函数，再调用返回的函数，参数是now函数，返回值最终是wrapper函数。</p>\n<p>以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有<strong>name</strong>等属性，但你去看经过decorator装饰之后的函数，它们的<strong>name</strong>已经从原来的’now’变成了’wrapper’。</p>\n<p>因为返回的那个wrapper()函数名字就是’wrapper’，所以，需要把原始函数的<strong>name</strong>等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。</p>\n<p>因此，可以通过Python内置的functools.wraps来它保留原有函数的名称和docstring。</p>\n<h3 id=\"练习-2\"><a href=\"#练习-2\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>1.请编写一个decorator，能在函数调用的前后打印出’begin call’和’end call’的日志。</p>\n<p>解答如下：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @functools.wraps(func)</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args,**kwargs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"begin call %s\"</span> % func.__name__</span><br><span class=\"line\">        m=func(*args,**kwargs)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"end call %s\"</span> % func.__name__</span><br><span class=\"line\">        <span class=\"keyword\">return</span> m</span><br><span class=\"line\">    <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@decorator</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">new</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"2016-09-25\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">new()</span><br></pre></td></tr></table></figure></p>\n<p>2.再思考一下能否写出一个@log的decorator，使它既支持：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@log</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>又支持：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@log(<span class=\"string\">'execute'</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    pass</span><br></pre></td></tr></table></figure></p>\n<p>解：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> functools</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">log</span><span class=\"params\">(txt=<span class=\"string\">\"hello\"</span>)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">decorator</span><span class=\"params\">(func)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">        @functools.wraps(func)</span></span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">wrapper</span><span class=\"params\">(*args,**kwargs)</span>:</span></span><br><span class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"%s begin call %s\"</span> % (txt,func.__name__)</span><br><span class=\"line\">            m=func(*args,**kwargs)</span><br><span class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"%s end call %s\"</span> % (txt,func.__name__)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> m</span><br><span class=\"line\">        <span class=\"keyword\">return</span> wrapper</span><br><span class=\"line\">    <span class=\"keyword\">return</span> decorator</span><br><span class=\"line\"><span class=\"meta\">@log('execute')</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">   <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@log()</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">f</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\">f()</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"偏函数\"><a href=\"#偏函数\" class=\"headerlink\" title=\"偏函数\"></a>偏函数</h2><p>上面提到了<code>·functools</code>模块，它有很多功能，其中之一就是偏函数。要注意，这里的偏函数和数学意义上的偏函数不一样。</p>\n<p><code>functools.partial</code>就是帮助我们创建一个偏函数的，不需要我们自己定义<code>int2()</code>，可以直接使用下面的代码创建一个新的函数<code>int2</code>：<br><figure class=\"highlight cs\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import functools</span><br><span class=\"line\">int2 = functools.<span class=\"keyword\">partial</span>(<span class=\"keyword\">int</span>, <span class=\"keyword\">base</span>=<span class=\"number\">2</span>)</span><br></pre></td></tr></table></figure></p>\n<p>当函数的参数个数太多，需要简化时，使用<code>functools.partial</code>可以创建一个新的函数，这个新函数可以固定住原函数的部分参数，从而在调用时更简单。</p>\n<p>调用方法就是：<code>functools.partial(函数名，要固定的参数名并赋值)</code></p>\n<p>所以先要通过<code>help()</code>函数来找到参数名，再进行固定。</p>\n<p>然而，这个函数仅仅是把默认值进行了修改，人为调用的时候，还是可以赋值。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>和官方文档的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"初探python(8)错误、调试与测试","date":"2016-10-12T13:26:30.000Z","_content":"\n\n\n程序运行过程中会遇到各种错误。\n\n有的是由于程序编写出现问题的，这种错误通常称之为bug，这是必须修复的。\n\n有的是由于用户输入错误造成的，这种错误可以检查用户输入来做相应处理。\n\n还有一类错误是完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为异常，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。\n<!-- more -->\nPython内置了一套异常处理机制，来帮助我们进行错误处理。\n\n此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的pdb可以让我们以单步方式执行代码。\n\n最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。\n\n\n## 错误处理\n\n在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。\n\n高级语言通常都内置了一套`try...except...finally...`的错误处理机制，Python也不例外。\n\n### try\n\n当我们认为某些代码可能会出错时，就可以用`try`来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即`except`语句块，执行完`except`后，如果有`finally`语句块，则执行`finally`语句块，至此，执行完毕。\n```\ntry:\n    print \"try...\"\n    r = 10/0\n    print 'result:',r\nexcept ZeroDivisionError,e:\n    print 'except:',e\nfinally:\n    print 'finally...'\n```\n如果没有出现错误，`except`不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。\n\n当然，错误可以有多个种类，可以添加多个`except`，此外，如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句。\n\n其实，Python的错误也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。\n\n[常见错误类型以及继承关系](https://docs.python.org/2/library/exceptions.html#exception-hierarchy)\n\n使用`try...except`捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用foo()，foo()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理。\n\n这样，也就减少了工作量，不需要在每个地方都去捕获错误，在适当的层次捕获即可。\n\n###　调用堆栈\n\n如果一个错误没有被捕获，它会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。\n```\ndef foo(s):\n    return 10 / int(s)\n\ndef bar(s):\n    return foo(s) * 2\n\ndef main():\n    bar('0')\n\nmain()\n\n#Traceback (most recent call last):\n#  File \"err.py\", line 11, in <module>\n#    main()\n#  File \"err.py\", line 9, in main\n#    bar('0')\n#  File \"err.py\", line 6, in bar\n#    return foo(s) * 2\n#  File \"err.py\", line 3, in foo\n#    return 10 / int(s)\n#ZeroDivisionError: integer division or modulo by zero\n```\n\n根据错误的跟踪信息，找到对应的错误所在位置。\n\n### 记录错误\n\n如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。\n\nPython内置的`logging`模块可以非常容易地记录错误信息:\n```\nimport logging\n\ndef foo(s):\n    return 10 / int(s)\n\ndef bar(s):\n    return foo(s) * 2\n\ndef main():\n    try:\n        bar('0')\n    except StandardError, e:\n        logging.exception(e)\n\nmain()\nprint 'END'\n```\n通过配置，`logging`还可以把错误记录到日志文件里，方便事后排查。\n\n### 抛出错误\n\n因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。我们可以通过`raise`来抛出错误的实例。\n\n有些时候，尽管捕获到了错误，可捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。\n\n`raise`如果不带参数，就将错误原样直接抛出；也可以在后面加一个`Error`，来将错误类型进行转化。当然，前提是要符合逻辑。\n\n## 调试\n程序很难一次性写对，因此，我们需要进行调试。\n调试有四种方式：\n1.print\n2.assert\n3.logging\n4.单步调试\n\n第一种简单粗暴，直接打印出来看看到底是什么。\n\n第二种可以替代`print`， 例如：`assert n != 0, 'n is zero!'`\n`assert`的意思是，表达式`n != 0`应该是`True`，否则，后面的代码就会出错。\n\n如果断言失败，`assert`语句本身就会抛出`AssertionError：n is zero!`\n\n不过，启动Python解释器时可以用-O参数来关闭assert。关闭后，你可以把所有的assert语句当成pass来看。\n\n```\n python -O err.py\n```\n\n第三种就是logging，允许输出一行文本。\n```\n__author__ = 'zjbao123'\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\ns = '3'\nn = int(s)\nlogging.info('n = %d' % n)\nprint 10 / n\n```\n这就是`logging`的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，指定高级别的时候，低级别就不起作用当我们指定`level=INFO`时，`logging.debug`就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。\n\n另外，就是单步调试了，利用IDE来设置断点进行单步调试。\n\n## 单元测试\n\n单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。\n\n当你修改模块内容的时候，单元测试仍然可用。\n\n单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。\n\n单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。\n\n这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。\n```\nclass test_abs(unittest.TestCase):\n    def test_value(self):\n        d = abs(-1)\n        self.assertEqual(d,1)\n\n    def test_abserror(self):\n        with self.assertRaises(TypeError):\n           abs('sd')\n    def setUp(self):\n        print 'setUp...'\n\n    def tearDown(self):\n        print 'tearDown...'\n\nif __name__ == '__main__':\n    unittest.main()\n```\n###　单元测试的写法\n\n编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。\n\n以`test`开头的方法就是测试方法，不以`test`开头的方法不被认为是测试方法，测试的时候不会被执行。\n\n对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEquals().\n\n另一种重要的断言就是期待抛出指定类型的Error,如上例子所述。\n\n### 运行单元测试\n\n最简单的运行方式是在mydict_test.py的最后加上两行代码：\n```\nif __name__ == '__main__':\n    unittest.main()\n```\n\n另一种更常见的方法是在命令行通过参数-m unittest直接运行单元测试\n\n```\npython -m unittest mydict_test\n```\n\n这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。\n\n\n###　setUp与tearDown\n\n这两个方法会分别在每调用一个测试方法的前后分别被执行。`setUp()`和`tearDown()`方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在`setUp()`方法中连接数据库，在`tearDown()`方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码。\n\n\n## 文档测试\n\n在官方文档中，有很多文档都有实例代码。这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？\n\n答案是肯定的。\n\n当我们编写注释时，如果写上这样的注释：\n```\ndef abs(n):\n    '''\n    Function to get absolute value of number.\n\n    Example:\n\n    >>> abs(-1)\n    1\n    >>> abs(0)\n    0\n    >>> abs('sd')\n    Traceback (most recent call last):\n        ...\n    TypeError: bad operand type\n    '''\n    if isinstance(n,int):\n        return n if n >= 0 else (-n)\n    else:\n        raise TypeError('bad operand type')\nif __name__=='__main__':\n    import doctest\n    doctest.testmod()\n```\n\n运行时，什么输出也没有。这说明我们编写的doctest运行都是正确的。如果程序有问题，再运行就会报错。\n\ndoctest非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest的注释提取出来。用户看文档的时候，同时也看到了doctest。\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","source":"_posts/python/初探python(8)错误、调试与测试.md","raw":"---\ntitle: 初探python(8)错误、调试与测试\ndate: 2016-10-12 21:26:30\ntags: \n- python\n- python教程\ncategories: 总结\n---\n\n\n\n程序运行过程中会遇到各种错误。\n\n有的是由于程序编写出现问题的，这种错误通常称之为bug，这是必须修复的。\n\n有的是由于用户输入错误造成的，这种错误可以检查用户输入来做相应处理。\n\n还有一类错误是完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为异常，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。\n<!-- more -->\nPython内置了一套异常处理机制，来帮助我们进行错误处理。\n\n此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的pdb可以让我们以单步方式执行代码。\n\n最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。\n\n\n## 错误处理\n\n在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。\n\n高级语言通常都内置了一套`try...except...finally...`的错误处理机制，Python也不例外。\n\n### try\n\n当我们认为某些代码可能会出错时，就可以用`try`来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即`except`语句块，执行完`except`后，如果有`finally`语句块，则执行`finally`语句块，至此，执行完毕。\n```\ntry:\n    print \"try...\"\n    r = 10/0\n    print 'result:',r\nexcept ZeroDivisionError,e:\n    print 'except:',e\nfinally:\n    print 'finally...'\n```\n如果没有出现错误，`except`不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。\n\n当然，错误可以有多个种类，可以添加多个`except`，此外，如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句。\n\n其实，Python的错误也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。\n\n[常见错误类型以及继承关系](https://docs.python.org/2/library/exceptions.html#exception-hierarchy)\n\n使用`try...except`捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用foo()，foo()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理。\n\n这样，也就减少了工作量，不需要在每个地方都去捕获错误，在适当的层次捕获即可。\n\n###　调用堆栈\n\n如果一个错误没有被捕获，它会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。\n```\ndef foo(s):\n    return 10 / int(s)\n\ndef bar(s):\n    return foo(s) * 2\n\ndef main():\n    bar('0')\n\nmain()\n\n#Traceback (most recent call last):\n#  File \"err.py\", line 11, in <module>\n#    main()\n#  File \"err.py\", line 9, in main\n#    bar('0')\n#  File \"err.py\", line 6, in bar\n#    return foo(s) * 2\n#  File \"err.py\", line 3, in foo\n#    return 10 / int(s)\n#ZeroDivisionError: integer division or modulo by zero\n```\n\n根据错误的跟踪信息，找到对应的错误所在位置。\n\n### 记录错误\n\n如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。\n\nPython内置的`logging`模块可以非常容易地记录错误信息:\n```\nimport logging\n\ndef foo(s):\n    return 10 / int(s)\n\ndef bar(s):\n    return foo(s) * 2\n\ndef main():\n    try:\n        bar('0')\n    except StandardError, e:\n        logging.exception(e)\n\nmain()\nprint 'END'\n```\n通过配置，`logging`还可以把错误记录到日志文件里，方便事后排查。\n\n### 抛出错误\n\n因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。我们可以通过`raise`来抛出错误的实例。\n\n有些时候，尽管捕获到了错误，可捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。\n\n`raise`如果不带参数，就将错误原样直接抛出；也可以在后面加一个`Error`，来将错误类型进行转化。当然，前提是要符合逻辑。\n\n## 调试\n程序很难一次性写对，因此，我们需要进行调试。\n调试有四种方式：\n1.print\n2.assert\n3.logging\n4.单步调试\n\n第一种简单粗暴，直接打印出来看看到底是什么。\n\n第二种可以替代`print`， 例如：`assert n != 0, 'n is zero!'`\n`assert`的意思是，表达式`n != 0`应该是`True`，否则，后面的代码就会出错。\n\n如果断言失败，`assert`语句本身就会抛出`AssertionError：n is zero!`\n\n不过，启动Python解释器时可以用-O参数来关闭assert。关闭后，你可以把所有的assert语句当成pass来看。\n\n```\n python -O err.py\n```\n\n第三种就是logging，允许输出一行文本。\n```\n__author__ = 'zjbao123'\nimport logging\nlogging.basicConfig(level=logging.INFO)\n\ns = '3'\nn = int(s)\nlogging.info('n = %d' % n)\nprint 10 / n\n```\n这就是`logging`的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，指定高级别的时候，低级别就不起作用当我们指定`level=INFO`时，`logging.debug`就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。\n\n另外，就是单步调试了，利用IDE来设置断点进行单步调试。\n\n## 单元测试\n\n单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。\n\n当你修改模块内容的时候，单元测试仍然可用。\n\n单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。\n\n单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。\n\n这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。\n```\nclass test_abs(unittest.TestCase):\n    def test_value(self):\n        d = abs(-1)\n        self.assertEqual(d,1)\n\n    def test_abserror(self):\n        with self.assertRaises(TypeError):\n           abs('sd')\n    def setUp(self):\n        print 'setUp...'\n\n    def tearDown(self):\n        print 'tearDown...'\n\nif __name__ == '__main__':\n    unittest.main()\n```\n###　单元测试的写法\n\n编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。\n\n以`test`开头的方法就是测试方法，不以`test`开头的方法不被认为是测试方法，测试的时候不会被执行。\n\n对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEquals().\n\n另一种重要的断言就是期待抛出指定类型的Error,如上例子所述。\n\n### 运行单元测试\n\n最简单的运行方式是在mydict_test.py的最后加上两行代码：\n```\nif __name__ == '__main__':\n    unittest.main()\n```\n\n另一种更常见的方法是在命令行通过参数-m unittest直接运行单元测试\n\n```\npython -m unittest mydict_test\n```\n\n这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。\n\n\n###　setUp与tearDown\n\n这两个方法会分别在每调用一个测试方法的前后分别被执行。`setUp()`和`tearDown()`方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在`setUp()`方法中连接数据库，在`tearDown()`方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码。\n\n\n## 文档测试\n\n在官方文档中，有很多文档都有实例代码。这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？\n\n答案是肯定的。\n\n当我们编写注释时，如果写上这样的注释：\n```\ndef abs(n):\n    '''\n    Function to get absolute value of number.\n\n    Example:\n\n    >>> abs(-1)\n    1\n    >>> abs(0)\n    0\n    >>> abs('sd')\n    Traceback (most recent call last):\n        ...\n    TypeError: bad operand type\n    '''\n    if isinstance(n,int):\n        return n if n >= 0 else (-n)\n    else:\n        raise TypeError('bad operand type')\nif __name__=='__main__':\n    import doctest\n    doctest.testmod()\n```\n\n运行时，什么输出也没有。这说明我们编写的doctest运行都是正确的。如果程序有问题，再运行就会报错。\n\ndoctest非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest的注释提取出来。用户看文档的时候，同时也看到了doctest。\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","slug":"python/初探python(8)错误、调试与测试","published":1,"updated":"2019-03-22T14:44:36.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0o009u4l3nz7wh0ket","content":"<p>程序运行过程中会遇到各种错误。</p>\n<p>有的是由于程序编写出现问题的，这种错误通常称之为bug，这是必须修复的。</p>\n<p>有的是由于用户输入错误造成的，这种错误可以检查用户输入来做相应处理。</p>\n<p>还有一类错误是完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为异常，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。<br><a id=\"more\"></a><br>Python内置了一套异常处理机制，来帮助我们进行错误处理。</p>\n<p>此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的pdb可以让我们以单步方式执行代码。</p>\n<p>最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。</p>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。</p>\n<p>高级语言通常都内置了一套<code>try...except...finally...</code>的错误处理机制，Python也不例外。</p>\n<h3 id=\"try\"><a href=\"#try\" class=\"headerlink\" title=\"try\"></a>try</h3><p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"try...\"</span></span><br><span class=\"line\">    r = <span class=\"number\">10</span>/<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'result:'</span>,r</span><br><span class=\"line\"><span class=\"keyword\">except</span> ZeroDivisionError,e:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'except:'</span>,e</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'finally...'</span></span><br></pre></td></tr></table></figure></p>\n<p>如果没有出现错误，<code>except</code>不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。</p>\n<p>当然，错误可以有多个种类，可以添加多个<code>except</code>，此外，如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句。</p>\n<p>其实，Python的错误也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。</p>\n<p><a href=\"https://docs.python.org/2/library/exceptions.html#exception-hierarchy\" target=\"_blank\" rel=\"noopener\">常见错误类型以及继承关系</a></p>\n<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用foo()，foo()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理。</p>\n<p>这样，也就减少了工作量，不需要在每个地方都去捕获错误，在适当的层次捕获即可。</p>\n<p>###　调用堆栈</p>\n<p>如果一个错误没有被捕获，它会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。<br><figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def foo(s):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">10</span> / <span class=\"keyword\">int</span>(s)</span><br><span class=\"line\"></span><br><span class=\"line\">def bar(s):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo(s) * <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">def main():</span><br><span class=\"line\">    bar(<span class=\"string\">'0'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">main()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"meta\">#  File \"err.py\", line 11, in &lt;module&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#    main()</span></span><br><span class=\"line\"><span class=\"meta\">#  File \"err.py\", line 9, in main</span></span><br><span class=\"line\"><span class=\"meta\">#    bar('0')</span></span><br><span class=\"line\"><span class=\"meta\">#  File \"err.py\", line 6, in bar</span></span><br><span class=\"line\"><span class=\"meta\">#    return foo(s) * 2</span></span><br><span class=\"line\"><span class=\"meta\">#  File \"err.py\", line 3, in foo</span></span><br><span class=\"line\"><span class=\"meta\">#    return 10 / int(s)</span></span><br><span class=\"line\"><span class=\"meta\">#ZeroDivisionError: integer division or modulo by zero</span></span><br></pre></td></tr></table></figure></p>\n<p>根据错误的跟踪信息，找到对应的错误所在位置。</p>\n<h3 id=\"记录错误\"><a href=\"#记录错误\" class=\"headerlink\" title=\"记录错误\"></a>记录错误</h3><p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p>\n<p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">10</span> / int(s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bar</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo(s) * <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        bar(<span class=\"string\">'0'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> StandardError, e:</span><br><span class=\"line\">        logging.exception(e)</span><br><span class=\"line\"></span><br><span class=\"line\">main()</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'END'</span></span><br></pre></td></tr></table></figure></p>\n<p>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</p>\n<h3 id=\"抛出错误\"><a href=\"#抛出错误\" class=\"headerlink\" title=\"抛出错误\"></a>抛出错误</h3><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。我们可以通过<code>raise</code>来抛出错误的实例。</p>\n<p>有些时候，尽管捕获到了错误，可捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p>\n<p><code>raise</code>如果不带参数，就将错误原样直接抛出；也可以在后面加一个<code>Error</code>，来将错误类型进行转化。当然，前提是要符合逻辑。</p>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>程序很难一次性写对，因此，我们需要进行调试。<br>调试有四种方式：<br>1.print<br>2.assert<br>3.logging<br>4.单步调试</p>\n<p>第一种简单粗暴，直接打印出来看看到底是什么。</p>\n<p>第二种可以替代<code>print</code>， 例如：<code>assert n != 0, &#39;n is zero!&#39;</code><br><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，后面的代码就会出错。</p>\n<p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError：n is zero!</code></p>\n<p>不过，启动Python解释器时可以用-O参数来关闭assert。关闭后，你可以把所有的assert语句当成pass来看。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">python</span> -O err.<span class=\"keyword\">py</span></span><br></pre></td></tr></table></figure>\n<p>第三种就是logging，允许输出一行文本。<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\">logging.basicConfig(level=logging.INFO)</span><br><span class=\"line\"></span><br><span class=\"line\">s = <span class=\"string\">'3'</span></span><br><span class=\"line\">n = <span class=\"keyword\">int</span>(s)</span><br><span class=\"line\">logging.info(<span class=\"string\">'n = %d'</span> % n)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"number\">10</span> / n</span><br></pre></td></tr></table></figure></p>\n<p>这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，指定高级别的时候，低级别就不起作用当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>\n<p>另外，就是单步调试了，利用IDE来设置断点进行单步调试。</p>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>\n<p>当你修改模块内容的时候，单元测试仍然可用。</p>\n<p>单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p>\n<p>单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。</p>\n<p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test_abs</span>(<span class=\"title\">unittest</span>.<span class=\"title\">TestCase</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_value</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        d = abs(-<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.assertEqual(d,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_abserror</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        with <span class=\"keyword\">self</span>.assertRaises(TypeError)<span class=\"symbol\">:</span></span><br><span class=\"line\">           abs(<span class=\"string\">'sd'</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setUp</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        print <span class=\"string\">'setUp...'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tearDown</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        print <span class=\"string\">'tearDown...'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name_<span class=\"number\">_</span> == <span class=\"string\">'__main__'</span><span class=\"symbol\">:</span></span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure></p>\n<p>###　单元测试的写法</p>\n<p>编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。</p>\n<p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p>\n<p>对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEquals().</p>\n<p>另一种重要的断言就是期待抛出指定类型的Error,如上例子所述。</p>\n<h3 id=\"运行单元测试\"><a href=\"#运行单元测试\" class=\"headerlink\" title=\"运行单元测试\"></a>运行单元测试</h3><p>最简单的运行方式是在mydict_test.py的最后加上两行代码：<br><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"variable\">__name__</span> == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure></p>\n<p>另一种更常见的方法是在命令行通过参数-m unittest直接运行单元测试</p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m <span class=\"keyword\">unittest</span> mydict_test</span><br></pre></td></tr></table></figure>\n<p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p>\n<p>###　setUp与tearDown</p>\n<p>这两个方法会分别在每调用一个测试方法的前后分别被执行。<code>setUp()</code>和<code>tearDown()</code>方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在<code>setUp()</code>方法中连接数据库，在<code>tearDown()</code>方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码。</p>\n<h2 id=\"文档测试\"><a href=\"#文档测试\" class=\"headerlink\" title=\"文档测试\"></a>文档测试</h2><p>在官方文档中，有很多文档都有实例代码。这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？</p>\n<p>答案是肯定的。</p>\n<p>当我们编写注释时，如果写上这样的注释：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">abs</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">    Function to get absolute value of number.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Example:</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; abs(-1)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; abs(0)</span></span><br><span class=\"line\"><span class=\"string\">    0</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; abs('sd')</span></span><br><span class=\"line\"><span class=\"string\">    Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"string\">        ...</span></span><br><span class=\"line\"><span class=\"string\">    TypeError: bad operand type</span></span><br><span class=\"line\"><span class=\"string\">    '''</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> isinstance(n,int):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n <span class=\"keyword\">if</span> n &gt;= <span class=\"number\">0</span> <span class=\"keyword\">else</span> (-n)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">'bad operand type'</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> doctest</span><br><span class=\"line\">    doctest.testmod()</span><br></pre></td></tr></table></figure></p>\n<p>运行时，什么输出也没有。这说明我们编写的doctest运行都是正确的。如果程序有问题，再运行就会报错。</p>\n<p>doctest非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest的注释提取出来。用户看文档的时候，同时也看到了doctest。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>程序运行过程中会遇到各种错误。</p>\n<p>有的是由于程序编写出现问题的，这种错误通常称之为bug，这是必须修复的。</p>\n<p>有的是由于用户输入错误造成的，这种错误可以检查用户输入来做相应处理。</p>\n<p>还有一类错误是完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了，或者从网络抓取数据，网络突然断掉了。这类错误也称为异常，在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。<br></p>","more":"<br>Python内置了一套异常处理机制，来帮助我们进行错误处理。<p></p>\n<p>此外，我们也需要跟踪程序的执行，查看变量的值是否正确，这个过程称为调试。Python的pdb可以让我们以单步方式执行代码。</p>\n<p>最后，编写测试也很重要。有了良好的测试，就可以在程序修改后反复运行，确保程序输出符合我们编写的测试。</p>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>在程序运行的过程中，如果发生了错误，可以事先约定返回一个错误代码，这样，就可以知道是否有错，以及出错的原因。</p>\n<p>高级语言通常都内置了一套<code>try...except...finally...</code>的错误处理机制，Python也不例外。</p>\n<h3 id=\"try\"><a href=\"#try\" class=\"headerlink\" title=\"try\"></a>try</h3><p>当我们认为某些代码可能会出错时，就可以用<code>try</code>来运行这段代码，如果执行出错，则后续代码不会继续执行，而是直接跳转至错误处理代码，即<code>except</code>语句块，执行完<code>except</code>后，如果有<code>finally</code>语句块，则执行<code>finally</code>语句块，至此，执行完毕。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">\"try...\"</span></span><br><span class=\"line\">    r = <span class=\"number\">10</span>/<span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'result:'</span>,r</span><br><span class=\"line\"><span class=\"keyword\">except</span> ZeroDivisionError,e:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'except:'</span>,e</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'finally...'</span></span><br></pre></td></tr></table></figure></p>\n<p>如果没有出现错误，<code>except</code>不会被执行，但是finally如果有，则一定会被执行（可以没有finally语句）。</p>\n<p>当然，错误可以有多个种类，可以添加多个<code>except</code>，此外，如果没有错误发生，可以在except语句块后面加一个else，当没有错误发生时，会自动执行else语句。</p>\n<p>其实，Python的错误也是class，所有的错误类型都继承自BaseException，所以在使用except时需要注意的是，它不但捕获该类型的错误，还把其子类也“一网打尽”。</p>\n<p><a href=\"https://docs.python.org/2/library/exceptions.html#exception-hierarchy\" target=\"_blank\" rel=\"noopener\">常见错误类型以及继承关系</a></p>\n<p>使用<code>try...except</code>捕获错误还有一个巨大的好处，就是可以跨越多层调用，比如函数main()调用foo()，foo()调用bar()，结果bar()出错了，这时，只要main()捕获到了，就可以处理。</p>\n<p>这样，也就减少了工作量，不需要在每个地方都去捕获错误，在适当的层次捕获即可。</p>\n<p>###　调用堆栈</p>\n<p>如果一个错误没有被捕获，它会一直往上抛，最后被Python解释器捕获，打印一个错误信息，然后程序退出。<br><figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def foo(s):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">10</span> / <span class=\"keyword\">int</span>(s)</span><br><span class=\"line\"></span><br><span class=\"line\">def bar(s):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo(s) * <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">def main():</span><br><span class=\"line\">    bar(<span class=\"string\">'0'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">main()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"meta\">#  File \"err.py\", line 11, in &lt;module&gt;</span></span><br><span class=\"line\"><span class=\"meta\">#    main()</span></span><br><span class=\"line\"><span class=\"meta\">#  File \"err.py\", line 9, in main</span></span><br><span class=\"line\"><span class=\"meta\">#    bar('0')</span></span><br><span class=\"line\"><span class=\"meta\">#  File \"err.py\", line 6, in bar</span></span><br><span class=\"line\"><span class=\"meta\">#    return foo(s) * 2</span></span><br><span class=\"line\"><span class=\"meta\">#  File \"err.py\", line 3, in foo</span></span><br><span class=\"line\"><span class=\"meta\">#    return 10 / int(s)</span></span><br><span class=\"line\"><span class=\"meta\">#ZeroDivisionError: integer division or modulo by zero</span></span><br></pre></td></tr></table></figure></p>\n<p>根据错误的跟踪信息，找到对应的错误所在位置。</p>\n<h3 id=\"记录错误\"><a href=\"#记录错误\" class=\"headerlink\" title=\"记录错误\"></a>记录错误</h3><p>如果不捕获错误，自然可以让Python解释器来打印出错误堆栈，但程序也被结束了。既然我们能捕获错误，就可以把错误堆栈打印出来，然后分析错误原因，同时，让程序继续执行下去。</p>\n<p>Python内置的<code>logging</code>模块可以非常容易地记录错误信息:<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">10</span> / int(s)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bar</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> foo(s) * <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">main</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        bar(<span class=\"string\">'0'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> StandardError, e:</span><br><span class=\"line\">        logging.exception(e)</span><br><span class=\"line\"></span><br><span class=\"line\">main()</span><br><span class=\"line\"><span class=\"keyword\">print</span> <span class=\"string\">'END'</span></span><br></pre></td></tr></table></figure></p>\n<p>通过配置，<code>logging</code>还可以把错误记录到日志文件里，方便事后排查。</p>\n<h3 id=\"抛出错误\"><a href=\"#抛出错误\" class=\"headerlink\" title=\"抛出错误\"></a>抛出错误</h3><p>因为错误是class，捕获一个错误就是捕获到该class的一个实例。因此，错误并不是凭空产生的，而是有意创建并抛出的。Python的内置函数会抛出很多类型的错误，我们自己编写的函数也可以抛出错误。我们可以通过<code>raise</code>来抛出错误的实例。</p>\n<p>有些时候，尽管捕获到了错误，可捕获错误目的只是记录一下，便于后续追踪。但是，由于当前函数不知道应该怎么处理该错误，所以，最恰当的方式是继续往上抛，让顶层调用者去处理。</p>\n<p><code>raise</code>如果不带参数，就将错误原样直接抛出；也可以在后面加一个<code>Error</code>，来将错误类型进行转化。当然，前提是要符合逻辑。</p>\n<h2 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h2><p>程序很难一次性写对，因此，我们需要进行调试。<br>调试有四种方式：<br>1.print<br>2.assert<br>3.logging<br>4.单步调试</p>\n<p>第一种简单粗暴，直接打印出来看看到底是什么。</p>\n<p>第二种可以替代<code>print</code>， 例如：<code>assert n != 0, &#39;n is zero!&#39;</code><br><code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，后面的代码就会出错。</p>\n<p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError：n is zero!</code></p>\n<p>不过，启动Python解释器时可以用-O参数来关闭assert。关闭后，你可以把所有的assert语句当成pass来看。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">python</span> -O err.<span class=\"keyword\">py</span></span><br></pre></td></tr></table></figure>\n<p>第三种就是logging，允许输出一行文本。<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> logging</span><br><span class=\"line\">logging.basicConfig(level=logging.INFO)</span><br><span class=\"line\"></span><br><span class=\"line\">s = <span class=\"string\">'3'</span></span><br><span class=\"line\">n = <span class=\"keyword\">int</span>(s)</span><br><span class=\"line\">logging.info(<span class=\"string\">'n = %d'</span> % n)</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"number\">10</span> / n</span><br></pre></td></tr></table></figure></p>\n<p>这就是<code>logging</code>的好处，它允许你指定记录信息的级别，有debug，info，warning，error等几个级别，指定高级别的时候，低级别就不起作用当我们指定<code>level=INFO</code>时，<code>logging.debug</code>就不起作用了。这样一来，你可以放心地输出不同级别的信息，也不用删除，最后统一控制输出哪个级别的信息。</p>\n<p>另外，就是单步调试了，利用IDE来设置断点进行单步调试。</p>\n<h2 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h2><p>单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。</p>\n<p>当你修改模块内容的时候，单元测试仍然可用。</p>\n<p>单元测试可以有效地测试某个程序模块的行为，是未来重构代码的信心保证。</p>\n<p>单元测试的测试用例要覆盖常用的输入组合、边界条件和异常。</p>\n<p>这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">test_abs</span>(<span class=\"title\">unittest</span>.<span class=\"title\">TestCase</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_value</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        d = abs(-<span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.assertEqual(d,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">test_abserror</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        with <span class=\"keyword\">self</span>.assertRaises(TypeError)<span class=\"symbol\">:</span></span><br><span class=\"line\">           abs(<span class=\"string\">'sd'</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">setUp</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        print <span class=\"string\">'setUp...'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">tearDown</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        print <span class=\"string\">'tearDown...'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name_<span class=\"number\">_</span> == <span class=\"string\">'__main__'</span><span class=\"symbol\">:</span></span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure></p>\n<p>###　单元测试的写法</p>\n<p>编写单元测试时，我们需要编写一个测试类，从unittest.TestCase继承。</p>\n<p>以<code>test</code>开头的方法就是测试方法，不以<code>test</code>开头的方法不被认为是测试方法，测试的时候不会被执行。</p>\n<p>对每一类测试都需要编写一个test_xxx()方法。由于unittest.TestCase提供了很多内置的条件判断，我们只需要调用这些方法就可以断言输出是否是我们所期望的。最常用的断言就是assertEquals().</p>\n<p>另一种重要的断言就是期待抛出指定类型的Error,如上例子所述。</p>\n<h3 id=\"运行单元测试\"><a href=\"#运行单元测试\" class=\"headerlink\" title=\"运行单元测试\"></a>运行单元测试</h3><p>最简单的运行方式是在mydict_test.py的最后加上两行代码：<br><figure class=\"highlight sqf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> <span class=\"variable\">__name__</span> == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    unittest.main()</span><br></pre></td></tr></table></figure></p>\n<p>另一种更常见的方法是在命令行通过参数-m unittest直接运行单元测试</p>\n<figure class=\"highlight d\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python -m <span class=\"keyword\">unittest</span> mydict_test</span><br></pre></td></tr></table></figure>\n<p>这是推荐的做法，因为这样可以一次批量运行很多单元测试，并且，有很多工具可以自动来运行这些单元测试。</p>\n<p>###　setUp与tearDown</p>\n<p>这两个方法会分别在每调用一个测试方法的前后分别被执行。<code>setUp()</code>和<code>tearDown()</code>方法有什么用呢？设想你的测试需要启动一个数据库，这时，就可以在<code>setUp()</code>方法中连接数据库，在<code>tearDown()</code>方法中关闭数据库，这样，不必在每个测试方法中重复相同的代码。</p>\n<h2 id=\"文档测试\"><a href=\"#文档测试\" class=\"headerlink\" title=\"文档测试\"></a>文档测试</h2><p>在官方文档中，有很多文档都有实例代码。这些代码与其他说明可以写在注释中，然后，由一些工具来自动生成文档。既然这些代码本身就可以粘贴出来直接运行，那么，可不可以自动执行写在注释中的这些代码呢？</p>\n<p>答案是肯定的。</p>\n<p>当我们编写注释时，如果写上这样的注释：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">abs</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"string\">    Function to get absolute value of number.</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    Example:</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; abs(-1)</span></span><br><span class=\"line\"><span class=\"string\">    1</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; abs(0)</span></span><br><span class=\"line\"><span class=\"string\">    0</span></span><br><span class=\"line\"><span class=\"string\">    &gt;&gt;&gt; abs('sd')</span></span><br><span class=\"line\"><span class=\"string\">    Traceback (most recent call last):</span></span><br><span class=\"line\"><span class=\"string\">        ...</span></span><br><span class=\"line\"><span class=\"string\">    TypeError: bad operand type</span></span><br><span class=\"line\"><span class=\"string\">    '''</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> isinstance(n,int):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n <span class=\"keyword\">if</span> n &gt;= <span class=\"number\">0</span> <span class=\"keyword\">else</span> (-n)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> TypeError(<span class=\"string\">'bad operand type'</span>)</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> doctest</span><br><span class=\"line\">    doctest.testmod()</span><br></pre></td></tr></table></figure></p>\n<p>运行时，什么输出也没有。这说明我们编写的doctest运行都是正确的。如果程序有问题，再运行就会报错。</p>\n<p>doctest非常有用，不但可以用来测试，还可以直接作为示例代码。通过某些文档生成工具，就可以自动把包含doctest的注释提取出来。用户看文档的时候，同时也看到了doctest。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"初探python(9)IO编程","date":"2016-10-13T08:55:30.000Z","_content":"\n\nIO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。\n<!-- more -->\nIO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。\n\n由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。也就是说，输出快，输入慢。有两种解决办法：\n\n1.第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；\n\n2.是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。\n\n很明显，同步IO性能远远低于异步IO，但异步IO的缺点就是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。\n\n本章内容都是同步IO模式。\n\n## 文件读写\n现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。\n\n### 读文件\n要以读文件的模式打开一个文件对象，使用Python内置的`open()`函数，传入文件名和标示符，标示符'r'表示读，这样，我们就成功地打开了一个文件。\n读取二进制文件，比如图片，视频等，用'rb'模式打开即可。\n```\ntry:\n    f = open('/path/to/file', 'r')\n    print f.read()\nfinally:\n    if f:\n        f.close()\n```\n一旦文件读写失败会报一个`IOerror`，一旦出错，后面的f.close()就不会调用。所以我们要将其用`try ... finally`包括起来。\n\n但为了方便，Python引入了`with`语句来自动帮我们调用`close()`方法:\n```\nwith open('/path/to/file', 'r') as f:\n    print f.read()\n```\n`read()`可以一次性读取到文件的全部内容。如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用`read(size)`方法，每次最多读取size个字节的内容。另外，调用`readline()`可以每次读取一行内容，调用`readlines()`一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。\n\n如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：\n```\nfor line in f.readlines():\n    print(line.strip()) # 把末尾的'\\n'删掉\n```\n###　file-like Object\n像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。\n\n`StringIO`就是在内存中创建的file-like Object，常用作临时缓冲。\n\n\n读取二进制文件，比如图片，视频等，用'rb'模式打开即可。\n\n### 字符编码\n要读取非ASCII编码的文本文件，就必须以二进制模式打开，再解码。比如GBK编码的文件：\n```\nf = open('/Users/michael/gbk.txt', 'rb')\nu = f.read().decode('gbk')\nu\n#u'\\u6d4b\\u8bd5'\nprint u\n#测试\n```\n也可以直接导入`codecs`模块，帮我们自动转化编码。\n```\nimport codecs\nwith codecs.open('/Users/michael/gbk.txt', 'r', 'gbk') as f:\n    f.read() # u'\\u6d4b\\u8bd5'\n```\n### 写文件\n\n写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件。\n```\nimport codecs\nwith codecs.open('/Users/michael/gbk.txt', 'r', 'gbk') as f:\n    f.write('nihao')\n```\n\n## 操作文件和目录\n\n如果我们在python下要操作文件、目录，可以使用`os`模块。\n我们可以使用'os.name'来显示系统名字，如果是`posix`，说明系统是Linux、Unix或Mac OS X，如果是`nt`，就是Windows系统。\n\n如果要获取详细信息，可以调用`uname()`函数。但在Windows下不支持。\n\n###　环境变量\n环境变量全部保存在`os.eniron`中。\n要获取某个环境变量的值，可以调用`os.getenv()`函数。例如：`os.getenv('PATH')`\n\n###　操作文件和目录\n\n操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。\n\n```\n# 查看当前目录的绝对路径:\n>>> os.path.abspath('.')\n'/Users/michael'\n# 在某个目录下创建一个新目录，\n# 首先把新目录的完整路径表示出来:\n>>> os.path.join('/Users/michael', 'testdir')\n'/Users/michael/testdir'\n# 然后创建一个目录:\n>>> os.mkdir('/Users/michael/testdir')\n# 删掉一个目录:\n>>> os.rmdir('/Users/michael/testdir')\n# 对文件重命名:\n>>> os.rename('test.txt', 'test.py')\n# 删掉文件:\n>>> os.remove('test.py')\n\n```\n把两个路径合为一个，用os.path.join()会自动将两个路径相连，并符合系统要求。无需自己手写字符串相连。\n\n同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过`os.path.split()`函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名。\n\n`os.path.splitext()`可以直接让你得到文件扩展名，很多时候非常方便。\n\n这些合并和拆分不要求真实存在，只对字符串进行操作。\n\n但复制操作并不在`os`模块中。原因是复制文件并非由操作系统提供的系统调用。\n\n幸运的是`shutil`模块提供了`copyfile()`的函数，你还可以在`shutil`模块中找到很多实用函数，它们可以看做是os模块的补充。\n```\nimport os\nimport shutil\ns = os.path.abspath('.')\nt = os.path.join(s, 'wode.txt')\nprint t\ns = os.path.join(s,\"woqu.txt\")\nshutil.copyfile(t,s)\n```\n\n最后，还可以通过python的特性来过滤文件。\n```\n# 列出所有该目录下的文件夹（即目录）\n[x for x in os.listdir('.') if os.path.isdir(x)]\n# 列出所有该目录下的.py文件\n[x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']\n\n```\n\n### 练习\n题目：编写一个search(s)的函数，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出完整路径。\n```\n__author__ = 'zjbao123'\n'''编写一个search(s)的函数，\n能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，\n并打印出完整路径\n\nUsage:\n    > search.py str\n    str: the str what you want to search in filename in your dir\n'''\nimport os\nimport sys\ndef search(s):\n    for root,dirs,files in os.walk('.'):\n        for f in files:\n            if(f.find(s) != -1):\n                print os.path.join(root,f)[2:]\n\nif __name__ == '__main__':\n    search(sys.argv[1])\n```\n\n##　序列化\n在程序运行的过程中，所有的变量都是在内存中，一旦程序结束，变量所占用的内存就被操作系统全部回收。即便你有所改动，没有被存储到磁盘里的，下次运行又回到了初始值。\n\n我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫`pickling`，在其他语言中也被称之为`serialization`，`marshalling`，`flattening`等等，都是一个意思。\n\n序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。\n\n反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即`unpickling`。\n\nPython提供两个模块来实现序列化：`cPickle`和`pickle`。这两个模块功能是一样的，区别在于`cPickle`是C语言写的，速度快，pickle是纯Python写的，速度慢，跟`cStringIO`和`StringIO`一个道理。用的时候，先尝试导入`cPickle`，如果失败，再导入`pickle`：\n```\ntry:\n    import cPickle as pickle\nexcept ImportError:\n    import pickle\n\n#序列化\nd = dict(name='bob', sex='m', age='19')\nwith open('wode.txt','w') as f:\n    pickle.dump(d, f)\n\n#反序列化\nwith open('wode.txt', 'r') as f:\n    w = pickle.load(f)\n    print w\n```\n\nPickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。\n\n###　JSON\n\n如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。\n\nJSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：\n\n|JSON类型\t|Python类型\n|:-----------|:---------|\n|{}|\tdict|\n|[]|\tlist|\n|\"string\"|\t'str'或u'unicode'|\n|1234.56\t|int或float|\n|true/false\t|True/False|\n|null\t|None|\n\nPython内置的`json`模块提供了非常完善的Python对象到JSON格式的转换。\n```\nd = dict(name='bob', sex='m', age='19')\ns=json.dumps(d)\nw = json.loads(s)\nprint w\n```\n有一点需要注意，就是反序列化得到的所有字符串对象默认都是unicode而不是str。由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str或unicode与JSON的字符串之间转换。\n\npython 3 很好的解决了这个问题。\n\n### JSON进阶\n我们大多数时候喜欢用class表示对象，那来讲一讲如何序列化类：\n```\nimport json\n\nclass Student(object):\n    def __init__(self, name, age, score):\n        self.name = name\n        self.age = age\n        self.score = score\n\ns = Student('Bob', 20, 88)\nprint(json.dumps(s))\n```\n但是直接调用上述代码会发现，报错了。原因是说Student对象不是一个可序列化为JSON的对象。dumps()方法不知道如何将Student实例变为一个JSON的{}对象。\n\n可选参数default就是把任意一个对象变成一个可序列为JSON的对象，因此我们需要另外写一个函数将函数值传入。\n```\ndef student2dict(std):\n    return {\n        'name': std.name,\n        'age': std.age,\n        'score': std.score\n    }\n\nprint(json.dumps(s, default=student2dict))\n```\n但还有一个偷懒的写法：\n\n```\nprint(json.dumps(s, default=lambda obj: obj.__dict__))\n```\n因为通常class的实例都有一个`__dict__`属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了`__slots__`的class。\n\n因此，Python语言特定的序列化模块是pickle，但如果要把序列化搞得更通用、更符合Web标准，就可以使用json模块。\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","source":"_posts/python/初探python(9)IO编程.md","raw":"---\ntitle: 初探python(9)IO编程\ndate: 2016-10-13 16:55:30\ntags: \n- python\n- python教程\ncategories: 总结\n---\n\n\nIO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。\n<!-- more -->\nIO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。\n\n由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。也就是说，输出快，输入慢。有两种解决办法：\n\n1.第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；\n\n2.是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。\n\n很明显，同步IO性能远远低于异步IO，但异步IO的缺点就是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。\n\n本章内容都是同步IO模式。\n\n## 文件读写\n现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。\n\n### 读文件\n要以读文件的模式打开一个文件对象，使用Python内置的`open()`函数，传入文件名和标示符，标示符'r'表示读，这样，我们就成功地打开了一个文件。\n读取二进制文件，比如图片，视频等，用'rb'模式打开即可。\n```\ntry:\n    f = open('/path/to/file', 'r')\n    print f.read()\nfinally:\n    if f:\n        f.close()\n```\n一旦文件读写失败会报一个`IOerror`，一旦出错，后面的f.close()就不会调用。所以我们要将其用`try ... finally`包括起来。\n\n但为了方便，Python引入了`with`语句来自动帮我们调用`close()`方法:\n```\nwith open('/path/to/file', 'r') as f:\n    print f.read()\n```\n`read()`可以一次性读取到文件的全部内容。如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用`read(size)`方法，每次最多读取size个字节的内容。另外，调用`readline()`可以每次读取一行内容，调用`readlines()`一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。\n\n如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：\n```\nfor line in f.readlines():\n    print(line.strip()) # 把末尾的'\\n'删掉\n```\n###　file-like Object\n像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。\n\n`StringIO`就是在内存中创建的file-like Object，常用作临时缓冲。\n\n\n读取二进制文件，比如图片，视频等，用'rb'模式打开即可。\n\n### 字符编码\n要读取非ASCII编码的文本文件，就必须以二进制模式打开，再解码。比如GBK编码的文件：\n```\nf = open('/Users/michael/gbk.txt', 'rb')\nu = f.read().decode('gbk')\nu\n#u'\\u6d4b\\u8bd5'\nprint u\n#测试\n```\n也可以直接导入`codecs`模块，帮我们自动转化编码。\n```\nimport codecs\nwith codecs.open('/Users/michael/gbk.txt', 'r', 'gbk') as f:\n    f.read() # u'\\u6d4b\\u8bd5'\n```\n### 写文件\n\n写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符'w'或者'wb'表示写文本文件或写二进制文件。\n```\nimport codecs\nwith codecs.open('/Users/michael/gbk.txt', 'r', 'gbk') as f:\n    f.write('nihao')\n```\n\n## 操作文件和目录\n\n如果我们在python下要操作文件、目录，可以使用`os`模块。\n我们可以使用'os.name'来显示系统名字，如果是`posix`，说明系统是Linux、Unix或Mac OS X，如果是`nt`，就是Windows系统。\n\n如果要获取详细信息，可以调用`uname()`函数。但在Windows下不支持。\n\n###　环境变量\n环境变量全部保存在`os.eniron`中。\n要获取某个环境变量的值，可以调用`os.getenv()`函数。例如：`os.getenv('PATH')`\n\n###　操作文件和目录\n\n操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。\n\n```\n# 查看当前目录的绝对路径:\n>>> os.path.abspath('.')\n'/Users/michael'\n# 在某个目录下创建一个新目录，\n# 首先把新目录的完整路径表示出来:\n>>> os.path.join('/Users/michael', 'testdir')\n'/Users/michael/testdir'\n# 然后创建一个目录:\n>>> os.mkdir('/Users/michael/testdir')\n# 删掉一个目录:\n>>> os.rmdir('/Users/michael/testdir')\n# 对文件重命名:\n>>> os.rename('test.txt', 'test.py')\n# 删掉文件:\n>>> os.remove('test.py')\n\n```\n把两个路径合为一个，用os.path.join()会自动将两个路径相连，并符合系统要求。无需自己手写字符串相连。\n\n同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过`os.path.split()`函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名。\n\n`os.path.splitext()`可以直接让你得到文件扩展名，很多时候非常方便。\n\n这些合并和拆分不要求真实存在，只对字符串进行操作。\n\n但复制操作并不在`os`模块中。原因是复制文件并非由操作系统提供的系统调用。\n\n幸运的是`shutil`模块提供了`copyfile()`的函数，你还可以在`shutil`模块中找到很多实用函数，它们可以看做是os模块的补充。\n```\nimport os\nimport shutil\ns = os.path.abspath('.')\nt = os.path.join(s, 'wode.txt')\nprint t\ns = os.path.join(s,\"woqu.txt\")\nshutil.copyfile(t,s)\n```\n\n最后，还可以通过python的特性来过滤文件。\n```\n# 列出所有该目录下的文件夹（即目录）\n[x for x in os.listdir('.') if os.path.isdir(x)]\n# 列出所有该目录下的.py文件\n[x for x in os.listdir('.') if os.path.isfile(x) and os.path.splitext(x)[1]=='.py']\n\n```\n\n### 练习\n题目：编写一个search(s)的函数，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出完整路径。\n```\n__author__ = 'zjbao123'\n'''编写一个search(s)的函数，\n能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，\n并打印出完整路径\n\nUsage:\n    > search.py str\n    str: the str what you want to search in filename in your dir\n'''\nimport os\nimport sys\ndef search(s):\n    for root,dirs,files in os.walk('.'):\n        for f in files:\n            if(f.find(s) != -1):\n                print os.path.join(root,f)[2:]\n\nif __name__ == '__main__':\n    search(sys.argv[1])\n```\n\n##　序列化\n在程序运行的过程中，所有的变量都是在内存中，一旦程序结束，变量所占用的内存就被操作系统全部回收。即便你有所改动，没有被存储到磁盘里的，下次运行又回到了初始值。\n\n我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫`pickling`，在其他语言中也被称之为`serialization`，`marshalling`，`flattening`等等，都是一个意思。\n\n序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。\n\n反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即`unpickling`。\n\nPython提供两个模块来实现序列化：`cPickle`和`pickle`。这两个模块功能是一样的，区别在于`cPickle`是C语言写的，速度快，pickle是纯Python写的，速度慢，跟`cStringIO`和`StringIO`一个道理。用的时候，先尝试导入`cPickle`，如果失败，再导入`pickle`：\n```\ntry:\n    import cPickle as pickle\nexcept ImportError:\n    import pickle\n\n#序列化\nd = dict(name='bob', sex='m', age='19')\nwith open('wode.txt','w') as f:\n    pickle.dump(d, f)\n\n#反序列化\nwith open('wode.txt', 'r') as f:\n    w = pickle.load(f)\n    print w\n```\n\nPickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。\n\n###　JSON\n\n如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。\n\nJSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：\n\n|JSON类型\t|Python类型\n|:-----------|:---------|\n|{}|\tdict|\n|[]|\tlist|\n|\"string\"|\t'str'或u'unicode'|\n|1234.56\t|int或float|\n|true/false\t|True/False|\n|null\t|None|\n\nPython内置的`json`模块提供了非常完善的Python对象到JSON格式的转换。\n```\nd = dict(name='bob', sex='m', age='19')\ns=json.dumps(d)\nw = json.loads(s)\nprint w\n```\n有一点需要注意，就是反序列化得到的所有字符串对象默认都是unicode而不是str。由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str或unicode与JSON的字符串之间转换。\n\npython 3 很好的解决了这个问题。\n\n### JSON进阶\n我们大多数时候喜欢用class表示对象，那来讲一讲如何序列化类：\n```\nimport json\n\nclass Student(object):\n    def __init__(self, name, age, score):\n        self.name = name\n        self.age = age\n        self.score = score\n\ns = Student('Bob', 20, 88)\nprint(json.dumps(s))\n```\n但是直接调用上述代码会发现，报错了。原因是说Student对象不是一个可序列化为JSON的对象。dumps()方法不知道如何将Student实例变为一个JSON的{}对象。\n\n可选参数default就是把任意一个对象变成一个可序列为JSON的对象，因此我们需要另外写一个函数将函数值传入。\n```\ndef student2dict(std):\n    return {\n        'name': std.name,\n        'age': std.age,\n        'score': std.score\n    }\n\nprint(json.dumps(s, default=student2dict))\n```\n但还有一个偷懒的写法：\n\n```\nprint(json.dumps(s, default=lambda obj: obj.__dict__))\n```\n因为通常class的实例都有一个`__dict__`属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了`__slots__`的class。\n\n因此，Python语言特定的序列化模块是pickle，但如果要把序列化搞得更通用、更符合Web标准，就可以使用json模块。\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","slug":"python/初探python(9)IO编程","published":1,"updated":"2019-03-22T14:44:36.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0p009w4l3nm9yhba7u","content":"<p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。<br><a id=\"more\"></a><br>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。</p>\n<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。也就是说，输出快，输入慢。有两种解决办法：</p>\n<p>1.第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p>\n<p>2.是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p>\n<p>很明显，同步IO性能远远低于异步IO，但异步IO的缺点就是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</p>\n<p>本章内容都是同步IO模式。</p>\n<h2 id=\"文件读写\"><a href=\"#文件读写\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h2><p>现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>\n<h3 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h3><p>要以读文件的模式打开一个文件对象，使用Python内置的<code>open()</code>函数，传入文件名和标示符，标示符’r’表示读，这样，我们就成功地打开了一个文件。<br>读取二进制文件，比如图片，视频等，用’rb’模式打开即可。<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">f</span> = <span class=\"keyword\">open</span>(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"keyword\">f</span>.<span class=\"keyword\">read</span>()</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">f</span>:</span><br><span class=\"line\">        <span class=\"keyword\">f</span>.<span class=\"keyword\">close</span>()</span><br></pre></td></tr></table></figure></p>\n<p>一旦文件读写失败会报一个<code>IOerror</code>，一旦出错，后面的f.close()就不会调用。所以我们要将其用<code>try ... finally</code>包括起来。</p>\n<p>但为了方便，Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法:<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    print f.<span class=\"built_in\">read</span>()</span><br></pre></td></tr></table></figure></p>\n<p><code>read()</code>可以一次性读取到文件的全部内容。如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取size个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>\n<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">for</span> <span class=\"built_in\">line</span> in f.readlines():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">line</span>.strip()) # 把末尾的<span class=\"string\">'\\n'</span>删掉</span><br></pre></td></tr></table></figure></p>\n<p>###　file-like Object<br>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。</p>\n<p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p>\n<p>读取二进制文件，比如图片，视频等，用’rb’模式打开即可。</p>\n<h3 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h3><p>要读取非ASCII编码的文本文件，就必须以二进制模式打开，再解码。比如GBK编码的文件：<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = <span class=\"built_in\">open</span>(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'rb'</span>)</span><br><span class=\"line\">u = f.<span class=\"built_in\">read</span>().decode(<span class=\"string\">'gbk'</span>)</span><br><span class=\"line\">u</span><br><span class=\"line\"><span class=\"comment\">#u'\\u6d4b\\u8bd5'</span></span><br><span class=\"line\">print u</span><br><span class=\"line\"><span class=\"comment\">#测试</span></span><br></pre></td></tr></table></figure></p>\n<p>也可以直接导入<code>codecs</code>模块，帮我们自动转化编码。<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> codecs</span><br><span class=\"line\"><span class=\"keyword\">with</span> codecs.open(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'gbk'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    f.read() # u<span class=\"string\">'\\u6d4b\\u8bd5'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h3><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件。<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import codecs</span><br><span class=\"line\"><span class=\"keyword\">with</span> codecs.<span class=\"built_in\">open</span>(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'gbk'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    f.<span class=\"built_in\">write</span>(<span class=\"string\">'nihao'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"操作文件和目录\"><a href=\"#操作文件和目录\" class=\"headerlink\" title=\"操作文件和目录\"></a>操作文件和目录</h2><p>如果我们在python下要操作文件、目录，可以使用<code>os</code>模块。<br>我们可以使用’os.name’来显示系统名字，如果是<code>posix</code>，说明系统是Linux、Unix或Mac OS X，如果是<code>nt</code>，就是Windows系统。</p>\n<p>如果要获取详细信息，可以调用<code>uname()</code>函数。但在Windows下不支持。</p>\n<p>###　环境变量<br>环境变量全部保存在<code>os.eniron</code>中。<br>要获取某个环境变量的值，可以调用<code>os.getenv()</code>函数。例如：<code>os.getenv(&#39;PATH&#39;)</code></p>\n<p>###　操作文件和目录</p>\n<p>操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前目录的绝对路径:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.path.abspath(<span class=\"string\">'.'</span>)</span><br><span class=\"line\"><span class=\"string\">'/Users/michael'</span></span><br><span class=\"line\"><span class=\"comment\"># 在某个目录下创建一个新目录，</span></span><br><span class=\"line\"><span class=\"comment\"># 首先把新目录的完整路径表示出来:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.path.join(<span class=\"string\">'/Users/michael'</span>, <span class=\"string\">'testdir'</span>)</span><br><span class=\"line\"><span class=\"string\">'/Users/michael/testdir'</span></span><br><span class=\"line\"><span class=\"comment\"># 然后创建一个目录:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.mkdir(<span class=\"string\">'/Users/michael/testdir'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 删掉一个目录:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.rmdir(<span class=\"string\">'/Users/michael/testdir'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 对文件重命名:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.rename(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'test.py'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 删掉文件:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.remove(<span class=\"string\">'test.py'</span>)</span><br></pre></td></tr></table></figure>\n<p>把两个路径合为一个，用os.path.join()会自动将两个路径相连，并符合系统要求。无需自己手写字符串相连。</p>\n<p>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名。</p>\n<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便。</p>\n<p>这些合并和拆分不要求真实存在，只对字符串进行操作。</p>\n<p>但复制操作并不在<code>os</code>模块中。原因是复制文件并非由操作系统提供的系统调用。</p>\n<p>幸运的是<code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是os模块的补充。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import os</span><br><span class=\"line\">import shutil</span><br><span class=\"line\">s = os<span class=\"selector-class\">.path</span><span class=\"selector-class\">.abspath</span>(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">t = os<span class=\"selector-class\">.path</span><span class=\"selector-class\">.join</span>(s, <span class=\"string\">'wode.txt'</span>)</span><br><span class=\"line\">print t</span><br><span class=\"line\">s = os<span class=\"selector-class\">.path</span><span class=\"selector-class\">.join</span>(s,<span class=\"string\">\"woqu.txt\"</span>)</span><br><span class=\"line\">shutil.copyfile(t,s)</span><br></pre></td></tr></table></figure></p>\n<p>最后，还可以通过python的特性来过滤文件。<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有该目录下的文件夹（即目录）</span><br><span class=\"line\">[x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">os</span>.listdir(<span class=\"string\">'.'</span>) <span class=\"keyword\">if</span> <span class=\"built_in\">os</span>.<span class=\"built_in\">path</span>.isdir(x)]</span><br><span class=\"line\"># 列出所有该目录下的.py文件</span><br><span class=\"line\">[x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">os</span>.listdir(<span class=\"string\">'.'</span>) <span class=\"keyword\">if</span> <span class=\"built_in\">os</span>.<span class=\"built_in\">path</span>.isfile(x) <span class=\"keyword\">and</span> <span class=\"built_in\">os</span>.<span class=\"built_in\">path</span>.splitext(x)[<span class=\"number\">1</span>]==<span class=\"string\">'.py'</span>]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>题目：编写一个search(s)的函数，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出完整路径。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"string\">'''编写一个search(s)的函数，</span></span><br><span class=\"line\"><span class=\"string\">能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，</span></span><br><span class=\"line\"><span class=\"string\">并打印出完整路径</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Usage:</span></span><br><span class=\"line\"><span class=\"string\">    &gt; search.py str</span></span><br><span class=\"line\"><span class=\"string\">    str: the str what you want to search in filename in your dir</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> root,dirs,files <span class=\"keyword\">in</span> os.walk(<span class=\"string\">'.'</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> f <span class=\"keyword\">in</span> files:</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(f.find(s) != <span class=\"number\">-1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">print</span> os.path.join(root,f)[<span class=\"number\">2</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    search(sys.argv[<span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure></p>\n<p>##　序列化<br>在程序运行的过程中，所有的变量都是在内存中，一旦程序结束，变量所占用的内存就被操作系统全部回收。即便你有所改动，没有被存储到磁盘里的，下次运行又回到了初始值。</p>\n<p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫<code>pickling</code>，在其他语言中也被称之为<code>serialization</code>，<code>marshalling</code>，<code>flattening</code>等等，都是一个意思。</p>\n<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>\n<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即<code>unpickling</code>。</p>\n<p>Python提供两个模块来实现序列化：<code>cPickle</code>和<code>pickle</code>。这两个模块功能是一样的，区别在于<code>cPickle</code>是C语言写的，速度快，pickle是纯Python写的，速度慢，跟<code>cStringIO</code>和<code>StringIO</code>一个道理。用的时候，先尝试导入<code>cPickle</code>，如果失败，再导入<code>pickle</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> cPickle <span class=\"keyword\">as</span> pickle</span><br><span class=\"line\"><span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> pickle</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#序列化</span></span><br><span class=\"line\">d = dict(name=<span class=\"string\">'bob'</span>, sex=<span class=\"string\">'m'</span>, age=<span class=\"string\">'19'</span>)</span><br><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'wode.txt'</span>,<span class=\"string\">'w'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    pickle.dump(d, f)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#反序列化</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'wode.txt'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    w = pickle.load(f)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> w</span><br></pre></td></tr></table></figure></p>\n<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>\n<p>###　JSON</p>\n<p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>\n<p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">JSON类型</th>\n<th style=\"text-align:left\">Python类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">{}</td>\n<td style=\"text-align:left\">dict</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[]</td>\n<td style=\"text-align:left\">list</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“string”</td>\n<td style=\"text-align:left\">‘str’或u’unicode’</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1234.56</td>\n<td style=\"text-align:left\">int或float</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">true/false</td>\n<td style=\"text-align:left\">True/False</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">null</td>\n<td style=\"text-align:left\">None</td>\n</tr>\n</tbody>\n</table>\n<p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = dict(<span class=\"attribute\">name</span>=<span class=\"string\">'bob'</span>, <span class=\"attribute\">sex</span>=<span class=\"string\">'m'</span>, <span class=\"attribute\">age</span>=<span class=\"string\">'19'</span>)</span><br><span class=\"line\"><span class=\"attribute\">s</span>=json.dumps(d)</span><br><span class=\"line\">w = json.loads(s)</span><br><span class=\"line\"><span class=\"builtin-name\">print</span> w</span><br></pre></td></tr></table></figure></p>\n<p>有一点需要注意，就是反序列化得到的所有字符串对象默认都是unicode而不是str。由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str或unicode与JSON的字符串之间转换。</p>\n<p>python 3 很好的解决了这个问题。</p>\n<h3 id=\"JSON进阶\"><a href=\"#JSON进阶\" class=\"headerlink\" title=\"JSON进阶\"></a>JSON进阶</h3><p>我们大多数时候喜欢用class表示对象，那来讲一讲如何序列化类：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, name, age, score)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age = age</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.score = score</span><br><span class=\"line\"></span><br><span class=\"line\">s = Student(<span class=\"string\">'Bob'</span>, <span class=\"number\">20</span>, <span class=\"number\">88</span>)</span><br><span class=\"line\">print(json.dumps(s))</span><br></pre></td></tr></table></figure></p>\n<p>但是直接调用上述代码会发现，报错了。原因是说Student对象不是一个可序列化为JSON的对象。dumps()方法不知道如何将Student实例变为一个JSON的{}对象。</p>\n<p>可选参数default就是把任意一个对象变成一个可序列为JSON的对象，因此我们需要另外写一个函数将函数值传入。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">student2dict</span><span class=\"params\">(std)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"string\">'name'</span>: std.name,</span><br><span class=\"line\">        <span class=\"string\">'age'</span>: std.age,</span><br><span class=\"line\">        <span class=\"string\">'score'</span>: std.score</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">print(json.dumps(s, default=student2dict))</span><br></pre></td></tr></table></figure></p>\n<p>但还有一个偷懒的写法：</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(<span class=\"name\">json</span>.dumps(<span class=\"name\">s</span>, default=lambda obj: obj.__dict__))</span><br></pre></td></tr></table></figure>\n<p>因为通常class的实例都有一个<code>__dict__</code>属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p>\n<p>因此，Python语言特定的序列化模块是pickle，但如果要把序列化搞得更通用、更符合Web标准，就可以使用json模块。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>IO在计算机中指Input/Output，也就是输入和输出。由于程序和运行时数据是在内存中驻留，由CPU这个超快的计算核心来执行，涉及到数据交换的地方，通常是磁盘、网络等，就需要IO接口。<br></p>","more":"<br>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。对于浏览网页来说，浏览器和新浪服务器之间至少需要建立两根水管，才可以既能发数据，又能收数据。<p></p>\n<p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。也就是说，输出快，输入慢。有两种解决办法：</p>\n<p>1.第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为同步IO；</p>\n<p>2.是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为异步IO。</p>\n<p>很明显，同步IO性能远远低于异步IO，但异步IO的缺点就是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</p>\n<p>本章内容都是同步IO模式。</p>\n<h2 id=\"文件读写\"><a href=\"#文件读写\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h2><p>现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）。</p>\n<h3 id=\"读文件\"><a href=\"#读文件\" class=\"headerlink\" title=\"读文件\"></a>读文件</h3><p>要以读文件的模式打开一个文件对象，使用Python内置的<code>open()</code>函数，传入文件名和标示符，标示符’r’表示读，这样，我们就成功地打开了一个文件。<br>读取二进制文件，比如图片，视频等，用’rb’模式打开即可。<br><figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">f</span> = <span class=\"keyword\">open</span>(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"keyword\">f</span>.<span class=\"keyword\">read</span>()</span><br><span class=\"line\"><span class=\"keyword\">finally</span>:</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"keyword\">f</span>:</span><br><span class=\"line\">        <span class=\"keyword\">f</span>.<span class=\"keyword\">close</span>()</span><br></pre></td></tr></table></figure></p>\n<p>一旦文件读写失败会报一个<code>IOerror</code>，一旦出错，后面的f.close()就不会调用。所以我们要将其用<code>try ... finally</code>包括起来。</p>\n<p>但为了方便，Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法:<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">'/path/to/file'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    print f.<span class=\"built_in\">read</span>()</span><br></pre></td></tr></table></figure></p>\n<p><code>read()</code>可以一次性读取到文件的全部内容。如果文件有10G，内存就爆了，所以，要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取size个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回list。因此，要根据需要决定怎么调用。</p>\n<p>如果文件很小，read()一次性读取最方便；如果不能确定文件大小，反复调用read(size)比较保险；如果是配置文件，调用readlines()最方便：<br><figure class=\"highlight arduino\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">for</span> <span class=\"built_in\">line</span> in f.readlines():</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(<span class=\"built_in\">line</span>.strip()) # 把末尾的<span class=\"string\">'\\n'</span>删掉</span><br></pre></td></tr></table></figure></p>\n<p>###　file-like Object<br>像open()函数返回的这种有个read()方法的对象，在Python中统称为file-like Object。</p>\n<p><code>StringIO</code>就是在内存中创建的file-like Object，常用作临时缓冲。</p>\n<p>读取二进制文件，比如图片，视频等，用’rb’模式打开即可。</p>\n<h3 id=\"字符编码\"><a href=\"#字符编码\" class=\"headerlink\" title=\"字符编码\"></a>字符编码</h3><p>要读取非ASCII编码的文本文件，就必须以二进制模式打开，再解码。比如GBK编码的文件：<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f = <span class=\"built_in\">open</span>(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'rb'</span>)</span><br><span class=\"line\">u = f.<span class=\"built_in\">read</span>().decode(<span class=\"string\">'gbk'</span>)</span><br><span class=\"line\">u</span><br><span class=\"line\"><span class=\"comment\">#u'\\u6d4b\\u8bd5'</span></span><br><span class=\"line\">print u</span><br><span class=\"line\"><span class=\"comment\">#测试</span></span><br></pre></td></tr></table></figure></p>\n<p>也可以直接导入<code>codecs</code>模块，帮我们自动转化编码。<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> codecs</span><br><span class=\"line\"><span class=\"keyword\">with</span> codecs.open(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'gbk'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    f.read() # u<span class=\"string\">'\\u6d4b\\u8bd5'</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"写文件\"><a href=\"#写文件\" class=\"headerlink\" title=\"写文件\"></a>写文件</h3><p>写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符’w’或者’wb’表示写文本文件或写二进制文件。<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import codecs</span><br><span class=\"line\"><span class=\"keyword\">with</span> codecs.<span class=\"built_in\">open</span>(<span class=\"string\">'/Users/michael/gbk.txt'</span>, <span class=\"string\">'r'</span>, <span class=\"string\">'gbk'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    f.<span class=\"built_in\">write</span>(<span class=\"string\">'nihao'</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"操作文件和目录\"><a href=\"#操作文件和目录\" class=\"headerlink\" title=\"操作文件和目录\"></a>操作文件和目录</h2><p>如果我们在python下要操作文件、目录，可以使用<code>os</code>模块。<br>我们可以使用’os.name’来显示系统名字，如果是<code>posix</code>，说明系统是Linux、Unix或Mac OS X，如果是<code>nt</code>，就是Windows系统。</p>\n<p>如果要获取详细信息，可以调用<code>uname()</code>函数。但在Windows下不支持。</p>\n<p>###　环境变量<br>环境变量全部保存在<code>os.eniron</code>中。<br>要获取某个环境变量的值，可以调用<code>os.getenv()</code>函数。例如：<code>os.getenv(&#39;PATH&#39;)</code></p>\n<p>###　操作文件和目录</p>\n<p>操作文件和目录的函数一部分放在os模块中，一部分放在os.path模块中，这一点要注意一下。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 查看当前目录的绝对路径:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.path.abspath(<span class=\"string\">'.'</span>)</span><br><span class=\"line\"><span class=\"string\">'/Users/michael'</span></span><br><span class=\"line\"><span class=\"comment\"># 在某个目录下创建一个新目录，</span></span><br><span class=\"line\"><span class=\"comment\"># 首先把新目录的完整路径表示出来:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.path.join(<span class=\"string\">'/Users/michael'</span>, <span class=\"string\">'testdir'</span>)</span><br><span class=\"line\"><span class=\"string\">'/Users/michael/testdir'</span></span><br><span class=\"line\"><span class=\"comment\"># 然后创建一个目录:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.mkdir(<span class=\"string\">'/Users/michael/testdir'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 删掉一个目录:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.rmdir(<span class=\"string\">'/Users/michael/testdir'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 对文件重命名:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.rename(<span class=\"string\">'test.txt'</span>, <span class=\"string\">'test.py'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 删掉文件:</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; os.remove(<span class=\"string\">'test.py'</span>)</span><br></pre></td></tr></table></figure>\n<p>把两个路径合为一个，用os.path.join()会自动将两个路径相连，并符合系统要求。无需自己手写字符串相连。</p>\n<p>同样的道理，要拆分路径时，也不要直接去拆字符串，而要通过<code>os.path.split()</code>函数，这样可以把一个路径拆分为两部分，后一部分总是最后级别的目录或文件名。</p>\n<p><code>os.path.splitext()</code>可以直接让你得到文件扩展名，很多时候非常方便。</p>\n<p>这些合并和拆分不要求真实存在，只对字符串进行操作。</p>\n<p>但复制操作并不在<code>os</code>模块中。原因是复制文件并非由操作系统提供的系统调用。</p>\n<p>幸运的是<code>shutil</code>模块提供了<code>copyfile()</code>的函数，你还可以在<code>shutil</code>模块中找到很多实用函数，它们可以看做是os模块的补充。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import os</span><br><span class=\"line\">import shutil</span><br><span class=\"line\">s = os<span class=\"selector-class\">.path</span><span class=\"selector-class\">.abspath</span>(<span class=\"string\">'.'</span>)</span><br><span class=\"line\">t = os<span class=\"selector-class\">.path</span><span class=\"selector-class\">.join</span>(s, <span class=\"string\">'wode.txt'</span>)</span><br><span class=\"line\">print t</span><br><span class=\"line\">s = os<span class=\"selector-class\">.path</span><span class=\"selector-class\">.join</span>(s,<span class=\"string\">\"woqu.txt\"</span>)</span><br><span class=\"line\">shutil.copyfile(t,s)</span><br></pre></td></tr></table></figure></p>\n<p>最后，还可以通过python的特性来过滤文件。<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 列出所有该目录下的文件夹（即目录）</span><br><span class=\"line\">[x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">os</span>.listdir(<span class=\"string\">'.'</span>) <span class=\"keyword\">if</span> <span class=\"built_in\">os</span>.<span class=\"built_in\">path</span>.isdir(x)]</span><br><span class=\"line\"># 列出所有该目录下的.py文件</span><br><span class=\"line\">[x <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> <span class=\"built_in\">os</span>.listdir(<span class=\"string\">'.'</span>) <span class=\"keyword\">if</span> <span class=\"built_in\">os</span>.<span class=\"built_in\">path</span>.isfile(x) <span class=\"keyword\">and</span> <span class=\"built_in\">os</span>.<span class=\"built_in\">path</span>.splitext(x)[<span class=\"number\">1</span>]==<span class=\"string\">'.py'</span>]</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>题目：编写一个search(s)的函数，能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，并打印出完整路径。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br><span class=\"line\"><span class=\"string\">'''编写一个search(s)的函数，</span></span><br><span class=\"line\"><span class=\"string\">能在当前目录以及当前目录的所有子目录下查找文件名包含指定字符串的文件，</span></span><br><span class=\"line\"><span class=\"string\">并打印出完整路径</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">Usage:</span></span><br><span class=\"line\"><span class=\"string\">    &gt; search.py str</span></span><br><span class=\"line\"><span class=\"string\">    str: the str what you want to search in filename in your dir</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">search</span><span class=\"params\">(s)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> root,dirs,files <span class=\"keyword\">in</span> os.walk(<span class=\"string\">'.'</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> f <span class=\"keyword\">in</span> files:</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(f.find(s) != <span class=\"number\">-1</span>):</span><br><span class=\"line\">                <span class=\"keyword\">print</span> os.path.join(root,f)[<span class=\"number\">2</span>:]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    search(sys.argv[<span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure></p>\n<p>##　序列化<br>在程序运行的过程中，所有的变量都是在内存中，一旦程序结束，变量所占用的内存就被操作系统全部回收。即便你有所改动，没有被存储到磁盘里的，下次运行又回到了初始值。</p>\n<p>我们把变量从内存中变成可存储或传输的过程称之为序列化，在Python中叫<code>pickling</code>，在其他语言中也被称之为<code>serialization</code>，<code>marshalling</code>，<code>flattening</code>等等，都是一个意思。</p>\n<p>序列化之后，就可以把序列化后的内容写入磁盘，或者通过网络传输到别的机器上。</p>\n<p>反过来，把变量内容从序列化的对象重新读到内存里称之为反序列化，即<code>unpickling</code>。</p>\n<p>Python提供两个模块来实现序列化：<code>cPickle</code>和<code>pickle</code>。这两个模块功能是一样的，区别在于<code>cPickle</code>是C语言写的，速度快，pickle是纯Python写的，速度慢，跟<code>cStringIO</code>和<code>StringIO</code>一个道理。用的时候，先尝试导入<code>cPickle</code>，如果失败，再导入<code>pickle</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> cPickle <span class=\"keyword\">as</span> pickle</span><br><span class=\"line\"><span class=\"keyword\">except</span> ImportError:</span><br><span class=\"line\">    <span class=\"keyword\">import</span> pickle</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#序列化</span></span><br><span class=\"line\">d = dict(name=<span class=\"string\">'bob'</span>, sex=<span class=\"string\">'m'</span>, age=<span class=\"string\">'19'</span>)</span><br><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'wode.txt'</span>,<span class=\"string\">'w'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    pickle.dump(d, f)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#反序列化</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'wode.txt'</span>, <span class=\"string\">'r'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    w = pickle.load(f)</span><br><span class=\"line\">    <span class=\"keyword\">print</span> w</span><br></pre></td></tr></table></figure></p>\n<p>Pickle的问题和所有其他编程语言特有的序列化问题一样，就是它只能用于Python，并且可能不同版本的Python彼此都不兼容，因此，只能用Pickle保存那些不重要的数据，不能成功地反序列化也没关系。</p>\n<p>###　JSON</p>\n<p>如果我们要在不同的编程语言之间传递对象，就必须把对象序列化为标准格式，比如XML，但更好的方法是序列化为JSON，因为JSON表示出来就是一个字符串，可以被所有语言读取，也可以方便地存储到磁盘或者通过网络传输。JSON不仅是标准格式，并且比XML更快，而且可以直接在Web页面中读取，非常方便。</p>\n<p>JSON表示的对象就是标准的JavaScript语言的对象，JSON和Python内置的数据类型对应如下：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">JSON类型</th>\n<th style=\"text-align:left\">Python类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">{}</td>\n<td style=\"text-align:left\">dict</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">[]</td>\n<td style=\"text-align:left\">list</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">“string”</td>\n<td style=\"text-align:left\">‘str’或u’unicode’</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">1234.56</td>\n<td style=\"text-align:left\">int或float</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">true/false</td>\n<td style=\"text-align:left\">True/False</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">null</td>\n<td style=\"text-align:left\">None</td>\n</tr>\n</tbody>\n</table>\n<p>Python内置的<code>json</code>模块提供了非常完善的Python对象到JSON格式的转换。<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">d = dict(<span class=\"attribute\">name</span>=<span class=\"string\">'bob'</span>, <span class=\"attribute\">sex</span>=<span class=\"string\">'m'</span>, <span class=\"attribute\">age</span>=<span class=\"string\">'19'</span>)</span><br><span class=\"line\"><span class=\"attribute\">s</span>=json.dumps(d)</span><br><span class=\"line\">w = json.loads(s)</span><br><span class=\"line\"><span class=\"builtin-name\">print</span> w</span><br></pre></td></tr></table></figure></p>\n<p>有一点需要注意，就是反序列化得到的所有字符串对象默认都是unicode而不是str。由于JSON标准规定JSON编码是UTF-8，所以我们总是能正确地在Python的str或unicode与JSON的字符串之间转换。</p>\n<p>python 3 很好的解决了这个问题。</p>\n<h3 id=\"JSON进阶\"><a href=\"#JSON进阶\" class=\"headerlink\" title=\"JSON进阶\"></a>JSON进阶</h3><p>我们大多数时候喜欢用class表示对象，那来讲一讲如何序列化类：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import json</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, name, age, score)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.age = age</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.score = score</span><br><span class=\"line\"></span><br><span class=\"line\">s = Student(<span class=\"string\">'Bob'</span>, <span class=\"number\">20</span>, <span class=\"number\">88</span>)</span><br><span class=\"line\">print(json.dumps(s))</span><br></pre></td></tr></table></figure></p>\n<p>但是直接调用上述代码会发现，报错了。原因是说Student对象不是一个可序列化为JSON的对象。dumps()方法不知道如何将Student实例变为一个JSON的{}对象。</p>\n<p>可选参数default就是把任意一个对象变成一个可序列为JSON的对象，因此我们需要另外写一个函数将函数值传入。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">student2dict</span><span class=\"params\">(std)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">        <span class=\"string\">'name'</span>: std.name,</span><br><span class=\"line\">        <span class=\"string\">'age'</span>: std.age,</span><br><span class=\"line\">        <span class=\"string\">'score'</span>: std.score</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">print(json.dumps(s, default=student2dict))</span><br></pre></td></tr></table></figure></p>\n<p>但还有一个偷懒的写法：</p>\n<figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(<span class=\"name\">json</span>.dumps(<span class=\"name\">s</span>, default=lambda obj: obj.__dict__))</span><br></pre></td></tr></table></figure>\n<p>因为通常class的实例都有一个<code>__dict__</code>属性，它就是一个dict，用来存储实例变量。也有少数例外，比如定义了<code>__slots__</code>的class。</p>\n<p>因此，Python语言特定的序列化模块是pickle，但如果要把序列化搞得更通用、更符合Web标准，就可以使用json模块。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"沪港通,深港通总结","date":"2017-12-06T09:22:50.000Z","_content":"\n## 概述\n### 何为沪港通,深港通\n\n沪港通是沪港股票市场交易互联互通机制的简称,包括沪股通和港股通两个部分.沪股通即香港投资者可以委托香港经纪商,通过联交所设立的证券交易服务公司(SPV),向上交所申报股票的买卖.港股通则反之。\n\n深港通即为深圳交易所和香港联合交易所互通互联.\n\n<!--more-->\n\n### 港股通标的\n\n|差异对比点|深港通|沪港通\n|-----------|:-----------------|:-----------------|\n|参考指数|恒生大型股指数,中型股指数,小型股指数|恒生大型股指数,中型股指数,小型股指数|\n|市值筛选条件|恒生综合小型股指数成分股,且成分股定期调整考察截止日（注1）|无|\n|A+H股相应标的|沪、深两所上市A+H股公司的相应的主板H股|上交所上市A+H股公司的相应H股|\n\n* **注1**:恒生综合小型股指数成分股考察12个月港股平均月末市值不低于50亿元,并且对A+H股不做市值参考\n\n### 港股通额度控制\n\n沪港通无总额度控制，每日额度有限制。沪股通的额度为130亿元，沪港通的额度为105亿元。深港通同理。\n\n\n## 交易规则\n### 港股与A股交易规则的差异\n\n|项目|港股|A股\n|-----------|:-----------------|:-----------------|\n|交易单位|交易规则没有相关规定，由发行公司自行决定。没手股数不等|买入100股或其整数倍，卖出余额不足100股应当一次性申报卖出|\n|涨跌幅限制|无|10%|\n|交易规则|T+0，当天买卖次数无限制|T+1|\n|交收规则|T+2交收，卖出股票的资金T+3日可取，如遇八号风暴等原因可能会延迟交收，一般警报解除后两小时开始交易|T+1交收，卖出股票资金T+1可取|\n|交易时间|两地都可以进行正常交易和结算的交易日**（注1）**|周一至周五（国家法定节假日和公告的休市时间除外）**（注2）**|\n|最小报价单位|不同价位8种价差|价差为0.01元|\n|报单价格限制|24个价位/10个价位|涨跌幅内|\n|申报数量|每个买卖盘手数上限为3000手，每一个经纪代号的未执行买卖盘不设上限，每个买卖盘股数上限为99,999,999|股票（基金）单笔申报最大数量应当低于100万股，债券单笔申报最大数量应当低于等于1万手|\n|零股（碎股）买卖|零股买卖暂时仅可卖出不可买入，联交所的交易系统不会为碎股提供自动对盘交易，而是在系统内设有“碎股/特别买卖单位市场”供碎股交易|低于100股的股票必须一次性卖出，不允许再分次卖出|\n|交易币种|以港币报价，以人民币实际支付收取|人民币|\n|融资融券|港股通投资者不得参与港市融资融券交易，更不允许裸卖空|只有某些指定的股票可以融资买入卖出**（注3）**|\n|股票数字位数|5位|6位|\n\t\n\n* **注1**:圣诞节前夕，新年前夕，元旦节前夕只有上半天交易日。9:00 - 9:15(竞价盘，竞价限价盘)，9:15-9:20（竞价盘，禁止改单撤单），9:20-9:28，对盘阶段，禁止下单，9:28 - 9:30 暂停阶段，9:30 - 12:00,13:00-16:00 持续交易阶段 (增强限价盘)。\n* **注2**：开盘集合竞价:9:15 - 9:25,连续竞价：9:30 - 11:30,13:00 - 15:00\n* **注3**：有关交易所指定的允许融资融券的证券名单可在交易所官网获得。\n\n**报价规则**：最先买盘价（在当日没有最先沽盘的情况下）或最先沽盘价（在当日没有最先买盘的情况下）不得偏离上日收市价（如有）九倍或以上。\n\n\n## 清算结算\n\n### 结算原则\n\n两级结算、净额清算、担保交收，人民币结算。\n\n|时间|中国结算\n|-----------|:-----------------|\n|T日|日终：1.交易清算；<br> 2.在人命比资金到账后，进行公司行为业务清算；<br> 3、风控资金清算；<br> 4.根据上日持有以及收盘价，计算证券组合费。<br>上述清算各分外币和人民币两次进行，数据当日发送结算参与人。|\n|T+1日|10:30：根据T日分控资金、公司行为类资金清算结果进行参与人资金交收。<br> 18：00：对T日证券组合费清算结果进行交收。|\n|T+2日|13:30：根据T日清算结果，进行参与人**应付**交易清算资金交收。<br>18:00：根据T日清算结果，进行参与人**应收**交易清算资金交收。<br>日终：对T日交易安证券账户逐笔进行证券交收。|\n\n\n### 两次清算\n原因是因为用港币交易，人民币清算，需要换汇。\n\n* 换汇银行向中国结算提供参考汇率，前台系统显示。\n* 首次清算：T日日终，以备付金账户为单位，进行港币清算。\n* 汇总计算T+2日全部港币应收/应付金额并通知换汇银行。\n* T日日终，换汇银行提供换汇汇率，用于T+2交收。\n* 二次清算：分摊换汇成本，计算汇兑比率，进行二次人民币清算，并将清算数据发送参与人。\n\nT+2日交收主要是流程原因，T+1做产品层面的交收，T+2日做结算参与人层面的交收。有因为香港市场还有实物股票的情况，所以给大家留的交收时间比较充分。\n\n### 证券组合费\n(1) 以上一日日终持有的市值为基础，每个自然日收取；\n(2) 对于周末和假日的情况，顺延到下一工作日计算。例如，周一计算上周五、周六以及周日的证券组合费；\n(3) 遇香港交易境内放假或者香港方向境内正常交易的，收盘价取前一港股通工作日的收盘价；\n(4) 实行超额累退费率；日费率等于年费除以365；\n\n### 港股交易日期\n\n基本原则：\n\n* “最小交集”：交易日仅在沪港两地均为交易日且能够满足结算安排时开通。\n* 境内放假、香港放假的均不作为交易日和交收日；\n* 若境内放假香港不放假，为避免资金交收违约，境内放假前两天不作为港股通交易日，但为交收日。\n\n\n### 特殊清算交收安排\n\n遇特定节假日、恶劣天气等情况，香港市场会在交易、结算等方面做出特殊安排，届时中国结算应做出相应调整，并及时通知市场。\n\n#### 情况一：台风/黑色暴雨警告9点前发出，12点为解除\n\n香港结算视当天（T日）为非交收日，改日原本的证券和资金交收会顺延至下一个交收日。\n即T-2日交易的交收顺延至T+1交收，T-1日交易的交收顺延至T+2交收。\n\n#### 情况二：台风讯号9点后发出，12点未解除\n\n香港结算当日仅作证券交收，资金顺延至下一交收日处理，该日视作为交收日。\n即：T-2日交易的资金交收顺延至T+1交收，T-1日交易的资金交收顺延至T+2交收。\n如黑色暴雨警告在9点后发出，则该日正常进行证券和资金的交收。\n\n#### 情况三：台风讯号发出又被解除\n\n开市前发出，7点至9点期间解除，则开始前时段被取消，后两小时恢复交易，开始时间必须为整点或者30分。；\n如在11点到12点之前解除，开市前阶段以及早上交易阶段被取消，下午交易时间顺延两个小时进行，开始时间必须为整点或者30分。\n\n\n#### 情况四：圣诞、元旦、农历新年前夕\n若圣诞节、元旦和农历新年前一天不是周末，则该日上午有交易，但非交收日。\n即：T-2日交易的资金交收顺延至T+1日交收，T-1日和T日的交易交收顺延至T+2交收。\n\n\n## 沪港与深港的区别\n\n### 结算汇率\n\n参考汇率相同，结算汇率不同。\n\n1.独立换汇：深、沪结算分公司独立换汇\n2.机制相同：深、沪两司换汇机制相同，每日参考汇率完全一致。\n3.成本分摊不同： 由于沪深两所交易量不同，按照买卖轧差摊分成本之后，汇率分摊至投资者可能存在较少差异。\n\n### 沪港、深港卖出、资金使用、账户体系的差异\n\n1.沪深港股通证券账户股票不能交叉卖出。\n2.沪深港股资金账户资金可以交叉使用。\n3.沪深两所账户体系不同。上交所指定交易，深交所可转托管。\n\n## 常用术语\n\n蓝筹股：本地实力雄厚的上市公司发行的股票，在香港，恒生指数的成分股一般皆被视为蓝筹股；\n\n红筹股：由中国内地机构控股并注册地在中国大陆以外的公司发行的股票；\n\nH股：也称国企股，由中国内地机构控股且注册地在中国大陆的公司发行的股票；\n\n仙股：“仙”是香港人对英语`cent`的译音，指价格低于1元，只能以分作为计价单位的股票；\n\n孖展：一词来自香港，英文为Margin，即保证金的意思。孖展投资者通过银行和证券公司提供融资服务，进行杠杆投资；\n\n沽空：类似融券业务，投资者通过证券公司就介入证券卖出，并在约定时间内购回还给公司。\n\n毫子股：香港专有用语，指股价低于 港币1元，但高于港币1角的股票\n\n红底股：香港专有用语，指股价超过港币100元的股票\n\n神仙股：香港专有用语，指涨跌幅很大的股票\n\n细价股：小盘股\n\n竞价盘：没有指定价格而在开市前时段的输入买卖盘时段或对盘前时段输入系统，以在开市前时段的对盘时段内，按开市前时段的对盘前时段结束时计算所得的参考平衡价格进行自动对盘的买盘或沽盘；\n\n竞价限价盘：有指定价格而在开市前时段的输入买卖盘时段输入系统，以在开市前时段的对盘时段内，于买盘指定价格相等于或高于参考平衡价格时，或于卖盘指定价格相等于或低于参考平衡价格时，按开市前时段的对盘前时段结束时计算所得的参考平衡价格进行自动对盘的买盘或沽盘；\n\n特别限价盘：一个在持续交易时段输入系统有指定价格的买盘或沽盘，根据下列价格在该时段内进行自动配对：\n\n\n\n","source":"_posts/业务知识总结/沪港通,深港通总结.md","raw":"---\ntitle: 沪港通,深港通总结\ndate: 2017-12-06 17:22:50\ntags: \n- 金融业务\ncategories: 总结\n---\n\n## 概述\n### 何为沪港通,深港通\n\n沪港通是沪港股票市场交易互联互通机制的简称,包括沪股通和港股通两个部分.沪股通即香港投资者可以委托香港经纪商,通过联交所设立的证券交易服务公司(SPV),向上交所申报股票的买卖.港股通则反之。\n\n深港通即为深圳交易所和香港联合交易所互通互联.\n\n<!--more-->\n\n### 港股通标的\n\n|差异对比点|深港通|沪港通\n|-----------|:-----------------|:-----------------|\n|参考指数|恒生大型股指数,中型股指数,小型股指数|恒生大型股指数,中型股指数,小型股指数|\n|市值筛选条件|恒生综合小型股指数成分股,且成分股定期调整考察截止日（注1）|无|\n|A+H股相应标的|沪、深两所上市A+H股公司的相应的主板H股|上交所上市A+H股公司的相应H股|\n\n* **注1**:恒生综合小型股指数成分股考察12个月港股平均月末市值不低于50亿元,并且对A+H股不做市值参考\n\n### 港股通额度控制\n\n沪港通无总额度控制，每日额度有限制。沪股通的额度为130亿元，沪港通的额度为105亿元。深港通同理。\n\n\n## 交易规则\n### 港股与A股交易规则的差异\n\n|项目|港股|A股\n|-----------|:-----------------|:-----------------|\n|交易单位|交易规则没有相关规定，由发行公司自行决定。没手股数不等|买入100股或其整数倍，卖出余额不足100股应当一次性申报卖出|\n|涨跌幅限制|无|10%|\n|交易规则|T+0，当天买卖次数无限制|T+1|\n|交收规则|T+2交收，卖出股票的资金T+3日可取，如遇八号风暴等原因可能会延迟交收，一般警报解除后两小时开始交易|T+1交收，卖出股票资金T+1可取|\n|交易时间|两地都可以进行正常交易和结算的交易日**（注1）**|周一至周五（国家法定节假日和公告的休市时间除外）**（注2）**|\n|最小报价单位|不同价位8种价差|价差为0.01元|\n|报单价格限制|24个价位/10个价位|涨跌幅内|\n|申报数量|每个买卖盘手数上限为3000手，每一个经纪代号的未执行买卖盘不设上限，每个买卖盘股数上限为99,999,999|股票（基金）单笔申报最大数量应当低于100万股，债券单笔申报最大数量应当低于等于1万手|\n|零股（碎股）买卖|零股买卖暂时仅可卖出不可买入，联交所的交易系统不会为碎股提供自动对盘交易，而是在系统内设有“碎股/特别买卖单位市场”供碎股交易|低于100股的股票必须一次性卖出，不允许再分次卖出|\n|交易币种|以港币报价，以人民币实际支付收取|人民币|\n|融资融券|港股通投资者不得参与港市融资融券交易，更不允许裸卖空|只有某些指定的股票可以融资买入卖出**（注3）**|\n|股票数字位数|5位|6位|\n\t\n\n* **注1**:圣诞节前夕，新年前夕，元旦节前夕只有上半天交易日。9:00 - 9:15(竞价盘，竞价限价盘)，9:15-9:20（竞价盘，禁止改单撤单），9:20-9:28，对盘阶段，禁止下单，9:28 - 9:30 暂停阶段，9:30 - 12:00,13:00-16:00 持续交易阶段 (增强限价盘)。\n* **注2**：开盘集合竞价:9:15 - 9:25,连续竞价：9:30 - 11:30,13:00 - 15:00\n* **注3**：有关交易所指定的允许融资融券的证券名单可在交易所官网获得。\n\n**报价规则**：最先买盘价（在当日没有最先沽盘的情况下）或最先沽盘价（在当日没有最先买盘的情况下）不得偏离上日收市价（如有）九倍或以上。\n\n\n## 清算结算\n\n### 结算原则\n\n两级结算、净额清算、担保交收，人民币结算。\n\n|时间|中国结算\n|-----------|:-----------------|\n|T日|日终：1.交易清算；<br> 2.在人命比资金到账后，进行公司行为业务清算；<br> 3、风控资金清算；<br> 4.根据上日持有以及收盘价，计算证券组合费。<br>上述清算各分外币和人民币两次进行，数据当日发送结算参与人。|\n|T+1日|10:30：根据T日分控资金、公司行为类资金清算结果进行参与人资金交收。<br> 18：00：对T日证券组合费清算结果进行交收。|\n|T+2日|13:30：根据T日清算结果，进行参与人**应付**交易清算资金交收。<br>18:00：根据T日清算结果，进行参与人**应收**交易清算资金交收。<br>日终：对T日交易安证券账户逐笔进行证券交收。|\n\n\n### 两次清算\n原因是因为用港币交易，人民币清算，需要换汇。\n\n* 换汇银行向中国结算提供参考汇率，前台系统显示。\n* 首次清算：T日日终，以备付金账户为单位，进行港币清算。\n* 汇总计算T+2日全部港币应收/应付金额并通知换汇银行。\n* T日日终，换汇银行提供换汇汇率，用于T+2交收。\n* 二次清算：分摊换汇成本，计算汇兑比率，进行二次人民币清算，并将清算数据发送参与人。\n\nT+2日交收主要是流程原因，T+1做产品层面的交收，T+2日做结算参与人层面的交收。有因为香港市场还有实物股票的情况，所以给大家留的交收时间比较充分。\n\n### 证券组合费\n(1) 以上一日日终持有的市值为基础，每个自然日收取；\n(2) 对于周末和假日的情况，顺延到下一工作日计算。例如，周一计算上周五、周六以及周日的证券组合费；\n(3) 遇香港交易境内放假或者香港方向境内正常交易的，收盘价取前一港股通工作日的收盘价；\n(4) 实行超额累退费率；日费率等于年费除以365；\n\n### 港股交易日期\n\n基本原则：\n\n* “最小交集”：交易日仅在沪港两地均为交易日且能够满足结算安排时开通。\n* 境内放假、香港放假的均不作为交易日和交收日；\n* 若境内放假香港不放假，为避免资金交收违约，境内放假前两天不作为港股通交易日，但为交收日。\n\n\n### 特殊清算交收安排\n\n遇特定节假日、恶劣天气等情况，香港市场会在交易、结算等方面做出特殊安排，届时中国结算应做出相应调整，并及时通知市场。\n\n#### 情况一：台风/黑色暴雨警告9点前发出，12点为解除\n\n香港结算视当天（T日）为非交收日，改日原本的证券和资金交收会顺延至下一个交收日。\n即T-2日交易的交收顺延至T+1交收，T-1日交易的交收顺延至T+2交收。\n\n#### 情况二：台风讯号9点后发出，12点未解除\n\n香港结算当日仅作证券交收，资金顺延至下一交收日处理，该日视作为交收日。\n即：T-2日交易的资金交收顺延至T+1交收，T-1日交易的资金交收顺延至T+2交收。\n如黑色暴雨警告在9点后发出，则该日正常进行证券和资金的交收。\n\n#### 情况三：台风讯号发出又被解除\n\n开市前发出，7点至9点期间解除，则开始前时段被取消，后两小时恢复交易，开始时间必须为整点或者30分。；\n如在11点到12点之前解除，开市前阶段以及早上交易阶段被取消，下午交易时间顺延两个小时进行，开始时间必须为整点或者30分。\n\n\n#### 情况四：圣诞、元旦、农历新年前夕\n若圣诞节、元旦和农历新年前一天不是周末，则该日上午有交易，但非交收日。\n即：T-2日交易的资金交收顺延至T+1日交收，T-1日和T日的交易交收顺延至T+2交收。\n\n\n## 沪港与深港的区别\n\n### 结算汇率\n\n参考汇率相同，结算汇率不同。\n\n1.独立换汇：深、沪结算分公司独立换汇\n2.机制相同：深、沪两司换汇机制相同，每日参考汇率完全一致。\n3.成本分摊不同： 由于沪深两所交易量不同，按照买卖轧差摊分成本之后，汇率分摊至投资者可能存在较少差异。\n\n### 沪港、深港卖出、资金使用、账户体系的差异\n\n1.沪深港股通证券账户股票不能交叉卖出。\n2.沪深港股资金账户资金可以交叉使用。\n3.沪深两所账户体系不同。上交所指定交易，深交所可转托管。\n\n## 常用术语\n\n蓝筹股：本地实力雄厚的上市公司发行的股票，在香港，恒生指数的成分股一般皆被视为蓝筹股；\n\n红筹股：由中国内地机构控股并注册地在中国大陆以外的公司发行的股票；\n\nH股：也称国企股，由中国内地机构控股且注册地在中国大陆的公司发行的股票；\n\n仙股：“仙”是香港人对英语`cent`的译音，指价格低于1元，只能以分作为计价单位的股票；\n\n孖展：一词来自香港，英文为Margin，即保证金的意思。孖展投资者通过银行和证券公司提供融资服务，进行杠杆投资；\n\n沽空：类似融券业务，投资者通过证券公司就介入证券卖出，并在约定时间内购回还给公司。\n\n毫子股：香港专有用语，指股价低于 港币1元，但高于港币1角的股票\n\n红底股：香港专有用语，指股价超过港币100元的股票\n\n神仙股：香港专有用语，指涨跌幅很大的股票\n\n细价股：小盘股\n\n竞价盘：没有指定价格而在开市前时段的输入买卖盘时段或对盘前时段输入系统，以在开市前时段的对盘时段内，按开市前时段的对盘前时段结束时计算所得的参考平衡价格进行自动对盘的买盘或沽盘；\n\n竞价限价盘：有指定价格而在开市前时段的输入买卖盘时段输入系统，以在开市前时段的对盘时段内，于买盘指定价格相等于或高于参考平衡价格时，或于卖盘指定价格相等于或低于参考平衡价格时，按开市前时段的对盘前时段结束时计算所得的参考平衡价格进行自动对盘的买盘或沽盘；\n\n特别限价盘：一个在持续交易时段输入系统有指定价格的买盘或沽盘，根据下列价格在该时段内进行自动配对：\n\n\n\n","slug":"业务知识总结/沪港通,深港通总结","published":1,"updated":"2019-03-22T14:44:36.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0q009z4l3npqcl1wo0","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"何为沪港通-深港通\"><a href=\"#何为沪港通-深港通\" class=\"headerlink\" title=\"何为沪港通,深港通\"></a>何为沪港通,深港通</h3><p>沪港通是沪港股票市场交易互联互通机制的简称,包括沪股通和港股通两个部分.沪股通即香港投资者可以委托香港经纪商,通过联交所设立的证券交易服务公司(SPV),向上交所申报股票的买卖.港股通则反之。</p>\n<p>深港通即为深圳交易所和香港联合交易所互通互联.</p>\n<a id=\"more\"></a>\n<h3 id=\"港股通标的\"><a href=\"#港股通标的\" class=\"headerlink\" title=\"港股通标的\"></a>港股通标的</h3><table>\n<thead>\n<tr>\n<th>差异对比点</th>\n<th style=\"text-align:left\">深港通</th>\n<th style=\"text-align:left\">沪港通</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>参考指数</td>\n<td style=\"text-align:left\">恒生大型股指数,中型股指数,小型股指数</td>\n<td style=\"text-align:left\">恒生大型股指数,中型股指数,小型股指数</td>\n</tr>\n<tr>\n<td>市值筛选条件</td>\n<td style=\"text-align:left\">恒生综合小型股指数成分股,且成分股定期调整考察截止日（注1）</td>\n<td style=\"text-align:left\">无</td>\n</tr>\n<tr>\n<td>A+H股相应标的</td>\n<td style=\"text-align:left\">沪、深两所上市A+H股公司的相应的主板H股</td>\n<td style=\"text-align:left\">上交所上市A+H股公司的相应H股</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>注1</strong>:恒生综合小型股指数成分股考察12个月港股平均月末市值不低于50亿元,并且对A+H股不做市值参考</li>\n</ul>\n<h3 id=\"港股通额度控制\"><a href=\"#港股通额度控制\" class=\"headerlink\" title=\"港股通额度控制\"></a>港股通额度控制</h3><p>沪港通无总额度控制，每日额度有限制。沪股通的额度为130亿元，沪港通的额度为105亿元。深港通同理。</p>\n<h2 id=\"交易规则\"><a href=\"#交易规则\" class=\"headerlink\" title=\"交易规则\"></a>交易规则</h2><h3 id=\"港股与A股交易规则的差异\"><a href=\"#港股与A股交易规则的差异\" class=\"headerlink\" title=\"港股与A股交易规则的差异\"></a>港股与A股交易规则的差异</h3><table>\n<thead>\n<tr>\n<th>项目</th>\n<th style=\"text-align:left\">港股</th>\n<th style=\"text-align:left\">A股</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>交易单位</td>\n<td style=\"text-align:left\">交易规则没有相关规定，由发行公司自行决定。没手股数不等</td>\n<td style=\"text-align:left\">买入100股或其整数倍，卖出余额不足100股应当一次性申报卖出</td>\n</tr>\n<tr>\n<td>涨跌幅限制</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">10%</td>\n</tr>\n<tr>\n<td>交易规则</td>\n<td style=\"text-align:left\">T+0，当天买卖次数无限制</td>\n<td style=\"text-align:left\">T+1</td>\n</tr>\n<tr>\n<td>交收规则</td>\n<td style=\"text-align:left\">T+2交收，卖出股票的资金T+3日可取，如遇八号风暴等原因可能会延迟交收，一般警报解除后两小时开始交易</td>\n<td style=\"text-align:left\">T+1交收，卖出股票资金T+1可取</td>\n</tr>\n<tr>\n<td>交易时间</td>\n<td style=\"text-align:left\">两地都可以进行正常交易和结算的交易日<strong>（注1）</strong></td>\n<td style=\"text-align:left\">周一至周五（国家法定节假日和公告的休市时间除外）<strong>（注2）</strong></td>\n</tr>\n<tr>\n<td>最小报价单位</td>\n<td style=\"text-align:left\">不同价位8种价差</td>\n<td style=\"text-align:left\">价差为0.01元</td>\n</tr>\n<tr>\n<td>报单价格限制</td>\n<td style=\"text-align:left\">24个价位/10个价位</td>\n<td style=\"text-align:left\">涨跌幅内</td>\n</tr>\n<tr>\n<td>申报数量</td>\n<td style=\"text-align:left\">每个买卖盘手数上限为3000手，每一个经纪代号的未执行买卖盘不设上限，每个买卖盘股数上限为99,999,999</td>\n<td style=\"text-align:left\">股票（基金）单笔申报最大数量应当低于100万股，债券单笔申报最大数量应当低于等于1万手</td>\n</tr>\n<tr>\n<td>零股（碎股）买卖</td>\n<td style=\"text-align:left\">零股买卖暂时仅可卖出不可买入，联交所的交易系统不会为碎股提供自动对盘交易，而是在系统内设有“碎股/特别买卖单位市场”供碎股交易</td>\n<td style=\"text-align:left\">低于100股的股票必须一次性卖出，不允许再分次卖出</td>\n</tr>\n<tr>\n<td>交易币种</td>\n<td style=\"text-align:left\">以港币报价，以人民币实际支付收取</td>\n<td style=\"text-align:left\">人民币</td>\n</tr>\n<tr>\n<td>融资融券</td>\n<td style=\"text-align:left\">港股通投资者不得参与港市融资融券交易，更不允许裸卖空</td>\n<td style=\"text-align:left\">只有某些指定的股票可以融资买入卖出<strong>（注3）</strong></td>\n</tr>\n<tr>\n<td>股票数字位数</td>\n<td style=\"text-align:left\">5位</td>\n<td style=\"text-align:left\">6位</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>注1</strong>:圣诞节前夕，新年前夕，元旦节前夕只有上半天交易日。9:00 - 9:15(竞价盘，竞价限价盘)，9:15-9:20（竞价盘，禁止改单撤单），9:20-9:28，对盘阶段，禁止下单，9:28 - 9:30 暂停阶段，9:30 - 12:00,13:00-16:00 持续交易阶段 (增强限价盘)。</li>\n<li><strong>注2</strong>：开盘集合竞价:9:15 - 9:25,连续竞价：9:30 - 11:30,13:00 - 15:00</li>\n<li><strong>注3</strong>：有关交易所指定的允许融资融券的证券名单可在交易所官网获得。</li>\n</ul>\n<p><strong>报价规则</strong>：最先买盘价（在当日没有最先沽盘的情况下）或最先沽盘价（在当日没有最先买盘的情况下）不得偏离上日收市价（如有）九倍或以上。</p>\n<h2 id=\"清算结算\"><a href=\"#清算结算\" class=\"headerlink\" title=\"清算结算\"></a>清算结算</h2><h3 id=\"结算原则\"><a href=\"#结算原则\" class=\"headerlink\" title=\"结算原则\"></a>结算原则</h3><p>两级结算、净额清算、担保交收，人民币结算。</p>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th style=\"text-align:left\">中国结算</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T日</td>\n<td style=\"text-align:left\">日终：1.交易清算；<br> 2.在人命比资金到账后，进行公司行为业务清算；<br> 3、风控资金清算；<br> 4.根据上日持有以及收盘价，计算证券组合费。<br>上述清算各分外币和人民币两次进行，数据当日发送结算参与人。</td>\n</tr>\n<tr>\n<td>T+1日</td>\n<td style=\"text-align:left\">10:30：根据T日分控资金、公司行为类资金清算结果进行参与人资金交收。<br> 18：00：对T日证券组合费清算结果进行交收。</td>\n</tr>\n<tr>\n<td>T+2日</td>\n<td style=\"text-align:left\">13:30：根据T日清算结果，进行参与人<strong>应付</strong>交易清算资金交收。<br>18:00：根据T日清算结果，进行参与人<strong>应收</strong>交易清算资金交收。<br>日终：对T日交易安证券账户逐笔进行证券交收。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"两次清算\"><a href=\"#两次清算\" class=\"headerlink\" title=\"两次清算\"></a>两次清算</h3><p>原因是因为用港币交易，人民币清算，需要换汇。</p>\n<ul>\n<li>换汇银行向中国结算提供参考汇率，前台系统显示。</li>\n<li>首次清算：T日日终，以备付金账户为单位，进行港币清算。</li>\n<li>汇总计算T+2日全部港币应收/应付金额并通知换汇银行。</li>\n<li>T日日终，换汇银行提供换汇汇率，用于T+2交收。</li>\n<li>二次清算：分摊换汇成本，计算汇兑比率，进行二次人民币清算，并将清算数据发送参与人。</li>\n</ul>\n<p>T+2日交收主要是流程原因，T+1做产品层面的交收，T+2日做结算参与人层面的交收。有因为香港市场还有实物股票的情况，所以给大家留的交收时间比较充分。</p>\n<h3 id=\"证券组合费\"><a href=\"#证券组合费\" class=\"headerlink\" title=\"证券组合费\"></a>证券组合费</h3><p>(1) 以上一日日终持有的市值为基础，每个自然日收取；<br>(2) 对于周末和假日的情况，顺延到下一工作日计算。例如，周一计算上周五、周六以及周日的证券组合费；<br>(3) 遇香港交易境内放假或者香港方向境内正常交易的，收盘价取前一港股通工作日的收盘价；<br>(4) 实行超额累退费率；日费率等于年费除以365；</p>\n<h3 id=\"港股交易日期\"><a href=\"#港股交易日期\" class=\"headerlink\" title=\"港股交易日期\"></a>港股交易日期</h3><p>基本原则：</p>\n<ul>\n<li>“最小交集”：交易日仅在沪港两地均为交易日且能够满足结算安排时开通。</li>\n<li>境内放假、香港放假的均不作为交易日和交收日；</li>\n<li>若境内放假香港不放假，为避免资金交收违约，境内放假前两天不作为港股通交易日，但为交收日。</li>\n</ul>\n<h3 id=\"特殊清算交收安排\"><a href=\"#特殊清算交收安排\" class=\"headerlink\" title=\"特殊清算交收安排\"></a>特殊清算交收安排</h3><p>遇特定节假日、恶劣天气等情况，香港市场会在交易、结算等方面做出特殊安排，届时中国结算应做出相应调整，并及时通知市场。</p>\n<h4 id=\"情况一：台风-黑色暴雨警告9点前发出，12点为解除\"><a href=\"#情况一：台风-黑色暴雨警告9点前发出，12点为解除\" class=\"headerlink\" title=\"情况一：台风/黑色暴雨警告9点前发出，12点为解除\"></a>情况一：台风/黑色暴雨警告9点前发出，12点为解除</h4><p>香港结算视当天（T日）为非交收日，改日原本的证券和资金交收会顺延至下一个交收日。<br>即T-2日交易的交收顺延至T+1交收，T-1日交易的交收顺延至T+2交收。</p>\n<h4 id=\"情况二：台风讯号9点后发出，12点未解除\"><a href=\"#情况二：台风讯号9点后发出，12点未解除\" class=\"headerlink\" title=\"情况二：台风讯号9点后发出，12点未解除\"></a>情况二：台风讯号9点后发出，12点未解除</h4><p>香港结算当日仅作证券交收，资金顺延至下一交收日处理，该日视作为交收日。<br>即：T-2日交易的资金交收顺延至T+1交收，T-1日交易的资金交收顺延至T+2交收。<br>如黑色暴雨警告在9点后发出，则该日正常进行证券和资金的交收。</p>\n<h4 id=\"情况三：台风讯号发出又被解除\"><a href=\"#情况三：台风讯号发出又被解除\" class=\"headerlink\" title=\"情况三：台风讯号发出又被解除\"></a>情况三：台风讯号发出又被解除</h4><p>开市前发出，7点至9点期间解除，则开始前时段被取消，后两小时恢复交易，开始时间必须为整点或者30分。；<br>如在11点到12点之前解除，开市前阶段以及早上交易阶段被取消，下午交易时间顺延两个小时进行，开始时间必须为整点或者30分。</p>\n<h4 id=\"情况四：圣诞、元旦、农历新年前夕\"><a href=\"#情况四：圣诞、元旦、农历新年前夕\" class=\"headerlink\" title=\"情况四：圣诞、元旦、农历新年前夕\"></a>情况四：圣诞、元旦、农历新年前夕</h4><p>若圣诞节、元旦和农历新年前一天不是周末，则该日上午有交易，但非交收日。<br>即：T-2日交易的资金交收顺延至T+1日交收，T-1日和T日的交易交收顺延至T+2交收。</p>\n<h2 id=\"沪港与深港的区别\"><a href=\"#沪港与深港的区别\" class=\"headerlink\" title=\"沪港与深港的区别\"></a>沪港与深港的区别</h2><h3 id=\"结算汇率\"><a href=\"#结算汇率\" class=\"headerlink\" title=\"结算汇率\"></a>结算汇率</h3><p>参考汇率相同，结算汇率不同。</p>\n<p>1.独立换汇：深、沪结算分公司独立换汇<br>2.机制相同：深、沪两司换汇机制相同，每日参考汇率完全一致。<br>3.成本分摊不同： 由于沪深两所交易量不同，按照买卖轧差摊分成本之后，汇率分摊至投资者可能存在较少差异。</p>\n<h3 id=\"沪港、深港卖出、资金使用、账户体系的差异\"><a href=\"#沪港、深港卖出、资金使用、账户体系的差异\" class=\"headerlink\" title=\"沪港、深港卖出、资金使用、账户体系的差异\"></a>沪港、深港卖出、资金使用、账户体系的差异</h3><p>1.沪深港股通证券账户股票不能交叉卖出。<br>2.沪深港股资金账户资金可以交叉使用。<br>3.沪深两所账户体系不同。上交所指定交易，深交所可转托管。</p>\n<h2 id=\"常用术语\"><a href=\"#常用术语\" class=\"headerlink\" title=\"常用术语\"></a>常用术语</h2><p>蓝筹股：本地实力雄厚的上市公司发行的股票，在香港，恒生指数的成分股一般皆被视为蓝筹股；</p>\n<p>红筹股：由中国内地机构控股并注册地在中国大陆以外的公司发行的股票；</p>\n<p>H股：也称国企股，由中国内地机构控股且注册地在中国大陆的公司发行的股票；</p>\n<p>仙股：“仙”是香港人对英语<code>cent</code>的译音，指价格低于1元，只能以分作为计价单位的股票；</p>\n<p>孖展：一词来自香港，英文为Margin，即保证金的意思。孖展投资者通过银行和证券公司提供融资服务，进行杠杆投资；</p>\n<p>沽空：类似融券业务，投资者通过证券公司就介入证券卖出，并在约定时间内购回还给公司。</p>\n<p>毫子股：香港专有用语，指股价低于 港币1元，但高于港币1角的股票</p>\n<p>红底股：香港专有用语，指股价超过港币100元的股票</p>\n<p>神仙股：香港专有用语，指涨跌幅很大的股票</p>\n<p>细价股：小盘股</p>\n<p>竞价盘：没有指定价格而在开市前时段的输入买卖盘时段或对盘前时段输入系统，以在开市前时段的对盘时段内，按开市前时段的对盘前时段结束时计算所得的参考平衡价格进行自动对盘的买盘或沽盘；</p>\n<p>竞价限价盘：有指定价格而在开市前时段的输入买卖盘时段输入系统，以在开市前时段的对盘时段内，于买盘指定价格相等于或高于参考平衡价格时，或于卖盘指定价格相等于或低于参考平衡价格时，按开市前时段的对盘前时段结束时计算所得的参考平衡价格进行自动对盘的买盘或沽盘；</p>\n<p>特别限价盘：一个在持续交易时段输入系统有指定价格的买盘或沽盘，根据下列价格在该时段内进行自动配对：</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><h3 id=\"何为沪港通-深港通\"><a href=\"#何为沪港通-深港通\" class=\"headerlink\" title=\"何为沪港通,深港通\"></a>何为沪港通,深港通</h3><p>沪港通是沪港股票市场交易互联互通机制的简称,包括沪股通和港股通两个部分.沪股通即香港投资者可以委托香港经纪商,通过联交所设立的证券交易服务公司(SPV),向上交所申报股票的买卖.港股通则反之。</p>\n<p>深港通即为深圳交易所和香港联合交易所互通互联.</p>","more":"<h3 id=\"港股通标的\"><a href=\"#港股通标的\" class=\"headerlink\" title=\"港股通标的\"></a>港股通标的</h3><table>\n<thead>\n<tr>\n<th>差异对比点</th>\n<th style=\"text-align:left\">深港通</th>\n<th style=\"text-align:left\">沪港通</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>参考指数</td>\n<td style=\"text-align:left\">恒生大型股指数,中型股指数,小型股指数</td>\n<td style=\"text-align:left\">恒生大型股指数,中型股指数,小型股指数</td>\n</tr>\n<tr>\n<td>市值筛选条件</td>\n<td style=\"text-align:left\">恒生综合小型股指数成分股,且成分股定期调整考察截止日（注1）</td>\n<td style=\"text-align:left\">无</td>\n</tr>\n<tr>\n<td>A+H股相应标的</td>\n<td style=\"text-align:left\">沪、深两所上市A+H股公司的相应的主板H股</td>\n<td style=\"text-align:left\">上交所上市A+H股公司的相应H股</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>注1</strong>:恒生综合小型股指数成分股考察12个月港股平均月末市值不低于50亿元,并且对A+H股不做市值参考</li>\n</ul>\n<h3 id=\"港股通额度控制\"><a href=\"#港股通额度控制\" class=\"headerlink\" title=\"港股通额度控制\"></a>港股通额度控制</h3><p>沪港通无总额度控制，每日额度有限制。沪股通的额度为130亿元，沪港通的额度为105亿元。深港通同理。</p>\n<h2 id=\"交易规则\"><a href=\"#交易规则\" class=\"headerlink\" title=\"交易规则\"></a>交易规则</h2><h3 id=\"港股与A股交易规则的差异\"><a href=\"#港股与A股交易规则的差异\" class=\"headerlink\" title=\"港股与A股交易规则的差异\"></a>港股与A股交易规则的差异</h3><table>\n<thead>\n<tr>\n<th>项目</th>\n<th style=\"text-align:left\">港股</th>\n<th style=\"text-align:left\">A股</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>交易单位</td>\n<td style=\"text-align:left\">交易规则没有相关规定，由发行公司自行决定。没手股数不等</td>\n<td style=\"text-align:left\">买入100股或其整数倍，卖出余额不足100股应当一次性申报卖出</td>\n</tr>\n<tr>\n<td>涨跌幅限制</td>\n<td style=\"text-align:left\">无</td>\n<td style=\"text-align:left\">10%</td>\n</tr>\n<tr>\n<td>交易规则</td>\n<td style=\"text-align:left\">T+0，当天买卖次数无限制</td>\n<td style=\"text-align:left\">T+1</td>\n</tr>\n<tr>\n<td>交收规则</td>\n<td style=\"text-align:left\">T+2交收，卖出股票的资金T+3日可取，如遇八号风暴等原因可能会延迟交收，一般警报解除后两小时开始交易</td>\n<td style=\"text-align:left\">T+1交收，卖出股票资金T+1可取</td>\n</tr>\n<tr>\n<td>交易时间</td>\n<td style=\"text-align:left\">两地都可以进行正常交易和结算的交易日<strong>（注1）</strong></td>\n<td style=\"text-align:left\">周一至周五（国家法定节假日和公告的休市时间除外）<strong>（注2）</strong></td>\n</tr>\n<tr>\n<td>最小报价单位</td>\n<td style=\"text-align:left\">不同价位8种价差</td>\n<td style=\"text-align:left\">价差为0.01元</td>\n</tr>\n<tr>\n<td>报单价格限制</td>\n<td style=\"text-align:left\">24个价位/10个价位</td>\n<td style=\"text-align:left\">涨跌幅内</td>\n</tr>\n<tr>\n<td>申报数量</td>\n<td style=\"text-align:left\">每个买卖盘手数上限为3000手，每一个经纪代号的未执行买卖盘不设上限，每个买卖盘股数上限为99,999,999</td>\n<td style=\"text-align:left\">股票（基金）单笔申报最大数量应当低于100万股，债券单笔申报最大数量应当低于等于1万手</td>\n</tr>\n<tr>\n<td>零股（碎股）买卖</td>\n<td style=\"text-align:left\">零股买卖暂时仅可卖出不可买入，联交所的交易系统不会为碎股提供自动对盘交易，而是在系统内设有“碎股/特别买卖单位市场”供碎股交易</td>\n<td style=\"text-align:left\">低于100股的股票必须一次性卖出，不允许再分次卖出</td>\n</tr>\n<tr>\n<td>交易币种</td>\n<td style=\"text-align:left\">以港币报价，以人民币实际支付收取</td>\n<td style=\"text-align:left\">人民币</td>\n</tr>\n<tr>\n<td>融资融券</td>\n<td style=\"text-align:left\">港股通投资者不得参与港市融资融券交易，更不允许裸卖空</td>\n<td style=\"text-align:left\">只有某些指定的股票可以融资买入卖出<strong>（注3）</strong></td>\n</tr>\n<tr>\n<td>股票数字位数</td>\n<td style=\"text-align:left\">5位</td>\n<td style=\"text-align:left\">6位</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li><strong>注1</strong>:圣诞节前夕，新年前夕，元旦节前夕只有上半天交易日。9:00 - 9:15(竞价盘，竞价限价盘)，9:15-9:20（竞价盘，禁止改单撤单），9:20-9:28，对盘阶段，禁止下单，9:28 - 9:30 暂停阶段，9:30 - 12:00,13:00-16:00 持续交易阶段 (增强限价盘)。</li>\n<li><strong>注2</strong>：开盘集合竞价:9:15 - 9:25,连续竞价：9:30 - 11:30,13:00 - 15:00</li>\n<li><strong>注3</strong>：有关交易所指定的允许融资融券的证券名单可在交易所官网获得。</li>\n</ul>\n<p><strong>报价规则</strong>：最先买盘价（在当日没有最先沽盘的情况下）或最先沽盘价（在当日没有最先买盘的情况下）不得偏离上日收市价（如有）九倍或以上。</p>\n<h2 id=\"清算结算\"><a href=\"#清算结算\" class=\"headerlink\" title=\"清算结算\"></a>清算结算</h2><h3 id=\"结算原则\"><a href=\"#结算原则\" class=\"headerlink\" title=\"结算原则\"></a>结算原则</h3><p>两级结算、净额清算、担保交收，人民币结算。</p>\n<table>\n<thead>\n<tr>\n<th>时间</th>\n<th style=\"text-align:left\">中国结算</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>T日</td>\n<td style=\"text-align:left\">日终：1.交易清算；<br> 2.在人命比资金到账后，进行公司行为业务清算；<br> 3、风控资金清算；<br> 4.根据上日持有以及收盘价，计算证券组合费。<br>上述清算各分外币和人民币两次进行，数据当日发送结算参与人。</td>\n</tr>\n<tr>\n<td>T+1日</td>\n<td style=\"text-align:left\">10:30：根据T日分控资金、公司行为类资金清算结果进行参与人资金交收。<br> 18：00：对T日证券组合费清算结果进行交收。</td>\n</tr>\n<tr>\n<td>T+2日</td>\n<td style=\"text-align:left\">13:30：根据T日清算结果，进行参与人<strong>应付</strong>交易清算资金交收。<br>18:00：根据T日清算结果，进行参与人<strong>应收</strong>交易清算资金交收。<br>日终：对T日交易安证券账户逐笔进行证券交收。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"两次清算\"><a href=\"#两次清算\" class=\"headerlink\" title=\"两次清算\"></a>两次清算</h3><p>原因是因为用港币交易，人民币清算，需要换汇。</p>\n<ul>\n<li>换汇银行向中国结算提供参考汇率，前台系统显示。</li>\n<li>首次清算：T日日终，以备付金账户为单位，进行港币清算。</li>\n<li>汇总计算T+2日全部港币应收/应付金额并通知换汇银行。</li>\n<li>T日日终，换汇银行提供换汇汇率，用于T+2交收。</li>\n<li>二次清算：分摊换汇成本，计算汇兑比率，进行二次人民币清算，并将清算数据发送参与人。</li>\n</ul>\n<p>T+2日交收主要是流程原因，T+1做产品层面的交收，T+2日做结算参与人层面的交收。有因为香港市场还有实物股票的情况，所以给大家留的交收时间比较充分。</p>\n<h3 id=\"证券组合费\"><a href=\"#证券组合费\" class=\"headerlink\" title=\"证券组合费\"></a>证券组合费</h3><p>(1) 以上一日日终持有的市值为基础，每个自然日收取；<br>(2) 对于周末和假日的情况，顺延到下一工作日计算。例如，周一计算上周五、周六以及周日的证券组合费；<br>(3) 遇香港交易境内放假或者香港方向境内正常交易的，收盘价取前一港股通工作日的收盘价；<br>(4) 实行超额累退费率；日费率等于年费除以365；</p>\n<h3 id=\"港股交易日期\"><a href=\"#港股交易日期\" class=\"headerlink\" title=\"港股交易日期\"></a>港股交易日期</h3><p>基本原则：</p>\n<ul>\n<li>“最小交集”：交易日仅在沪港两地均为交易日且能够满足结算安排时开通。</li>\n<li>境内放假、香港放假的均不作为交易日和交收日；</li>\n<li>若境内放假香港不放假，为避免资金交收违约，境内放假前两天不作为港股通交易日，但为交收日。</li>\n</ul>\n<h3 id=\"特殊清算交收安排\"><a href=\"#特殊清算交收安排\" class=\"headerlink\" title=\"特殊清算交收安排\"></a>特殊清算交收安排</h3><p>遇特定节假日、恶劣天气等情况，香港市场会在交易、结算等方面做出特殊安排，届时中国结算应做出相应调整，并及时通知市场。</p>\n<h4 id=\"情况一：台风-黑色暴雨警告9点前发出，12点为解除\"><a href=\"#情况一：台风-黑色暴雨警告9点前发出，12点为解除\" class=\"headerlink\" title=\"情况一：台风/黑色暴雨警告9点前发出，12点为解除\"></a>情况一：台风/黑色暴雨警告9点前发出，12点为解除</h4><p>香港结算视当天（T日）为非交收日，改日原本的证券和资金交收会顺延至下一个交收日。<br>即T-2日交易的交收顺延至T+1交收，T-1日交易的交收顺延至T+2交收。</p>\n<h4 id=\"情况二：台风讯号9点后发出，12点未解除\"><a href=\"#情况二：台风讯号9点后发出，12点未解除\" class=\"headerlink\" title=\"情况二：台风讯号9点后发出，12点未解除\"></a>情况二：台风讯号9点后发出，12点未解除</h4><p>香港结算当日仅作证券交收，资金顺延至下一交收日处理，该日视作为交收日。<br>即：T-2日交易的资金交收顺延至T+1交收，T-1日交易的资金交收顺延至T+2交收。<br>如黑色暴雨警告在9点后发出，则该日正常进行证券和资金的交收。</p>\n<h4 id=\"情况三：台风讯号发出又被解除\"><a href=\"#情况三：台风讯号发出又被解除\" class=\"headerlink\" title=\"情况三：台风讯号发出又被解除\"></a>情况三：台风讯号发出又被解除</h4><p>开市前发出，7点至9点期间解除，则开始前时段被取消，后两小时恢复交易，开始时间必须为整点或者30分。；<br>如在11点到12点之前解除，开市前阶段以及早上交易阶段被取消，下午交易时间顺延两个小时进行，开始时间必须为整点或者30分。</p>\n<h4 id=\"情况四：圣诞、元旦、农历新年前夕\"><a href=\"#情况四：圣诞、元旦、农历新年前夕\" class=\"headerlink\" title=\"情况四：圣诞、元旦、农历新年前夕\"></a>情况四：圣诞、元旦、农历新年前夕</h4><p>若圣诞节、元旦和农历新年前一天不是周末，则该日上午有交易，但非交收日。<br>即：T-2日交易的资金交收顺延至T+1日交收，T-1日和T日的交易交收顺延至T+2交收。</p>\n<h2 id=\"沪港与深港的区别\"><a href=\"#沪港与深港的区别\" class=\"headerlink\" title=\"沪港与深港的区别\"></a>沪港与深港的区别</h2><h3 id=\"结算汇率\"><a href=\"#结算汇率\" class=\"headerlink\" title=\"结算汇率\"></a>结算汇率</h3><p>参考汇率相同，结算汇率不同。</p>\n<p>1.独立换汇：深、沪结算分公司独立换汇<br>2.机制相同：深、沪两司换汇机制相同，每日参考汇率完全一致。<br>3.成本分摊不同： 由于沪深两所交易量不同，按照买卖轧差摊分成本之后，汇率分摊至投资者可能存在较少差异。</p>\n<h3 id=\"沪港、深港卖出、资金使用、账户体系的差异\"><a href=\"#沪港、深港卖出、资金使用、账户体系的差异\" class=\"headerlink\" title=\"沪港、深港卖出、资金使用、账户体系的差异\"></a>沪港、深港卖出、资金使用、账户体系的差异</h3><p>1.沪深港股通证券账户股票不能交叉卖出。<br>2.沪深港股资金账户资金可以交叉使用。<br>3.沪深两所账户体系不同。上交所指定交易，深交所可转托管。</p>\n<h2 id=\"常用术语\"><a href=\"#常用术语\" class=\"headerlink\" title=\"常用术语\"></a>常用术语</h2><p>蓝筹股：本地实力雄厚的上市公司发行的股票，在香港，恒生指数的成分股一般皆被视为蓝筹股；</p>\n<p>红筹股：由中国内地机构控股并注册地在中国大陆以外的公司发行的股票；</p>\n<p>H股：也称国企股，由中国内地机构控股且注册地在中国大陆的公司发行的股票；</p>\n<p>仙股：“仙”是香港人对英语<code>cent</code>的译音，指价格低于1元，只能以分作为计价单位的股票；</p>\n<p>孖展：一词来自香港，英文为Margin，即保证金的意思。孖展投资者通过银行和证券公司提供融资服务，进行杠杆投资；</p>\n<p>沽空：类似融券业务，投资者通过证券公司就介入证券卖出，并在约定时间内购回还给公司。</p>\n<p>毫子股：香港专有用语，指股价低于 港币1元，但高于港币1角的股票</p>\n<p>红底股：香港专有用语，指股价超过港币100元的股票</p>\n<p>神仙股：香港专有用语，指涨跌幅很大的股票</p>\n<p>细价股：小盘股</p>\n<p>竞价盘：没有指定价格而在开市前时段的输入买卖盘时段或对盘前时段输入系统，以在开市前时段的对盘时段内，按开市前时段的对盘前时段结束时计算所得的参考平衡价格进行自动对盘的买盘或沽盘；</p>\n<p>竞价限价盘：有指定价格而在开市前时段的输入买卖盘时段输入系统，以在开市前时段的对盘时段内，于买盘指定价格相等于或高于参考平衡价格时，或于卖盘指定价格相等于或低于参考平衡价格时，按开市前时段的对盘前时段结束时计算所得的参考平衡价格进行自动对盘的买盘或沽盘；</p>\n<p>特别限价盘：一个在持续交易时段输入系统有指定价格的买盘或沽盘，根据下列价格在该时段内进行自动配对：</p>"},{"title":"优化你的 nexT","date":"2016-04-07T05:07:57.000Z","_content":"\n\n![next](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-7/64957320.jpg)\n## 什么是NexT？\n[NexT](https://github.com/iissnan/hexo-theme-next)为hexo一个较为经典的主题，我的博客目前所用的就是这个主题。感谢作者[iissnan](https://github.com/iissnan)的提供。<!-- more -->\n\n\n`NexT` 主旨在于简洁优雅且易于使用，所以首先要尽量确保 `NexT` 的简洁易用性。在保证其原有的基础上，我对其一些基本功能进行了优化。\n如果你也想尝试与我一样的主题，可以参考[NexT帮助文档](http://theme-next.iissnan.com/getting-started.html)来个性化你的`NexT`。或者你也可以选择一个Hexo主题：\n>选择主题建议遵循KISS原则,即简单就是美。\n\n* Hexo Themes - http://hexo.io/themes/\n* Jacman - http://wsgzao.github.io/post/hexo-jacman/\n\n## 如何设置阅读全文\n`hexo`提供了在文章中使用 <!-- more --> 手动进行截断的方式，前提是需要在主题文件夹下的`_config.yml`设置：\n>scroll\\_to\\_more: true\n\n## hexo NexT主题首页title的优化\n更改`index.swig`文件，文件路径为`your-hexo-site\\themes\\next\\layout`，将下面代码\n\n```\n\t{% block title %} {{ config.title }} {% endblock %}\n```\n\n更改为\n\n```\n\t{% block title %} {{ config.title }} - {{ theme.description }} {% endblock %}\n```\n\n即可实现使你的首页显示`网站名称 - 网站描述`这种格式了。\n\n## 设置最近访客菜单\n本设置参考学习了`arao`的博客[动动手指，给你的Hexo站点添加最近访客（多说篇）](http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/)，并且将多说评论UA与其相结合，实现了最近访客功能以及评论栏的背景及评论栏头像360度旋转。\n## 第三方服务配置\n第一次接触的`NexT`的时候，按照教程来还是遇到了挺多的问题。在集成第三方服务的时候，由于`NexT`默认使用国外比较流行的disqus，为了与国内相匹配，我将其修改为“多说”评论系统。\n\n在每一条多说的评论之后我想要显示出评论者所使用的代理消息（如 操作系统、浏览器），可是按照教程之后发现并没有出现。![](http://theme-next.iissnan.com/uploads/duoshuo-ua.png)\n\n后参考了HelloDog的博客[多说自定义CSS头像和多说评论显示UA](http://wsgzao.github.io/post/duoshuo/)才明白需要到多说后台自定义CSS（此CSS样式包括了最近访客功能以及评论栏的背景及评论栏头像360度旋转的功能），具体步骤为：\n\n>注册/登录多说后台->设置->基本设置->自定义CSS\n\n\n\n```\n\t/*UA Start*/\n\tspan.this_ua {\n\t    background-color: #ccc!important;\n\t    border-radius: 4px;\n\t    padding: 0 5px!important;\n\t    margin: 0 1px!important;\n\t    border: 1px solid #BBB!important;\n\t    color: #fff;\n\t    /*text-transform: Capitalize!important;\n\t    float: right!important;\n\t    line-height: 18px!important;*/\n\t}\n\t.this_ua.platform.Windows{\n\t    background-color: #39b3d7!important;\n\t    border-color: #46b8da!important;\n\t}\n\t.this_ua.platform.Linux {\n\t    background-color: #3A3A3A!important;\n\t    border-color: #1F1F1F!important;\n\t}\n\t.this_ua.platform.Ubuntu {\n\t    background-color: #DD4814!important;\n\t    border-color: #DD4814!important;\n\t}\n\t.this_ua.platform.Mac {\n\t    background-color: #666666!important;\n\t    border-color: #666666!important;\n\t}\n\t.this_ua.platform.Android {\n\t    background-color: #98C13D!important;\n\t    border-color: #98C13D!important;\n\t}\n\t.this_ua.platform.iOS {\n\t    background-color: #666666!important;\n\t    border-color: #666666!important;\n\t}\n\t.this_ua.browser.Chrome{\n\t    background-color: #EE6252!important;\n\t    border-color: #EE6252!important;\n\t}\n\t.this_ua.browser.Chromium{\n\t    background-color: #EE6252!important;\n\t    border-color: #EE6252!important;\n\t}\n\t.this_ua.browser.Firefox{\n\t    background-color: #f0ad4e!important;\n\t    border-color: #eea236!important;\n\t}\n\t.this_ua.browser.IE{\n\t    background-color: #428bca!important;\n\t    border-color: #357ebd!important;\n\t}\n\t.this_ua.browser.Edge{\n\t    background-color: #428bca!important;\n\t    border-color: #357ebd!important;\n\t}\n\t.this_ua.browser.Opera{\n\t    background-color: #d9534f!important;\n\t    border-color: #d43f3a!important;\n\t}\n\t.this_ua.browser.Maxthon{\n\t    background-color: #7373B9!important;\n\t    border-color: #7373B9!important;\n\t}\n\t.this_ua.browser.Safari{\n\t    background-color: #666666!important;\n\t    border-color: #666666!important;\n\t}\n\t.this_ua.sskadmin {\n\t    background-color: #00a67c!important;\n\t    border-color: #00a67c!important;\n\t}\n\t/*UA End*/\n\t/*Head Start*/\n\t#ds-thread #ds-reset ul.ds-comments-tabs li.ds-tab a.ds-current {\n\t    border: 0px;\n\t    color: #6D6D6B;\n\t    text-shadow: none;\n\t    background: #F3F3F3;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-highlight {\n\t    font-family: Microsoft YaHei, \"Helvetica Neue\", Helvetica, Arial, Sans-serif;\n\t    ;font-size: 100%;\n\t    color: #6D6D6B !important;\n\t}\n\t\n\t#ds-thread #ds-reset ul.ds-comments-tabs li.ds-tab a.ds-current:hover {\n\t    color: #696a52;\n\t    background: #F2F2F2;\n\t}\n\t\n\t#ds-thread #ds-reset a.ds-highlight:hover {\n\t    color: #696a52 !important;\n\t}\n\t\n\t#ds-thread {\n\t    padding-left: 15px;\n\t}\n\t\n\t#ds-thread #ds-reset li.ds-post,#ds-thread #ds-reset #ds-hot-posts {\n\t    overflow: visible;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-post-self {\n\t    padding: 10px 0 10px 10px;\n\t}\n\t\n\t#ds-thread #ds-reset li.ds-post,#ds-thread #ds-reset .ds-post-self {\n\t    border: 0 !important;\n\t}\n\t\n\t#ds-reset .ds-avatar, #ds-thread #ds-reset ul.ds-children .ds-avatar {\n\t    top: 15px;\n\t    left: -20px;\n\t    padding: 5px;\n\t    width: 36px;\n\t    height: 36px;\n\t    box-shadow: -1px 0 1px rgba(0,0,0,.15) inset;\n\t    border-radius: 46px;\n\t    background: #FAFAFA;\n\t}\n\t\n\t#ds-thread .ds-avatar a {\n\t    display: inline-block;\n\t    padding: 1px;\n\t    width: 32px;\n\t    height: 32px;\n\t    border: 1px solid #b9baa6;\n\t    border-radius: 50%;\n\t    background-color: #fff !important;\n\t}\n\t\n\t#ds-thread .ds-avatar a:hover {\n\t}\n\t\n\t#ds-thread .ds-avatar > img {\n\t    margin: 2px 0 0 2px;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-replybox {\n\t    box-shadow: none;\n\t}\n\t\n\t#ds-thread #ds-reset ul.ds-children .ds-replybox.ds-inline-replybox a.ds-avatar,\n\t#ds-reset .ds-replybox.ds-inline-replybox a.ds-avatar {\n\t    left: 0;\n\t    top: 0;\n\t    padding: 0;\n\t    width: 32px !important;\n\t    height: 32px !important;\n\t    background: none;\n\t    box-shadow: none;\n\t}\n\t\n\t#ds-reset .ds-replybox.ds-inline-replybox a.ds-avatar img {\n\t    width: 32px !important;\n\t    height: 32px !important;\n\t    border-radius: 50%;\n\t}\n\t\n\t#ds-reset .ds-replybox a.ds-avatar,\n\t#ds-reset .ds-replybox .ds-avatar img {\n\t    padding: 0;\n\t    width: 32px !important;\n\t    height: 32px !important;\n\t    border-radius: 5px;\n\t}\n\t\n\t#ds-reset .ds-avatar img {\n\t    width: 32px !important;\n\t    height: 32px !important;\n\t    border-radius: 32px;\n\t    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.22);\n\t    -webkit-transition: .8s all ease-in-out;\n\t    -moz-transition: .4s all ease-in-out;\n\t    -o-transition: .4s all ease-in-out;\n\t    -ms-transition: .4s all ease-in-out;\n\t    transition: .4s all ease-in-out;\n\t}\n\t\n\t.ds-post-self:hover .ds-avatar img {\n\t    -webkit-transform: rotateX(360deg);\n\t    -moz-transform: rotate(360deg);\n\t    -o-transform: rotate(360deg);\n\t    -ms-transform: rotate(360deg);\n\t    transform: rotate(360deg);\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comment-body {\n\t    -webkit-transition-delay: initial;\n\t    -webkit-transition-duration: 0.4s;\n\t    -webkit-transition-property: all;\n\t    -webkit-transition-timing-function: initial;\n\t    background: #F7F7F7;\n\t    padding: 15px 15px 15px 47px;\n\t    border-radius: 5px;\n\t    box-shadow: #B8B9B9 0 1px 3px;\n\t    border: white 1px solid;\n\t}\n\t\n\t#ds-thread #ds-reset ul.ds-children .ds-comment-body {\n\t    padding-left: 15px;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comment-body p {\n\t    color: #787968;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comments {\n\t    border-bottom: 0px;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-powered-by {\n\t    display: none;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comments a.ds-user-name {\n\t    font-weight: normal;\n\t    color: #3D3D3D !important;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comments a.ds-user-name:hover {\n\t    color: #D32 !important;\n\t}\n\t\n\t#ds-thread #ds-reset #ds-bubble {\n\t    display: none !important;\n\t}\n\t\n\t#ds-thread #ds-reset #ds-hot-posts {\n\t    border: 0;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-textarea-wrapper textarea {\n\t\tbackground: url(http://ww4.sinaimg.cn/small/649a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;\n\t}\n\n\t#ds-recent-visitors .ds-avatar {\n\t\tfloat: left\n\t}\n\t/*隐藏多说底部版权*/\n\t#ds-thread #ds-reset .ds-powered-by {\n\t\tdisplay: none;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comment-body:hover {\n\t    background-color: #F1F1F1;\n\t    -webkit-transition-delay: initial;\n\t    -webkit-transition-duration: 0.4s;\n\t    -webkit-transition-property: all;\n\t    -webkit-transition-timing-function: initial;\n\t}\n\t\n```\n\n添加上述代码，最后在命令行中 `hexo cl`&`hexo g`&`hexo s`,最后显示如下图所示：![评论](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-7/11047875.jpg)实现了上述功能。\n\n## 添加`小心！`\n\n再次感谢开源\n\n效果很赞，整个页面渐进式摇摆，摇摆，还有音乐\n\n在 Hexo\\themes\\next\\layout_partials\\header.swig 中的 ul 标签加入如下 li 代码：\n```\n<li> <a title=\"把这个链接拖到你的Chrome收藏夹工具栏中\" href='javascript:(function() {\n    function c() {\n        var e = document.createElement(\"link\");\n        e.setAttribute(\"type\", \"text/css\");\n        e.setAttribute(\"rel\", \"stylesheet\");\n        e.setAttribute(\"href\", f);\n        e.setAttribute(\"class\", l);\n        document.body.appendChild(e)\n    }\n \n    function h() {\n        var e = document.getElementsByClassName(l);\n        for (var t = 0; t < e.length; t++) {\n            document.body.removeChild(e[t])\n        }\n    }\n \n    function p() {\n        var e = document.createElement(\"div\");\n        e.setAttribute(\"class\", a);\n        document.body.appendChild(e);\n        setTimeout(function() {\n            document.body.removeChild(e)\n        }, 100)\n    }\n \n    function d(e) {\n        return {\n            height : e.offsetHeight,\n            width : e.offsetWidth\n        }\n    }\n \n    function v(i) {\n        var s = d(i);\n        return s.height > e && s.height < n && s.width > t && s.width < r\n    }\n \n    function m(e) {\n        var t = e;\n        var n = 0;\n        while (!!t) {\n            n += t.offsetTop;\n            t = t.offsetParent\n        }\n        return n\n    }\n \n    function g() {\n        var e = document.documentElement;\n        if (!!window.innerWidth) {\n            return window.innerHeight\n        } else if (e && !isNaN(e.clientHeight)) {\n            return e.clientHeight\n        }\n        return 0\n    }\n \n    function y() {\n        if (window.pageYOffset) {\n            return window.pageYOffset\n        }\n        return Math.max(document.documentElement.scrollTop, document.body.scrollTop)\n    }\n \n    function E(e) {\n        var t = m(e);\n        return t >= w && t <= b + w\n    }\n \n    function S() {\n        var e = document.createElement(\"audio\");\n        e.setAttribute(\"class\", l);\n        e.src = i;\n        e.loop = false;\n        e.addEventListener(\"canplay\", function() {\n            setTimeout(function() {\n                x(k)\n            }, 500);\n            setTimeout(function() {\n                N();\n                p();\n                for (var e = 0; e < O.length; e++) {\n                    T(O[e])\n                }\n            }, 15500)\n        }, true);\n        e.addEventListener(\"ended\", function() {\n            N();\n            h()\n        }, true);\n        e.innerHTML = \" <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>\";\n        document.body.appendChild(e);\n        e.play()\n    }\n \n    function x(e) {\n        e.className += \" \" + s + \" \" + o\n    }\n \n    function T(e) {\n        e.className += \" \" + s + \" \" + u[Math.floor(Math.random() * u.length)]\n    }\n \n    function N() {\n        var e = document.getElementsByClassName(s);\n        var t = new RegExp(\"\\\\b\" + s + \"\\\\b\");\n        for (var n = 0; n < e.length; ) {\n            e[n].className = e[n].className.replace(t, \"\")\n        }\n    }\n \n    var e = 30;\n    var t = 30;\n    var n = 350;\n    var r = 350;\n    var i = \"//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3\";\n    var s = \"mw-harlem_shake_me\";\n    var o = \"im_first\";\n    var u = [\"im_drunk\", \"im_baked\", \"im_trippin\", \"im_blown\"];\n    var a = \"mw-strobe_light\";\n    var f = \"//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css\";\n    var l = \"mw_added_css\";\n    var b = g();\n    var w = y();\n    var C = document.getElementsByTagName(\"*\");\n    var k = null;\n    for (var L = 0; L < C.length; L++) {\n        var A = C[L];\n        if (v(A)) {\n            if (E(A)) {\n                k = A;\n                break\n            }\n        }\n    }\n    if (A === null) {\n        console.warn(\"Could not find a node of the right size. Please try a different page.\");\n        return\n    }\n    c();\n    S();\n    var O = [];\n    for (var L = 0; L < C.length; L++) {\n        var A = C[L];\n        if (v(A)) {\n            O.push(A)\n        }\n    }\n})()    '>小心！</a> </li>\n```\n很刺激的特效 = =\n\n总体感觉，nexT的主题很有特色，简单，有极客范。","source":"_posts/博客相关/优化你的 nexT.md","raw":"---\ntitle: 优化你的 nexT\ndate: 2016-04-07 13:07:57\ntags:\n- hexo\n- nexT优化\ncategories: 优化\n---\n\n\n![next](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-7/64957320.jpg)\n## 什么是NexT？\n[NexT](https://github.com/iissnan/hexo-theme-next)为hexo一个较为经典的主题，我的博客目前所用的就是这个主题。感谢作者[iissnan](https://github.com/iissnan)的提供。<!-- more -->\n\n\n`NexT` 主旨在于简洁优雅且易于使用，所以首先要尽量确保 `NexT` 的简洁易用性。在保证其原有的基础上，我对其一些基本功能进行了优化。\n如果你也想尝试与我一样的主题，可以参考[NexT帮助文档](http://theme-next.iissnan.com/getting-started.html)来个性化你的`NexT`。或者你也可以选择一个Hexo主题：\n>选择主题建议遵循KISS原则,即简单就是美。\n\n* Hexo Themes - http://hexo.io/themes/\n* Jacman - http://wsgzao.github.io/post/hexo-jacman/\n\n## 如何设置阅读全文\n`hexo`提供了在文章中使用 <!-- more --> 手动进行截断的方式，前提是需要在主题文件夹下的`_config.yml`设置：\n>scroll\\_to\\_more: true\n\n## hexo NexT主题首页title的优化\n更改`index.swig`文件，文件路径为`your-hexo-site\\themes\\next\\layout`，将下面代码\n\n```\n\t{% block title %} {{ config.title }} {% endblock %}\n```\n\n更改为\n\n```\n\t{% block title %} {{ config.title }} - {{ theme.description }} {% endblock %}\n```\n\n即可实现使你的首页显示`网站名称 - 网站描述`这种格式了。\n\n## 设置最近访客菜单\n本设置参考学习了`arao`的博客[动动手指，给你的Hexo站点添加最近访客（多说篇）](http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/)，并且将多说评论UA与其相结合，实现了最近访客功能以及评论栏的背景及评论栏头像360度旋转。\n## 第三方服务配置\n第一次接触的`NexT`的时候，按照教程来还是遇到了挺多的问题。在集成第三方服务的时候，由于`NexT`默认使用国外比较流行的disqus，为了与国内相匹配，我将其修改为“多说”评论系统。\n\n在每一条多说的评论之后我想要显示出评论者所使用的代理消息（如 操作系统、浏览器），可是按照教程之后发现并没有出现。![](http://theme-next.iissnan.com/uploads/duoshuo-ua.png)\n\n后参考了HelloDog的博客[多说自定义CSS头像和多说评论显示UA](http://wsgzao.github.io/post/duoshuo/)才明白需要到多说后台自定义CSS（此CSS样式包括了最近访客功能以及评论栏的背景及评论栏头像360度旋转的功能），具体步骤为：\n\n>注册/登录多说后台->设置->基本设置->自定义CSS\n\n\n\n```\n\t/*UA Start*/\n\tspan.this_ua {\n\t    background-color: #ccc!important;\n\t    border-radius: 4px;\n\t    padding: 0 5px!important;\n\t    margin: 0 1px!important;\n\t    border: 1px solid #BBB!important;\n\t    color: #fff;\n\t    /*text-transform: Capitalize!important;\n\t    float: right!important;\n\t    line-height: 18px!important;*/\n\t}\n\t.this_ua.platform.Windows{\n\t    background-color: #39b3d7!important;\n\t    border-color: #46b8da!important;\n\t}\n\t.this_ua.platform.Linux {\n\t    background-color: #3A3A3A!important;\n\t    border-color: #1F1F1F!important;\n\t}\n\t.this_ua.platform.Ubuntu {\n\t    background-color: #DD4814!important;\n\t    border-color: #DD4814!important;\n\t}\n\t.this_ua.platform.Mac {\n\t    background-color: #666666!important;\n\t    border-color: #666666!important;\n\t}\n\t.this_ua.platform.Android {\n\t    background-color: #98C13D!important;\n\t    border-color: #98C13D!important;\n\t}\n\t.this_ua.platform.iOS {\n\t    background-color: #666666!important;\n\t    border-color: #666666!important;\n\t}\n\t.this_ua.browser.Chrome{\n\t    background-color: #EE6252!important;\n\t    border-color: #EE6252!important;\n\t}\n\t.this_ua.browser.Chromium{\n\t    background-color: #EE6252!important;\n\t    border-color: #EE6252!important;\n\t}\n\t.this_ua.browser.Firefox{\n\t    background-color: #f0ad4e!important;\n\t    border-color: #eea236!important;\n\t}\n\t.this_ua.browser.IE{\n\t    background-color: #428bca!important;\n\t    border-color: #357ebd!important;\n\t}\n\t.this_ua.browser.Edge{\n\t    background-color: #428bca!important;\n\t    border-color: #357ebd!important;\n\t}\n\t.this_ua.browser.Opera{\n\t    background-color: #d9534f!important;\n\t    border-color: #d43f3a!important;\n\t}\n\t.this_ua.browser.Maxthon{\n\t    background-color: #7373B9!important;\n\t    border-color: #7373B9!important;\n\t}\n\t.this_ua.browser.Safari{\n\t    background-color: #666666!important;\n\t    border-color: #666666!important;\n\t}\n\t.this_ua.sskadmin {\n\t    background-color: #00a67c!important;\n\t    border-color: #00a67c!important;\n\t}\n\t/*UA End*/\n\t/*Head Start*/\n\t#ds-thread #ds-reset ul.ds-comments-tabs li.ds-tab a.ds-current {\n\t    border: 0px;\n\t    color: #6D6D6B;\n\t    text-shadow: none;\n\t    background: #F3F3F3;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-highlight {\n\t    font-family: Microsoft YaHei, \"Helvetica Neue\", Helvetica, Arial, Sans-serif;\n\t    ;font-size: 100%;\n\t    color: #6D6D6B !important;\n\t}\n\t\n\t#ds-thread #ds-reset ul.ds-comments-tabs li.ds-tab a.ds-current:hover {\n\t    color: #696a52;\n\t    background: #F2F2F2;\n\t}\n\t\n\t#ds-thread #ds-reset a.ds-highlight:hover {\n\t    color: #696a52 !important;\n\t}\n\t\n\t#ds-thread {\n\t    padding-left: 15px;\n\t}\n\t\n\t#ds-thread #ds-reset li.ds-post,#ds-thread #ds-reset #ds-hot-posts {\n\t    overflow: visible;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-post-self {\n\t    padding: 10px 0 10px 10px;\n\t}\n\t\n\t#ds-thread #ds-reset li.ds-post,#ds-thread #ds-reset .ds-post-self {\n\t    border: 0 !important;\n\t}\n\t\n\t#ds-reset .ds-avatar, #ds-thread #ds-reset ul.ds-children .ds-avatar {\n\t    top: 15px;\n\t    left: -20px;\n\t    padding: 5px;\n\t    width: 36px;\n\t    height: 36px;\n\t    box-shadow: -1px 0 1px rgba(0,0,0,.15) inset;\n\t    border-radius: 46px;\n\t    background: #FAFAFA;\n\t}\n\t\n\t#ds-thread .ds-avatar a {\n\t    display: inline-block;\n\t    padding: 1px;\n\t    width: 32px;\n\t    height: 32px;\n\t    border: 1px solid #b9baa6;\n\t    border-radius: 50%;\n\t    background-color: #fff !important;\n\t}\n\t\n\t#ds-thread .ds-avatar a:hover {\n\t}\n\t\n\t#ds-thread .ds-avatar > img {\n\t    margin: 2px 0 0 2px;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-replybox {\n\t    box-shadow: none;\n\t}\n\t\n\t#ds-thread #ds-reset ul.ds-children .ds-replybox.ds-inline-replybox a.ds-avatar,\n\t#ds-reset .ds-replybox.ds-inline-replybox a.ds-avatar {\n\t    left: 0;\n\t    top: 0;\n\t    padding: 0;\n\t    width: 32px !important;\n\t    height: 32px !important;\n\t    background: none;\n\t    box-shadow: none;\n\t}\n\t\n\t#ds-reset .ds-replybox.ds-inline-replybox a.ds-avatar img {\n\t    width: 32px !important;\n\t    height: 32px !important;\n\t    border-radius: 50%;\n\t}\n\t\n\t#ds-reset .ds-replybox a.ds-avatar,\n\t#ds-reset .ds-replybox .ds-avatar img {\n\t    padding: 0;\n\t    width: 32px !important;\n\t    height: 32px !important;\n\t    border-radius: 5px;\n\t}\n\t\n\t#ds-reset .ds-avatar img {\n\t    width: 32px !important;\n\t    height: 32px !important;\n\t    border-radius: 32px;\n\t    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.22);\n\t    -webkit-transition: .8s all ease-in-out;\n\t    -moz-transition: .4s all ease-in-out;\n\t    -o-transition: .4s all ease-in-out;\n\t    -ms-transition: .4s all ease-in-out;\n\t    transition: .4s all ease-in-out;\n\t}\n\t\n\t.ds-post-self:hover .ds-avatar img {\n\t    -webkit-transform: rotateX(360deg);\n\t    -moz-transform: rotate(360deg);\n\t    -o-transform: rotate(360deg);\n\t    -ms-transform: rotate(360deg);\n\t    transform: rotate(360deg);\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comment-body {\n\t    -webkit-transition-delay: initial;\n\t    -webkit-transition-duration: 0.4s;\n\t    -webkit-transition-property: all;\n\t    -webkit-transition-timing-function: initial;\n\t    background: #F7F7F7;\n\t    padding: 15px 15px 15px 47px;\n\t    border-radius: 5px;\n\t    box-shadow: #B8B9B9 0 1px 3px;\n\t    border: white 1px solid;\n\t}\n\t\n\t#ds-thread #ds-reset ul.ds-children .ds-comment-body {\n\t    padding-left: 15px;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comment-body p {\n\t    color: #787968;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comments {\n\t    border-bottom: 0px;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-powered-by {\n\t    display: none;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comments a.ds-user-name {\n\t    font-weight: normal;\n\t    color: #3D3D3D !important;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comments a.ds-user-name:hover {\n\t    color: #D32 !important;\n\t}\n\t\n\t#ds-thread #ds-reset #ds-bubble {\n\t    display: none !important;\n\t}\n\t\n\t#ds-thread #ds-reset #ds-hot-posts {\n\t    border: 0;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-textarea-wrapper textarea {\n\t\tbackground: url(http://ww4.sinaimg.cn/small/649a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;\n\t}\n\n\t#ds-recent-visitors .ds-avatar {\n\t\tfloat: left\n\t}\n\t/*隐藏多说底部版权*/\n\t#ds-thread #ds-reset .ds-powered-by {\n\t\tdisplay: none;\n\t}\n\t\n\t#ds-thread #ds-reset .ds-comment-body:hover {\n\t    background-color: #F1F1F1;\n\t    -webkit-transition-delay: initial;\n\t    -webkit-transition-duration: 0.4s;\n\t    -webkit-transition-property: all;\n\t    -webkit-transition-timing-function: initial;\n\t}\n\t\n```\n\n添加上述代码，最后在命令行中 `hexo cl`&`hexo g`&`hexo s`,最后显示如下图所示：![评论](http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-7/11047875.jpg)实现了上述功能。\n\n## 添加`小心！`\n\n再次感谢开源\n\n效果很赞，整个页面渐进式摇摆，摇摆，还有音乐\n\n在 Hexo\\themes\\next\\layout_partials\\header.swig 中的 ul 标签加入如下 li 代码：\n```\n<li> <a title=\"把这个链接拖到你的Chrome收藏夹工具栏中\" href='javascript:(function() {\n    function c() {\n        var e = document.createElement(\"link\");\n        e.setAttribute(\"type\", \"text/css\");\n        e.setAttribute(\"rel\", \"stylesheet\");\n        e.setAttribute(\"href\", f);\n        e.setAttribute(\"class\", l);\n        document.body.appendChild(e)\n    }\n \n    function h() {\n        var e = document.getElementsByClassName(l);\n        for (var t = 0; t < e.length; t++) {\n            document.body.removeChild(e[t])\n        }\n    }\n \n    function p() {\n        var e = document.createElement(\"div\");\n        e.setAttribute(\"class\", a);\n        document.body.appendChild(e);\n        setTimeout(function() {\n            document.body.removeChild(e)\n        }, 100)\n    }\n \n    function d(e) {\n        return {\n            height : e.offsetHeight,\n            width : e.offsetWidth\n        }\n    }\n \n    function v(i) {\n        var s = d(i);\n        return s.height > e && s.height < n && s.width > t && s.width < r\n    }\n \n    function m(e) {\n        var t = e;\n        var n = 0;\n        while (!!t) {\n            n += t.offsetTop;\n            t = t.offsetParent\n        }\n        return n\n    }\n \n    function g() {\n        var e = document.documentElement;\n        if (!!window.innerWidth) {\n            return window.innerHeight\n        } else if (e && !isNaN(e.clientHeight)) {\n            return e.clientHeight\n        }\n        return 0\n    }\n \n    function y() {\n        if (window.pageYOffset) {\n            return window.pageYOffset\n        }\n        return Math.max(document.documentElement.scrollTop, document.body.scrollTop)\n    }\n \n    function E(e) {\n        var t = m(e);\n        return t >= w && t <= b + w\n    }\n \n    function S() {\n        var e = document.createElement(\"audio\");\n        e.setAttribute(\"class\", l);\n        e.src = i;\n        e.loop = false;\n        e.addEventListener(\"canplay\", function() {\n            setTimeout(function() {\n                x(k)\n            }, 500);\n            setTimeout(function() {\n                N();\n                p();\n                for (var e = 0; e < O.length; e++) {\n                    T(O[e])\n                }\n            }, 15500)\n        }, true);\n        e.addEventListener(\"ended\", function() {\n            N();\n            h()\n        }, true);\n        e.innerHTML = \" <p>If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.</p> <p>\";\n        document.body.appendChild(e);\n        e.play()\n    }\n \n    function x(e) {\n        e.className += \" \" + s + \" \" + o\n    }\n \n    function T(e) {\n        e.className += \" \" + s + \" \" + u[Math.floor(Math.random() * u.length)]\n    }\n \n    function N() {\n        var e = document.getElementsByClassName(s);\n        var t = new RegExp(\"\\\\b\" + s + \"\\\\b\");\n        for (var n = 0; n < e.length; ) {\n            e[n].className = e[n].className.replace(t, \"\")\n        }\n    }\n \n    var e = 30;\n    var t = 30;\n    var n = 350;\n    var r = 350;\n    var i = \"//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3\";\n    var s = \"mw-harlem_shake_me\";\n    var o = \"im_first\";\n    var u = [\"im_drunk\", \"im_baked\", \"im_trippin\", \"im_blown\"];\n    var a = \"mw-strobe_light\";\n    var f = \"//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css\";\n    var l = \"mw_added_css\";\n    var b = g();\n    var w = y();\n    var C = document.getElementsByTagName(\"*\");\n    var k = null;\n    for (var L = 0; L < C.length; L++) {\n        var A = C[L];\n        if (v(A)) {\n            if (E(A)) {\n                k = A;\n                break\n            }\n        }\n    }\n    if (A === null) {\n        console.warn(\"Could not find a node of the right size. Please try a different page.\");\n        return\n    }\n    c();\n    S();\n    var O = [];\n    for (var L = 0; L < C.length; L++) {\n        var A = C[L];\n        if (v(A)) {\n            O.push(A)\n        }\n    }\n})()    '>小心！</a> </li>\n```\n很刺激的特效 = =\n\n总体感觉，nexT的主题很有特色，简单，有极客范。","slug":"博客相关/优化你的 nexT","published":1,"updated":"2019-03-22T14:44:36.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0r00a24l3nf2ezmk0w","content":"<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-7/64957320.jpg\" alt=\"next\"></p>\n<h2 id=\"什么是NexT？\"><a href=\"#什么是NexT？\" class=\"headerlink\" title=\"什么是NexT？\"></a>什么是NexT？</h2><p><a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">NexT</a>为hexo一个较为经典的主题，我的博客目前所用的就是这个主题。感谢作者<a href=\"https://github.com/iissnan\" target=\"_blank\" rel=\"noopener\">iissnan</a>的提供。<a id=\"more\"></a></p>\n<p><code>NexT</code> 主旨在于简洁优雅且易于使用，所以首先要尽量确保 <code>NexT</code> 的简洁易用性。在保证其原有的基础上，我对其一些基本功能进行了优化。<br>如果你也想尝试与我一样的主题，可以参考<a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"noopener\">NexT帮助文档</a>来个性化你的<code>NexT</code>。或者你也可以选择一个Hexo主题：</p>\n<blockquote>\n<p>选择主题建议遵循KISS原则,即简单就是美。</p>\n</blockquote>\n<ul>\n<li>Hexo Themes - <a href=\"http://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">http://hexo.io/themes/</a></li>\n<li>Jacman - <a href=\"http://wsgzao.github.io/post/hexo-jacman/\" target=\"_blank\" rel=\"noopener\">http://wsgzao.github.io/post/hexo-jacman/</a></li>\n</ul>\n<h2 id=\"如何设置阅读全文\"><a href=\"#如何设置阅读全文\" class=\"headerlink\" title=\"如何设置阅读全文\"></a>如何设置阅读全文</h2><p><code>hexo</code>提供了在文章中使用 <!-- more --> 手动进行截断的方式，前提是需要在主题文件夹下的<code>_config.yml</code>设置：</p>\n<blockquote>\n<p>scroll_to_more: true</p>\n</blockquote>\n<h2 id=\"hexo-NexT主题首页title的优化\"><a href=\"#hexo-NexT主题首页title的优化\" class=\"headerlink\" title=\"hexo NexT主题首页title的优化\"></a>hexo NexT主题首页title的优化</h2><p>更改<code>index.swig</code>文件，文件路径为<code>your-hexo-site\\themes\\next\\layout</code>，将下面代码</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">block</span></span> title %&#125;</span><span class=\"xml\"> </span><span class=\"template-variable\">&#123;&#123; config.title &#125;&#125;</span><span class=\"xml\"> </span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">endblock</span></span> %&#125;</span><span class=\"xml\"></span></span><br></pre></td></tr></table></figure>\n<p>更改为</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">block</span></span> title %&#125;</span><span class=\"xml\"> </span><span class=\"template-variable\">&#123;&#123; config.title &#125;&#125;</span><span class=\"xml\"> - </span><span class=\"template-variable\">&#123;&#123; theme.description &#125;&#125;</span><span class=\"xml\"> </span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">endblock</span></span> %&#125;</span><span class=\"xml\"></span></span><br></pre></td></tr></table></figure>\n<p>即可实现使你的首页显示<code>网站名称 - 网站描述</code>这种格式了。</p>\n<h2 id=\"设置最近访客菜单\"><a href=\"#设置最近访客菜单\" class=\"headerlink\" title=\"设置最近访客菜单\"></a>设置最近访客菜单</h2><p>本设置参考学习了<code>arao</code>的博客<a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/\" target=\"_blank\" rel=\"noopener\">动动手指，给你的Hexo站点添加最近访客（多说篇）</a>，并且将多说评论UA与其相结合，实现了最近访客功能以及评论栏的背景及评论栏头像360度旋转。</p>\n<h2 id=\"第三方服务配置\"><a href=\"#第三方服务配置\" class=\"headerlink\" title=\"第三方服务配置\"></a>第三方服务配置</h2><p>第一次接触的<code>NexT</code>的时候，按照教程来还是遇到了挺多的问题。在集成第三方服务的时候，由于<code>NexT</code>默认使用国外比较流行的disqus，为了与国内相匹配，我将其修改为“多说”评论系统。</p>\n<p>在每一条多说的评论之后我想要显示出评论者所使用的代理消息（如 操作系统、浏览器），可是按照教程之后发现并没有出现。<img src=\"http://theme-next.iissnan.com/uploads/duoshuo-ua.png\" alt></p>\n<p>后参考了HelloDog的博客<a href=\"http://wsgzao.github.io/post/duoshuo/\" target=\"_blank\" rel=\"noopener\">多说自定义CSS头像和多说评论显示UA</a>才明白需要到多说后台自定义CSS（此CSS样式包括了最近访客功能以及评论栏的背景及评论栏头像360度旋转的功能），具体步骤为：</p>\n<blockquote>\n<p>注册/登录多说后台-&gt;设置-&gt;基本设置-&gt;自定义CSS</p>\n</blockquote>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*UA Start*/</span></span><br><span class=\"line\"><span class=\"selector-tag\">span</span><span class=\"selector-class\">.this_ua</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#ccc</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">4px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span> <span class=\"number\">5px</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> <span class=\"number\">1px</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#BBB</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*text-transform: Capitalize!important;</span></span><br><span class=\"line\"><span class=\"comment\">    float: right!important;</span></span><br><span class=\"line\"><span class=\"comment\">    line-height: 18px!important;*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.Windows</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#39b3d7</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#46b8da</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.Linux</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#3A3A3A</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#1F1F1F</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.Ubuntu</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#DD4814</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#DD4814</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.Mac</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.Android</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#98C13D</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#98C13D</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.iOS</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Chrome</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#EE6252</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#EE6252</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Chromium</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#EE6252</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#EE6252</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Firefox</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#f0ad4e</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#eea236</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.IE</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#428bca</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#357ebd</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Edge</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#428bca</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#357ebd</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Opera</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#d9534f</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#d43f3a</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Maxthon</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#7373B9</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#7373B9</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Safari</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.sskadmin</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#00a67c</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#00a67c</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*UA End*/</span></span><br><span class=\"line\"><span class=\"comment\">/*Head Start*/</span></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">ul</span><span class=\"selector-class\">.ds-comments-tabs</span> <span class=\"selector-tag\">li</span><span class=\"selector-class\">.ds-tab</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-current</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#6D6D6B</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-shadow</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#F3F3F3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-highlight</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: Microsoft YaHei, <span class=\"string\">\"Helvetica Neue\"</span>, Helvetica, Arial, Sans-serif;</span><br><span class=\"line\">    ;<span class=\"attribute\">font-size</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#6D6D6B</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">ul</span><span class=\"selector-class\">.ds-comments-tabs</span> <span class=\"selector-tag\">li</span><span class=\"selector-class\">.ds-tab</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-current</span>:hover &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#696a52</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#F2F2F2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-highlight</span>:hover &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#696a52</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding-left</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">li</span><span class=\"selector-class\">.ds-post</span>,<span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-id\">#ds-hot-posts</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: visible;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-post-self</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">li</span><span class=\"selector-class\">.ds-post</span>,<span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-post-self</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">0</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-avatar</span>, <span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">ul</span><span class=\"selector-class\">.ds-children</span> <span class=\"selector-class\">.ds-avatar</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: -<span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">36px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">36px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: -<span class=\"number\">1px</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> rgba(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,.<span class=\"number\">15</span>) inset;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">46px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#FAFAFA</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">32px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">32px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#b9baa6</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">a</span>:hover &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-class\">.ds-avatar</span> &gt; <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">2px</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">2px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-replybox</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">ul</span><span class=\"selector-class\">.ds-children</span> <span class=\"selector-class\">.ds-replybox</span><span class=\"selector-class\">.ds-inline-replybox</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-avatar</span>,</span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-replybox</span><span class=\"selector-class\">.ds-inline-replybox</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-avatar</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-replybox</span><span class=\"selector-class\">.ds-inline-replybox</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-replybox</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-avatar</span>,</span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-replybox</span> <span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">32px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">3px</span> rgba(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.22</span>);</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition</span>: .<span class=\"number\">8s</span> all ease-in-out;</span><br><span class=\"line\">    -moz-<span class=\"attribute\">transition</span>: .<span class=\"number\">4s</span> all ease-in-out;</span><br><span class=\"line\">    -o-<span class=\"attribute\">transition</span>: .<span class=\"number\">4s</span> all ease-in-out;</span><br><span class=\"line\">    -ms-<span class=\"attribute\">transition</span>: .<span class=\"number\">4s</span> all ease-in-out;</span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: .<span class=\"number\">4s</span> all ease-in-out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.ds-post-self</span>:hover <span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transform</span>: rotateX(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">    -moz-<span class=\"attribute\">transform</span>: rotate(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">    -o-<span class=\"attribute\">transform</span>: rotate(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">    -ms-<span class=\"attribute\">transform</span>: rotate(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: rotate(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comment-body</span> &#123;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-delay</span>: initial;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-duration</span>: <span class=\"number\">0.4s</span>;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-property</span>: all;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-timing-function</span>: initial;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#F7F7F7</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">15px</span> <span class=\"number\">15px</span> <span class=\"number\">15px</span> <span class=\"number\">47px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: <span class=\"number\">#B8B9B9</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">3px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: white <span class=\"number\">1px</span> solid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">ul</span><span class=\"selector-class\">.ds-children</span> <span class=\"selector-class\">.ds-comment-body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding-left</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comment-body</span> <span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#787968</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comments</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-powered-by</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comments</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-user-name</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: normal;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#3D3D3D</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comments</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-user-name</span>:hover &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#D32</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-id\">#ds-bubble</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: none <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-id\">#ds-hot-posts</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-textarea-wrapper</span> <span class=\"selector-tag\">textarea</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">background</span>: url(http://ww4.sinaimg.cn/small/<span class=\"number\">649</span>a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-recent-visitors</span> <span class=\"selector-class\">.ds-avatar</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">float</span>: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*隐藏多说底部版权*/</span><br><span class=\"line\"><span class=\"number\">#d</span>s-thread <span class=\"number\">#d</span>s-reset .ds-powered-by &#123;</span><br><span class=\"line\">\tdisplay: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comment-body</span>:hover &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#F1F1F1</span>;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-delay</span>: initial;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-duration</span>: <span class=\"number\">0.4s</span>;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-property</span>: all;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-timing-function</span>: initial;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>添加上述代码，最后在命令行中 <code>hexo cl</code>&amp;<code>hexo g</code>&amp;<code>hexo s</code>,最后显示如下图所示：<img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-7/11047875.jpg\" alt=\"评论\">实现了上述功能。</p>\n<h2 id=\"添加小心！\"><a href=\"#添加小心！\" class=\"headerlink\" title=\"添加小心！\"></a>添加<code>小心！</code></h2><p>再次感谢开源</p>\n<p>效果很赞，整个页面渐进式摇摆，摇摆，还有音乐</p>\n<p>在 Hexo\\themes\\next\\layout_partials\\header.swig 中的 ul 标签加入如下 li 代码：<br><figure class=\"highlight golo\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li&gt; &lt;a title=<span class=\"string\">\"把这个链接拖到你的Chrome收藏夹工具栏中\"</span> href='javascript:(<span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> c() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.createElement(<span class=\"string\">\"link\"</span>);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"type\"</span>, <span class=\"string\">\"text/css\"</span>);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"rel\"</span>, <span class=\"string\">\"stylesheet\"</span>);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"href\"</span>, f);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"class\"</span>, l);</span><br><span class=\"line\">        document.body.appendChild(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> h() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.getElementsByClassName(l);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> t = <span class=\"number\">0</span>; t &lt; e.length; t++) &#123;</span><br><span class=\"line\">            document.body.removeChild(e[t])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> p() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"class\"</span>, a);</span><br><span class=\"line\">        document.body.appendChild(e);</span><br><span class=\"line\">        setTimeout(<span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">            document.body.removeChild(e)</span><br><span class=\"line\">        &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> d(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            height : e.offsetHeight,</span><br><span class=\"line\">            width : e.offsetWidth</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> v(i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = d(i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> m(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> t = e;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!!t) &#123;</span><br><span class=\"line\">            n += t.offsetTop;</span><br><span class=\"line\">            t = t.offsetParent</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> g() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.documentElement;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!window.innerWidth) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> window.innerHeight</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e &amp;&amp; !isNaN(e.clientHeight)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.clientHeight</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> y() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (window.pageYOffset) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> window.pageYOffset</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(document.documentElement.scrollTop, document.body.scrollTop)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> E(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> t = m(e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t &gt;= w &amp;&amp; t &lt;= b + w</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> S() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.createElement(<span class=\"string\">\"audio\"</span>);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"class\"</span>, l);</span><br><span class=\"line\">        e.src = i;</span><br><span class=\"line\">        e.loop = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        e.addEventListener(<span class=\"string\">\"canplay\"</span>, <span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">            setTimeout(<span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">                x(k)</span><br><span class=\"line\">            &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">            setTimeout(<span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">                N();</span><br><span class=\"line\">                p();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> e = <span class=\"number\">0</span>; e &lt; O.length; e++) &#123;</span><br><span class=\"line\">                    T(O[e])</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, <span class=\"number\">15500</span>)</span><br><span class=\"line\">        &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        e.addEventListener(<span class=\"string\">\"ended\"</span>, <span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">            N();</span><br><span class=\"line\">            h()</span><br><span class=\"line\">        &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        e.innerHTML = <span class=\"string\">\" &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;\"</span>;</span><br><span class=\"line\">        document.body.appendChild(e);</span><br><span class=\"line\">        e.play()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> x(e) &#123;</span><br><span class=\"line\">        e.className += <span class=\"string\">\" \"</span> + s + <span class=\"string\">\" \"</span> + o</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> T(e) &#123;</span><br><span class=\"line\">        e.className += <span class=\"string\">\" \"</span> + s + <span class=\"string\">\" \"</span> + u[Math.floor(Math.random() * u.length)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> N() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.getElementsByClassName(s);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> t = new RegExp(<span class=\"string\">\"\\\\b\"</span> + s + <span class=\"string\">\"\\\\b\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> n = <span class=\"number\">0</span>; n &lt; e.length; ) &#123;</span><br><span class=\"line\">            e[n].className = e[n].className.replace(t, <span class=\"string\">\"\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">var</span> e = <span class=\"number\">30</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> t = <span class=\"number\">30</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n = <span class=\"number\">350</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = <span class=\"number\">350</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"string\">\"//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"string\">\"mw-harlem_shake_me\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"string\">\"im_first\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> u = [<span class=\"string\">\"im_drunk\"</span>, <span class=\"string\">\"im_baked\"</span>, <span class=\"string\">\"im_trippin\"</span>, <span class=\"string\">\"im_blown\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">\"mw-strobe_light\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f = <span class=\"string\">\"//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> l = <span class=\"string\">\"mw_added_css\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = g();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> w = y();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> C = document.getElementsByTagName(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> k = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> L = <span class=\"number\">0</span>; L &lt; C.length; L++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> A = C[L];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v(A)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (E(A)) &#123;</span><br><span class=\"line\">                k = A;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        console.warn(<span class=\"string\">\"Could not find a node of the right size. Please try a different page.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    c();</span><br><span class=\"line\">    S();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> O = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> L = <span class=\"number\">0</span>; L &lt; C.length; L++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> A = C[L];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v(A)) &#123;</span><br><span class=\"line\">            O.push(A)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()    '&gt;小心！&lt;/a&gt; &lt;/li&gt;</span><br></pre></td></tr></table></figure></p>\n<p>很刺激的特效 = =</p>\n<p>总体感觉，nexT的主题很有特色，简单，有极客范。</p>\n","site":{"data":{}},"excerpt":"<p><img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-7/64957320.jpg\" alt=\"next\"></p>\n<h2 id=\"什么是NexT？\"><a href=\"#什么是NexT？\" class=\"headerlink\" title=\"什么是NexT？\"></a>什么是NexT？</h2><p><a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\">NexT</a>为hexo一个较为经典的主题，我的博客目前所用的就是这个主题。感谢作者<a href=\"https://github.com/iissnan\" target=\"_blank\" rel=\"noopener\">iissnan</a>的提供。</p>","more":"<p></p>\n<p><code>NexT</code> 主旨在于简洁优雅且易于使用，所以首先要尽量确保 <code>NexT</code> 的简洁易用性。在保证其原有的基础上，我对其一些基本功能进行了优化。<br>如果你也想尝试与我一样的主题，可以参考<a href=\"http://theme-next.iissnan.com/getting-started.html\" target=\"_blank\" rel=\"noopener\">NexT帮助文档</a>来个性化你的<code>NexT</code>。或者你也可以选择一个Hexo主题：</p>\n<blockquote>\n<p>选择主题建议遵循KISS原则,即简单就是美。</p>\n</blockquote>\n<ul>\n<li>Hexo Themes - <a href=\"http://hexo.io/themes/\" target=\"_blank\" rel=\"noopener\">http://hexo.io/themes/</a></li>\n<li>Jacman - <a href=\"http://wsgzao.github.io/post/hexo-jacman/\" target=\"_blank\" rel=\"noopener\">http://wsgzao.github.io/post/hexo-jacman/</a></li>\n</ul>\n<h2 id=\"如何设置阅读全文\"><a href=\"#如何设置阅读全文\" class=\"headerlink\" title=\"如何设置阅读全文\"></a>如何设置阅读全文</h2><p><code>hexo</code>提供了在文章中使用 <!-- more --> 手动进行截断的方式，前提是需要在主题文件夹下的<code>_config.yml</code>设置：</p>\n<blockquote>\n<p>scroll_to_more: true</p>\n</blockquote>\n<h2 id=\"hexo-NexT主题首页title的优化\"><a href=\"#hexo-NexT主题首页title的优化\" class=\"headerlink\" title=\"hexo NexT主题首页title的优化\"></a>hexo NexT主题首页title的优化</h2><p>更改<code>index.swig</code>文件，文件路径为<code>your-hexo-site\\themes\\next\\layout</code>，将下面代码</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">block</span></span> title %&#125;</span><span class=\"xml\"> </span><span class=\"template-variable\">&#123;&#123; config.title &#125;&#125;</span><span class=\"xml\"> </span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">endblock</span></span> %&#125;</span><span class=\"xml\"></span></span><br></pre></td></tr></table></figure>\n<p>更改为</p>\n<figure class=\"highlight django\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"xml\"></span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">block</span></span> title %&#125;</span><span class=\"xml\"> </span><span class=\"template-variable\">&#123;&#123; config.title &#125;&#125;</span><span class=\"xml\"> - </span><span class=\"template-variable\">&#123;&#123; theme.description &#125;&#125;</span><span class=\"xml\"> </span><span class=\"template-tag\">&#123;% <span class=\"name\"><span class=\"name\">endblock</span></span> %&#125;</span><span class=\"xml\"></span></span><br></pre></td></tr></table></figure>\n<p>即可实现使你的首页显示<code>网站名称 - 网站描述</code>这种格式了。</p>\n<h2 id=\"设置最近访客菜单\"><a href=\"#设置最近访客菜单\" class=\"headerlink\" title=\"设置最近访客菜单\"></a>设置最近访客菜单</h2><p>本设置参考学习了<code>arao</code>的博客<a href=\"http://www.arao.me/2015/hexo-next-theme-optimize-duoshuo/\" target=\"_blank\" rel=\"noopener\">动动手指，给你的Hexo站点添加最近访客（多说篇）</a>，并且将多说评论UA与其相结合，实现了最近访客功能以及评论栏的背景及评论栏头像360度旋转。</p>\n<h2 id=\"第三方服务配置\"><a href=\"#第三方服务配置\" class=\"headerlink\" title=\"第三方服务配置\"></a>第三方服务配置</h2><p>第一次接触的<code>NexT</code>的时候，按照教程来还是遇到了挺多的问题。在集成第三方服务的时候，由于<code>NexT</code>默认使用国外比较流行的disqus，为了与国内相匹配，我将其修改为“多说”评论系统。</p>\n<p>在每一条多说的评论之后我想要显示出评论者所使用的代理消息（如 操作系统、浏览器），可是按照教程之后发现并没有出现。<img src=\"http://theme-next.iissnan.com/uploads/duoshuo-ua.png\" alt></p>\n<p>后参考了HelloDog的博客<a href=\"http://wsgzao.github.io/post/duoshuo/\" target=\"_blank\" rel=\"noopener\">多说自定义CSS头像和多说评论显示UA</a>才明白需要到多说后台自定义CSS（此CSS样式包括了最近访客功能以及评论栏的背景及评论栏头像360度旋转的功能），具体步骤为：</p>\n<blockquote>\n<p>注册/登录多说后台-&gt;设置-&gt;基本设置-&gt;自定义CSS</p>\n</blockquote>\n<figure class=\"highlight scss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*UA Start*/</span></span><br><span class=\"line\"><span class=\"selector-tag\">span</span><span class=\"selector-class\">.this_ua</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#ccc</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">4px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span> <span class=\"number\">5px</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">0</span> <span class=\"number\">1px</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#BBB</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#fff</span>;</span><br><span class=\"line\">    <span class=\"comment\">/*text-transform: Capitalize!important;</span></span><br><span class=\"line\"><span class=\"comment\">    float: right!important;</span></span><br><span class=\"line\"><span class=\"comment\">    line-height: 18px!important;*/</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.Windows</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#39b3d7</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#46b8da</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.Linux</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#3A3A3A</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#1F1F1F</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.Ubuntu</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#DD4814</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#DD4814</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.Mac</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.Android</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#98C13D</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#98C13D</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.platform</span><span class=\"selector-class\">.iOS</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Chrome</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#EE6252</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#EE6252</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Chromium</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#EE6252</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#EE6252</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Firefox</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#f0ad4e</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#eea236</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.IE</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#428bca</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#357ebd</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Edge</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#428bca</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#357ebd</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Opera</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#d9534f</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#d43f3a</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Maxthon</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#7373B9</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#7373B9</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.browser</span><span class=\"selector-class\">.Safari</span>&#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#666666</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"selector-class\">.this_ua</span><span class=\"selector-class\">.sskadmin</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#00a67c</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-color</span>: <span class=\"number\">#00a67c</span><span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/*UA End*/</span></span><br><span class=\"line\"><span class=\"comment\">/*Head Start*/</span></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">ul</span><span class=\"selector-class\">.ds-comments-tabs</span> <span class=\"selector-tag\">li</span><span class=\"selector-class\">.ds-tab</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-current</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#6D6D6B</span>;</span><br><span class=\"line\">    <span class=\"attribute\">text-shadow</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#F3F3F3</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-highlight</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-family</span>: Microsoft YaHei, <span class=\"string\">\"Helvetica Neue\"</span>, Helvetica, Arial, Sans-serif;</span><br><span class=\"line\">    ;<span class=\"attribute\">font-size</span>: <span class=\"number\">100%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#6D6D6B</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">ul</span><span class=\"selector-class\">.ds-comments-tabs</span> <span class=\"selector-tag\">li</span><span class=\"selector-class\">.ds-tab</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-current</span>:hover &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#696a52</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#F2F2F2</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-highlight</span>:hover &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#696a52</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding-left</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">li</span><span class=\"selector-class\">.ds-post</span>,<span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-id\">#ds-hot-posts</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">overflow</span>: visible;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-post-self</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">10px</span> <span class=\"number\">0</span> <span class=\"number\">10px</span> <span class=\"number\">10px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">li</span><span class=\"selector-class\">.ds-post</span>,<span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-post-self</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">0</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-avatar</span>, <span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">ul</span><span class=\"selector-class\">.ds-children</span> <span class=\"selector-class\">.ds-avatar</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: -<span class=\"number\">20px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">36px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">36px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: -<span class=\"number\">1px</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> rgba(<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,.<span class=\"number\">15</span>) inset;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">46px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#FAFAFA</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">a</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: inline-block;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">1px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">32px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">32px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">1px</span> solid <span class=\"number\">#b9baa6</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#fff</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">a</span>:hover &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-class\">.ds-avatar</span> &gt; <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">margin</span>: <span class=\"number\">2px</span> <span class=\"number\">0</span> <span class=\"number\">0</span> <span class=\"number\">2px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-replybox</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">ul</span><span class=\"selector-class\">.ds-children</span> <span class=\"selector-class\">.ds-replybox</span><span class=\"selector-class\">.ds-inline-replybox</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-avatar</span>,</span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-replybox</span><span class=\"selector-class\">.ds-inline-replybox</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-avatar</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">left</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">top</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: none;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-replybox</span><span class=\"selector-class\">.ds-inline-replybox</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">50%</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-replybox</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-avatar</span>,</span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-replybox</span> <span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">width</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">height</span>: <span class=\"number\">32px</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">32px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">3px</span> rgba(<span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0.22</span>);</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition</span>: .<span class=\"number\">8s</span> all ease-in-out;</span><br><span class=\"line\">    -moz-<span class=\"attribute\">transition</span>: .<span class=\"number\">4s</span> all ease-in-out;</span><br><span class=\"line\">    -o-<span class=\"attribute\">transition</span>: .<span class=\"number\">4s</span> all ease-in-out;</span><br><span class=\"line\">    -ms-<span class=\"attribute\">transition</span>: .<span class=\"number\">4s</span> all ease-in-out;</span><br><span class=\"line\">    <span class=\"attribute\">transition</span>: .<span class=\"number\">4s</span> all ease-in-out;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-class\">.ds-post-self</span>:hover <span class=\"selector-class\">.ds-avatar</span> <span class=\"selector-tag\">img</span> &#123;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transform</span>: rotateX(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">    -moz-<span class=\"attribute\">transform</span>: rotate(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">    -o-<span class=\"attribute\">transform</span>: rotate(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">    -ms-<span class=\"attribute\">transform</span>: rotate(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">    <span class=\"attribute\">transform</span>: rotate(<span class=\"number\">360deg</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comment-body</span> &#123;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-delay</span>: initial;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-duration</span>: <span class=\"number\">0.4s</span>;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-property</span>: all;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-timing-function</span>: initial;</span><br><span class=\"line\">    <span class=\"attribute\">background</span>: <span class=\"number\">#F7F7F7</span>;</span><br><span class=\"line\">    <span class=\"attribute\">padding</span>: <span class=\"number\">15px</span> <span class=\"number\">15px</span> <span class=\"number\">15px</span> <span class=\"number\">47px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border-radius</span>: <span class=\"number\">5px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">box-shadow</span>: <span class=\"number\">#B8B9B9</span> <span class=\"number\">0</span> <span class=\"number\">1px</span> <span class=\"number\">3px</span>;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: white <span class=\"number\">1px</span> solid;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-tag\">ul</span><span class=\"selector-class\">.ds-children</span> <span class=\"selector-class\">.ds-comment-body</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">padding-left</span>: <span class=\"number\">15px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comment-body</span> <span class=\"selector-tag\">p</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#787968</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comments</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border-bottom</span>: <span class=\"number\">0px</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-powered-by</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comments</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-user-name</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">font-weight</span>: normal;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#3D3D3D</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comments</span> <span class=\"selector-tag\">a</span><span class=\"selector-class\">.ds-user-name</span>:hover &#123;</span><br><span class=\"line\">    <span class=\"attribute\">color</span>: <span class=\"number\">#D32</span> <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-id\">#ds-bubble</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">display</span>: none <span class=\"meta\">!important</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-id\">#ds-hot-posts</span> &#123;</span><br><span class=\"line\">    <span class=\"attribute\">border</span>: <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-textarea-wrapper</span> <span class=\"selector-tag\">textarea</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">background</span>: url(http://ww4.sinaimg.cn/small/<span class=\"number\">649</span>a4735gw1et7gnhy5fej20zk0m8q3q.jpg) right no-repeat;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-recent-visitors</span> <span class=\"selector-class\">.ds-avatar</span> &#123;</span><br><span class=\"line\">\t<span class=\"attribute\">float</span>: left</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">/*隐藏多说底部版权*/</span><br><span class=\"line\"><span class=\"number\">#d</span>s-thread <span class=\"number\">#d</span>s-reset .ds-powered-by &#123;</span><br><span class=\"line\">\tdisplay: none;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"selector-id\">#ds-thread</span> <span class=\"selector-id\">#ds-reset</span> <span class=\"selector-class\">.ds-comment-body</span>:hover &#123;</span><br><span class=\"line\">    <span class=\"attribute\">background-color</span>: <span class=\"number\">#F1F1F1</span>;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-delay</span>: initial;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-duration</span>: <span class=\"number\">0.4s</span>;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-property</span>: all;</span><br><span class=\"line\">    -webkit-<span class=\"attribute\">transition-timing-function</span>: initial;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>添加上述代码，最后在命令行中 <code>hexo cl</code>&amp;<code>hexo g</code>&amp;<code>hexo s</code>,最后显示如下图所示：<img src=\"http://7xsp7y.com2.z0.glb.qiniucdn.com/16-4-7/11047875.jpg\" alt=\"评论\">实现了上述功能。</p>\n<h2 id=\"添加小心！\"><a href=\"#添加小心！\" class=\"headerlink\" title=\"添加小心！\"></a>添加<code>小心！</code></h2><p>再次感谢开源</p>\n<p>效果很赞，整个页面渐进式摇摆，摇摆，还有音乐</p>\n<p>在 Hexo\\themes\\next\\layout_partials\\header.swig 中的 ul 标签加入如下 li 代码：<br><figure class=\"highlight golo\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;li&gt; &lt;a title=<span class=\"string\">\"把这个链接拖到你的Chrome收藏夹工具栏中\"</span> href='javascript:(<span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">    <span class=\"keyword\">function</span> c() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.createElement(<span class=\"string\">\"link\"</span>);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"type\"</span>, <span class=\"string\">\"text/css\"</span>);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"rel\"</span>, <span class=\"string\">\"stylesheet\"</span>);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"href\"</span>, f);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"class\"</span>, l);</span><br><span class=\"line\">        document.body.appendChild(e)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> h() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.getElementsByClassName(l);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> t = <span class=\"number\">0</span>; t &lt; e.length; t++) &#123;</span><br><span class=\"line\">            document.body.removeChild(e[t])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> p() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.createElement(<span class=\"string\">\"div\"</span>);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"class\"</span>, a);</span><br><span class=\"line\">        document.body.appendChild(e);</span><br><span class=\"line\">        setTimeout(<span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">            document.body.removeChild(e)</span><br><span class=\"line\">        &#125;, <span class=\"number\">100</span>)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> d(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">            height : e.offsetHeight,</span><br><span class=\"line\">            width : e.offsetWidth</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> v(i) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> s = d(i);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> s.height &gt; e &amp;&amp; s.height &lt; n &amp;&amp; s.width &gt; t &amp;&amp; s.width &lt; r</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> m(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> t = e;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (!!t) &#123;</span><br><span class=\"line\">            n += t.offsetTop;</span><br><span class=\"line\">            t = t.offsetParent</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> g() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.documentElement;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!!window.innerWidth) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> window.innerHeight</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e &amp;&amp; !isNaN(e.clientHeight)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> e.clientHeight</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> y() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (window.pageYOffset) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> window.pageYOffset</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> Math.max(document.documentElement.scrollTop, document.body.scrollTop)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> E(e) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> t = m(e);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> t &gt;= w &amp;&amp; t &lt;= b + w</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> S() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.createElement(<span class=\"string\">\"audio\"</span>);</span><br><span class=\"line\">        e.setAttribute(<span class=\"string\">\"class\"</span>, l);</span><br><span class=\"line\">        e.src = i;</span><br><span class=\"line\">        e.loop = <span class=\"literal\">false</span>;</span><br><span class=\"line\">        e.addEventListener(<span class=\"string\">\"canplay\"</span>, <span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">            setTimeout(<span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">                x(k)</span><br><span class=\"line\">            &#125;, <span class=\"number\">500</span>);</span><br><span class=\"line\">            setTimeout(<span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">                N();</span><br><span class=\"line\">                p();</span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> e = <span class=\"number\">0</span>; e &lt; O.length; e++) &#123;</span><br><span class=\"line\">                    T(O[e])</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;, <span class=\"number\">15500</span>)</span><br><span class=\"line\">        &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        e.addEventListener(<span class=\"string\">\"ended\"</span>, <span class=\"keyword\">function</span>() &#123;</span><br><span class=\"line\">            N();</span><br><span class=\"line\">            h()</span><br><span class=\"line\">        &#125;, <span class=\"literal\">true</span>);</span><br><span class=\"line\">        e.innerHTML = <span class=\"string\">\" &lt;p&gt;If you are reading this, it is because your browser does not support the audio element. We recommend that you get a new browser.&lt;/p&gt; &lt;p&gt;\"</span>;</span><br><span class=\"line\">        document.body.appendChild(e);</span><br><span class=\"line\">        e.play()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> x(e) &#123;</span><br><span class=\"line\">        e.className += <span class=\"string\">\" \"</span> + s + <span class=\"string\">\" \"</span> + o</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> T(e) &#123;</span><br><span class=\"line\">        e.className += <span class=\"string\">\" \"</span> + s + <span class=\"string\">\" \"</span> + u[Math.floor(Math.random() * u.length)]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">function</span> N() &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> e = document.getElementsByClassName(s);</span><br><span class=\"line\">        <span class=\"keyword\">var</span> t = new RegExp(<span class=\"string\">\"\\\\b\"</span> + s + <span class=\"string\">\"\\\\b\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> n = <span class=\"number\">0</span>; n &lt; e.length; ) &#123;</span><br><span class=\"line\">            e[n].className = e[n].className.replace(t, <span class=\"string\">\"\"</span>)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">var</span> e = <span class=\"number\">30</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> t = <span class=\"number\">30</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> n = <span class=\"number\">350</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> r = <span class=\"number\">350</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> i = <span class=\"string\">\"//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake.mp3\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> s = <span class=\"string\">\"mw-harlem_shake_me\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> o = <span class=\"string\">\"im_first\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> u = [<span class=\"string\">\"im_drunk\"</span>, <span class=\"string\">\"im_baked\"</span>, <span class=\"string\">\"im_trippin\"</span>, <span class=\"string\">\"im_blown\"</span>];</span><br><span class=\"line\">    <span class=\"keyword\">var</span> a = <span class=\"string\">\"mw-strobe_light\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> f = <span class=\"string\">\"//s3.amazonaws.com/moovweb-marketing/playground/harlem-shake-style.css\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> l = <span class=\"string\">\"mw_added_css\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> b = g();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> w = y();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> C = document.getElementsByTagName(<span class=\"string\">\"*\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">var</span> k = <span class=\"literal\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> L = <span class=\"number\">0</span>; L &lt; C.length; L++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> A = C[L];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v(A)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (E(A)) &#123;</span><br><span class=\"line\">                k = A;</span><br><span class=\"line\">                <span class=\"keyword\">break</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (A === <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">        console.warn(<span class=\"string\">\"Could not find a node of the right size. Please try a different page.\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    c();</span><br><span class=\"line\">    S();</span><br><span class=\"line\">    <span class=\"keyword\">var</span> O = [];</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> L = <span class=\"number\">0</span>; L &lt; C.length; L++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> A = C[L];</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (v(A)) &#123;</span><br><span class=\"line\">            O.push(A)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)()    '&gt;小心！&lt;/a&gt; &lt;/li&gt;</span><br></pre></td></tr></table></figure></p>\n<p>很刺激的特效 = =</p>\n<p>总体感觉，nexT的主题很有特色，简单，有极客范。</p>"},{"title":"我们培养了很多高学历的野蛮人","date":"2017-02-15T04:14:50.000Z","_content":"\n偶得一篇文章，严格说来是一篇演讲稿，还是值得深思一番的。\n\n>(来源：解放日报，作者：鲍鹏山 )\n\n<!-- more -->\n\n常有人说我的演讲很有激情，可是今天我听了前面两位嘉宾的演讲，我觉得自己被秒杀了。（全场大笑）\n\n尚老师、许院长他们的激情，来自对文化的热爱。文化确实是一个能够激发我们感情的崇高东西，它和知识是不一样的。一个有文化的人，你会发现他的生命力是非常旺盛的。他不是冷冰冰的，而是富有激情、情怀，对这个世界充满了爱和诗意的眼光。\n\n可是今天，我们从中小学到大学的教育，更多的是在教知识、技术、专业，唯独缺少文化。我们培养了很多精致的利己主义者，很多高学历的野蛮人，他们是冷冰冰的。\n\n有句很有名的话：知识就是力量。中国人耳熟能详，而且对它很是认同。从历史上看，1840年以后，中国面对西方的科学技术，不堪一击，于是得出一个结论：落后就要挨打。这个落后，就是指科学技术的落后。从现实上看，如果今天我们不能用知识很好地答出一份标准化试卷，可能就读不了好大学、好专业，找不到好工作，以更好地满足自己物质的欲望。\n\n无论从历史经验还是现实压力，我们都知道知识太重要了。但是我今天要对大家讲的是，尽管知识确实重要，但知识也有局限性。\n\n## 这根胡萝卜把他一辈子都拴死了\n\n首先，知识是无限的。什么叫知识？知识是对这个世界所有事实的认知。既然世界是无限的，那么知识也是无限的，可悲剧的是人生是有限的。庄子就说过：“吾生也有涯，而知也无涯；以有涯随无涯，殆矣。”世界是无限的，我们的生命是有限的，用有限的生命去追求无限世界所包含的无限知识，那我们的人生就会废掉。\n\n当知识不成体系时，它是无用的，只是碎片。举个例子，曾有一家报社搞国学知识竞赛，找了一批专家出了一套国学题目。题目出完后，编辑想让我审一下。我看了5分钟，对它的判断就是6个字：无趣、无聊、无用。\n\n比如有一道题目问：在中国历史上哪一个时代的宦官是可以娶妻的？（全场笑）这是非常严肃的知识。如果你专门研究宦官，把他们的生存状况、心理状态以及他们在中国历史上的地位、影响、作用都搞明白，你将会成为一名了不起的专家。可是假如你的主要精力不在此，这样的知识碎片，对你一点用处都没有。\n\n还有一道题目：胡萝卜是什么时候传入中国的？如果你能把它变成系统的知识进行分析研究，它是有意义的。但是假如一个人并没有这样的意愿和目标，他只知道胡萝卜是什么时候传入中国的，这样的知识对他不仅没用，还可能产生负面影响。\n\n因为他知道大多数人都不知道答案，心里一阵窃喜，觉得自己是世界上最牛的人，并且他特别想让别人知道这一点。于是，他天天等着别人提问，以期收获别人的敬佩。为了等到这一天，他可能每次和朋友吃饭的时候都点胡萝卜，（全场笑）别人吃得很香，他却只等着一个问题。\n\n这根胡萝卜把他一辈子都拴死了。\n\n有不少人用琐碎的知识，把自己的人生切割成碎片。德国哲学家尼采写过一篇文章叫《我为什么这么聪明》。他的结论就一句话：我之所以这么聪明，是因为我从来不在不必要的事情上浪费精力。\n\n有一次我坐出租车，司机正在收听一档知识竞赛节目。节目中，主持人放了5个音乐片断，每个片断几秒钟，随后提问：这5个音乐片断，有2个片断属于同一首歌，你们谁知道？一个小伙子抢答说他知道，并且回答正确。\n\n紧接着第二个问题是：其中有2首歌出自同一张音乐专辑，你知道吗？这时我紧张了，我怕他知道。他不知道，说明他还是正常人，如果他知道，他这一辈子可能就废了。但是没想到他真知道。（全场笑）这时我让司机把收音机关掉。司机吓一跳，问为什么？我说：“它在侮辱我们的智商，并且在误导我们生命的流向。”\n\n这就叫无用的知识，生活中有太多这样无用的知识。比如，很多人关心某个明星喜欢的颜色是什么，星座是什么，结了几次婚，又离了几次婚。当一个人把精力花在这些地方时，他可能获得了知识，并且在饭桌上能与人聊天，但他会变得特别琐碎。\n\n我曾写过一篇文章，题目是《警惕知识》。主要观点就是，我们的生命本来就不可能占有无限的知识。更可悲的是，无聊的知识会让人生变得无聊，琐碎的知识会让人格变得琐碎，甚至猥琐。\n\n孔子的学生子夏早就说：“虽小道，必有可观者焉”，但是“致远恐泥,是以君子不为也”。即使是胡萝卜什么时候传入中国的这样的知识，你可以拿来吹吹牛，但如果你老是把认知集中在这种信息上，你的一生肯定不会有什么成就。你用琐碎的知识把人生变成了碎片，所以君子不为。\n\n荀子曾提出过对知识的鉴别。他说有些知识是无聊的、无用的、无趣的，这样的知识荀子有一个判断，叫“不知，无害为君子；知之，无损为小人。”你知道了这样的知识，并不能够因此成为君子，你不知道这个知识也不会因此成为小人。有的知识对你的人生，一分都没加，又何必耗费精力和时间呢？\n\n但是在生活中，确实有不少人专心致志、兴高采烈、兴趣盎然地用琐碎的知识，把自己的人生切割成碎片。\n\n## 实际上，在知识之外有一种更重要的东西\n\n实际上，在知识之外有一种更重要的东西。\n\n《列子》里面有篇文章叫《两小儿辩日》，在座的都读过。两个小孩辩论说，太阳早晨离我们近，还是中午离我们近。两个人都有根据，说早晨近是因为早晨的太阳比中午大；说中午近是因为中午的太阳比早晨热。\n\n孔子活得真有压力，他几乎是那时候的“谷歌”和“百度”，大家有什么问题都跑去问他。两个小儿问孔子，但孔子没法判断。于是作者就借小孩的口吻讽刺孔子：“谁说你知识多？”作者大概是想，只要否定孔子的知识多，那就否定了孔子的价值。\n\n这个思路显然是错误的。在人生知识的考场上，谁能站到最后？我今天跟大家打个赌，我可以出一套100分的知识类题目，每道都有标准答案，但我能让在座所有人都得零分。反过来，你们也可以给我出100分的知识类题目，让我一分都得不到。\n\n比如，复旦大学自主招生出过一道题，老师对学生提一个要求：“你现在问我一个问题，必须满足两个条件，第一是要我回答不出来，第二是你必须要有标准答案。”很多人说这个题目太雷人了，可我就觉得出得很好。因为它告诉我们，在知识的考场上，没有人可以站到最后。有一个聪明的学生马上问：“老师，你知道我祖父的名字吗？”（全场笑）\n\n我也可以按照这个思路给大家出题，不需要费劲，就能让大家都得零分。你们知道我祖父的名字吗？知道我祖母的名字吗？知道我祖父的二大爷的名字吗？在座的谁能答出来，今晚我请客。（全场笑）可见，知识可以把任何一个人打倒。\n\n如果要算知识的总量，我相信今天在座的人，你们的知识总量都超过孔子。比如说，我可以出计算机、物理、英语、数学之类的题目，孔子肯定答不过你们。\n\n但我们就比孔子的境界高吗？这就要思考另一个问题了：决定孔子境界的不是知识的总量，而是另外一种东西。孔子自己早就说过：“吾有知乎哉？无知也。”我有知识吗？不，没有。苏格拉底也曾经说：“我比别人多知道的那一点，就是我知道自己是无知的。”\n\n他们说这些不是谦虚，只不过说出了一种真相。面对世界的无限，我们短暂生命里的知识可以忽略不计。所以，我们应该允许自己的无知，也应该宽容别人的无知。\n\n你看我不顺眼，给我出一道数学题。我为了防备下一次再有人给我出数学题，于是我天天学数学，学了10年以后，解放日报文化讲坛大概已经到6800期了，我终于有勇气上台演讲，突然又有人说：“鲍老师，我这有一套物理题。”（全场笑）你不会这样干，对不对？因为你们会宽容我的无知，我们也会宽容他人的无知，但是有种情况是不能宽容的，那是什么呢？没有良知。\n\n## 没有知识可以被宽容，没有良知不可以被宽容\n\n没有知识可以被宽容，没有良知不可以被宽容。我们遇到标准化的试卷，回答不好没有问题，但是涉及良知判断、是非判断、善恶美丑判断，如果出了问题，那就是大问题。\n\n我讲一个故事。有一位父亲发现15岁的女儿不在家，留下一封信，上面写着：\n\n“亲爱的爸爸妈妈，今天我和兰迪私奔了。兰迪是个很有个性的人，身上刺了各种花纹，只有42岁，并不老，对不对？我将和他住到森林里去，当然，不只是我和他两个人，兰迪还有另外几个女人，可是我并不介意。我们将会种植大麻，除了自己抽，还可以卖给朋友。我还希望我们在那个地方生很多孩子。在这个过程里，也希望医学技术可以有很大的进步，这样兰迪的艾滋病可以治好。”\n\n父亲读到这里，已经崩溃了。然而，他发现最下面还有一句话：“未完，请看背面。”\n\n背面是这样写的：“爸爸，那一页所说的都不是真的。真相是我在隔壁同学家里，期中考试的试卷放在抽屉里，你打开后签上字。我之所以写这封信，就是告诉你，世界上有比试卷没答好更糟糕的事情。你现在给我打电话，告诉我，我可以安全回家了。”（全场大笑）\n\n这封信说明，一个人在知识的试卷上可以犯错，甚至不止一次犯错，一辈子犯错，我们到老了都是无知的。但是在良知问题上，可能犯一次错，我们就万劫不复了。所以，比事实判断更重要的是价值判断。事实判断，我们做不到什么都懂，但是做人要有良知，要有价值判断力，这一点还是应该尽量做到的。\n\n今天中国社会的一个问题，就是缺乏判断力。中国教育的一个问题，就是缺乏文化素养。比如，为了抵制日货，很多年轻人走到大街上砸同胞的车，甚至伤害同胞的身体。他们带着一腔热血，以为在爱国，但实际上却是在“碍国”。\n\n为什么一个带着良好爱国热情的人，会去做妨碍国家、损伤中国人形象的事？他们缺少的是什么呢？良知。\n\n知识就是力量，但我要告诉大家，良知才是方向。我们常常说落后就要挨打，我还要告诉大家，野蛮也会招打。\n\n我就讲到这里，谢谢大家！（全场鼓掌）","source":"_posts/摘录/我们培养了很多高学历的野蛮人.md","raw":"---\ntitle: 我们培养了很多高学历的野蛮人\ndate: 2017-02-15 12:14:50\ntags: \n- 摘录\ncategories: 杂谈\n---\n\n偶得一篇文章，严格说来是一篇演讲稿，还是值得深思一番的。\n\n>(来源：解放日报，作者：鲍鹏山 )\n\n<!-- more -->\n\n常有人说我的演讲很有激情，可是今天我听了前面两位嘉宾的演讲，我觉得自己被秒杀了。（全场大笑）\n\n尚老师、许院长他们的激情，来自对文化的热爱。文化确实是一个能够激发我们感情的崇高东西，它和知识是不一样的。一个有文化的人，你会发现他的生命力是非常旺盛的。他不是冷冰冰的，而是富有激情、情怀，对这个世界充满了爱和诗意的眼光。\n\n可是今天，我们从中小学到大学的教育，更多的是在教知识、技术、专业，唯独缺少文化。我们培养了很多精致的利己主义者，很多高学历的野蛮人，他们是冷冰冰的。\n\n有句很有名的话：知识就是力量。中国人耳熟能详，而且对它很是认同。从历史上看，1840年以后，中国面对西方的科学技术，不堪一击，于是得出一个结论：落后就要挨打。这个落后，就是指科学技术的落后。从现实上看，如果今天我们不能用知识很好地答出一份标准化试卷，可能就读不了好大学、好专业，找不到好工作，以更好地满足自己物质的欲望。\n\n无论从历史经验还是现实压力，我们都知道知识太重要了。但是我今天要对大家讲的是，尽管知识确实重要，但知识也有局限性。\n\n## 这根胡萝卜把他一辈子都拴死了\n\n首先，知识是无限的。什么叫知识？知识是对这个世界所有事实的认知。既然世界是无限的，那么知识也是无限的，可悲剧的是人生是有限的。庄子就说过：“吾生也有涯，而知也无涯；以有涯随无涯，殆矣。”世界是无限的，我们的生命是有限的，用有限的生命去追求无限世界所包含的无限知识，那我们的人生就会废掉。\n\n当知识不成体系时，它是无用的，只是碎片。举个例子，曾有一家报社搞国学知识竞赛，找了一批专家出了一套国学题目。题目出完后，编辑想让我审一下。我看了5分钟，对它的判断就是6个字：无趣、无聊、无用。\n\n比如有一道题目问：在中国历史上哪一个时代的宦官是可以娶妻的？（全场笑）这是非常严肃的知识。如果你专门研究宦官，把他们的生存状况、心理状态以及他们在中国历史上的地位、影响、作用都搞明白，你将会成为一名了不起的专家。可是假如你的主要精力不在此，这样的知识碎片，对你一点用处都没有。\n\n还有一道题目：胡萝卜是什么时候传入中国的？如果你能把它变成系统的知识进行分析研究，它是有意义的。但是假如一个人并没有这样的意愿和目标，他只知道胡萝卜是什么时候传入中国的，这样的知识对他不仅没用，还可能产生负面影响。\n\n因为他知道大多数人都不知道答案，心里一阵窃喜，觉得自己是世界上最牛的人，并且他特别想让别人知道这一点。于是，他天天等着别人提问，以期收获别人的敬佩。为了等到这一天，他可能每次和朋友吃饭的时候都点胡萝卜，（全场笑）别人吃得很香，他却只等着一个问题。\n\n这根胡萝卜把他一辈子都拴死了。\n\n有不少人用琐碎的知识，把自己的人生切割成碎片。德国哲学家尼采写过一篇文章叫《我为什么这么聪明》。他的结论就一句话：我之所以这么聪明，是因为我从来不在不必要的事情上浪费精力。\n\n有一次我坐出租车，司机正在收听一档知识竞赛节目。节目中，主持人放了5个音乐片断，每个片断几秒钟，随后提问：这5个音乐片断，有2个片断属于同一首歌，你们谁知道？一个小伙子抢答说他知道，并且回答正确。\n\n紧接着第二个问题是：其中有2首歌出自同一张音乐专辑，你知道吗？这时我紧张了，我怕他知道。他不知道，说明他还是正常人，如果他知道，他这一辈子可能就废了。但是没想到他真知道。（全场笑）这时我让司机把收音机关掉。司机吓一跳，问为什么？我说：“它在侮辱我们的智商，并且在误导我们生命的流向。”\n\n这就叫无用的知识，生活中有太多这样无用的知识。比如，很多人关心某个明星喜欢的颜色是什么，星座是什么，结了几次婚，又离了几次婚。当一个人把精力花在这些地方时，他可能获得了知识，并且在饭桌上能与人聊天，但他会变得特别琐碎。\n\n我曾写过一篇文章，题目是《警惕知识》。主要观点就是，我们的生命本来就不可能占有无限的知识。更可悲的是，无聊的知识会让人生变得无聊，琐碎的知识会让人格变得琐碎，甚至猥琐。\n\n孔子的学生子夏早就说：“虽小道，必有可观者焉”，但是“致远恐泥,是以君子不为也”。即使是胡萝卜什么时候传入中国的这样的知识，你可以拿来吹吹牛，但如果你老是把认知集中在这种信息上，你的一生肯定不会有什么成就。你用琐碎的知识把人生变成了碎片，所以君子不为。\n\n荀子曾提出过对知识的鉴别。他说有些知识是无聊的、无用的、无趣的，这样的知识荀子有一个判断，叫“不知，无害为君子；知之，无损为小人。”你知道了这样的知识，并不能够因此成为君子，你不知道这个知识也不会因此成为小人。有的知识对你的人生，一分都没加，又何必耗费精力和时间呢？\n\n但是在生活中，确实有不少人专心致志、兴高采烈、兴趣盎然地用琐碎的知识，把自己的人生切割成碎片。\n\n## 实际上，在知识之外有一种更重要的东西\n\n实际上，在知识之外有一种更重要的东西。\n\n《列子》里面有篇文章叫《两小儿辩日》，在座的都读过。两个小孩辩论说，太阳早晨离我们近，还是中午离我们近。两个人都有根据，说早晨近是因为早晨的太阳比中午大；说中午近是因为中午的太阳比早晨热。\n\n孔子活得真有压力，他几乎是那时候的“谷歌”和“百度”，大家有什么问题都跑去问他。两个小儿问孔子，但孔子没法判断。于是作者就借小孩的口吻讽刺孔子：“谁说你知识多？”作者大概是想，只要否定孔子的知识多，那就否定了孔子的价值。\n\n这个思路显然是错误的。在人生知识的考场上，谁能站到最后？我今天跟大家打个赌，我可以出一套100分的知识类题目，每道都有标准答案，但我能让在座所有人都得零分。反过来，你们也可以给我出100分的知识类题目，让我一分都得不到。\n\n比如，复旦大学自主招生出过一道题，老师对学生提一个要求：“你现在问我一个问题，必须满足两个条件，第一是要我回答不出来，第二是你必须要有标准答案。”很多人说这个题目太雷人了，可我就觉得出得很好。因为它告诉我们，在知识的考场上，没有人可以站到最后。有一个聪明的学生马上问：“老师，你知道我祖父的名字吗？”（全场笑）\n\n我也可以按照这个思路给大家出题，不需要费劲，就能让大家都得零分。你们知道我祖父的名字吗？知道我祖母的名字吗？知道我祖父的二大爷的名字吗？在座的谁能答出来，今晚我请客。（全场笑）可见，知识可以把任何一个人打倒。\n\n如果要算知识的总量，我相信今天在座的人，你们的知识总量都超过孔子。比如说，我可以出计算机、物理、英语、数学之类的题目，孔子肯定答不过你们。\n\n但我们就比孔子的境界高吗？这就要思考另一个问题了：决定孔子境界的不是知识的总量，而是另外一种东西。孔子自己早就说过：“吾有知乎哉？无知也。”我有知识吗？不，没有。苏格拉底也曾经说：“我比别人多知道的那一点，就是我知道自己是无知的。”\n\n他们说这些不是谦虚，只不过说出了一种真相。面对世界的无限，我们短暂生命里的知识可以忽略不计。所以，我们应该允许自己的无知，也应该宽容别人的无知。\n\n你看我不顺眼，给我出一道数学题。我为了防备下一次再有人给我出数学题，于是我天天学数学，学了10年以后，解放日报文化讲坛大概已经到6800期了，我终于有勇气上台演讲，突然又有人说：“鲍老师，我这有一套物理题。”（全场笑）你不会这样干，对不对？因为你们会宽容我的无知，我们也会宽容他人的无知，但是有种情况是不能宽容的，那是什么呢？没有良知。\n\n## 没有知识可以被宽容，没有良知不可以被宽容\n\n没有知识可以被宽容，没有良知不可以被宽容。我们遇到标准化的试卷，回答不好没有问题，但是涉及良知判断、是非判断、善恶美丑判断，如果出了问题，那就是大问题。\n\n我讲一个故事。有一位父亲发现15岁的女儿不在家，留下一封信，上面写着：\n\n“亲爱的爸爸妈妈，今天我和兰迪私奔了。兰迪是个很有个性的人，身上刺了各种花纹，只有42岁，并不老，对不对？我将和他住到森林里去，当然，不只是我和他两个人，兰迪还有另外几个女人，可是我并不介意。我们将会种植大麻，除了自己抽，还可以卖给朋友。我还希望我们在那个地方生很多孩子。在这个过程里，也希望医学技术可以有很大的进步，这样兰迪的艾滋病可以治好。”\n\n父亲读到这里，已经崩溃了。然而，他发现最下面还有一句话：“未完，请看背面。”\n\n背面是这样写的：“爸爸，那一页所说的都不是真的。真相是我在隔壁同学家里，期中考试的试卷放在抽屉里，你打开后签上字。我之所以写这封信，就是告诉你，世界上有比试卷没答好更糟糕的事情。你现在给我打电话，告诉我，我可以安全回家了。”（全场大笑）\n\n这封信说明，一个人在知识的试卷上可以犯错，甚至不止一次犯错，一辈子犯错，我们到老了都是无知的。但是在良知问题上，可能犯一次错，我们就万劫不复了。所以，比事实判断更重要的是价值判断。事实判断，我们做不到什么都懂，但是做人要有良知，要有价值判断力，这一点还是应该尽量做到的。\n\n今天中国社会的一个问题，就是缺乏判断力。中国教育的一个问题，就是缺乏文化素养。比如，为了抵制日货，很多年轻人走到大街上砸同胞的车，甚至伤害同胞的身体。他们带着一腔热血，以为在爱国，但实际上却是在“碍国”。\n\n为什么一个带着良好爱国热情的人，会去做妨碍国家、损伤中国人形象的事？他们缺少的是什么呢？良知。\n\n知识就是力量，但我要告诉大家，良知才是方向。我们常常说落后就要挨打，我还要告诉大家，野蛮也会招打。\n\n我就讲到这里，谢谢大家！（全场鼓掌）","slug":"摘录/我们培养了很多高学历的野蛮人","published":1,"updated":"2019-03-22T14:44:36.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0t00a54l3ntajn1tvg","content":"<p>偶得一篇文章，严格说来是一篇演讲稿，还是值得深思一番的。</p>\n<blockquote>\n<p>(来源：解放日报，作者：鲍鹏山 )</p>\n</blockquote>\n<a id=\"more\"></a>\n<p>常有人说我的演讲很有激情，可是今天我听了前面两位嘉宾的演讲，我觉得自己被秒杀了。（全场大笑）</p>\n<p>尚老师、许院长他们的激情，来自对文化的热爱。文化确实是一个能够激发我们感情的崇高东西，它和知识是不一样的。一个有文化的人，你会发现他的生命力是非常旺盛的。他不是冷冰冰的，而是富有激情、情怀，对这个世界充满了爱和诗意的眼光。</p>\n<p>可是今天，我们从中小学到大学的教育，更多的是在教知识、技术、专业，唯独缺少文化。我们培养了很多精致的利己主义者，很多高学历的野蛮人，他们是冷冰冰的。</p>\n<p>有句很有名的话：知识就是力量。中国人耳熟能详，而且对它很是认同。从历史上看，1840年以后，中国面对西方的科学技术，不堪一击，于是得出一个结论：落后就要挨打。这个落后，就是指科学技术的落后。从现实上看，如果今天我们不能用知识很好地答出一份标准化试卷，可能就读不了好大学、好专业，找不到好工作，以更好地满足自己物质的欲望。</p>\n<p>无论从历史经验还是现实压力，我们都知道知识太重要了。但是我今天要对大家讲的是，尽管知识确实重要，但知识也有局限性。</p>\n<h2 id=\"这根胡萝卜把他一辈子都拴死了\"><a href=\"#这根胡萝卜把他一辈子都拴死了\" class=\"headerlink\" title=\"这根胡萝卜把他一辈子都拴死了\"></a>这根胡萝卜把他一辈子都拴死了</h2><p>首先，知识是无限的。什么叫知识？知识是对这个世界所有事实的认知。既然世界是无限的，那么知识也是无限的，可悲剧的是人生是有限的。庄子就说过：“吾生也有涯，而知也无涯；以有涯随无涯，殆矣。”世界是无限的，我们的生命是有限的，用有限的生命去追求无限世界所包含的无限知识，那我们的人生就会废掉。</p>\n<p>当知识不成体系时，它是无用的，只是碎片。举个例子，曾有一家报社搞国学知识竞赛，找了一批专家出了一套国学题目。题目出完后，编辑想让我审一下。我看了5分钟，对它的判断就是6个字：无趣、无聊、无用。</p>\n<p>比如有一道题目问：在中国历史上哪一个时代的宦官是可以娶妻的？（全场笑）这是非常严肃的知识。如果你专门研究宦官，把他们的生存状况、心理状态以及他们在中国历史上的地位、影响、作用都搞明白，你将会成为一名了不起的专家。可是假如你的主要精力不在此，这样的知识碎片，对你一点用处都没有。</p>\n<p>还有一道题目：胡萝卜是什么时候传入中国的？如果你能把它变成系统的知识进行分析研究，它是有意义的。但是假如一个人并没有这样的意愿和目标，他只知道胡萝卜是什么时候传入中国的，这样的知识对他不仅没用，还可能产生负面影响。</p>\n<p>因为他知道大多数人都不知道答案，心里一阵窃喜，觉得自己是世界上最牛的人，并且他特别想让别人知道这一点。于是，他天天等着别人提问，以期收获别人的敬佩。为了等到这一天，他可能每次和朋友吃饭的时候都点胡萝卜，（全场笑）别人吃得很香，他却只等着一个问题。</p>\n<p>这根胡萝卜把他一辈子都拴死了。</p>\n<p>有不少人用琐碎的知识，把自己的人生切割成碎片。德国哲学家尼采写过一篇文章叫《我为什么这么聪明》。他的结论就一句话：我之所以这么聪明，是因为我从来不在不必要的事情上浪费精力。</p>\n<p>有一次我坐出租车，司机正在收听一档知识竞赛节目。节目中，主持人放了5个音乐片断，每个片断几秒钟，随后提问：这5个音乐片断，有2个片断属于同一首歌，你们谁知道？一个小伙子抢答说他知道，并且回答正确。</p>\n<p>紧接着第二个问题是：其中有2首歌出自同一张音乐专辑，你知道吗？这时我紧张了，我怕他知道。他不知道，说明他还是正常人，如果他知道，他这一辈子可能就废了。但是没想到他真知道。（全场笑）这时我让司机把收音机关掉。司机吓一跳，问为什么？我说：“它在侮辱我们的智商，并且在误导我们生命的流向。”</p>\n<p>这就叫无用的知识，生活中有太多这样无用的知识。比如，很多人关心某个明星喜欢的颜色是什么，星座是什么，结了几次婚，又离了几次婚。当一个人把精力花在这些地方时，他可能获得了知识，并且在饭桌上能与人聊天，但他会变得特别琐碎。</p>\n<p>我曾写过一篇文章，题目是《警惕知识》。主要观点就是，我们的生命本来就不可能占有无限的知识。更可悲的是，无聊的知识会让人生变得无聊，琐碎的知识会让人格变得琐碎，甚至猥琐。</p>\n<p>孔子的学生子夏早就说：“虽小道，必有可观者焉”，但是“致远恐泥,是以君子不为也”。即使是胡萝卜什么时候传入中国的这样的知识，你可以拿来吹吹牛，但如果你老是把认知集中在这种信息上，你的一生肯定不会有什么成就。你用琐碎的知识把人生变成了碎片，所以君子不为。</p>\n<p>荀子曾提出过对知识的鉴别。他说有些知识是无聊的、无用的、无趣的，这样的知识荀子有一个判断，叫“不知，无害为君子；知之，无损为小人。”你知道了这样的知识，并不能够因此成为君子，你不知道这个知识也不会因此成为小人。有的知识对你的人生，一分都没加，又何必耗费精力和时间呢？</p>\n<p>但是在生活中，确实有不少人专心致志、兴高采烈、兴趣盎然地用琐碎的知识，把自己的人生切割成碎片。</p>\n<h2 id=\"实际上，在知识之外有一种更重要的东西\"><a href=\"#实际上，在知识之外有一种更重要的东西\" class=\"headerlink\" title=\"实际上，在知识之外有一种更重要的东西\"></a>实际上，在知识之外有一种更重要的东西</h2><p>实际上，在知识之外有一种更重要的东西。</p>\n<p>《列子》里面有篇文章叫《两小儿辩日》，在座的都读过。两个小孩辩论说，太阳早晨离我们近，还是中午离我们近。两个人都有根据，说早晨近是因为早晨的太阳比中午大；说中午近是因为中午的太阳比早晨热。</p>\n<p>孔子活得真有压力，他几乎是那时候的“谷歌”和“百度”，大家有什么问题都跑去问他。两个小儿问孔子，但孔子没法判断。于是作者就借小孩的口吻讽刺孔子：“谁说你知识多？”作者大概是想，只要否定孔子的知识多，那就否定了孔子的价值。</p>\n<p>这个思路显然是错误的。在人生知识的考场上，谁能站到最后？我今天跟大家打个赌，我可以出一套100分的知识类题目，每道都有标准答案，但我能让在座所有人都得零分。反过来，你们也可以给我出100分的知识类题目，让我一分都得不到。</p>\n<p>比如，复旦大学自主招生出过一道题，老师对学生提一个要求：“你现在问我一个问题，必须满足两个条件，第一是要我回答不出来，第二是你必须要有标准答案。”很多人说这个题目太雷人了，可我就觉得出得很好。因为它告诉我们，在知识的考场上，没有人可以站到最后。有一个聪明的学生马上问：“老师，你知道我祖父的名字吗？”（全场笑）</p>\n<p>我也可以按照这个思路给大家出题，不需要费劲，就能让大家都得零分。你们知道我祖父的名字吗？知道我祖母的名字吗？知道我祖父的二大爷的名字吗？在座的谁能答出来，今晚我请客。（全场笑）可见，知识可以把任何一个人打倒。</p>\n<p>如果要算知识的总量，我相信今天在座的人，你们的知识总量都超过孔子。比如说，我可以出计算机、物理、英语、数学之类的题目，孔子肯定答不过你们。</p>\n<p>但我们就比孔子的境界高吗？这就要思考另一个问题了：决定孔子境界的不是知识的总量，而是另外一种东西。孔子自己早就说过：“吾有知乎哉？无知也。”我有知识吗？不，没有。苏格拉底也曾经说：“我比别人多知道的那一点，就是我知道自己是无知的。”</p>\n<p>他们说这些不是谦虚，只不过说出了一种真相。面对世界的无限，我们短暂生命里的知识可以忽略不计。所以，我们应该允许自己的无知，也应该宽容别人的无知。</p>\n<p>你看我不顺眼，给我出一道数学题。我为了防备下一次再有人给我出数学题，于是我天天学数学，学了10年以后，解放日报文化讲坛大概已经到6800期了，我终于有勇气上台演讲，突然又有人说：“鲍老师，我这有一套物理题。”（全场笑）你不会这样干，对不对？因为你们会宽容我的无知，我们也会宽容他人的无知，但是有种情况是不能宽容的，那是什么呢？没有良知。</p>\n<h2 id=\"没有知识可以被宽容，没有良知不可以被宽容\"><a href=\"#没有知识可以被宽容，没有良知不可以被宽容\" class=\"headerlink\" title=\"没有知识可以被宽容，没有良知不可以被宽容\"></a>没有知识可以被宽容，没有良知不可以被宽容</h2><p>没有知识可以被宽容，没有良知不可以被宽容。我们遇到标准化的试卷，回答不好没有问题，但是涉及良知判断、是非判断、善恶美丑判断，如果出了问题，那就是大问题。</p>\n<p>我讲一个故事。有一位父亲发现15岁的女儿不在家，留下一封信，上面写着：</p>\n<p>“亲爱的爸爸妈妈，今天我和兰迪私奔了。兰迪是个很有个性的人，身上刺了各种花纹，只有42岁，并不老，对不对？我将和他住到森林里去，当然，不只是我和他两个人，兰迪还有另外几个女人，可是我并不介意。我们将会种植大麻，除了自己抽，还可以卖给朋友。我还希望我们在那个地方生很多孩子。在这个过程里，也希望医学技术可以有很大的进步，这样兰迪的艾滋病可以治好。”</p>\n<p>父亲读到这里，已经崩溃了。然而，他发现最下面还有一句话：“未完，请看背面。”</p>\n<p>背面是这样写的：“爸爸，那一页所说的都不是真的。真相是我在隔壁同学家里，期中考试的试卷放在抽屉里，你打开后签上字。我之所以写这封信，就是告诉你，世界上有比试卷没答好更糟糕的事情。你现在给我打电话，告诉我，我可以安全回家了。”（全场大笑）</p>\n<p>这封信说明，一个人在知识的试卷上可以犯错，甚至不止一次犯错，一辈子犯错，我们到老了都是无知的。但是在良知问题上，可能犯一次错，我们就万劫不复了。所以，比事实判断更重要的是价值判断。事实判断，我们做不到什么都懂，但是做人要有良知，要有价值判断力，这一点还是应该尽量做到的。</p>\n<p>今天中国社会的一个问题，就是缺乏判断力。中国教育的一个问题，就是缺乏文化素养。比如，为了抵制日货，很多年轻人走到大街上砸同胞的车，甚至伤害同胞的身体。他们带着一腔热血，以为在爱国，但实际上却是在“碍国”。</p>\n<p>为什么一个带着良好爱国热情的人，会去做妨碍国家、损伤中国人形象的事？他们缺少的是什么呢？良知。</p>\n<p>知识就是力量，但我要告诉大家，良知才是方向。我们常常说落后就要挨打，我还要告诉大家，野蛮也会招打。</p>\n<p>我就讲到这里，谢谢大家！（全场鼓掌）</p>\n","site":{"data":{}},"excerpt":"<p>偶得一篇文章，严格说来是一篇演讲稿，还是值得深思一番的。</p>\n<blockquote>\n<p>(来源：解放日报，作者：鲍鹏山 )</p>\n</blockquote>","more":"<p>常有人说我的演讲很有激情，可是今天我听了前面两位嘉宾的演讲，我觉得自己被秒杀了。（全场大笑）</p>\n<p>尚老师、许院长他们的激情，来自对文化的热爱。文化确实是一个能够激发我们感情的崇高东西，它和知识是不一样的。一个有文化的人，你会发现他的生命力是非常旺盛的。他不是冷冰冰的，而是富有激情、情怀，对这个世界充满了爱和诗意的眼光。</p>\n<p>可是今天，我们从中小学到大学的教育，更多的是在教知识、技术、专业，唯独缺少文化。我们培养了很多精致的利己主义者，很多高学历的野蛮人，他们是冷冰冰的。</p>\n<p>有句很有名的话：知识就是力量。中国人耳熟能详，而且对它很是认同。从历史上看，1840年以后，中国面对西方的科学技术，不堪一击，于是得出一个结论：落后就要挨打。这个落后，就是指科学技术的落后。从现实上看，如果今天我们不能用知识很好地答出一份标准化试卷，可能就读不了好大学、好专业，找不到好工作，以更好地满足自己物质的欲望。</p>\n<p>无论从历史经验还是现实压力，我们都知道知识太重要了。但是我今天要对大家讲的是，尽管知识确实重要，但知识也有局限性。</p>\n<h2 id=\"这根胡萝卜把他一辈子都拴死了\"><a href=\"#这根胡萝卜把他一辈子都拴死了\" class=\"headerlink\" title=\"这根胡萝卜把他一辈子都拴死了\"></a>这根胡萝卜把他一辈子都拴死了</h2><p>首先，知识是无限的。什么叫知识？知识是对这个世界所有事实的认知。既然世界是无限的，那么知识也是无限的，可悲剧的是人生是有限的。庄子就说过：“吾生也有涯，而知也无涯；以有涯随无涯，殆矣。”世界是无限的，我们的生命是有限的，用有限的生命去追求无限世界所包含的无限知识，那我们的人生就会废掉。</p>\n<p>当知识不成体系时，它是无用的，只是碎片。举个例子，曾有一家报社搞国学知识竞赛，找了一批专家出了一套国学题目。题目出完后，编辑想让我审一下。我看了5分钟，对它的判断就是6个字：无趣、无聊、无用。</p>\n<p>比如有一道题目问：在中国历史上哪一个时代的宦官是可以娶妻的？（全场笑）这是非常严肃的知识。如果你专门研究宦官，把他们的生存状况、心理状态以及他们在中国历史上的地位、影响、作用都搞明白，你将会成为一名了不起的专家。可是假如你的主要精力不在此，这样的知识碎片，对你一点用处都没有。</p>\n<p>还有一道题目：胡萝卜是什么时候传入中国的？如果你能把它变成系统的知识进行分析研究，它是有意义的。但是假如一个人并没有这样的意愿和目标，他只知道胡萝卜是什么时候传入中国的，这样的知识对他不仅没用，还可能产生负面影响。</p>\n<p>因为他知道大多数人都不知道答案，心里一阵窃喜，觉得自己是世界上最牛的人，并且他特别想让别人知道这一点。于是，他天天等着别人提问，以期收获别人的敬佩。为了等到这一天，他可能每次和朋友吃饭的时候都点胡萝卜，（全场笑）别人吃得很香，他却只等着一个问题。</p>\n<p>这根胡萝卜把他一辈子都拴死了。</p>\n<p>有不少人用琐碎的知识，把自己的人生切割成碎片。德国哲学家尼采写过一篇文章叫《我为什么这么聪明》。他的结论就一句话：我之所以这么聪明，是因为我从来不在不必要的事情上浪费精力。</p>\n<p>有一次我坐出租车，司机正在收听一档知识竞赛节目。节目中，主持人放了5个音乐片断，每个片断几秒钟，随后提问：这5个音乐片断，有2个片断属于同一首歌，你们谁知道？一个小伙子抢答说他知道，并且回答正确。</p>\n<p>紧接着第二个问题是：其中有2首歌出自同一张音乐专辑，你知道吗？这时我紧张了，我怕他知道。他不知道，说明他还是正常人，如果他知道，他这一辈子可能就废了。但是没想到他真知道。（全场笑）这时我让司机把收音机关掉。司机吓一跳，问为什么？我说：“它在侮辱我们的智商，并且在误导我们生命的流向。”</p>\n<p>这就叫无用的知识，生活中有太多这样无用的知识。比如，很多人关心某个明星喜欢的颜色是什么，星座是什么，结了几次婚，又离了几次婚。当一个人把精力花在这些地方时，他可能获得了知识，并且在饭桌上能与人聊天，但他会变得特别琐碎。</p>\n<p>我曾写过一篇文章，题目是《警惕知识》。主要观点就是，我们的生命本来就不可能占有无限的知识。更可悲的是，无聊的知识会让人生变得无聊，琐碎的知识会让人格变得琐碎，甚至猥琐。</p>\n<p>孔子的学生子夏早就说：“虽小道，必有可观者焉”，但是“致远恐泥,是以君子不为也”。即使是胡萝卜什么时候传入中国的这样的知识，你可以拿来吹吹牛，但如果你老是把认知集中在这种信息上，你的一生肯定不会有什么成就。你用琐碎的知识把人生变成了碎片，所以君子不为。</p>\n<p>荀子曾提出过对知识的鉴别。他说有些知识是无聊的、无用的、无趣的，这样的知识荀子有一个判断，叫“不知，无害为君子；知之，无损为小人。”你知道了这样的知识，并不能够因此成为君子，你不知道这个知识也不会因此成为小人。有的知识对你的人生，一分都没加，又何必耗费精力和时间呢？</p>\n<p>但是在生活中，确实有不少人专心致志、兴高采烈、兴趣盎然地用琐碎的知识，把自己的人生切割成碎片。</p>\n<h2 id=\"实际上，在知识之外有一种更重要的东西\"><a href=\"#实际上，在知识之外有一种更重要的东西\" class=\"headerlink\" title=\"实际上，在知识之外有一种更重要的东西\"></a>实际上，在知识之外有一种更重要的东西</h2><p>实际上，在知识之外有一种更重要的东西。</p>\n<p>《列子》里面有篇文章叫《两小儿辩日》，在座的都读过。两个小孩辩论说，太阳早晨离我们近，还是中午离我们近。两个人都有根据，说早晨近是因为早晨的太阳比中午大；说中午近是因为中午的太阳比早晨热。</p>\n<p>孔子活得真有压力，他几乎是那时候的“谷歌”和“百度”，大家有什么问题都跑去问他。两个小儿问孔子，但孔子没法判断。于是作者就借小孩的口吻讽刺孔子：“谁说你知识多？”作者大概是想，只要否定孔子的知识多，那就否定了孔子的价值。</p>\n<p>这个思路显然是错误的。在人生知识的考场上，谁能站到最后？我今天跟大家打个赌，我可以出一套100分的知识类题目，每道都有标准答案，但我能让在座所有人都得零分。反过来，你们也可以给我出100分的知识类题目，让我一分都得不到。</p>\n<p>比如，复旦大学自主招生出过一道题，老师对学生提一个要求：“你现在问我一个问题，必须满足两个条件，第一是要我回答不出来，第二是你必须要有标准答案。”很多人说这个题目太雷人了，可我就觉得出得很好。因为它告诉我们，在知识的考场上，没有人可以站到最后。有一个聪明的学生马上问：“老师，你知道我祖父的名字吗？”（全场笑）</p>\n<p>我也可以按照这个思路给大家出题，不需要费劲，就能让大家都得零分。你们知道我祖父的名字吗？知道我祖母的名字吗？知道我祖父的二大爷的名字吗？在座的谁能答出来，今晚我请客。（全场笑）可见，知识可以把任何一个人打倒。</p>\n<p>如果要算知识的总量，我相信今天在座的人，你们的知识总量都超过孔子。比如说，我可以出计算机、物理、英语、数学之类的题目，孔子肯定答不过你们。</p>\n<p>但我们就比孔子的境界高吗？这就要思考另一个问题了：决定孔子境界的不是知识的总量，而是另外一种东西。孔子自己早就说过：“吾有知乎哉？无知也。”我有知识吗？不，没有。苏格拉底也曾经说：“我比别人多知道的那一点，就是我知道自己是无知的。”</p>\n<p>他们说这些不是谦虚，只不过说出了一种真相。面对世界的无限，我们短暂生命里的知识可以忽略不计。所以，我们应该允许自己的无知，也应该宽容别人的无知。</p>\n<p>你看我不顺眼，给我出一道数学题。我为了防备下一次再有人给我出数学题，于是我天天学数学，学了10年以后，解放日报文化讲坛大概已经到6800期了，我终于有勇气上台演讲，突然又有人说：“鲍老师，我这有一套物理题。”（全场笑）你不会这样干，对不对？因为你们会宽容我的无知，我们也会宽容他人的无知，但是有种情况是不能宽容的，那是什么呢？没有良知。</p>\n<h2 id=\"没有知识可以被宽容，没有良知不可以被宽容\"><a href=\"#没有知识可以被宽容，没有良知不可以被宽容\" class=\"headerlink\" title=\"没有知识可以被宽容，没有良知不可以被宽容\"></a>没有知识可以被宽容，没有良知不可以被宽容</h2><p>没有知识可以被宽容，没有良知不可以被宽容。我们遇到标准化的试卷，回答不好没有问题，但是涉及良知判断、是非判断、善恶美丑判断，如果出了问题，那就是大问题。</p>\n<p>我讲一个故事。有一位父亲发现15岁的女儿不在家，留下一封信，上面写着：</p>\n<p>“亲爱的爸爸妈妈，今天我和兰迪私奔了。兰迪是个很有个性的人，身上刺了各种花纹，只有42岁，并不老，对不对？我将和他住到森林里去，当然，不只是我和他两个人，兰迪还有另外几个女人，可是我并不介意。我们将会种植大麻，除了自己抽，还可以卖给朋友。我还希望我们在那个地方生很多孩子。在这个过程里，也希望医学技术可以有很大的进步，这样兰迪的艾滋病可以治好。”</p>\n<p>父亲读到这里，已经崩溃了。然而，他发现最下面还有一句话：“未完，请看背面。”</p>\n<p>背面是这样写的：“爸爸，那一页所说的都不是真的。真相是我在隔壁同学家里，期中考试的试卷放在抽屉里，你打开后签上字。我之所以写这封信，就是告诉你，世界上有比试卷没答好更糟糕的事情。你现在给我打电话，告诉我，我可以安全回家了。”（全场大笑）</p>\n<p>这封信说明，一个人在知识的试卷上可以犯错，甚至不止一次犯错，一辈子犯错，我们到老了都是无知的。但是在良知问题上，可能犯一次错，我们就万劫不复了。所以，比事实判断更重要的是价值判断。事实判断，我们做不到什么都懂，但是做人要有良知，要有价值判断力，这一点还是应该尽量做到的。</p>\n<p>今天中国社会的一个问题，就是缺乏判断力。中国教育的一个问题，就是缺乏文化素养。比如，为了抵制日货，很多年轻人走到大街上砸同胞的车，甚至伤害同胞的身体。他们带着一腔热血，以为在爱国，但实际上却是在“碍国”。</p>\n<p>为什么一个带着良好爱国热情的人，会去做妨碍国家、损伤中国人形象的事？他们缺少的是什么呢？良知。</p>\n<p>知识就是力量，但我要告诉大家，良知才是方向。我们常常说落后就要挨打，我还要告诉大家，野蛮也会招打。</p>\n<p>我就讲到这里，谢谢大家！（全场鼓掌）</p>"},{"title":"知乎live分享——我的读书经验","date":"2016-09-20T01:51:02.000Z","_content":"这个知乎live又是李笑来老师开设的专题。尽管在李笑来老师的书中也涉及了他以前的读书经验，但因为《把时间当做朋友》是09年出版的，现在16年正好一辈子(7年)的时间。所以我更想看看目前笑来老师是如何做的，与之前的内容是否有所不同。听完分享果然干货满满，0.99也是真·良心价。\n<!-- more -->\n## 分享原则\n\n这次分享是有原则的。\n\n首先，这不是一次掉书袋（卖弄才学）的一次分享。\n其次，不会列出一长串书单。\n最后，思考是否这些看法有价值。\n\n## 我的读书路径与境界更新\n\n### 第一阶段 饥不择食\n读书这件事很难做到目标明确，如果一开始就目标明确的话，很容易会造成失去意外好运的机会。所以第一个阶段就应该漫无目的的读书，能读多少，就读多少，不用挑。因为挑书也是一种逐步积累的能力。\n\n这种饥不择食也有很大的好处，随便罗列，也有这么三个：\n\n1.阅读变成了吃饭一样的需求，不读脑子就会饿。（督促自己）\n2.经常有各种意外的好运，从莫名其妙的地方读到了原本不可能获得的知识。\n3.一不小心就积累了足够的里程——你要知道，驾驶经验远比驾驶技巧重要的多。\n\n### 第二阶段 自己挑书\n\n向别人索要书单是没有用的，书单始终是别人的书单，反而是**使自己的挑书能力逐步退化至零的最有效方法**。\n\n你的挑书能力是不可能不长进的。别人的选择结果并不重要，选择原则很具有参考价值。\n\n从逐步的阅读经验累积发现，从最早的看读者，再到看小说等虚构类的书，最后发现自己更喜欢那些“有繁殖能力”的知识，选择非虚构类书籍。相对于“有繁殖能力”的知识，有部分知识其实就是信息，并没有繁殖能力，并不能更新得到新的知识，例如那种偏门冷知识，而有人却喜欢这类，数量越多越好，个人选择罢了。\n\n我需要做到的就是：\n\n**1.我需要认清现实并思考未来**\n**2.我更喜欢有繁殖能力的知识，比如说非虚构类，英文原版书籍，心理学，经济学，策略学，脑科学。**\n\n看到这里，就又进一步的会挑了。哪个出版社更加靠谱，哪个作者更有趣，然后就很快进入第三个阶段。\n\n### 第三阶段 学术文献\n\n学术文献和通俗读物最大的区别在于作者的态度。学术论文通常不关心读者是否能读懂，他所关心的是如何自圆其说并且尽量写清楚。所以学术论文真的是很锻炼阅读理解能力的。\n\n批量阅读学术文献，刚刚开始确实会有点害怕，可没有过多久，就开始可怜起以前的自己来，总是衣来伸手，饭来张口，而没有自己去找食吃。因为学术文献再到通识读物，期间又要经历好久才能到大众眼前。\n\n### 第四阶段 检索阅读\n\n原版书大行其道，电子版开始风靡。开始建立自己的电脑图书馆，开始大量检索阅读，即有目标的阅读。当你需要什么的时候，就用关键词搜索，把那部分内容找出来参考。\n\n### 第五阶段 什么都看\n\n挑书已经成为一种内建能力，目的性减弱，可还是会挑书看。到这个阶段，开始研究真正的世界。想知道书甚至APP背后的用户是怎么样的一个世界。\n\n以上就是读书路径。从泛到精再到泛，还有另外一个维度的路径，从全盘接受，到部分接受，到不能接受的部分也想想看。\n\n## 阅读的目的\n\n**阅读的目的就是改变生活。**\n\n例如认真学了概率论的人是不会去买彩票的，以前的自己太傻了，这等同于对自己已经增长了的智商的侮辱。所谓的智商是可以学出来的。\n\n改变生活中最直接有效的办法就是习得新的技能。\n\n\n## 升级自己的阅读操作系统\n\n### 不仅要只字不差地读，还要反复地读\n\n别总觉得“专业”这事高高在上，触不可及——事实上，只要你学习能力专业，无论什么，其实都可以学的比较专业。\n\n一本书，只要必要，即便是读不懂，也要读完。\n\n很多知识都不是线性的。但凡有点难度的书，都是递归结构的。有些书是这样的：想要深入理解第一章，依赖于你对后一章，例如第五章的深入理解。\n\n\n甚至连小说都是这样的。看一遍甚至看不懂，看好几遍才能发现通路。读不懂不要紧，要相信你的大脑有成长能力。什么叫悟性啊？就是反复读，想不通的东西要反复想，想着想着，不知道在那个方向上就想到通路了，这就是所谓的恍然大悟了。\n\n### 读书和学习，也是一种社交活动\n\n笑来老师总是花很多时间去读这个书的书评，总是在别人的留言里发现自己阅读的遗漏。总是有自己想的不够全面，理解的不够全面的地方，甚至会出现即便是自己挣扎了竟然也鬼使神差地错过了一些重要内容的情况。互联网改变了一切，无论多冷门的书，都有人愿意留下评论，这是多么美好的世界啊。\n\n### 提高阅读理解能力——写作\n\n像作者一样阅读。\n\n教，是最好的学习方法。\n\n遇到好书好文章好段落的时候，要只字不差的阅读，可只有少数人能做到。那如何获得这种能力呢？开始写作。\n\n阅读的时候，很有可能三心二意错过很多细节。而写作的时候，只能一个字一个字的写出来，没有办法少写，除非是拷贝粘贴。\n\n当遇到“我写出来的东西太肤浅，总不好意思拿出去给别人看”的情况时，其实这事没有什么技巧，是你长期以来阅读理解能力出了问题。\n阅读不仔细，所以你思考不深入，不严谨，不深刻，所以没有写作技巧可以帮你。\n\n写作相对于阅读来说，更有目的性，做到主动阅读。这里举了例子，一个托福作文的题目是人们为什么越来越长寿？后来笑来老师经常会回想起这个题目并一直琢磨人们为什么越来越长寿，发现一个长寿的意义，就是是赚钱时间拉长，投资时间延长，人群中可能受到福利效应的人也增加了。人群当中可能获得财富自由的人数都可能大幅度的增长，这也说明了笑来老师那个付费专栏《通往财富自由之路》是如何成型的。也就是带着目的性去思考，去阅读写作。\n\n从貌似无意义，到实际意义重大，那怎么会三心二意的学习呢。不会写作的人，读书效率一定很差，甚至连快感都会少很多。\n\n另外，他提到为了在虚构内容（即影视）中得到更多的快感，甚至看了导演，编剧有关的书籍，去上了相关课程。**其实所谓的专业，就是提高品位和品味。**\n\n看热闹的快感和看门道的快感肯定是不一样的。而且，所有的知识都融会贯通。包括可以应用导演的内容去演讲，上课。\n\n可所有这些最多的是从书本中获得的。最重要的就是只字不差的阅读直至印到脑子中。一切投资的知识，都可以通过阅读去入门。通过实践去提高，再通过阅读去深入。\n\n做不到只字不差的阅读，就很难做到只字不差的写作和只字不差的讲述。\n\n## 一些必要的说明和问答\n\n### 1.如何看待碎片化阅读\n哪有人每天捡硬币发财？每天都要给自己定一个固定长度的阅读时间，至少连续一小时，这才是正道。**到最后，一个人的总价值基本上相当于他能够有效集中注意力解决问题的时间长度再乘以那些被解决的问题在多大程度上是这个世界所需要的。**\n\n### 2.关于电子书和纸质书的选择\n关于电子书伤眼睛，其实眼睛也没那么脆弱，所谓的耳聪目明，也是一小部分老人脑子好使才有可能耳聪目明的。也就是说，视觉，听觉这东西很大一部分是由大脑决定的而不是由器官结构决定的。\n\n### 3.如何做笔记\n最早用卡片做笔记。现在不做笔记，定期做备份，需要的时候全文检索。\n推荐一个网站，浓缩书，要付费订阅。\nblinkist.com\n\n### 4.阅读一定要在安静的地方么？\n观察一下大自然就知道了，如果只能在安静的地方读书，那你就完了，你随时都有可能被打断。边上多乱都不怕，自己该干嘛就干嘛，这也就是真的硬功夫。这种基本的练习会使得一生都占便宜。\n\n一定要养成在嘈杂的环境也能看书的习惯。\n\n写作是有读者目标的。如果我读了这本书，如果我认同这本书里的道理，那么我就会认真思考，过去我有哪些事情做错了需要改正，然后将来我按照这个原则该做怎样的改变，那么我就去做，于是就固化了自己的知识。\n\n### 5.如何深入思考\n\n小的时候只是告诉我们使劲想，拼命想，想并不是靠使劲的，所谓的深入呢，不停地问自己更为深入的问题。当你学会了一个知识之后，你就要问自己：你过去哪里做错了，之后该怎么做。所谓的思考的方式就是不断地向自己提正确的问题，然后尝试着回答那些问题。\n\n\n\n\n\n\n\n\n\n","source":"_posts/摘录/知乎live分享——我的读书经验.md","raw":"---\ntitle: 知乎live分享——我的读书经验\ndate: 2016-09-20 09:51:02\ntags:\n- 读书\ncategories: 总结\n---\n这个知乎live又是李笑来老师开设的专题。尽管在李笑来老师的书中也涉及了他以前的读书经验，但因为《把时间当做朋友》是09年出版的，现在16年正好一辈子(7年)的时间。所以我更想看看目前笑来老师是如何做的，与之前的内容是否有所不同。听完分享果然干货满满，0.99也是真·良心价。\n<!-- more -->\n## 分享原则\n\n这次分享是有原则的。\n\n首先，这不是一次掉书袋（卖弄才学）的一次分享。\n其次，不会列出一长串书单。\n最后，思考是否这些看法有价值。\n\n## 我的读书路径与境界更新\n\n### 第一阶段 饥不择食\n读书这件事很难做到目标明确，如果一开始就目标明确的话，很容易会造成失去意外好运的机会。所以第一个阶段就应该漫无目的的读书，能读多少，就读多少，不用挑。因为挑书也是一种逐步积累的能力。\n\n这种饥不择食也有很大的好处，随便罗列，也有这么三个：\n\n1.阅读变成了吃饭一样的需求，不读脑子就会饿。（督促自己）\n2.经常有各种意外的好运，从莫名其妙的地方读到了原本不可能获得的知识。\n3.一不小心就积累了足够的里程——你要知道，驾驶经验远比驾驶技巧重要的多。\n\n### 第二阶段 自己挑书\n\n向别人索要书单是没有用的，书单始终是别人的书单，反而是**使自己的挑书能力逐步退化至零的最有效方法**。\n\n你的挑书能力是不可能不长进的。别人的选择结果并不重要，选择原则很具有参考价值。\n\n从逐步的阅读经验累积发现，从最早的看读者，再到看小说等虚构类的书，最后发现自己更喜欢那些“有繁殖能力”的知识，选择非虚构类书籍。相对于“有繁殖能力”的知识，有部分知识其实就是信息，并没有繁殖能力，并不能更新得到新的知识，例如那种偏门冷知识，而有人却喜欢这类，数量越多越好，个人选择罢了。\n\n我需要做到的就是：\n\n**1.我需要认清现实并思考未来**\n**2.我更喜欢有繁殖能力的知识，比如说非虚构类，英文原版书籍，心理学，经济学，策略学，脑科学。**\n\n看到这里，就又进一步的会挑了。哪个出版社更加靠谱，哪个作者更有趣，然后就很快进入第三个阶段。\n\n### 第三阶段 学术文献\n\n学术文献和通俗读物最大的区别在于作者的态度。学术论文通常不关心读者是否能读懂，他所关心的是如何自圆其说并且尽量写清楚。所以学术论文真的是很锻炼阅读理解能力的。\n\n批量阅读学术文献，刚刚开始确实会有点害怕，可没有过多久，就开始可怜起以前的自己来，总是衣来伸手，饭来张口，而没有自己去找食吃。因为学术文献再到通识读物，期间又要经历好久才能到大众眼前。\n\n### 第四阶段 检索阅读\n\n原版书大行其道，电子版开始风靡。开始建立自己的电脑图书馆，开始大量检索阅读，即有目标的阅读。当你需要什么的时候，就用关键词搜索，把那部分内容找出来参考。\n\n### 第五阶段 什么都看\n\n挑书已经成为一种内建能力，目的性减弱，可还是会挑书看。到这个阶段，开始研究真正的世界。想知道书甚至APP背后的用户是怎么样的一个世界。\n\n以上就是读书路径。从泛到精再到泛，还有另外一个维度的路径，从全盘接受，到部分接受，到不能接受的部分也想想看。\n\n## 阅读的目的\n\n**阅读的目的就是改变生活。**\n\n例如认真学了概率论的人是不会去买彩票的，以前的自己太傻了，这等同于对自己已经增长了的智商的侮辱。所谓的智商是可以学出来的。\n\n改变生活中最直接有效的办法就是习得新的技能。\n\n\n## 升级自己的阅读操作系统\n\n### 不仅要只字不差地读，还要反复地读\n\n别总觉得“专业”这事高高在上，触不可及——事实上，只要你学习能力专业，无论什么，其实都可以学的比较专业。\n\n一本书，只要必要，即便是读不懂，也要读完。\n\n很多知识都不是线性的。但凡有点难度的书，都是递归结构的。有些书是这样的：想要深入理解第一章，依赖于你对后一章，例如第五章的深入理解。\n\n\n甚至连小说都是这样的。看一遍甚至看不懂，看好几遍才能发现通路。读不懂不要紧，要相信你的大脑有成长能力。什么叫悟性啊？就是反复读，想不通的东西要反复想，想着想着，不知道在那个方向上就想到通路了，这就是所谓的恍然大悟了。\n\n### 读书和学习，也是一种社交活动\n\n笑来老师总是花很多时间去读这个书的书评，总是在别人的留言里发现自己阅读的遗漏。总是有自己想的不够全面，理解的不够全面的地方，甚至会出现即便是自己挣扎了竟然也鬼使神差地错过了一些重要内容的情况。互联网改变了一切，无论多冷门的书，都有人愿意留下评论，这是多么美好的世界啊。\n\n### 提高阅读理解能力——写作\n\n像作者一样阅读。\n\n教，是最好的学习方法。\n\n遇到好书好文章好段落的时候，要只字不差的阅读，可只有少数人能做到。那如何获得这种能力呢？开始写作。\n\n阅读的时候，很有可能三心二意错过很多细节。而写作的时候，只能一个字一个字的写出来，没有办法少写，除非是拷贝粘贴。\n\n当遇到“我写出来的东西太肤浅，总不好意思拿出去给别人看”的情况时，其实这事没有什么技巧，是你长期以来阅读理解能力出了问题。\n阅读不仔细，所以你思考不深入，不严谨，不深刻，所以没有写作技巧可以帮你。\n\n写作相对于阅读来说，更有目的性，做到主动阅读。这里举了例子，一个托福作文的题目是人们为什么越来越长寿？后来笑来老师经常会回想起这个题目并一直琢磨人们为什么越来越长寿，发现一个长寿的意义，就是是赚钱时间拉长，投资时间延长，人群中可能受到福利效应的人也增加了。人群当中可能获得财富自由的人数都可能大幅度的增长，这也说明了笑来老师那个付费专栏《通往财富自由之路》是如何成型的。也就是带着目的性去思考，去阅读写作。\n\n从貌似无意义，到实际意义重大，那怎么会三心二意的学习呢。不会写作的人，读书效率一定很差，甚至连快感都会少很多。\n\n另外，他提到为了在虚构内容（即影视）中得到更多的快感，甚至看了导演，编剧有关的书籍，去上了相关课程。**其实所谓的专业，就是提高品位和品味。**\n\n看热闹的快感和看门道的快感肯定是不一样的。而且，所有的知识都融会贯通。包括可以应用导演的内容去演讲，上课。\n\n可所有这些最多的是从书本中获得的。最重要的就是只字不差的阅读直至印到脑子中。一切投资的知识，都可以通过阅读去入门。通过实践去提高，再通过阅读去深入。\n\n做不到只字不差的阅读，就很难做到只字不差的写作和只字不差的讲述。\n\n## 一些必要的说明和问答\n\n### 1.如何看待碎片化阅读\n哪有人每天捡硬币发财？每天都要给自己定一个固定长度的阅读时间，至少连续一小时，这才是正道。**到最后，一个人的总价值基本上相当于他能够有效集中注意力解决问题的时间长度再乘以那些被解决的问题在多大程度上是这个世界所需要的。**\n\n### 2.关于电子书和纸质书的选择\n关于电子书伤眼睛，其实眼睛也没那么脆弱，所谓的耳聪目明，也是一小部分老人脑子好使才有可能耳聪目明的。也就是说，视觉，听觉这东西很大一部分是由大脑决定的而不是由器官结构决定的。\n\n### 3.如何做笔记\n最早用卡片做笔记。现在不做笔记，定期做备份，需要的时候全文检索。\n推荐一个网站，浓缩书，要付费订阅。\nblinkist.com\n\n### 4.阅读一定要在安静的地方么？\n观察一下大自然就知道了，如果只能在安静的地方读书，那你就完了，你随时都有可能被打断。边上多乱都不怕，自己该干嘛就干嘛，这也就是真的硬功夫。这种基本的练习会使得一生都占便宜。\n\n一定要养成在嘈杂的环境也能看书的习惯。\n\n写作是有读者目标的。如果我读了这本书，如果我认同这本书里的道理，那么我就会认真思考，过去我有哪些事情做错了需要改正，然后将来我按照这个原则该做怎样的改变，那么我就去做，于是就固化了自己的知识。\n\n### 5.如何深入思考\n\n小的时候只是告诉我们使劲想，拼命想，想并不是靠使劲的，所谓的深入呢，不停地问自己更为深入的问题。当你学会了一个知识之后，你就要问自己：你过去哪里做错了，之后该怎么做。所谓的思考的方式就是不断地向自己提正确的问题，然后尝试着回答那些问题。\n\n\n\n\n\n\n\n\n\n","slug":"摘录/知乎live分享——我的读书经验","published":1,"updated":"2019-03-22T14:44:36.738Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0u00aa4l3nflv2sn0g","content":"<p>这个知乎live又是李笑来老师开设的专题。尽管在李笑来老师的书中也涉及了他以前的读书经验，但因为《把时间当做朋友》是09年出版的，现在16年正好一辈子(7年)的时间。所以我更想看看目前笑来老师是如何做的，与之前的内容是否有所不同。听完分享果然干货满满，0.99也是真·良心价。<br><a id=\"more\"></a></p>\n<h2 id=\"分享原则\"><a href=\"#分享原则\" class=\"headerlink\" title=\"分享原则\"></a>分享原则</h2><p>这次分享是有原则的。</p>\n<p>首先，这不是一次掉书袋（卖弄才学）的一次分享。<br>其次，不会列出一长串书单。<br>最后，思考是否这些看法有价值。</p>\n<h2 id=\"我的读书路径与境界更新\"><a href=\"#我的读书路径与境界更新\" class=\"headerlink\" title=\"我的读书路径与境界更新\"></a>我的读书路径与境界更新</h2><h3 id=\"第一阶段-饥不择食\"><a href=\"#第一阶段-饥不择食\" class=\"headerlink\" title=\"第一阶段 饥不择食\"></a>第一阶段 饥不择食</h3><p>读书这件事很难做到目标明确，如果一开始就目标明确的话，很容易会造成失去意外好运的机会。所以第一个阶段就应该漫无目的的读书，能读多少，就读多少，不用挑。因为挑书也是一种逐步积累的能力。</p>\n<p>这种饥不择食也有很大的好处，随便罗列，也有这么三个：</p>\n<p>1.阅读变成了吃饭一样的需求，不读脑子就会饿。（督促自己）<br>2.经常有各种意外的好运，从莫名其妙的地方读到了原本不可能获得的知识。<br>3.一不小心就积累了足够的里程——你要知道，驾驶经验远比驾驶技巧重要的多。</p>\n<h3 id=\"第二阶段-自己挑书\"><a href=\"#第二阶段-自己挑书\" class=\"headerlink\" title=\"第二阶段 自己挑书\"></a>第二阶段 自己挑书</h3><p>向别人索要书单是没有用的，书单始终是别人的书单，反而是<strong>使自己的挑书能力逐步退化至零的最有效方法</strong>。</p>\n<p>你的挑书能力是不可能不长进的。别人的选择结果并不重要，选择原则很具有参考价值。</p>\n<p>从逐步的阅读经验累积发现，从最早的看读者，再到看小说等虚构类的书，最后发现自己更喜欢那些“有繁殖能力”的知识，选择非虚构类书籍。相对于“有繁殖能力”的知识，有部分知识其实就是信息，并没有繁殖能力，并不能更新得到新的知识，例如那种偏门冷知识，而有人却喜欢这类，数量越多越好，个人选择罢了。</p>\n<p>我需要做到的就是：</p>\n<p><strong>1.我需要认清现实并思考未来</strong><br><strong>2.我更喜欢有繁殖能力的知识，比如说非虚构类，英文原版书籍，心理学，经济学，策略学，脑科学。</strong></p>\n<p>看到这里，就又进一步的会挑了。哪个出版社更加靠谱，哪个作者更有趣，然后就很快进入第三个阶段。</p>\n<h3 id=\"第三阶段-学术文献\"><a href=\"#第三阶段-学术文献\" class=\"headerlink\" title=\"第三阶段 学术文献\"></a>第三阶段 学术文献</h3><p>学术文献和通俗读物最大的区别在于作者的态度。学术论文通常不关心读者是否能读懂，他所关心的是如何自圆其说并且尽量写清楚。所以学术论文真的是很锻炼阅读理解能力的。</p>\n<p>批量阅读学术文献，刚刚开始确实会有点害怕，可没有过多久，就开始可怜起以前的自己来，总是衣来伸手，饭来张口，而没有自己去找食吃。因为学术文献再到通识读物，期间又要经历好久才能到大众眼前。</p>\n<h3 id=\"第四阶段-检索阅读\"><a href=\"#第四阶段-检索阅读\" class=\"headerlink\" title=\"第四阶段 检索阅读\"></a>第四阶段 检索阅读</h3><p>原版书大行其道，电子版开始风靡。开始建立自己的电脑图书馆，开始大量检索阅读，即有目标的阅读。当你需要什么的时候，就用关键词搜索，把那部分内容找出来参考。</p>\n<h3 id=\"第五阶段-什么都看\"><a href=\"#第五阶段-什么都看\" class=\"headerlink\" title=\"第五阶段 什么都看\"></a>第五阶段 什么都看</h3><p>挑书已经成为一种内建能力，目的性减弱，可还是会挑书看。到这个阶段，开始研究真正的世界。想知道书甚至APP背后的用户是怎么样的一个世界。</p>\n<p>以上就是读书路径。从泛到精再到泛，还有另外一个维度的路径，从全盘接受，到部分接受，到不能接受的部分也想想看。</p>\n<h2 id=\"阅读的目的\"><a href=\"#阅读的目的\" class=\"headerlink\" title=\"阅读的目的\"></a>阅读的目的</h2><p><strong>阅读的目的就是改变生活。</strong></p>\n<p>例如认真学了概率论的人是不会去买彩票的，以前的自己太傻了，这等同于对自己已经增长了的智商的侮辱。所谓的智商是可以学出来的。</p>\n<p>改变生活中最直接有效的办法就是习得新的技能。</p>\n<h2 id=\"升级自己的阅读操作系统\"><a href=\"#升级自己的阅读操作系统\" class=\"headerlink\" title=\"升级自己的阅读操作系统\"></a>升级自己的阅读操作系统</h2><h3 id=\"不仅要只字不差地读，还要反复地读\"><a href=\"#不仅要只字不差地读，还要反复地读\" class=\"headerlink\" title=\"不仅要只字不差地读，还要反复地读\"></a>不仅要只字不差地读，还要反复地读</h3><p>别总觉得“专业”这事高高在上，触不可及——事实上，只要你学习能力专业，无论什么，其实都可以学的比较专业。</p>\n<p>一本书，只要必要，即便是读不懂，也要读完。</p>\n<p>很多知识都不是线性的。但凡有点难度的书，都是递归结构的。有些书是这样的：想要深入理解第一章，依赖于你对后一章，例如第五章的深入理解。</p>\n<p>甚至连小说都是这样的。看一遍甚至看不懂，看好几遍才能发现通路。读不懂不要紧，要相信你的大脑有成长能力。什么叫悟性啊？就是反复读，想不通的东西要反复想，想着想着，不知道在那个方向上就想到通路了，这就是所谓的恍然大悟了。</p>\n<h3 id=\"读书和学习，也是一种社交活动\"><a href=\"#读书和学习，也是一种社交活动\" class=\"headerlink\" title=\"读书和学习，也是一种社交活动\"></a>读书和学习，也是一种社交活动</h3><p>笑来老师总是花很多时间去读这个书的书评，总是在别人的留言里发现自己阅读的遗漏。总是有自己想的不够全面，理解的不够全面的地方，甚至会出现即便是自己挣扎了竟然也鬼使神差地错过了一些重要内容的情况。互联网改变了一切，无论多冷门的书，都有人愿意留下评论，这是多么美好的世界啊。</p>\n<h3 id=\"提高阅读理解能力——写作\"><a href=\"#提高阅读理解能力——写作\" class=\"headerlink\" title=\"提高阅读理解能力——写作\"></a>提高阅读理解能力——写作</h3><p>像作者一样阅读。</p>\n<p>教，是最好的学习方法。</p>\n<p>遇到好书好文章好段落的时候，要只字不差的阅读，可只有少数人能做到。那如何获得这种能力呢？开始写作。</p>\n<p>阅读的时候，很有可能三心二意错过很多细节。而写作的时候，只能一个字一个字的写出来，没有办法少写，除非是拷贝粘贴。</p>\n<p>当遇到“我写出来的东西太肤浅，总不好意思拿出去给别人看”的情况时，其实这事没有什么技巧，是你长期以来阅读理解能力出了问题。<br>阅读不仔细，所以你思考不深入，不严谨，不深刻，所以没有写作技巧可以帮你。</p>\n<p>写作相对于阅读来说，更有目的性，做到主动阅读。这里举了例子，一个托福作文的题目是人们为什么越来越长寿？后来笑来老师经常会回想起这个题目并一直琢磨人们为什么越来越长寿，发现一个长寿的意义，就是是赚钱时间拉长，投资时间延长，人群中可能受到福利效应的人也增加了。人群当中可能获得财富自由的人数都可能大幅度的增长，这也说明了笑来老师那个付费专栏《通往财富自由之路》是如何成型的。也就是带着目的性去思考，去阅读写作。</p>\n<p>从貌似无意义，到实际意义重大，那怎么会三心二意的学习呢。不会写作的人，读书效率一定很差，甚至连快感都会少很多。</p>\n<p>另外，他提到为了在虚构内容（即影视）中得到更多的快感，甚至看了导演，编剧有关的书籍，去上了相关课程。<strong>其实所谓的专业，就是提高品位和品味。</strong></p>\n<p>看热闹的快感和看门道的快感肯定是不一样的。而且，所有的知识都融会贯通。包括可以应用导演的内容去演讲，上课。</p>\n<p>可所有这些最多的是从书本中获得的。最重要的就是只字不差的阅读直至印到脑子中。一切投资的知识，都可以通过阅读去入门。通过实践去提高，再通过阅读去深入。</p>\n<p>做不到只字不差的阅读，就很难做到只字不差的写作和只字不差的讲述。</p>\n<h2 id=\"一些必要的说明和问答\"><a href=\"#一些必要的说明和问答\" class=\"headerlink\" title=\"一些必要的说明和问答\"></a>一些必要的说明和问答</h2><h3 id=\"1-如何看待碎片化阅读\"><a href=\"#1-如何看待碎片化阅读\" class=\"headerlink\" title=\"1.如何看待碎片化阅读\"></a>1.如何看待碎片化阅读</h3><p>哪有人每天捡硬币发财？每天都要给自己定一个固定长度的阅读时间，至少连续一小时，这才是正道。<strong>到最后，一个人的总价值基本上相当于他能够有效集中注意力解决问题的时间长度再乘以那些被解决的问题在多大程度上是这个世界所需要的。</strong></p>\n<h3 id=\"2-关于电子书和纸质书的选择\"><a href=\"#2-关于电子书和纸质书的选择\" class=\"headerlink\" title=\"2.关于电子书和纸质书的选择\"></a>2.关于电子书和纸质书的选择</h3><p>关于电子书伤眼睛，其实眼睛也没那么脆弱，所谓的耳聪目明，也是一小部分老人脑子好使才有可能耳聪目明的。也就是说，视觉，听觉这东西很大一部分是由大脑决定的而不是由器官结构决定的。</p>\n<h3 id=\"3-如何做笔记\"><a href=\"#3-如何做笔记\" class=\"headerlink\" title=\"3.如何做笔记\"></a>3.如何做笔记</h3><p>最早用卡片做笔记。现在不做笔记，定期做备份，需要的时候全文检索。<br>推荐一个网站，浓缩书，要付费订阅。<br>blinkist.com</p>\n<h3 id=\"4-阅读一定要在安静的地方么？\"><a href=\"#4-阅读一定要在安静的地方么？\" class=\"headerlink\" title=\"4.阅读一定要在安静的地方么？\"></a>4.阅读一定要在安静的地方么？</h3><p>观察一下大自然就知道了，如果只能在安静的地方读书，那你就完了，你随时都有可能被打断。边上多乱都不怕，自己该干嘛就干嘛，这也就是真的硬功夫。这种基本的练习会使得一生都占便宜。</p>\n<p>一定要养成在嘈杂的环境也能看书的习惯。</p>\n<p>写作是有读者目标的。如果我读了这本书，如果我认同这本书里的道理，那么我就会认真思考，过去我有哪些事情做错了需要改正，然后将来我按照这个原则该做怎样的改变，那么我就去做，于是就固化了自己的知识。</p>\n<h3 id=\"5-如何深入思考\"><a href=\"#5-如何深入思考\" class=\"headerlink\" title=\"5.如何深入思考\"></a>5.如何深入思考</h3><p>小的时候只是告诉我们使劲想，拼命想，想并不是靠使劲的，所谓的深入呢，不停地问自己更为深入的问题。当你学会了一个知识之后，你就要问自己：你过去哪里做错了，之后该怎么做。所谓的思考的方式就是不断地向自己提正确的问题，然后尝试着回答那些问题。</p>\n","site":{"data":{}},"excerpt":"<p>这个知乎live又是李笑来老师开设的专题。尽管在李笑来老师的书中也涉及了他以前的读书经验，但因为《把时间当做朋友》是09年出版的，现在16年正好一辈子(7年)的时间。所以我更想看看目前笑来老师是如何做的，与之前的内容是否有所不同。听完分享果然干货满满，0.99也是真·良心价。<br></p>","more":"<p></p>\n<h2 id=\"分享原则\"><a href=\"#分享原则\" class=\"headerlink\" title=\"分享原则\"></a>分享原则</h2><p>这次分享是有原则的。</p>\n<p>首先，这不是一次掉书袋（卖弄才学）的一次分享。<br>其次，不会列出一长串书单。<br>最后，思考是否这些看法有价值。</p>\n<h2 id=\"我的读书路径与境界更新\"><a href=\"#我的读书路径与境界更新\" class=\"headerlink\" title=\"我的读书路径与境界更新\"></a>我的读书路径与境界更新</h2><h3 id=\"第一阶段-饥不择食\"><a href=\"#第一阶段-饥不择食\" class=\"headerlink\" title=\"第一阶段 饥不择食\"></a>第一阶段 饥不择食</h3><p>读书这件事很难做到目标明确，如果一开始就目标明确的话，很容易会造成失去意外好运的机会。所以第一个阶段就应该漫无目的的读书，能读多少，就读多少，不用挑。因为挑书也是一种逐步积累的能力。</p>\n<p>这种饥不择食也有很大的好处，随便罗列，也有这么三个：</p>\n<p>1.阅读变成了吃饭一样的需求，不读脑子就会饿。（督促自己）<br>2.经常有各种意外的好运，从莫名其妙的地方读到了原本不可能获得的知识。<br>3.一不小心就积累了足够的里程——你要知道，驾驶经验远比驾驶技巧重要的多。</p>\n<h3 id=\"第二阶段-自己挑书\"><a href=\"#第二阶段-自己挑书\" class=\"headerlink\" title=\"第二阶段 自己挑书\"></a>第二阶段 自己挑书</h3><p>向别人索要书单是没有用的，书单始终是别人的书单，反而是<strong>使自己的挑书能力逐步退化至零的最有效方法</strong>。</p>\n<p>你的挑书能力是不可能不长进的。别人的选择结果并不重要，选择原则很具有参考价值。</p>\n<p>从逐步的阅读经验累积发现，从最早的看读者，再到看小说等虚构类的书，最后发现自己更喜欢那些“有繁殖能力”的知识，选择非虚构类书籍。相对于“有繁殖能力”的知识，有部分知识其实就是信息，并没有繁殖能力，并不能更新得到新的知识，例如那种偏门冷知识，而有人却喜欢这类，数量越多越好，个人选择罢了。</p>\n<p>我需要做到的就是：</p>\n<p><strong>1.我需要认清现实并思考未来</strong><br><strong>2.我更喜欢有繁殖能力的知识，比如说非虚构类，英文原版书籍，心理学，经济学，策略学，脑科学。</strong></p>\n<p>看到这里，就又进一步的会挑了。哪个出版社更加靠谱，哪个作者更有趣，然后就很快进入第三个阶段。</p>\n<h3 id=\"第三阶段-学术文献\"><a href=\"#第三阶段-学术文献\" class=\"headerlink\" title=\"第三阶段 学术文献\"></a>第三阶段 学术文献</h3><p>学术文献和通俗读物最大的区别在于作者的态度。学术论文通常不关心读者是否能读懂，他所关心的是如何自圆其说并且尽量写清楚。所以学术论文真的是很锻炼阅读理解能力的。</p>\n<p>批量阅读学术文献，刚刚开始确实会有点害怕，可没有过多久，就开始可怜起以前的自己来，总是衣来伸手，饭来张口，而没有自己去找食吃。因为学术文献再到通识读物，期间又要经历好久才能到大众眼前。</p>\n<h3 id=\"第四阶段-检索阅读\"><a href=\"#第四阶段-检索阅读\" class=\"headerlink\" title=\"第四阶段 检索阅读\"></a>第四阶段 检索阅读</h3><p>原版书大行其道，电子版开始风靡。开始建立自己的电脑图书馆，开始大量检索阅读，即有目标的阅读。当你需要什么的时候，就用关键词搜索，把那部分内容找出来参考。</p>\n<h3 id=\"第五阶段-什么都看\"><a href=\"#第五阶段-什么都看\" class=\"headerlink\" title=\"第五阶段 什么都看\"></a>第五阶段 什么都看</h3><p>挑书已经成为一种内建能力，目的性减弱，可还是会挑书看。到这个阶段，开始研究真正的世界。想知道书甚至APP背后的用户是怎么样的一个世界。</p>\n<p>以上就是读书路径。从泛到精再到泛，还有另外一个维度的路径，从全盘接受，到部分接受，到不能接受的部分也想想看。</p>\n<h2 id=\"阅读的目的\"><a href=\"#阅读的目的\" class=\"headerlink\" title=\"阅读的目的\"></a>阅读的目的</h2><p><strong>阅读的目的就是改变生活。</strong></p>\n<p>例如认真学了概率论的人是不会去买彩票的，以前的自己太傻了，这等同于对自己已经增长了的智商的侮辱。所谓的智商是可以学出来的。</p>\n<p>改变生活中最直接有效的办法就是习得新的技能。</p>\n<h2 id=\"升级自己的阅读操作系统\"><a href=\"#升级自己的阅读操作系统\" class=\"headerlink\" title=\"升级自己的阅读操作系统\"></a>升级自己的阅读操作系统</h2><h3 id=\"不仅要只字不差地读，还要反复地读\"><a href=\"#不仅要只字不差地读，还要反复地读\" class=\"headerlink\" title=\"不仅要只字不差地读，还要反复地读\"></a>不仅要只字不差地读，还要反复地读</h3><p>别总觉得“专业”这事高高在上，触不可及——事实上，只要你学习能力专业，无论什么，其实都可以学的比较专业。</p>\n<p>一本书，只要必要，即便是读不懂，也要读完。</p>\n<p>很多知识都不是线性的。但凡有点难度的书，都是递归结构的。有些书是这样的：想要深入理解第一章，依赖于你对后一章，例如第五章的深入理解。</p>\n<p>甚至连小说都是这样的。看一遍甚至看不懂，看好几遍才能发现通路。读不懂不要紧，要相信你的大脑有成长能力。什么叫悟性啊？就是反复读，想不通的东西要反复想，想着想着，不知道在那个方向上就想到通路了，这就是所谓的恍然大悟了。</p>\n<h3 id=\"读书和学习，也是一种社交活动\"><a href=\"#读书和学习，也是一种社交活动\" class=\"headerlink\" title=\"读书和学习，也是一种社交活动\"></a>读书和学习，也是一种社交活动</h3><p>笑来老师总是花很多时间去读这个书的书评，总是在别人的留言里发现自己阅读的遗漏。总是有自己想的不够全面，理解的不够全面的地方，甚至会出现即便是自己挣扎了竟然也鬼使神差地错过了一些重要内容的情况。互联网改变了一切，无论多冷门的书，都有人愿意留下评论，这是多么美好的世界啊。</p>\n<h3 id=\"提高阅读理解能力——写作\"><a href=\"#提高阅读理解能力——写作\" class=\"headerlink\" title=\"提高阅读理解能力——写作\"></a>提高阅读理解能力——写作</h3><p>像作者一样阅读。</p>\n<p>教，是最好的学习方法。</p>\n<p>遇到好书好文章好段落的时候，要只字不差的阅读，可只有少数人能做到。那如何获得这种能力呢？开始写作。</p>\n<p>阅读的时候，很有可能三心二意错过很多细节。而写作的时候，只能一个字一个字的写出来，没有办法少写，除非是拷贝粘贴。</p>\n<p>当遇到“我写出来的东西太肤浅，总不好意思拿出去给别人看”的情况时，其实这事没有什么技巧，是你长期以来阅读理解能力出了问题。<br>阅读不仔细，所以你思考不深入，不严谨，不深刻，所以没有写作技巧可以帮你。</p>\n<p>写作相对于阅读来说，更有目的性，做到主动阅读。这里举了例子，一个托福作文的题目是人们为什么越来越长寿？后来笑来老师经常会回想起这个题目并一直琢磨人们为什么越来越长寿，发现一个长寿的意义，就是是赚钱时间拉长，投资时间延长，人群中可能受到福利效应的人也增加了。人群当中可能获得财富自由的人数都可能大幅度的增长，这也说明了笑来老师那个付费专栏《通往财富自由之路》是如何成型的。也就是带着目的性去思考，去阅读写作。</p>\n<p>从貌似无意义，到实际意义重大，那怎么会三心二意的学习呢。不会写作的人，读书效率一定很差，甚至连快感都会少很多。</p>\n<p>另外，他提到为了在虚构内容（即影视）中得到更多的快感，甚至看了导演，编剧有关的书籍，去上了相关课程。<strong>其实所谓的专业，就是提高品位和品味。</strong></p>\n<p>看热闹的快感和看门道的快感肯定是不一样的。而且，所有的知识都融会贯通。包括可以应用导演的内容去演讲，上课。</p>\n<p>可所有这些最多的是从书本中获得的。最重要的就是只字不差的阅读直至印到脑子中。一切投资的知识，都可以通过阅读去入门。通过实践去提高，再通过阅读去深入。</p>\n<p>做不到只字不差的阅读，就很难做到只字不差的写作和只字不差的讲述。</p>\n<h2 id=\"一些必要的说明和问答\"><a href=\"#一些必要的说明和问答\" class=\"headerlink\" title=\"一些必要的说明和问答\"></a>一些必要的说明和问答</h2><h3 id=\"1-如何看待碎片化阅读\"><a href=\"#1-如何看待碎片化阅读\" class=\"headerlink\" title=\"1.如何看待碎片化阅读\"></a>1.如何看待碎片化阅读</h3><p>哪有人每天捡硬币发财？每天都要给自己定一个固定长度的阅读时间，至少连续一小时，这才是正道。<strong>到最后，一个人的总价值基本上相当于他能够有效集中注意力解决问题的时间长度再乘以那些被解决的问题在多大程度上是这个世界所需要的。</strong></p>\n<h3 id=\"2-关于电子书和纸质书的选择\"><a href=\"#2-关于电子书和纸质书的选择\" class=\"headerlink\" title=\"2.关于电子书和纸质书的选择\"></a>2.关于电子书和纸质书的选择</h3><p>关于电子书伤眼睛，其实眼睛也没那么脆弱，所谓的耳聪目明，也是一小部分老人脑子好使才有可能耳聪目明的。也就是说，视觉，听觉这东西很大一部分是由大脑决定的而不是由器官结构决定的。</p>\n<h3 id=\"3-如何做笔记\"><a href=\"#3-如何做笔记\" class=\"headerlink\" title=\"3.如何做笔记\"></a>3.如何做笔记</h3><p>最早用卡片做笔记。现在不做笔记，定期做备份，需要的时候全文检索。<br>推荐一个网站，浓缩书，要付费订阅。<br>blinkist.com</p>\n<h3 id=\"4-阅读一定要在安静的地方么？\"><a href=\"#4-阅读一定要在安静的地方么？\" class=\"headerlink\" title=\"4.阅读一定要在安静的地方么？\"></a>4.阅读一定要在安静的地方么？</h3><p>观察一下大自然就知道了，如果只能在安静的地方读书，那你就完了，你随时都有可能被打断。边上多乱都不怕，自己该干嘛就干嘛，这也就是真的硬功夫。这种基本的练习会使得一生都占便宜。</p>\n<p>一定要养成在嘈杂的环境也能看书的习惯。</p>\n<p>写作是有读者目标的。如果我读了这本书，如果我认同这本书里的道理，那么我就会认真思考，过去我有哪些事情做错了需要改正，然后将来我按照这个原则该做怎样的改变，那么我就去做，于是就固化了自己的知识。</p>\n<h3 id=\"5-如何深入思考\"><a href=\"#5-如何深入思考\" class=\"headerlink\" title=\"5.如何深入思考\"></a>5.如何深入思考</h3><p>小的时候只是告诉我们使劲想，拼命想，想并不是靠使劲的，所谓的深入呢，不停地问自己更为深入的问题。当你学会了一个知识之后，你就要问自己：你过去哪里做错了，之后该怎么做。所谓的思考的方式就是不断地向自己提正确的问题，然后尝试着回答那些问题。</p>"},{"title":"如何看懂K线","date":"2019-09-08T14:35:00.000Z","_content":"\n此篇内容是基于摸鱼小组的一个K线学习课的小结，需要时常温故知新并有序执行。\n<!-- more -->\n### 基础概念\n\n成交量： 一段时间内成交的股数。成交额：则表示成交量 * 股价；\n在相同的成交量的时候，股价的不一致，会导致成交额的不一致；\n换手率： 成交量 / 总股本 or 流通股本\n内盘： 主动卖出方的数量\n外盘： 主动买入方的数量\n成交量 = 外盘 + 内盘\n\n### 量价关系\n\n量分为： 放量，常量，缩量\n价分为： 上涨，横盘，下跌\n因此分为 3*3= 9种组合。\n\n放量上涨： 主动买盘增加，意味着增量资金进场，较为乐观；\n\n放量下跌： 主动卖盘增加，一般不健康，但是也有特殊情形，在牛市中出现单根的放量下跌， 意味着获利盘出逃， 多头依然强势时，有买入的机会。\n\n放量横盘： 多空双方力量僵持；\n\n缩量上涨： 主动卖盘减少，意味着投资者锁仓，在贵州茅台的拉升中，有这种情况的出现。一般有长期投资者介入才会有这种情况出现。\n\n缩量下跌：主动买盘减少，两种情况会出现： 下跌趋势中的阴跌走势和上涨趋势后的回调，由于在回调周期，是健康的，我们可以对行情看高一线；\n\n缩量横盘： 继续观察；\n\n常量则沿着当前趋势继续；\n\n量价分析其本质是为了通过分析市场背后多头和空头的态度对市场进一步地研判。\n\n那么如何判断缩量，常量和放量呢？一般认为3%以下属于缩量， 5%以下常量， 12%放量，以上则为巨量。\n一般通过换手率来判断量的程度，不同股的比例不同，不能死记硬背；\n\n放量则表示：\n1. 市场出现分歧，看空与看多的双方有非常多的争议；\n2. 主力行为，庄家对个股进行对倒，并不真实，避免交易；\n\n缩量一般认为投资者达成共识，比较真实；\n\n### 均线系统\n全称移动平均线MA， 有20世纪中期葛南维提出。我们日常听说的五日线，十日线，二十日线都属于均线系统。不同之处就在于周期不同。是趋势指标。\n五日均线：从今天开始往前数5天，五天收盘价的平均值作为均线数值。\n\n均线有三个特点：稳定性，滞后性，引力性。这个从字面可以理解。\n引力性这里要引入乖离的概念， 股价与均线远近程度有关。当股价距离均线较远时，则表示乖离较大，具有回调的需求。\n\n### 均线状态\n分为多头排列，空头排列\n短期均线高于长期均线，则以持股为主；当短期均线下穿长期均线，这个时候多头均线已经破坏，应该适当减仓；如果短期均线都低于长线均线，则以持币为主。\n要注意的是， 由于是趋势指标， 多空相互转变时，一定是指示右侧操作，也就意味着，不可能买在最低点，也不可能卖在最高点。\n\n特点：趋势行情中，收益较大，震荡行情收益并不好。但是趋势并不是这么好判断的。对于市场，我们最怕的并不是做错，而是没有结论。\n\n### 均线作用\n由于均线是几日的平均值，也一定程度上反映了投资者的成本。这个价格一般对于股价具有一定的支撑和压力作用。\n比如股价一路上行，但是只要一往下触碰到20日均线就会停止调整继续向上。那么20日线就是股价的支撑线。很多人会找到20线和30日线作为股价的压力线和支撑线。那么，当趋势运行时，给趋势提供支撑或者压力的那根均线，就是可以被用作判断的均线。\n\n### 交易方式\n#### 金叉死叉\n当短期均线上穿长期均线时买入，当短期均线下穿长期均线时卖出。\n但是一旦进入震荡期，就容易频繁止损。这也是趋势指标的特点。\n\n#### 葛南维八大买卖法\n\n![葛南维八大买卖法](K线的基础知识/葛南维八大买卖法.jpeg)\n\n### K线形态\n结合量价分析来进行观察分析\n\n#### 单根K线\n\n* 大阳线\n\n分为放量大阳线和常量大阳线。\n放量大阳线意味着有买入也有卖出，平均成本抬升，多头强劲。\n常量大阳线意味着空头不多。\n需要分析持有筹码的投资者锁仓，还是庄家持有大量筹码。\n如果是后者，需要考虑庄家的筹码可能存在抛压，投资风险不小。\n\n* 大阴线\n\n放量：说明在大跌的同时，有不少投资者接盘。暂时安全。但是在股灾的时候也会出现连续下跌。\n\n缩量：空头不需要卖出多少量就可以把价格砸的很低。一般出现在被市场边缘化的股票，并且股票会有持续下跌的趋势。需要无比等待。等股价逆转才开始介入。\n\n\n* 上影线\n\n属于股价冲高回落而形成的。\n1. 到了短期高点，需要等待空头完全释放再考虑介入。\n2. 因大盘下跌拉低股价。这种往往是错杀股，若在第二天大盘企稳，则会有不错的收益。\n\n* 下影线\n\n股价先向下，再向上回收。\n1. 短期空头已经跌杀完毕，可以看涨。\n2. 投资者心态买入和卖出不同，一般为个股的行为。单独受大盘的影响出现这个走势可能性较小。如果大盘出现比较长的下影线，那就意味着接下来的几天是比较安全的。\n\n#### K线组合\n\n* M顶和W底\n\n  ![W底](K线的基础知识/Wdi.png) \nK线组合其实就是多空力量相互抗衡。C点和E点是买点。\n当股价第一次到达A点时，空头是比较强的。接下来是多头力量开始反击，A点直至B点，BF的高度就是多头的力量。接下来股价从B点直至C点，BF的长度也意味着空头的力量，此时发现空头力量开始衰竭，甚至在C点开始反转，那么C点则为多空头力量均衡点，此时可以押注多头。\nC点之后，直到D点，发现CD长于BC，说明多头强于空头。所以我们等待空头的再一次释放。\nE点就是我们的最后机会。当到达颈线位置时止跌，说明颈线下方的筹码已经不愿意卖了。M顶也是一样的分析方法。\n\n* 头肩顶和头肩底\n\n  ![头肩底](K线的基础知识/头肩底.png) \n我们用多空分析的方法来进行同样的分析，就可以发现，E点是第一个买点，颈线则为第二个买点。\n\n其实和数学题一样，明白道理之后需要大量的实践来进行验证。\n\n### K线形态\n\n#### 趋势线\n![趋势线](K线的基础知识/趋势线.png) \n连上股价的高点和低点，我们就得到了趋势线。\n当股价下跌或上涨击破趋势线则认为趋势可能被破坏，那么需要等待一个反抽的机会再做交易。\n并不是趋势一被击破，就认为趋势被破坏了，我们还要观察原趋势的能量是否能把股价拉回到趋势中。\n如果可以拉回，就需要改变趋势线的画法，将起始点与最新的低点或者高点连接，从而形成新的一条趋势线。\n如果不能拉回，则有可能股价反转。\n#### 三角形\n把上涨趋势和下跌趋势都画出来之后，一般会得到一个三角形，股价会在这个三角形内运动。\n当股价突破三角形的一条边时，则要看股价是否会波动回三角形中。\n如果回到三角形里，那还是继续在三角形内部波动。\n如果不会，这个三角形已经收敛完毕，股价将会朝着另一个方向再次趋势运动。\n![三角形](K线的基础知识/三角形.png) \n\n#### 箱体\n趋势线的一种特殊形态就是箱体。股价突破一边不回落至箱体内，则运行结束。\n\n![箱体](K线的基础知识/箱体.png) \n\n#### 缺口理论\n一般在趋势较强或者出现重大消息时，股价在开盘会有大波动，此时会形成缺口。需要结合量价分析一起看。\n\n|类型|描述|指导意义\n|-----------|:-----------------|:-----------------|\n|普通型缺口 |幅度不大，多空均衡 可能会回落或者冲高回补缺口| 后续可能回补|\n|突破缺口| 力量强，继续上涨或者下跌| 重大基本面变化，短时间内不会回补，顺势而为|\n|衰竭缺口| 上涨或者下跌的后端|需要警惕是否反向力量即将出现|\n\n#### 波浪理论\n\n##### 1.波浪构造\n波浪理论是20世纪30年代由艾罗特·波浪提出。\n分为主要趋势：主浪【五个子浪12345】\n次要趋势：调整浪【三个子浪，ABC】\n\n波浪理论认为，市场所有的波动都是由5+3浪组成的。而每一个浪型中的子浪又能分出子浪。\n![波浪](K线的基础知识/波浪.png) \n##### 2.波浪规则\n\n这是为了解决千人千浪的问题。\n##### 1）4浪不能进入2浪\n四浪的最低点不可低于二郎最高点\n![整个二浪](K线的基础知识/整个二浪.png)  \n##### 2）三浪是整个波浪中最好挣钱的浪\n原因： \n1.一浪难判断，由于存在趋势反转，难以判断准确\n2.二浪调整弱\n3.三浪力度强\n\n首先要数清楚2浪中的C浪是什么时候结束的。C浪的最低点不一定是二浪的最低点。\n\n##### 3）浪形可延长，五浪难言顶\n一个浪走出第五浪，如果反方力量一直不出现，那么市场会沿着当前形势继续前行。\n五浪不知道何时才到顶，也正是市场的魅力所在。\n因此我们要做的是，找出能 **决策** 的点。而不是任何一个时间点都进行判断。\n\n\n#### 3.浪形分析\n##### 形态\n主浪：沿着当前趋势走，向上或向下。只需要对比135浪斜率的不同。\n调整浪：\n![二浪](K线的基础知识/二浪.png) \n![四浪](K线的基础知识/四浪.png) \n\n##### 浪形的长度（时间维度）\n* 无法确定第一浪的时间长度\n* 二三四浪的时间长度与一浪相当（时间差平均不超过20%）\n* 不判断五浪\n\n原则： 多空双方出牌时间相当\n\n多头出完空头出，如果时间太短，则空头可能还没出完；如果时间太长，空头可能已经出牌结束，多头再出。\n如果从股价的角度没有看到多头出牌，而从时间的角度感受到多头出牌，则又可能趋势出现反转。\n\n##### 浪形的宽度（空间维度）\n![浪形宽度](K线的基础知识/浪形宽度.png) \n调整幅度有多大可以通过黄金分割和50分位来提前判断。\n如图所述，二浪回撤有以下几个点位的可能性，19.1%，38.2%，50%，61.8%。\n\n* 调整浪幅度有多大？\n\n二浪通过一浪的涨幅来判断，四浪则通过三浪的涨幅来计算。\n\n* 三浪有多高呢？\n\n三浪的高度在一浪的1.618至2.618倍区间内。\n\n通过波浪理论，可以了解到接下来哪种走势最有可能，来辅助做出投资决策。\n\n#### 技术指标\n\n分类：趋势指标（MACD），乖离指标（KDJ），支撑压力指标（BOLL）。\n每类各挑一种来做解析。\n\n\n##### MACD\nMACD应用了移动平均线的原理，通过计算得出。\n![MACD](K线的基础知识/MACD.png) \n黄线代表快线，蓝线代表缦线，红色柱子和绿色柱子代表（快线-慢线）*2\n\n一般认为柱子呈现红色，处于多头市场；柱子呈现绿色则反之。颜色反转处则认为是买入/卖出信号。\n\n当两根线都处于0轴以上，则认为绿柱是调整；\n当两根线都处于0轴以下，则认为红柱为反弹。\n\n* 背离\n\n![MACD背离](K线的基础知识/MACD背离.png) \n股价和MACD出现相反走势则称之为背离。\n如果股价创新高，而MACD不创新高，则认为是顶背离，通常作为卖出信号；\n![底背离](K线的基础知识/底背离.png) \n如果股价创新低，MACD不创新低，则认为是底背离。通常是一个买入信号。\n这就意味着趋势可能发生改变。\n\n##### KDJ\nn(9)日RSV = (Cn - Ln) / (Hn - Ln) * 100\nCn为第n日收盘价，Ln为n日内最低价，Hn为n日内最高价\nK值 = 2/3 * 前一日K值+ 1/3 * 当日RSV\nD值 = 2/3 * 前一日D值+ 1/3 * 当日K值\nJ值 = 3 * 当日K值 - 2 * 当日D值\n无值，K，D则用50代替。\n\n用来判断是否出现超买超卖。\n![KDJ](K线的基础知识/KDJ.png) \n三者线的区别子在于变化速度不同。\n当触及100的上限，则认为是超买，有可能回调；\n当触及-100的下限，则认为是超卖，有可能会反弹。\n这个指标更适合帮助我们判断回调和反弹结束，用来加仓或者减仓。\n\n##### BOLL\n布林线又称为布林轨，由三根线组成。\n中间的线称之为中轨线，是N日的移动平均线。\n上轨线 = 中轨线 + 两倍的标准差\n下轨线 = 中轨线 + 两倍的标准差\n一般这个N是20。\n\n是一个分布概率的指标，可以大概确定支撑压力。接近上轨卖出，接近下轨买入。\n用来指导我们适当加仓和减仓。\n![BOLL](K线的基础知识/BOLL.png) \n\n\n上述三种指标中，MACD比较重要，有重要的指导意义，需要在实战中经常使用。\n\n#### 看盘\n主要讲看盘看什么，怎么看。\n\n##### 软件\n行情软件： 同花顺，通达信，东方财富，Wind等；\n新闻软件：Wind， 财联社等，提供24小时新闻滚动；\n\n越早了解到一些投资信息，交易越有优势。\n\n##### 编排操作页面\n一般关注板块涨幅排序，关注股票的移动，全市场短线的涨跌；\n\n##### 看个股盘口成交\n主要应用于短线投资。\n![BOLL](K线的基础知识/BOLL.png)\n\n* 如何在上冲下冲结束后，以比较精准的价位买入或者卖出呢？\n\n委买委卖的差额，就可以用来判断这个指标。\n负值是卖盘大于买盘，比较常见，一般来说，总委卖是总委买的两倍左右。\n需要观察差额反向波动，当差额反向波动大时，需要立刻做出买卖操作。\n\n![委买委卖](K线的基础知识/委买委卖.png)\n\n当股价上涨或下跌到证书关口时，往往会有压力或者支撑。\n也要注意指数的假突破。要看买盘和卖盘是否可以顺利接上。\n\n##### 看大盘\n\n![看大盘](K线的基础知识/看大盘.png)\n当黄线高于白线，则小盘股比较强，投资者总体偏爱小盘股，说明市场氛围好；\n当白线高于黄线，则大盘股比较强。\n\n","source":"_posts/学做操盘手/K线的基础知识.md","raw":"---\ntitle: 如何看懂K线\ndate: 2019-09-08 22:35:00\ntags: \n- K线\ncategories: 学做操盘手\n---\n\n此篇内容是基于摸鱼小组的一个K线学习课的小结，需要时常温故知新并有序执行。\n<!-- more -->\n### 基础概念\n\n成交量： 一段时间内成交的股数。成交额：则表示成交量 * 股价；\n在相同的成交量的时候，股价的不一致，会导致成交额的不一致；\n换手率： 成交量 / 总股本 or 流通股本\n内盘： 主动卖出方的数量\n外盘： 主动买入方的数量\n成交量 = 外盘 + 内盘\n\n### 量价关系\n\n量分为： 放量，常量，缩量\n价分为： 上涨，横盘，下跌\n因此分为 3*3= 9种组合。\n\n放量上涨： 主动买盘增加，意味着增量资金进场，较为乐观；\n\n放量下跌： 主动卖盘增加，一般不健康，但是也有特殊情形，在牛市中出现单根的放量下跌， 意味着获利盘出逃， 多头依然强势时，有买入的机会。\n\n放量横盘： 多空双方力量僵持；\n\n缩量上涨： 主动卖盘减少，意味着投资者锁仓，在贵州茅台的拉升中，有这种情况的出现。一般有长期投资者介入才会有这种情况出现。\n\n缩量下跌：主动买盘减少，两种情况会出现： 下跌趋势中的阴跌走势和上涨趋势后的回调，由于在回调周期，是健康的，我们可以对行情看高一线；\n\n缩量横盘： 继续观察；\n\n常量则沿着当前趋势继续；\n\n量价分析其本质是为了通过分析市场背后多头和空头的态度对市场进一步地研判。\n\n那么如何判断缩量，常量和放量呢？一般认为3%以下属于缩量， 5%以下常量， 12%放量，以上则为巨量。\n一般通过换手率来判断量的程度，不同股的比例不同，不能死记硬背；\n\n放量则表示：\n1. 市场出现分歧，看空与看多的双方有非常多的争议；\n2. 主力行为，庄家对个股进行对倒，并不真实，避免交易；\n\n缩量一般认为投资者达成共识，比较真实；\n\n### 均线系统\n全称移动平均线MA， 有20世纪中期葛南维提出。我们日常听说的五日线，十日线，二十日线都属于均线系统。不同之处就在于周期不同。是趋势指标。\n五日均线：从今天开始往前数5天，五天收盘价的平均值作为均线数值。\n\n均线有三个特点：稳定性，滞后性，引力性。这个从字面可以理解。\n引力性这里要引入乖离的概念， 股价与均线远近程度有关。当股价距离均线较远时，则表示乖离较大，具有回调的需求。\n\n### 均线状态\n分为多头排列，空头排列\n短期均线高于长期均线，则以持股为主；当短期均线下穿长期均线，这个时候多头均线已经破坏，应该适当减仓；如果短期均线都低于长线均线，则以持币为主。\n要注意的是， 由于是趋势指标， 多空相互转变时，一定是指示右侧操作，也就意味着，不可能买在最低点，也不可能卖在最高点。\n\n特点：趋势行情中，收益较大，震荡行情收益并不好。但是趋势并不是这么好判断的。对于市场，我们最怕的并不是做错，而是没有结论。\n\n### 均线作用\n由于均线是几日的平均值，也一定程度上反映了投资者的成本。这个价格一般对于股价具有一定的支撑和压力作用。\n比如股价一路上行，但是只要一往下触碰到20日均线就会停止调整继续向上。那么20日线就是股价的支撑线。很多人会找到20线和30日线作为股价的压力线和支撑线。那么，当趋势运行时，给趋势提供支撑或者压力的那根均线，就是可以被用作判断的均线。\n\n### 交易方式\n#### 金叉死叉\n当短期均线上穿长期均线时买入，当短期均线下穿长期均线时卖出。\n但是一旦进入震荡期，就容易频繁止损。这也是趋势指标的特点。\n\n#### 葛南维八大买卖法\n\n![葛南维八大买卖法](K线的基础知识/葛南维八大买卖法.jpeg)\n\n### K线形态\n结合量价分析来进行观察分析\n\n#### 单根K线\n\n* 大阳线\n\n分为放量大阳线和常量大阳线。\n放量大阳线意味着有买入也有卖出，平均成本抬升，多头强劲。\n常量大阳线意味着空头不多。\n需要分析持有筹码的投资者锁仓，还是庄家持有大量筹码。\n如果是后者，需要考虑庄家的筹码可能存在抛压，投资风险不小。\n\n* 大阴线\n\n放量：说明在大跌的同时，有不少投资者接盘。暂时安全。但是在股灾的时候也会出现连续下跌。\n\n缩量：空头不需要卖出多少量就可以把价格砸的很低。一般出现在被市场边缘化的股票，并且股票会有持续下跌的趋势。需要无比等待。等股价逆转才开始介入。\n\n\n* 上影线\n\n属于股价冲高回落而形成的。\n1. 到了短期高点，需要等待空头完全释放再考虑介入。\n2. 因大盘下跌拉低股价。这种往往是错杀股，若在第二天大盘企稳，则会有不错的收益。\n\n* 下影线\n\n股价先向下，再向上回收。\n1. 短期空头已经跌杀完毕，可以看涨。\n2. 投资者心态买入和卖出不同，一般为个股的行为。单独受大盘的影响出现这个走势可能性较小。如果大盘出现比较长的下影线，那就意味着接下来的几天是比较安全的。\n\n#### K线组合\n\n* M顶和W底\n\n  ![W底](K线的基础知识/Wdi.png) \nK线组合其实就是多空力量相互抗衡。C点和E点是买点。\n当股价第一次到达A点时，空头是比较强的。接下来是多头力量开始反击，A点直至B点，BF的高度就是多头的力量。接下来股价从B点直至C点，BF的长度也意味着空头的力量，此时发现空头力量开始衰竭，甚至在C点开始反转，那么C点则为多空头力量均衡点，此时可以押注多头。\nC点之后，直到D点，发现CD长于BC，说明多头强于空头。所以我们等待空头的再一次释放。\nE点就是我们的最后机会。当到达颈线位置时止跌，说明颈线下方的筹码已经不愿意卖了。M顶也是一样的分析方法。\n\n* 头肩顶和头肩底\n\n  ![头肩底](K线的基础知识/头肩底.png) \n我们用多空分析的方法来进行同样的分析，就可以发现，E点是第一个买点，颈线则为第二个买点。\n\n其实和数学题一样，明白道理之后需要大量的实践来进行验证。\n\n### K线形态\n\n#### 趋势线\n![趋势线](K线的基础知识/趋势线.png) \n连上股价的高点和低点，我们就得到了趋势线。\n当股价下跌或上涨击破趋势线则认为趋势可能被破坏，那么需要等待一个反抽的机会再做交易。\n并不是趋势一被击破，就认为趋势被破坏了，我们还要观察原趋势的能量是否能把股价拉回到趋势中。\n如果可以拉回，就需要改变趋势线的画法，将起始点与最新的低点或者高点连接，从而形成新的一条趋势线。\n如果不能拉回，则有可能股价反转。\n#### 三角形\n把上涨趋势和下跌趋势都画出来之后，一般会得到一个三角形，股价会在这个三角形内运动。\n当股价突破三角形的一条边时，则要看股价是否会波动回三角形中。\n如果回到三角形里，那还是继续在三角形内部波动。\n如果不会，这个三角形已经收敛完毕，股价将会朝着另一个方向再次趋势运动。\n![三角形](K线的基础知识/三角形.png) \n\n#### 箱体\n趋势线的一种特殊形态就是箱体。股价突破一边不回落至箱体内，则运行结束。\n\n![箱体](K线的基础知识/箱体.png) \n\n#### 缺口理论\n一般在趋势较强或者出现重大消息时，股价在开盘会有大波动，此时会形成缺口。需要结合量价分析一起看。\n\n|类型|描述|指导意义\n|-----------|:-----------------|:-----------------|\n|普通型缺口 |幅度不大，多空均衡 可能会回落或者冲高回补缺口| 后续可能回补|\n|突破缺口| 力量强，继续上涨或者下跌| 重大基本面变化，短时间内不会回补，顺势而为|\n|衰竭缺口| 上涨或者下跌的后端|需要警惕是否反向力量即将出现|\n\n#### 波浪理论\n\n##### 1.波浪构造\n波浪理论是20世纪30年代由艾罗特·波浪提出。\n分为主要趋势：主浪【五个子浪12345】\n次要趋势：调整浪【三个子浪，ABC】\n\n波浪理论认为，市场所有的波动都是由5+3浪组成的。而每一个浪型中的子浪又能分出子浪。\n![波浪](K线的基础知识/波浪.png) \n##### 2.波浪规则\n\n这是为了解决千人千浪的问题。\n##### 1）4浪不能进入2浪\n四浪的最低点不可低于二郎最高点\n![整个二浪](K线的基础知识/整个二浪.png)  \n##### 2）三浪是整个波浪中最好挣钱的浪\n原因： \n1.一浪难判断，由于存在趋势反转，难以判断准确\n2.二浪调整弱\n3.三浪力度强\n\n首先要数清楚2浪中的C浪是什么时候结束的。C浪的最低点不一定是二浪的最低点。\n\n##### 3）浪形可延长，五浪难言顶\n一个浪走出第五浪，如果反方力量一直不出现，那么市场会沿着当前形势继续前行。\n五浪不知道何时才到顶，也正是市场的魅力所在。\n因此我们要做的是，找出能 **决策** 的点。而不是任何一个时间点都进行判断。\n\n\n#### 3.浪形分析\n##### 形态\n主浪：沿着当前趋势走，向上或向下。只需要对比135浪斜率的不同。\n调整浪：\n![二浪](K线的基础知识/二浪.png) \n![四浪](K线的基础知识/四浪.png) \n\n##### 浪形的长度（时间维度）\n* 无法确定第一浪的时间长度\n* 二三四浪的时间长度与一浪相当（时间差平均不超过20%）\n* 不判断五浪\n\n原则： 多空双方出牌时间相当\n\n多头出完空头出，如果时间太短，则空头可能还没出完；如果时间太长，空头可能已经出牌结束，多头再出。\n如果从股价的角度没有看到多头出牌，而从时间的角度感受到多头出牌，则又可能趋势出现反转。\n\n##### 浪形的宽度（空间维度）\n![浪形宽度](K线的基础知识/浪形宽度.png) \n调整幅度有多大可以通过黄金分割和50分位来提前判断。\n如图所述，二浪回撤有以下几个点位的可能性，19.1%，38.2%，50%，61.8%。\n\n* 调整浪幅度有多大？\n\n二浪通过一浪的涨幅来判断，四浪则通过三浪的涨幅来计算。\n\n* 三浪有多高呢？\n\n三浪的高度在一浪的1.618至2.618倍区间内。\n\n通过波浪理论，可以了解到接下来哪种走势最有可能，来辅助做出投资决策。\n\n#### 技术指标\n\n分类：趋势指标（MACD），乖离指标（KDJ），支撑压力指标（BOLL）。\n每类各挑一种来做解析。\n\n\n##### MACD\nMACD应用了移动平均线的原理，通过计算得出。\n![MACD](K线的基础知识/MACD.png) \n黄线代表快线，蓝线代表缦线，红色柱子和绿色柱子代表（快线-慢线）*2\n\n一般认为柱子呈现红色，处于多头市场；柱子呈现绿色则反之。颜色反转处则认为是买入/卖出信号。\n\n当两根线都处于0轴以上，则认为绿柱是调整；\n当两根线都处于0轴以下，则认为红柱为反弹。\n\n* 背离\n\n![MACD背离](K线的基础知识/MACD背离.png) \n股价和MACD出现相反走势则称之为背离。\n如果股价创新高，而MACD不创新高，则认为是顶背离，通常作为卖出信号；\n![底背离](K线的基础知识/底背离.png) \n如果股价创新低，MACD不创新低，则认为是底背离。通常是一个买入信号。\n这就意味着趋势可能发生改变。\n\n##### KDJ\nn(9)日RSV = (Cn - Ln) / (Hn - Ln) * 100\nCn为第n日收盘价，Ln为n日内最低价，Hn为n日内最高价\nK值 = 2/3 * 前一日K值+ 1/3 * 当日RSV\nD值 = 2/3 * 前一日D值+ 1/3 * 当日K值\nJ值 = 3 * 当日K值 - 2 * 当日D值\n无值，K，D则用50代替。\n\n用来判断是否出现超买超卖。\n![KDJ](K线的基础知识/KDJ.png) \n三者线的区别子在于变化速度不同。\n当触及100的上限，则认为是超买，有可能回调；\n当触及-100的下限，则认为是超卖，有可能会反弹。\n这个指标更适合帮助我们判断回调和反弹结束，用来加仓或者减仓。\n\n##### BOLL\n布林线又称为布林轨，由三根线组成。\n中间的线称之为中轨线，是N日的移动平均线。\n上轨线 = 中轨线 + 两倍的标准差\n下轨线 = 中轨线 + 两倍的标准差\n一般这个N是20。\n\n是一个分布概率的指标，可以大概确定支撑压力。接近上轨卖出，接近下轨买入。\n用来指导我们适当加仓和减仓。\n![BOLL](K线的基础知识/BOLL.png) \n\n\n上述三种指标中，MACD比较重要，有重要的指导意义，需要在实战中经常使用。\n\n#### 看盘\n主要讲看盘看什么，怎么看。\n\n##### 软件\n行情软件： 同花顺，通达信，东方财富，Wind等；\n新闻软件：Wind， 财联社等，提供24小时新闻滚动；\n\n越早了解到一些投资信息，交易越有优势。\n\n##### 编排操作页面\n一般关注板块涨幅排序，关注股票的移动，全市场短线的涨跌；\n\n##### 看个股盘口成交\n主要应用于短线投资。\n![BOLL](K线的基础知识/BOLL.png)\n\n* 如何在上冲下冲结束后，以比较精准的价位买入或者卖出呢？\n\n委买委卖的差额，就可以用来判断这个指标。\n负值是卖盘大于买盘，比较常见，一般来说，总委卖是总委买的两倍左右。\n需要观察差额反向波动，当差额反向波动大时，需要立刻做出买卖操作。\n\n![委买委卖](K线的基础知识/委买委卖.png)\n\n当股价上涨或下跌到证书关口时，往往会有压力或者支撑。\n也要注意指数的假突破。要看买盘和卖盘是否可以顺利接上。\n\n##### 看大盘\n\n![看大盘](K线的基础知识/看大盘.png)\n当黄线高于白线，则小盘股比较强，投资者总体偏爱小盘股，说明市场氛围好；\n当白线高于黄线，则大盘股比较强。\n\n","slug":"学做操盘手/K线的基础知识","published":1,"updated":"2019-09-08T15:24:20.626Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0v00ad4l3nk8o1wkvi","content":"<p>此篇内容是基于摸鱼小组的一个K线学习课的小结，需要时常温故知新并有序执行。<br><a id=\"more\"></a></p>\n<h3 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h3><p>成交量： 一段时间内成交的股数。成交额：则表示成交量 * 股价；<br>在相同的成交量的时候，股价的不一致，会导致成交额的不一致；<br>换手率： 成交量 / 总股本 or 流通股本<br>内盘： 主动卖出方的数量<br>外盘： 主动买入方的数量<br>成交量 = 外盘 + 内盘</p>\n<h3 id=\"量价关系\"><a href=\"#量价关系\" class=\"headerlink\" title=\"量价关系\"></a>量价关系</h3><p>量分为： 放量，常量，缩量<br>价分为： 上涨，横盘，下跌<br>因此分为 3*3= 9种组合。</p>\n<p>放量上涨： 主动买盘增加，意味着增量资金进场，较为乐观；</p>\n<p>放量下跌： 主动卖盘增加，一般不健康，但是也有特殊情形，在牛市中出现单根的放量下跌， 意味着获利盘出逃， 多头依然强势时，有买入的机会。</p>\n<p>放量横盘： 多空双方力量僵持；</p>\n<p>缩量上涨： 主动卖盘减少，意味着投资者锁仓，在贵州茅台的拉升中，有这种情况的出现。一般有长期投资者介入才会有这种情况出现。</p>\n<p>缩量下跌：主动买盘减少，两种情况会出现： 下跌趋势中的阴跌走势和上涨趋势后的回调，由于在回调周期，是健康的，我们可以对行情看高一线；</p>\n<p>缩量横盘： 继续观察；</p>\n<p>常量则沿着当前趋势继续；</p>\n<p>量价分析其本质是为了通过分析市场背后多头和空头的态度对市场进一步地研判。</p>\n<p>那么如何判断缩量，常量和放量呢？一般认为3%以下属于缩量， 5%以下常量， 12%放量，以上则为巨量。<br>一般通过换手率来判断量的程度，不同股的比例不同，不能死记硬背；</p>\n<p>放量则表示：</p>\n<ol>\n<li>市场出现分歧，看空与看多的双方有非常多的争议；</li>\n<li>主力行为，庄家对个股进行对倒，并不真实，避免交易；</li>\n</ol>\n<p>缩量一般认为投资者达成共识，比较真实；</p>\n<h3 id=\"均线系统\"><a href=\"#均线系统\" class=\"headerlink\" title=\"均线系统\"></a>均线系统</h3><p>全称移动平均线MA， 有20世纪中期葛南维提出。我们日常听说的五日线，十日线，二十日线都属于均线系统。不同之处就在于周期不同。是趋势指标。<br>五日均线：从今天开始往前数5天，五天收盘价的平均值作为均线数值。</p>\n<p>均线有三个特点：稳定性，滞后性，引力性。这个从字面可以理解。<br>引力性这里要引入乖离的概念， 股价与均线远近程度有关。当股价距离均线较远时，则表示乖离较大，具有回调的需求。</p>\n<h3 id=\"均线状态\"><a href=\"#均线状态\" class=\"headerlink\" title=\"均线状态\"></a>均线状态</h3><p>分为多头排列，空头排列<br>短期均线高于长期均线，则以持股为主；当短期均线下穿长期均线，这个时候多头均线已经破坏，应该适当减仓；如果短期均线都低于长线均线，则以持币为主。<br>要注意的是， 由于是趋势指标， 多空相互转变时，一定是指示右侧操作，也就意味着，不可能买在最低点，也不可能卖在最高点。</p>\n<p>特点：趋势行情中，收益较大，震荡行情收益并不好。但是趋势并不是这么好判断的。对于市场，我们最怕的并不是做错，而是没有结论。</p>\n<h3 id=\"均线作用\"><a href=\"#均线作用\" class=\"headerlink\" title=\"均线作用\"></a>均线作用</h3><p>由于均线是几日的平均值，也一定程度上反映了投资者的成本。这个价格一般对于股价具有一定的支撑和压力作用。<br>比如股价一路上行，但是只要一往下触碰到20日均线就会停止调整继续向上。那么20日线就是股价的支撑线。很多人会找到20线和30日线作为股价的压力线和支撑线。那么，当趋势运行时，给趋势提供支撑或者压力的那根均线，就是可以被用作判断的均线。</p>\n<h3 id=\"交易方式\"><a href=\"#交易方式\" class=\"headerlink\" title=\"交易方式\"></a>交易方式</h3><h4 id=\"金叉死叉\"><a href=\"#金叉死叉\" class=\"headerlink\" title=\"金叉死叉\"></a>金叉死叉</h4><p>当短期均线上穿长期均线时买入，当短期均线下穿长期均线时卖出。<br>但是一旦进入震荡期，就容易频繁止损。这也是趋势指标的特点。</p>\n<h4 id=\"葛南维八大买卖法\"><a href=\"#葛南维八大买卖法\" class=\"headerlink\" title=\"葛南维八大买卖法\"></a>葛南维八大买卖法</h4><p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/葛南维八大买卖法.jpeg\" alt=\"葛南维八大买卖法\"></p>\n<h3 id=\"K线形态\"><a href=\"#K线形态\" class=\"headerlink\" title=\"K线形态\"></a>K线形态</h3><p>结合量价分析来进行观察分析</p>\n<h4 id=\"单根K线\"><a href=\"#单根K线\" class=\"headerlink\" title=\"单根K线\"></a>单根K线</h4><ul>\n<li>大阳线</li>\n</ul>\n<p>分为放量大阳线和常量大阳线。<br>放量大阳线意味着有买入也有卖出，平均成本抬升，多头强劲。<br>常量大阳线意味着空头不多。<br>需要分析持有筹码的投资者锁仓，还是庄家持有大量筹码。<br>如果是后者，需要考虑庄家的筹码可能存在抛压，投资风险不小。</p>\n<ul>\n<li>大阴线</li>\n</ul>\n<p>放量：说明在大跌的同时，有不少投资者接盘。暂时安全。但是在股灾的时候也会出现连续下跌。</p>\n<p>缩量：空头不需要卖出多少量就可以把价格砸的很低。一般出现在被市场边缘化的股票，并且股票会有持续下跌的趋势。需要无比等待。等股价逆转才开始介入。</p>\n<ul>\n<li>上影线</li>\n</ul>\n<p>属于股价冲高回落而形成的。</p>\n<ol>\n<li>到了短期高点，需要等待空头完全释放再考虑介入。</li>\n<li>因大盘下跌拉低股价。这种往往是错杀股，若在第二天大盘企稳，则会有不错的收益。</li>\n</ol>\n<ul>\n<li>下影线</li>\n</ul>\n<p>股价先向下，再向上回收。</p>\n<ol>\n<li>短期空头已经跌杀完毕，可以看涨。</li>\n<li>投资者心态买入和卖出不同，一般为个股的行为。单独受大盘的影响出现这个走势可能性较小。如果大盘出现比较长的下影线，那就意味着接下来的几天是比较安全的。</li>\n</ol>\n<h4 id=\"K线组合\"><a href=\"#K线组合\" class=\"headerlink\" title=\"K线组合\"></a>K线组合</h4><ul>\n<li><p>M顶和W底</p>\n<p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/Wdi.png\" alt=\"W底\"><br>K线组合其实就是多空力量相互抗衡。C点和E点是买点。<br>当股价第一次到达A点时，空头是比较强的。接下来是多头力量开始反击，A点直至B点，BF的高度就是多头的力量。接下来股价从B点直至C点，BF的长度也意味着空头的力量，此时发现空头力量开始衰竭，甚至在C点开始反转，那么C点则为多空头力量均衡点，此时可以押注多头。<br>C点之后，直到D点，发现CD长于BC，说明多头强于空头。所以我们等待空头的再一次释放。<br>E点就是我们的最后机会。当到达颈线位置时止跌，说明颈线下方的筹码已经不愿意卖了。M顶也是一样的分析方法。</p>\n</li>\n<li><p>头肩顶和头肩底</p>\n<p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/头肩底.png\" alt=\"头肩底\"><br>我们用多空分析的方法来进行同样的分析，就可以发现，E点是第一个买点，颈线则为第二个买点。</p>\n</li>\n</ul>\n<p>其实和数学题一样，明白道理之后需要大量的实践来进行验证。</p>\n<h3 id=\"K线形态-1\"><a href=\"#K线形态-1\" class=\"headerlink\" title=\"K线形态\"></a>K线形态</h3><h4 id=\"趋势线\"><a href=\"#趋势线\" class=\"headerlink\" title=\"趋势线\"></a>趋势线</h4><p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/趋势线.png\" alt=\"趋势线\"><br>连上股价的高点和低点，我们就得到了趋势线。<br>当股价下跌或上涨击破趋势线则认为趋势可能被破坏，那么需要等待一个反抽的机会再做交易。<br>并不是趋势一被击破，就认为趋势被破坏了，我们还要观察原趋势的能量是否能把股价拉回到趋势中。<br>如果可以拉回，就需要改变趋势线的画法，将起始点与最新的低点或者高点连接，从而形成新的一条趋势线。<br>如果不能拉回，则有可能股价反转。</p>\n<h4 id=\"三角形\"><a href=\"#三角形\" class=\"headerlink\" title=\"三角形\"></a>三角形</h4><p>把上涨趋势和下跌趋势都画出来之后，一般会得到一个三角形，股价会在这个三角形内运动。<br>当股价突破三角形的一条边时，则要看股价是否会波动回三角形中。<br>如果回到三角形里，那还是继续在三角形内部波动。<br>如果不会，这个三角形已经收敛完毕，股价将会朝着另一个方向再次趋势运动。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/三角形.png\" alt=\"三角形\"> </p>\n<h4 id=\"箱体\"><a href=\"#箱体\" class=\"headerlink\" title=\"箱体\"></a>箱体</h4><p>趋势线的一种特殊形态就是箱体。股价突破一边不回落至箱体内，则运行结束。</p>\n<p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/箱体.png\" alt=\"箱体\"> </p>\n<h4 id=\"缺口理论\"><a href=\"#缺口理论\" class=\"headerlink\" title=\"缺口理论\"></a>缺口理论</h4><p>一般在趋势较强或者出现重大消息时，股价在开盘会有大波动，此时会形成缺口。需要结合量价分析一起看。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th style=\"text-align:left\">描述</th>\n<th style=\"text-align:left\">指导意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>普通型缺口</td>\n<td style=\"text-align:left\">幅度不大，多空均衡 可能会回落或者冲高回补缺口</td>\n<td style=\"text-align:left\">后续可能回补</td>\n</tr>\n<tr>\n<td>突破缺口</td>\n<td style=\"text-align:left\">力量强，继续上涨或者下跌</td>\n<td style=\"text-align:left\">重大基本面变化，短时间内不会回补，顺势而为</td>\n</tr>\n<tr>\n<td>衰竭缺口</td>\n<td style=\"text-align:left\">上涨或者下跌的后端</td>\n<td style=\"text-align:left\">需要警惕是否反向力量即将出现</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"波浪理论\"><a href=\"#波浪理论\" class=\"headerlink\" title=\"波浪理论\"></a>波浪理论</h4><h5 id=\"1-波浪构造\"><a href=\"#1-波浪构造\" class=\"headerlink\" title=\"1.波浪构造\"></a>1.波浪构造</h5><p>波浪理论是20世纪30年代由艾罗特·波浪提出。<br>分为主要趋势：主浪【五个子浪12345】<br>次要趋势：调整浪【三个子浪，ABC】</p>\n<p>波浪理论认为，市场所有的波动都是由5+3浪组成的。而每一个浪型中的子浪又能分出子浪。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/波浪.png\" alt=\"波浪\"> </p>\n<h5 id=\"2-波浪规则\"><a href=\"#2-波浪规则\" class=\"headerlink\" title=\"2.波浪规则\"></a>2.波浪规则</h5><p>这是为了解决千人千浪的问题。</p>\n<h5 id=\"1）4浪不能进入2浪\"><a href=\"#1）4浪不能进入2浪\" class=\"headerlink\" title=\"1）4浪不能进入2浪\"></a>1）4浪不能进入2浪</h5><p>四浪的最低点不可低于二郎最高点<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/整个二浪.png\" alt=\"整个二浪\">  </p>\n<h5 id=\"2）三浪是整个波浪中最好挣钱的浪\"><a href=\"#2）三浪是整个波浪中最好挣钱的浪\" class=\"headerlink\" title=\"2）三浪是整个波浪中最好挣钱的浪\"></a>2）三浪是整个波浪中最好挣钱的浪</h5><p>原因：<br>1.一浪难判断，由于存在趋势反转，难以判断准确<br>2.二浪调整弱<br>3.三浪力度强</p>\n<p>首先要数清楚2浪中的C浪是什么时候结束的。C浪的最低点不一定是二浪的最低点。</p>\n<h5 id=\"3）浪形可延长，五浪难言顶\"><a href=\"#3）浪形可延长，五浪难言顶\" class=\"headerlink\" title=\"3）浪形可延长，五浪难言顶\"></a>3）浪形可延长，五浪难言顶</h5><p>一个浪走出第五浪，如果反方力量一直不出现，那么市场会沿着当前形势继续前行。<br>五浪不知道何时才到顶，也正是市场的魅力所在。<br>因此我们要做的是，找出能 <strong>决策</strong> 的点。而不是任何一个时间点都进行判断。</p>\n<h4 id=\"3-浪形分析\"><a href=\"#3-浪形分析\" class=\"headerlink\" title=\"3.浪形分析\"></a>3.浪形分析</h4><h5 id=\"形态\"><a href=\"#形态\" class=\"headerlink\" title=\"形态\"></a>形态</h5><p>主浪：沿着当前趋势走，向上或向下。只需要对比135浪斜率的不同。<br>调整浪：<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/二浪.png\" alt=\"二浪\"><br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/四浪.png\" alt=\"四浪\"> </p>\n<h5 id=\"浪形的长度（时间维度）\"><a href=\"#浪形的长度（时间维度）\" class=\"headerlink\" title=\"浪形的长度（时间维度）\"></a>浪形的长度（时间维度）</h5><ul>\n<li>无法确定第一浪的时间长度</li>\n<li>二三四浪的时间长度与一浪相当（时间差平均不超过20%）</li>\n<li>不判断五浪</li>\n</ul>\n<p>原则： 多空双方出牌时间相当</p>\n<p>多头出完空头出，如果时间太短，则空头可能还没出完；如果时间太长，空头可能已经出牌结束，多头再出。<br>如果从股价的角度没有看到多头出牌，而从时间的角度感受到多头出牌，则又可能趋势出现反转。</p>\n<h5 id=\"浪形的宽度（空间维度）\"><a href=\"#浪形的宽度（空间维度）\" class=\"headerlink\" title=\"浪形的宽度（空间维度）\"></a>浪形的宽度（空间维度）</h5><p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/浪形宽度.png\" alt=\"浪形宽度\"><br>调整幅度有多大可以通过黄金分割和50分位来提前判断。<br>如图所述，二浪回撤有以下几个点位的可能性，19.1%，38.2%，50%，61.8%。</p>\n<ul>\n<li>调整浪幅度有多大？</li>\n</ul>\n<p>二浪通过一浪的涨幅来判断，四浪则通过三浪的涨幅来计算。</p>\n<ul>\n<li>三浪有多高呢？</li>\n</ul>\n<p>三浪的高度在一浪的1.618至2.618倍区间内。</p>\n<p>通过波浪理论，可以了解到接下来哪种走势最有可能，来辅助做出投资决策。</p>\n<h4 id=\"技术指标\"><a href=\"#技术指标\" class=\"headerlink\" title=\"技术指标\"></a>技术指标</h4><p>分类：趋势指标（MACD），乖离指标（KDJ），支撑压力指标（BOLL）。<br>每类各挑一种来做解析。</p>\n<h5 id=\"MACD\"><a href=\"#MACD\" class=\"headerlink\" title=\"MACD\"></a>MACD</h5><p>MACD应用了移动平均线的原理，通过计算得出。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/MACD.png\" alt=\"MACD\"><br>黄线代表快线，蓝线代表缦线，红色柱子和绿色柱子代表（快线-慢线）*2</p>\n<p>一般认为柱子呈现红色，处于多头市场；柱子呈现绿色则反之。颜色反转处则认为是买入/卖出信号。</p>\n<p>当两根线都处于0轴以上，则认为绿柱是调整；<br>当两根线都处于0轴以下，则认为红柱为反弹。</p>\n<ul>\n<li>背离</li>\n</ul>\n<p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/MACD背离.png\" alt=\"MACD背离\"><br>股价和MACD出现相反走势则称之为背离。<br>如果股价创新高，而MACD不创新高，则认为是顶背离，通常作为卖出信号；<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/底背离.png\" alt=\"底背离\"><br>如果股价创新低，MACD不创新低，则认为是底背离。通常是一个买入信号。<br>这就意味着趋势可能发生改变。</p>\n<h5 id=\"KDJ\"><a href=\"#KDJ\" class=\"headerlink\" title=\"KDJ\"></a>KDJ</h5><p>n(9)日RSV = (Cn - Ln) / (Hn - Ln) <em> 100<br>Cn为第n日收盘价，Ln为n日内最低价，Hn为n日内最高价<br>K值 = 2/3 </em> 前一日K值+ 1/3 <em> 当日RSV<br>D值 = 2/3 </em> 前一日D值+ 1/3 <em> 当日K值<br>J值 = 3 </em> 当日K值 - 2 * 当日D值<br>无值，K，D则用50代替。</p>\n<p>用来判断是否出现超买超卖。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/KDJ.png\" alt=\"KDJ\"><br>三者线的区别子在于变化速度不同。<br>当触及100的上限，则认为是超买，有可能回调；<br>当触及-100的下限，则认为是超卖，有可能会反弹。<br>这个指标更适合帮助我们判断回调和反弹结束，用来加仓或者减仓。</p>\n<h5 id=\"BOLL\"><a href=\"#BOLL\" class=\"headerlink\" title=\"BOLL\"></a>BOLL</h5><p>布林线又称为布林轨，由三根线组成。<br>中间的线称之为中轨线，是N日的移动平均线。<br>上轨线 = 中轨线 + 两倍的标准差<br>下轨线 = 中轨线 + 两倍的标准差<br>一般这个N是20。</p>\n<p>是一个分布概率的指标，可以大概确定支撑压力。接近上轨卖出，接近下轨买入。<br>用来指导我们适当加仓和减仓。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/BOLL.png\" alt=\"BOLL\"> </p>\n<p>上述三种指标中，MACD比较重要，有重要的指导意义，需要在实战中经常使用。</p>\n<h4 id=\"看盘\"><a href=\"#看盘\" class=\"headerlink\" title=\"看盘\"></a>看盘</h4><p>主要讲看盘看什么，怎么看。</p>\n<h5 id=\"软件\"><a href=\"#软件\" class=\"headerlink\" title=\"软件\"></a>软件</h5><p>行情软件： 同花顺，通达信，东方财富，Wind等；<br>新闻软件：Wind， 财联社等，提供24小时新闻滚动；</p>\n<p>越早了解到一些投资信息，交易越有优势。</p>\n<h5 id=\"编排操作页面\"><a href=\"#编排操作页面\" class=\"headerlink\" title=\"编排操作页面\"></a>编排操作页面</h5><p>一般关注板块涨幅排序，关注股票的移动，全市场短线的涨跌；</p>\n<h5 id=\"看个股盘口成交\"><a href=\"#看个股盘口成交\" class=\"headerlink\" title=\"看个股盘口成交\"></a>看个股盘口成交</h5><p>主要应用于短线投资。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/BOLL.png\" alt=\"BOLL\"></p>\n<ul>\n<li>如何在上冲下冲结束后，以比较精准的价位买入或者卖出呢？</li>\n</ul>\n<p>委买委卖的差额，就可以用来判断这个指标。<br>负值是卖盘大于买盘，比较常见，一般来说，总委卖是总委买的两倍左右。<br>需要观察差额反向波动，当差额反向波动大时，需要立刻做出买卖操作。</p>\n<p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/委买委卖.png\" alt=\"委买委卖\"></p>\n<p>当股价上涨或下跌到证书关口时，往往会有压力或者支撑。<br>也要注意指数的假突破。要看买盘和卖盘是否可以顺利接上。</p>\n<h5 id=\"看大盘\"><a href=\"#看大盘\" class=\"headerlink\" title=\"看大盘\"></a>看大盘</h5><p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/看大盘.png\" alt=\"看大盘\"><br>当黄线高于白线，则小盘股比较强，投资者总体偏爱小盘股，说明市场氛围好；<br>当白线高于黄线，则大盘股比较强。</p>\n","site":{"data":{}},"excerpt":"<p>此篇内容是基于摸鱼小组的一个K线学习课的小结，需要时常温故知新并有序执行。<br></p>","more":"<p></p>\n<h3 id=\"基础概念\"><a href=\"#基础概念\" class=\"headerlink\" title=\"基础概念\"></a>基础概念</h3><p>成交量： 一段时间内成交的股数。成交额：则表示成交量 * 股价；<br>在相同的成交量的时候，股价的不一致，会导致成交额的不一致；<br>换手率： 成交量 / 总股本 or 流通股本<br>内盘： 主动卖出方的数量<br>外盘： 主动买入方的数量<br>成交量 = 外盘 + 内盘</p>\n<h3 id=\"量价关系\"><a href=\"#量价关系\" class=\"headerlink\" title=\"量价关系\"></a>量价关系</h3><p>量分为： 放量，常量，缩量<br>价分为： 上涨，横盘，下跌<br>因此分为 3*3= 9种组合。</p>\n<p>放量上涨： 主动买盘增加，意味着增量资金进场，较为乐观；</p>\n<p>放量下跌： 主动卖盘增加，一般不健康，但是也有特殊情形，在牛市中出现单根的放量下跌， 意味着获利盘出逃， 多头依然强势时，有买入的机会。</p>\n<p>放量横盘： 多空双方力量僵持；</p>\n<p>缩量上涨： 主动卖盘减少，意味着投资者锁仓，在贵州茅台的拉升中，有这种情况的出现。一般有长期投资者介入才会有这种情况出现。</p>\n<p>缩量下跌：主动买盘减少，两种情况会出现： 下跌趋势中的阴跌走势和上涨趋势后的回调，由于在回调周期，是健康的，我们可以对行情看高一线；</p>\n<p>缩量横盘： 继续观察；</p>\n<p>常量则沿着当前趋势继续；</p>\n<p>量价分析其本质是为了通过分析市场背后多头和空头的态度对市场进一步地研判。</p>\n<p>那么如何判断缩量，常量和放量呢？一般认为3%以下属于缩量， 5%以下常量， 12%放量，以上则为巨量。<br>一般通过换手率来判断量的程度，不同股的比例不同，不能死记硬背；</p>\n<p>放量则表示：</p>\n<ol>\n<li>市场出现分歧，看空与看多的双方有非常多的争议；</li>\n<li>主力行为，庄家对个股进行对倒，并不真实，避免交易；</li>\n</ol>\n<p>缩量一般认为投资者达成共识，比较真实；</p>\n<h3 id=\"均线系统\"><a href=\"#均线系统\" class=\"headerlink\" title=\"均线系统\"></a>均线系统</h3><p>全称移动平均线MA， 有20世纪中期葛南维提出。我们日常听说的五日线，十日线，二十日线都属于均线系统。不同之处就在于周期不同。是趋势指标。<br>五日均线：从今天开始往前数5天，五天收盘价的平均值作为均线数值。</p>\n<p>均线有三个特点：稳定性，滞后性，引力性。这个从字面可以理解。<br>引力性这里要引入乖离的概念， 股价与均线远近程度有关。当股价距离均线较远时，则表示乖离较大，具有回调的需求。</p>\n<h3 id=\"均线状态\"><a href=\"#均线状态\" class=\"headerlink\" title=\"均线状态\"></a>均线状态</h3><p>分为多头排列，空头排列<br>短期均线高于长期均线，则以持股为主；当短期均线下穿长期均线，这个时候多头均线已经破坏，应该适当减仓；如果短期均线都低于长线均线，则以持币为主。<br>要注意的是， 由于是趋势指标， 多空相互转变时，一定是指示右侧操作，也就意味着，不可能买在最低点，也不可能卖在最高点。</p>\n<p>特点：趋势行情中，收益较大，震荡行情收益并不好。但是趋势并不是这么好判断的。对于市场，我们最怕的并不是做错，而是没有结论。</p>\n<h3 id=\"均线作用\"><a href=\"#均线作用\" class=\"headerlink\" title=\"均线作用\"></a>均线作用</h3><p>由于均线是几日的平均值，也一定程度上反映了投资者的成本。这个价格一般对于股价具有一定的支撑和压力作用。<br>比如股价一路上行，但是只要一往下触碰到20日均线就会停止调整继续向上。那么20日线就是股价的支撑线。很多人会找到20线和30日线作为股价的压力线和支撑线。那么，当趋势运行时，给趋势提供支撑或者压力的那根均线，就是可以被用作判断的均线。</p>\n<h3 id=\"交易方式\"><a href=\"#交易方式\" class=\"headerlink\" title=\"交易方式\"></a>交易方式</h3><h4 id=\"金叉死叉\"><a href=\"#金叉死叉\" class=\"headerlink\" title=\"金叉死叉\"></a>金叉死叉</h4><p>当短期均线上穿长期均线时买入，当短期均线下穿长期均线时卖出。<br>但是一旦进入震荡期，就容易频繁止损。这也是趋势指标的特点。</p>\n<h4 id=\"葛南维八大买卖法\"><a href=\"#葛南维八大买卖法\" class=\"headerlink\" title=\"葛南维八大买卖法\"></a>葛南维八大买卖法</h4><p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/葛南维八大买卖法.jpeg\" alt=\"葛南维八大买卖法\"></p>\n<h3 id=\"K线形态\"><a href=\"#K线形态\" class=\"headerlink\" title=\"K线形态\"></a>K线形态</h3><p>结合量价分析来进行观察分析</p>\n<h4 id=\"单根K线\"><a href=\"#单根K线\" class=\"headerlink\" title=\"单根K线\"></a>单根K线</h4><ul>\n<li>大阳线</li>\n</ul>\n<p>分为放量大阳线和常量大阳线。<br>放量大阳线意味着有买入也有卖出，平均成本抬升，多头强劲。<br>常量大阳线意味着空头不多。<br>需要分析持有筹码的投资者锁仓，还是庄家持有大量筹码。<br>如果是后者，需要考虑庄家的筹码可能存在抛压，投资风险不小。</p>\n<ul>\n<li>大阴线</li>\n</ul>\n<p>放量：说明在大跌的同时，有不少投资者接盘。暂时安全。但是在股灾的时候也会出现连续下跌。</p>\n<p>缩量：空头不需要卖出多少量就可以把价格砸的很低。一般出现在被市场边缘化的股票，并且股票会有持续下跌的趋势。需要无比等待。等股价逆转才开始介入。</p>\n<ul>\n<li>上影线</li>\n</ul>\n<p>属于股价冲高回落而形成的。</p>\n<ol>\n<li>到了短期高点，需要等待空头完全释放再考虑介入。</li>\n<li>因大盘下跌拉低股价。这种往往是错杀股，若在第二天大盘企稳，则会有不错的收益。</li>\n</ol>\n<ul>\n<li>下影线</li>\n</ul>\n<p>股价先向下，再向上回收。</p>\n<ol>\n<li>短期空头已经跌杀完毕，可以看涨。</li>\n<li>投资者心态买入和卖出不同，一般为个股的行为。单独受大盘的影响出现这个走势可能性较小。如果大盘出现比较长的下影线，那就意味着接下来的几天是比较安全的。</li>\n</ol>\n<h4 id=\"K线组合\"><a href=\"#K线组合\" class=\"headerlink\" title=\"K线组合\"></a>K线组合</h4><ul>\n<li><p>M顶和W底</p>\n<p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/Wdi.png\" alt=\"W底\"><br>K线组合其实就是多空力量相互抗衡。C点和E点是买点。<br>当股价第一次到达A点时，空头是比较强的。接下来是多头力量开始反击，A点直至B点，BF的高度就是多头的力量。接下来股价从B点直至C点，BF的长度也意味着空头的力量，此时发现空头力量开始衰竭，甚至在C点开始反转，那么C点则为多空头力量均衡点，此时可以押注多头。<br>C点之后，直到D点，发现CD长于BC，说明多头强于空头。所以我们等待空头的再一次释放。<br>E点就是我们的最后机会。当到达颈线位置时止跌，说明颈线下方的筹码已经不愿意卖了。M顶也是一样的分析方法。</p>\n</li>\n<li><p>头肩顶和头肩底</p>\n<p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/头肩底.png\" alt=\"头肩底\"><br>我们用多空分析的方法来进行同样的分析，就可以发现，E点是第一个买点，颈线则为第二个买点。</p>\n</li>\n</ul>\n<p>其实和数学题一样，明白道理之后需要大量的实践来进行验证。</p>\n<h3 id=\"K线形态-1\"><a href=\"#K线形态-1\" class=\"headerlink\" title=\"K线形态\"></a>K线形态</h3><h4 id=\"趋势线\"><a href=\"#趋势线\" class=\"headerlink\" title=\"趋势线\"></a>趋势线</h4><p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/趋势线.png\" alt=\"趋势线\"><br>连上股价的高点和低点，我们就得到了趋势线。<br>当股价下跌或上涨击破趋势线则认为趋势可能被破坏，那么需要等待一个反抽的机会再做交易。<br>并不是趋势一被击破，就认为趋势被破坏了，我们还要观察原趋势的能量是否能把股价拉回到趋势中。<br>如果可以拉回，就需要改变趋势线的画法，将起始点与最新的低点或者高点连接，从而形成新的一条趋势线。<br>如果不能拉回，则有可能股价反转。</p>\n<h4 id=\"三角形\"><a href=\"#三角形\" class=\"headerlink\" title=\"三角形\"></a>三角形</h4><p>把上涨趋势和下跌趋势都画出来之后，一般会得到一个三角形，股价会在这个三角形内运动。<br>当股价突破三角形的一条边时，则要看股价是否会波动回三角形中。<br>如果回到三角形里，那还是继续在三角形内部波动。<br>如果不会，这个三角形已经收敛完毕，股价将会朝着另一个方向再次趋势运动。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/三角形.png\" alt=\"三角形\"> </p>\n<h4 id=\"箱体\"><a href=\"#箱体\" class=\"headerlink\" title=\"箱体\"></a>箱体</h4><p>趋势线的一种特殊形态就是箱体。股价突破一边不回落至箱体内，则运行结束。</p>\n<p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/箱体.png\" alt=\"箱体\"> </p>\n<h4 id=\"缺口理论\"><a href=\"#缺口理论\" class=\"headerlink\" title=\"缺口理论\"></a>缺口理论</h4><p>一般在趋势较强或者出现重大消息时，股价在开盘会有大波动，此时会形成缺口。需要结合量价分析一起看。</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th style=\"text-align:left\">描述</th>\n<th style=\"text-align:left\">指导意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>普通型缺口</td>\n<td style=\"text-align:left\">幅度不大，多空均衡 可能会回落或者冲高回补缺口</td>\n<td style=\"text-align:left\">后续可能回补</td>\n</tr>\n<tr>\n<td>突破缺口</td>\n<td style=\"text-align:left\">力量强，继续上涨或者下跌</td>\n<td style=\"text-align:left\">重大基本面变化，短时间内不会回补，顺势而为</td>\n</tr>\n<tr>\n<td>衰竭缺口</td>\n<td style=\"text-align:left\">上涨或者下跌的后端</td>\n<td style=\"text-align:left\">需要警惕是否反向力量即将出现</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"波浪理论\"><a href=\"#波浪理论\" class=\"headerlink\" title=\"波浪理论\"></a>波浪理论</h4><h5 id=\"1-波浪构造\"><a href=\"#1-波浪构造\" class=\"headerlink\" title=\"1.波浪构造\"></a>1.波浪构造</h5><p>波浪理论是20世纪30年代由艾罗特·波浪提出。<br>分为主要趋势：主浪【五个子浪12345】<br>次要趋势：调整浪【三个子浪，ABC】</p>\n<p>波浪理论认为，市场所有的波动都是由5+3浪组成的。而每一个浪型中的子浪又能分出子浪。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/波浪.png\" alt=\"波浪\"> </p>\n<h5 id=\"2-波浪规则\"><a href=\"#2-波浪规则\" class=\"headerlink\" title=\"2.波浪规则\"></a>2.波浪规则</h5><p>这是为了解决千人千浪的问题。</p>\n<h5 id=\"1）4浪不能进入2浪\"><a href=\"#1）4浪不能进入2浪\" class=\"headerlink\" title=\"1）4浪不能进入2浪\"></a>1）4浪不能进入2浪</h5><p>四浪的最低点不可低于二郎最高点<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/整个二浪.png\" alt=\"整个二浪\">  </p>\n<h5 id=\"2）三浪是整个波浪中最好挣钱的浪\"><a href=\"#2）三浪是整个波浪中最好挣钱的浪\" class=\"headerlink\" title=\"2）三浪是整个波浪中最好挣钱的浪\"></a>2）三浪是整个波浪中最好挣钱的浪</h5><p>原因：<br>1.一浪难判断，由于存在趋势反转，难以判断准确<br>2.二浪调整弱<br>3.三浪力度强</p>\n<p>首先要数清楚2浪中的C浪是什么时候结束的。C浪的最低点不一定是二浪的最低点。</p>\n<h5 id=\"3）浪形可延长，五浪难言顶\"><a href=\"#3）浪形可延长，五浪难言顶\" class=\"headerlink\" title=\"3）浪形可延长，五浪难言顶\"></a>3）浪形可延长，五浪难言顶</h5><p>一个浪走出第五浪，如果反方力量一直不出现，那么市场会沿着当前形势继续前行。<br>五浪不知道何时才到顶，也正是市场的魅力所在。<br>因此我们要做的是，找出能 <strong>决策</strong> 的点。而不是任何一个时间点都进行判断。</p>\n<h4 id=\"3-浪形分析\"><a href=\"#3-浪形分析\" class=\"headerlink\" title=\"3.浪形分析\"></a>3.浪形分析</h4><h5 id=\"形态\"><a href=\"#形态\" class=\"headerlink\" title=\"形态\"></a>形态</h5><p>主浪：沿着当前趋势走，向上或向下。只需要对比135浪斜率的不同。<br>调整浪：<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/二浪.png\" alt=\"二浪\"><br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/四浪.png\" alt=\"四浪\"> </p>\n<h5 id=\"浪形的长度（时间维度）\"><a href=\"#浪形的长度（时间维度）\" class=\"headerlink\" title=\"浪形的长度（时间维度）\"></a>浪形的长度（时间维度）</h5><ul>\n<li>无法确定第一浪的时间长度</li>\n<li>二三四浪的时间长度与一浪相当（时间差平均不超过20%）</li>\n<li>不判断五浪</li>\n</ul>\n<p>原则： 多空双方出牌时间相当</p>\n<p>多头出完空头出，如果时间太短，则空头可能还没出完；如果时间太长，空头可能已经出牌结束，多头再出。<br>如果从股价的角度没有看到多头出牌，而从时间的角度感受到多头出牌，则又可能趋势出现反转。</p>\n<h5 id=\"浪形的宽度（空间维度）\"><a href=\"#浪形的宽度（空间维度）\" class=\"headerlink\" title=\"浪形的宽度（空间维度）\"></a>浪形的宽度（空间维度）</h5><p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/浪形宽度.png\" alt=\"浪形宽度\"><br>调整幅度有多大可以通过黄金分割和50分位来提前判断。<br>如图所述，二浪回撤有以下几个点位的可能性，19.1%，38.2%，50%，61.8%。</p>\n<ul>\n<li>调整浪幅度有多大？</li>\n</ul>\n<p>二浪通过一浪的涨幅来判断，四浪则通过三浪的涨幅来计算。</p>\n<ul>\n<li>三浪有多高呢？</li>\n</ul>\n<p>三浪的高度在一浪的1.618至2.618倍区间内。</p>\n<p>通过波浪理论，可以了解到接下来哪种走势最有可能，来辅助做出投资决策。</p>\n<h4 id=\"技术指标\"><a href=\"#技术指标\" class=\"headerlink\" title=\"技术指标\"></a>技术指标</h4><p>分类：趋势指标（MACD），乖离指标（KDJ），支撑压力指标（BOLL）。<br>每类各挑一种来做解析。</p>\n<h5 id=\"MACD\"><a href=\"#MACD\" class=\"headerlink\" title=\"MACD\"></a>MACD</h5><p>MACD应用了移动平均线的原理，通过计算得出。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/MACD.png\" alt=\"MACD\"><br>黄线代表快线，蓝线代表缦线，红色柱子和绿色柱子代表（快线-慢线）*2</p>\n<p>一般认为柱子呈现红色，处于多头市场；柱子呈现绿色则反之。颜色反转处则认为是买入/卖出信号。</p>\n<p>当两根线都处于0轴以上，则认为绿柱是调整；<br>当两根线都处于0轴以下，则认为红柱为反弹。</p>\n<ul>\n<li>背离</li>\n</ul>\n<p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/MACD背离.png\" alt=\"MACD背离\"><br>股价和MACD出现相反走势则称之为背离。<br>如果股价创新高，而MACD不创新高，则认为是顶背离，通常作为卖出信号；<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/底背离.png\" alt=\"底背离\"><br>如果股价创新低，MACD不创新低，则认为是底背离。通常是一个买入信号。<br>这就意味着趋势可能发生改变。</p>\n<h5 id=\"KDJ\"><a href=\"#KDJ\" class=\"headerlink\" title=\"KDJ\"></a>KDJ</h5><p>n(9)日RSV = (Cn - Ln) / (Hn - Ln) <em> 100<br>Cn为第n日收盘价，Ln为n日内最低价，Hn为n日内最高价<br>K值 = 2/3 </em> 前一日K值+ 1/3 <em> 当日RSV<br>D值 = 2/3 </em> 前一日D值+ 1/3 <em> 当日K值<br>J值 = 3 </em> 当日K值 - 2 * 当日D值<br>无值，K，D则用50代替。</p>\n<p>用来判断是否出现超买超卖。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/KDJ.png\" alt=\"KDJ\"><br>三者线的区别子在于变化速度不同。<br>当触及100的上限，则认为是超买，有可能回调；<br>当触及-100的下限，则认为是超卖，有可能会反弹。<br>这个指标更适合帮助我们判断回调和反弹结束，用来加仓或者减仓。</p>\n<h5 id=\"BOLL\"><a href=\"#BOLL\" class=\"headerlink\" title=\"BOLL\"></a>BOLL</h5><p>布林线又称为布林轨，由三根线组成。<br>中间的线称之为中轨线，是N日的移动平均线。<br>上轨线 = 中轨线 + 两倍的标准差<br>下轨线 = 中轨线 + 两倍的标准差<br>一般这个N是20。</p>\n<p>是一个分布概率的指标，可以大概确定支撑压力。接近上轨卖出，接近下轨买入。<br>用来指导我们适当加仓和减仓。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/BOLL.png\" alt=\"BOLL\"> </p>\n<p>上述三种指标中，MACD比较重要，有重要的指导意义，需要在实战中经常使用。</p>\n<h4 id=\"看盘\"><a href=\"#看盘\" class=\"headerlink\" title=\"看盘\"></a>看盘</h4><p>主要讲看盘看什么，怎么看。</p>\n<h5 id=\"软件\"><a href=\"#软件\" class=\"headerlink\" title=\"软件\"></a>软件</h5><p>行情软件： 同花顺，通达信，东方财富，Wind等；<br>新闻软件：Wind， 财联社等，提供24小时新闻滚动；</p>\n<p>越早了解到一些投资信息，交易越有优势。</p>\n<h5 id=\"编排操作页面\"><a href=\"#编排操作页面\" class=\"headerlink\" title=\"编排操作页面\"></a>编排操作页面</h5><p>一般关注板块涨幅排序，关注股票的移动，全市场短线的涨跌；</p>\n<h5 id=\"看个股盘口成交\"><a href=\"#看个股盘口成交\" class=\"headerlink\" title=\"看个股盘口成交\"></a>看个股盘口成交</h5><p>主要应用于短线投资。<br><img src=\"/2019/09/08/学做操盘手/K线的基础知识/BOLL.png\" alt=\"BOLL\"></p>\n<ul>\n<li>如何在上冲下冲结束后，以比较精准的价位买入或者卖出呢？</li>\n</ul>\n<p>委买委卖的差额，就可以用来判断这个指标。<br>负值是卖盘大于买盘，比较常见，一般来说，总委卖是总委买的两倍左右。<br>需要观察差额反向波动，当差额反向波动大时，需要立刻做出买卖操作。</p>\n<p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/委买委卖.png\" alt=\"委买委卖\"></p>\n<p>当股价上涨或下跌到证书关口时，往往会有压力或者支撑。<br>也要注意指数的假突破。要看买盘和卖盘是否可以顺利接上。</p>\n<h5 id=\"看大盘\"><a href=\"#看大盘\" class=\"headerlink\" title=\"看大盘\"></a>看大盘</h5><p><img src=\"/2019/09/08/学做操盘手/K线的基础知识/看大盘.png\" alt=\"看大盘\"><br>当黄线高于白线，则小盘股比较强，投资者总体偏爱小盘股，说明市场氛围好；<br>当白线高于黄线，则大盘股比较强。</p>"},{"title":"通向自由之路(3)落后篇","date":"2016-09-19T02:17:34.000Z","_content":">比上不足，比下有余。\n\n这句话是常听我妈提起的。可是真的比下有余么？过度自信似乎是我们的天性。与此同时，我们又习惯性地低估他人。\n\n**对自己的定位没有清晰认识，一直选择回避问题，等到问题真暴露的时候，可能为时已晚了。**\n<!-- more -->\n这一期我们谈论什么是落后。每个人都对于落后的定义可能都不同。无论是上学时的60分，还是工作中的绩效考评，都有自己的评价标准。\n首先，要思考的是：\n1.你定义的落后是什么？\n2.你采用这个标准的理由是什么？\n3.在这个标准下，你是否已经落后于他人了？\n\n## 对上述问题我的回答\n\n1.在我看来，我将自己是否掌握程度达到80%作为一个考核点，未达到则算落后。\n\n2.我之所以采取这样的标准是因为我想做前20%的人。\n\n3.在这个标准下，在很多方面我已经落后了。\n\n## 再一步认知\n我们通常凭感觉来判断是否达到该水平，可是感觉通常是有误差的。经常被用来证明的一点就是：\n\n>接近90%的人认为自己的驾驶水平处于平均水平以上。\n\n宏观来看，这是不可能的。可落在自己头上的时候，“感觉自己就是平均水平以上啊”——这个关乎每个人都自认高于平均水准这事，有个专门的词，叫**乌比冈湖效应**。社会心理学借用这个词，指人的一种总觉得什么都高出平均水平的心理倾向，用另一种通俗的说法就是自我拉抬偏差。与此类似的另一种效应杜宁-克鲁格效应，“越差越牛逼，越强越谦虚”。说的就是能力欠缺的人有一种虚幻的自我优越感，错误得认为自己的真实情况更加优秀。\n\n细心观察我们周边的生活，就会发现这些心理学的偏差研究不是没有依据的。\n\n比如那些平时什么事情也做不好的人，最容易瞧不上别人，动不动就觉得自己比别人强，只不过自己不屑于去做而已。\n\n反而是那些真正处于领先位置的高手会格外的谦虚，甚至低估自己的能力。因为他们知道，到达这个阶段需要经历什么，付出什么，自然也就不会盲目骄傲。\n\n拿着这些效应去对比一下现实生活，再反观一下自己，或许是一种不错的提醒。\n\n更为深层的原因是这样的：\n\n**我们并不能感知整个世界，我们只能通过感知自己的周遭来判断自己是否处在平均水准以上。**\n\n一个井底之蛙在它的世界里处于平均水准以上有如何呢？\n\n在二八定律提出这一转眼，已经过去了一百多年。\n\n对于有些人来说，别说是20%，就连超过平均线，都足够给他们创造优越感了。\n我们不可能也没必要每一件事都比别人做的好，但是不代表我们应该逃避自己面临的困难。\n\n还记得麻烦守恒定律么？如果这是你应该面对并解决的问题，它就一定不会凭空消失。\n\n总是拿着比下有余的借口去逃避，最终就会发现自己在这种假想的优越感中，和别人拉开巨大的差距。\n\n进入二十一世纪，有一个重大的变化正在揭示更为残酷的事实：\n\n**弄不好，百分之一之后全是落后。**\n\n在全球互联的今天，我们所感知到的世界不仅仅局限于我们周遭，通过自己手中的设备，我们每个人都可以尽量感知这个世界的全部。\n\n一方面，你能看到更多比你优秀的人，意识到自己和他们的差距。\n\n这对于一些人来说是一种正向的激励。他们想的是，还有这么多人在我前面，我还有这么多空间可以提升，那我一定要多加努力。而对于另一些人来说，这反而成为打击他们自信心的对比，还有那么多人比我优秀，我不过如此。\n\n另一方面，你也看到了许多不如你的人。\n这对于那些喜欢“比下有余”的人来说，简直是最大的福音。如果在附近找不到比自己差的，那就利用网络去别的地方寻找，这个世界这么大，总归有比我差的人。\n\n其实网络能够带来的仅仅是更为客观，更为完整的信息，他能让你更清楚地认识到自己的位置。至于应该用一个什么样的态度去面对，随后又该如何调整，则取决于每一个人自己。\n\n现在大家都能看得到，原来那些成功的人(或者简单粗暴：赚到很多钱的人)，真的知道很多大家不知道的事情，自己不知道的方法。\n\n**当每个人都连接在一起的时候，对于知识的渴求是异常强烈的，因为差异明显可见。**\n甚至于这种渴求已经成为了一种恐惧——害怕落后的恐惧。\n\n事实上确实应该恐惧。落后的百分比越来越高，以前百分之40算落后，如今到百分之二十，现在甚至很可能百分之一之后的都算落后。从李笑来老师的专栏里可以看到，6万多的订阅者每篇点击量只有40%~50%,而留言量更是少到5%。换句话说，有一半人是付了钱根本不看的，当要思考并且转换为文字的时候，有会筛选掉90%的读者。\n\n\n另外还有一个更为恐怖的趋势:机器人正在崛起，人工智能正在崛起，而大多数人正在走越来越没用的路上。\n\n也许这会使你焦虑，如果这种焦虑使用得当，我们可称之为“危机感”，可是至少，我已经有了两个阅读后改善的目标：\n\n1.早晚有一天，你要做到不再为了生活而出卖自己的时间。\n2.早晚有一天，你要做到不落后，成为百分之二十，甚至于百分之一。\n\n不必担心自己选现在还不够好，你要做的可能只是保持耐心，把该做的事情做好即可。\n\n\n## 再一步思考\n\n1.你有没有哪一方面的能力处于身边群体中的前20%？如果有，是什么？如何做到的？\n2.你有没有想过如何才能让自己某方面的能力逐步成长到处于身边群体中的前20%？除了下决心之外，你还有什么具体方法和步骤？\n3.如果你已经有了危机感，能不能想出摆脱焦虑的方式？如何才能摆脱焦虑？\n4.这一周，每天花三十分钟静下心来进行自我审视，想想有没有在哪个方面你自己有幻觉？误以为自己处于平均水平之上？\n\n## 反思\n其实程非回答上述问题很难，过常挣扎。尽管不完善，但依然去尽力去思考。\n\n事实上，自己常常会有一种想法，某段时间突然觉得自己在学习上落下的东西很多，一顿补，回过头来发现周围人也不过这样，总会有一个小人跳出来麻痹自己：你看周围人都在玩，你为什么不玩一下放松一下呢？反正之后也会追上他们的。\n\n可能这就是`比下有余`最好的例子了。回顾学习之路，好像我永远只选择比下有余。自诩做到百分之80就不错了，为什么要死读书？别人玩我就不能玩么？适当的玩一下又怎么了？可惜，一玩就是很久。知道真的发现自己跟上课进度有点累了跟不上了，才恶补一下。自己却经常吹嘘，如果我玩用功读书，我也可以考到10%的啊。可是，殊不知，那最后的20%分数远比那80%的分数难拿太多。很少有事情是线性发展的。“差不多”可能真的差了很多。仅仅比别人好一点点是没有用的，必须强很多才能体现明显的优势。\n\n别人在玩，那可能是已经攻克了最困难的部分，而如果你只选择做简单的工作，那就不要用劳逸结合作为幌子。\n\n“差不多”是最好的自我麻痹。\n\n**想要打破差不多的状态，最好也最直接的办法就是先把一件事情做到足够好。有过一次类似的体验，你马上就能破除在其他事情上“差不多”的幻想，转而踏踏实实地认真做事。事情的发展多半类似，所以不要好高骛远，先把一件事情做好。**\n\n知易行难。写作在某种程度上也是体力活，只要你不断地写，就会越写越好。\n\n增加反思频率。一周一总结吧。回顾一次这周的得失，综合评估一下那些方面做得好，那些方面欠佳。\n\n能否拉开差距都取决于你是否肯硬着头皮把最难的部分啃下来。\n\n\n\n\n\n\n\n\n\n","source":"_posts/通向自由之路/通向自由之路(3)落后篇.md","raw":"---\ntitle: 通向自由之路(3)落后篇\ndate: 2016-09-19 10:17:34\ntags: \n- 通向自由之路\ncategories: 反思\n---\n>比上不足，比下有余。\n\n这句话是常听我妈提起的。可是真的比下有余么？过度自信似乎是我们的天性。与此同时，我们又习惯性地低估他人。\n\n**对自己的定位没有清晰认识，一直选择回避问题，等到问题真暴露的时候，可能为时已晚了。**\n<!-- more -->\n这一期我们谈论什么是落后。每个人都对于落后的定义可能都不同。无论是上学时的60分，还是工作中的绩效考评，都有自己的评价标准。\n首先，要思考的是：\n1.你定义的落后是什么？\n2.你采用这个标准的理由是什么？\n3.在这个标准下，你是否已经落后于他人了？\n\n## 对上述问题我的回答\n\n1.在我看来，我将自己是否掌握程度达到80%作为一个考核点，未达到则算落后。\n\n2.我之所以采取这样的标准是因为我想做前20%的人。\n\n3.在这个标准下，在很多方面我已经落后了。\n\n## 再一步认知\n我们通常凭感觉来判断是否达到该水平，可是感觉通常是有误差的。经常被用来证明的一点就是：\n\n>接近90%的人认为自己的驾驶水平处于平均水平以上。\n\n宏观来看，这是不可能的。可落在自己头上的时候，“感觉自己就是平均水平以上啊”——这个关乎每个人都自认高于平均水准这事，有个专门的词，叫**乌比冈湖效应**。社会心理学借用这个词，指人的一种总觉得什么都高出平均水平的心理倾向，用另一种通俗的说法就是自我拉抬偏差。与此类似的另一种效应杜宁-克鲁格效应，“越差越牛逼，越强越谦虚”。说的就是能力欠缺的人有一种虚幻的自我优越感，错误得认为自己的真实情况更加优秀。\n\n细心观察我们周边的生活，就会发现这些心理学的偏差研究不是没有依据的。\n\n比如那些平时什么事情也做不好的人，最容易瞧不上别人，动不动就觉得自己比别人强，只不过自己不屑于去做而已。\n\n反而是那些真正处于领先位置的高手会格外的谦虚，甚至低估自己的能力。因为他们知道，到达这个阶段需要经历什么，付出什么，自然也就不会盲目骄傲。\n\n拿着这些效应去对比一下现实生活，再反观一下自己，或许是一种不错的提醒。\n\n更为深层的原因是这样的：\n\n**我们并不能感知整个世界，我们只能通过感知自己的周遭来判断自己是否处在平均水准以上。**\n\n一个井底之蛙在它的世界里处于平均水准以上有如何呢？\n\n在二八定律提出这一转眼，已经过去了一百多年。\n\n对于有些人来说，别说是20%，就连超过平均线，都足够给他们创造优越感了。\n我们不可能也没必要每一件事都比别人做的好，但是不代表我们应该逃避自己面临的困难。\n\n还记得麻烦守恒定律么？如果这是你应该面对并解决的问题，它就一定不会凭空消失。\n\n总是拿着比下有余的借口去逃避，最终就会发现自己在这种假想的优越感中，和别人拉开巨大的差距。\n\n进入二十一世纪，有一个重大的变化正在揭示更为残酷的事实：\n\n**弄不好，百分之一之后全是落后。**\n\n在全球互联的今天，我们所感知到的世界不仅仅局限于我们周遭，通过自己手中的设备，我们每个人都可以尽量感知这个世界的全部。\n\n一方面，你能看到更多比你优秀的人，意识到自己和他们的差距。\n\n这对于一些人来说是一种正向的激励。他们想的是，还有这么多人在我前面，我还有这么多空间可以提升，那我一定要多加努力。而对于另一些人来说，这反而成为打击他们自信心的对比，还有那么多人比我优秀，我不过如此。\n\n另一方面，你也看到了许多不如你的人。\n这对于那些喜欢“比下有余”的人来说，简直是最大的福音。如果在附近找不到比自己差的，那就利用网络去别的地方寻找，这个世界这么大，总归有比我差的人。\n\n其实网络能够带来的仅仅是更为客观，更为完整的信息，他能让你更清楚地认识到自己的位置。至于应该用一个什么样的态度去面对，随后又该如何调整，则取决于每一个人自己。\n\n现在大家都能看得到，原来那些成功的人(或者简单粗暴：赚到很多钱的人)，真的知道很多大家不知道的事情，自己不知道的方法。\n\n**当每个人都连接在一起的时候，对于知识的渴求是异常强烈的，因为差异明显可见。**\n甚至于这种渴求已经成为了一种恐惧——害怕落后的恐惧。\n\n事实上确实应该恐惧。落后的百分比越来越高，以前百分之40算落后，如今到百分之二十，现在甚至很可能百分之一之后的都算落后。从李笑来老师的专栏里可以看到，6万多的订阅者每篇点击量只有40%~50%,而留言量更是少到5%。换句话说，有一半人是付了钱根本不看的，当要思考并且转换为文字的时候，有会筛选掉90%的读者。\n\n\n另外还有一个更为恐怖的趋势:机器人正在崛起，人工智能正在崛起，而大多数人正在走越来越没用的路上。\n\n也许这会使你焦虑，如果这种焦虑使用得当，我们可称之为“危机感”，可是至少，我已经有了两个阅读后改善的目标：\n\n1.早晚有一天，你要做到不再为了生活而出卖自己的时间。\n2.早晚有一天，你要做到不落后，成为百分之二十，甚至于百分之一。\n\n不必担心自己选现在还不够好，你要做的可能只是保持耐心，把该做的事情做好即可。\n\n\n## 再一步思考\n\n1.你有没有哪一方面的能力处于身边群体中的前20%？如果有，是什么？如何做到的？\n2.你有没有想过如何才能让自己某方面的能力逐步成长到处于身边群体中的前20%？除了下决心之外，你还有什么具体方法和步骤？\n3.如果你已经有了危机感，能不能想出摆脱焦虑的方式？如何才能摆脱焦虑？\n4.这一周，每天花三十分钟静下心来进行自我审视，想想有没有在哪个方面你自己有幻觉？误以为自己处于平均水平之上？\n\n## 反思\n其实程非回答上述问题很难，过常挣扎。尽管不完善，但依然去尽力去思考。\n\n事实上，自己常常会有一种想法，某段时间突然觉得自己在学习上落下的东西很多，一顿补，回过头来发现周围人也不过这样，总会有一个小人跳出来麻痹自己：你看周围人都在玩，你为什么不玩一下放松一下呢？反正之后也会追上他们的。\n\n可能这就是`比下有余`最好的例子了。回顾学习之路，好像我永远只选择比下有余。自诩做到百分之80就不错了，为什么要死读书？别人玩我就不能玩么？适当的玩一下又怎么了？可惜，一玩就是很久。知道真的发现自己跟上课进度有点累了跟不上了，才恶补一下。自己却经常吹嘘，如果我玩用功读书，我也可以考到10%的啊。可是，殊不知，那最后的20%分数远比那80%的分数难拿太多。很少有事情是线性发展的。“差不多”可能真的差了很多。仅仅比别人好一点点是没有用的，必须强很多才能体现明显的优势。\n\n别人在玩，那可能是已经攻克了最困难的部分，而如果你只选择做简单的工作，那就不要用劳逸结合作为幌子。\n\n“差不多”是最好的自我麻痹。\n\n**想要打破差不多的状态，最好也最直接的办法就是先把一件事情做到足够好。有过一次类似的体验，你马上就能破除在其他事情上“差不多”的幻想，转而踏踏实实地认真做事。事情的发展多半类似，所以不要好高骛远，先把一件事情做好。**\n\n知易行难。写作在某种程度上也是体力活，只要你不断地写，就会越写越好。\n\n增加反思频率。一周一总结吧。回顾一次这周的得失，综合评估一下那些方面做得好，那些方面欠佳。\n\n能否拉开差距都取决于你是否肯硬着头皮把最难的部分啃下来。\n\n\n\n\n\n\n\n\n\n","slug":"通向自由之路/通向自由之路(3)落后篇","published":1,"updated":"2019-03-22T14:44:36.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0w00ag4l3nag738qfc","content":"<blockquote>\n<p>比上不足，比下有余。</p>\n</blockquote>\n<p>这句话是常听我妈提起的。可是真的比下有余么？过度自信似乎是我们的天性。与此同时，我们又习惯性地低估他人。</p>\n<p><strong>对自己的定位没有清晰认识，一直选择回避问题，等到问题真暴露的时候，可能为时已晚了。</strong><br><a id=\"more\"></a><br>这一期我们谈论什么是落后。每个人都对于落后的定义可能都不同。无论是上学时的60分，还是工作中的绩效考评，都有自己的评价标准。<br>首先，要思考的是：<br>1.你定义的落后是什么？<br>2.你采用这个标准的理由是什么？<br>3.在这个标准下，你是否已经落后于他人了？</p>\n<h2 id=\"对上述问题我的回答\"><a href=\"#对上述问题我的回答\" class=\"headerlink\" title=\"对上述问题我的回答\"></a>对上述问题我的回答</h2><p>1.在我看来，我将自己是否掌握程度达到80%作为一个考核点，未达到则算落后。</p>\n<p>2.我之所以采取这样的标准是因为我想做前20%的人。</p>\n<p>3.在这个标准下，在很多方面我已经落后了。</p>\n<h2 id=\"再一步认知\"><a href=\"#再一步认知\" class=\"headerlink\" title=\"再一步认知\"></a>再一步认知</h2><p>我们通常凭感觉来判断是否达到该水平，可是感觉通常是有误差的。经常被用来证明的一点就是：</p>\n<blockquote>\n<p>接近90%的人认为自己的驾驶水平处于平均水平以上。</p>\n</blockquote>\n<p>宏观来看，这是不可能的。可落在自己头上的时候，“感觉自己就是平均水平以上啊”——这个关乎每个人都自认高于平均水准这事，有个专门的词，叫<strong>乌比冈湖效应</strong>。社会心理学借用这个词，指人的一种总觉得什么都高出平均水平的心理倾向，用另一种通俗的说法就是自我拉抬偏差。与此类似的另一种效应杜宁-克鲁格效应，“越差越牛逼，越强越谦虚”。说的就是能力欠缺的人有一种虚幻的自我优越感，错误得认为自己的真实情况更加优秀。</p>\n<p>细心观察我们周边的生活，就会发现这些心理学的偏差研究不是没有依据的。</p>\n<p>比如那些平时什么事情也做不好的人，最容易瞧不上别人，动不动就觉得自己比别人强，只不过自己不屑于去做而已。</p>\n<p>反而是那些真正处于领先位置的高手会格外的谦虚，甚至低估自己的能力。因为他们知道，到达这个阶段需要经历什么，付出什么，自然也就不会盲目骄傲。</p>\n<p>拿着这些效应去对比一下现实生活，再反观一下自己，或许是一种不错的提醒。</p>\n<p>更为深层的原因是这样的：</p>\n<p><strong>我们并不能感知整个世界，我们只能通过感知自己的周遭来判断自己是否处在平均水准以上。</strong></p>\n<p>一个井底之蛙在它的世界里处于平均水准以上有如何呢？</p>\n<p>在二八定律提出这一转眼，已经过去了一百多年。</p>\n<p>对于有些人来说，别说是20%，就连超过平均线，都足够给他们创造优越感了。<br>我们不可能也没必要每一件事都比别人做的好，但是不代表我们应该逃避自己面临的困难。</p>\n<p>还记得麻烦守恒定律么？如果这是你应该面对并解决的问题，它就一定不会凭空消失。</p>\n<p>总是拿着比下有余的借口去逃避，最终就会发现自己在这种假想的优越感中，和别人拉开巨大的差距。</p>\n<p>进入二十一世纪，有一个重大的变化正在揭示更为残酷的事实：</p>\n<p><strong>弄不好，百分之一之后全是落后。</strong></p>\n<p>在全球互联的今天，我们所感知到的世界不仅仅局限于我们周遭，通过自己手中的设备，我们每个人都可以尽量感知这个世界的全部。</p>\n<p>一方面，你能看到更多比你优秀的人，意识到自己和他们的差距。</p>\n<p>这对于一些人来说是一种正向的激励。他们想的是，还有这么多人在我前面，我还有这么多空间可以提升，那我一定要多加努力。而对于另一些人来说，这反而成为打击他们自信心的对比，还有那么多人比我优秀，我不过如此。</p>\n<p>另一方面，你也看到了许多不如你的人。<br>这对于那些喜欢“比下有余”的人来说，简直是最大的福音。如果在附近找不到比自己差的，那就利用网络去别的地方寻找，这个世界这么大，总归有比我差的人。</p>\n<p>其实网络能够带来的仅仅是更为客观，更为完整的信息，他能让你更清楚地认识到自己的位置。至于应该用一个什么样的态度去面对，随后又该如何调整，则取决于每一个人自己。</p>\n<p>现在大家都能看得到，原来那些成功的人(或者简单粗暴：赚到很多钱的人)，真的知道很多大家不知道的事情，自己不知道的方法。</p>\n<p><strong>当每个人都连接在一起的时候，对于知识的渴求是异常强烈的，因为差异明显可见。</strong><br>甚至于这种渴求已经成为了一种恐惧——害怕落后的恐惧。</p>\n<p>事实上确实应该恐惧。落后的百分比越来越高，以前百分之40算落后，如今到百分之二十，现在甚至很可能百分之一之后的都算落后。从李笑来老师的专栏里可以看到，6万多的订阅者每篇点击量只有40%~50%,而留言量更是少到5%。换句话说，有一半人是付了钱根本不看的，当要思考并且转换为文字的时候，有会筛选掉90%的读者。</p>\n<p>另外还有一个更为恐怖的趋势:机器人正在崛起，人工智能正在崛起，而大多数人正在走越来越没用的路上。</p>\n<p>也许这会使你焦虑，如果这种焦虑使用得当，我们可称之为“危机感”，可是至少，我已经有了两个阅读后改善的目标：</p>\n<p>1.早晚有一天，你要做到不再为了生活而出卖自己的时间。<br>2.早晚有一天，你要做到不落后，成为百分之二十，甚至于百分之一。</p>\n<p>不必担心自己选现在还不够好，你要做的可能只是保持耐心，把该做的事情做好即可。</p>\n<h2 id=\"再一步思考\"><a href=\"#再一步思考\" class=\"headerlink\" title=\"再一步思考\"></a>再一步思考</h2><p>1.你有没有哪一方面的能力处于身边群体中的前20%？如果有，是什么？如何做到的？<br>2.你有没有想过如何才能让自己某方面的能力逐步成长到处于身边群体中的前20%？除了下决心之外，你还有什么具体方法和步骤？<br>3.如果你已经有了危机感，能不能想出摆脱焦虑的方式？如何才能摆脱焦虑？<br>4.这一周，每天花三十分钟静下心来进行自我审视，想想有没有在哪个方面你自己有幻觉？误以为自己处于平均水平之上？</p>\n<h2 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h2><p>其实程非回答上述问题很难，过常挣扎。尽管不完善，但依然去尽力去思考。</p>\n<p>事实上，自己常常会有一种想法，某段时间突然觉得自己在学习上落下的东西很多，一顿补，回过头来发现周围人也不过这样，总会有一个小人跳出来麻痹自己：你看周围人都在玩，你为什么不玩一下放松一下呢？反正之后也会追上他们的。</p>\n<p>可能这就是<code>比下有余</code>最好的例子了。回顾学习之路，好像我永远只选择比下有余。自诩做到百分之80就不错了，为什么要死读书？别人玩我就不能玩么？适当的玩一下又怎么了？可惜，一玩就是很久。知道真的发现自己跟上课进度有点累了跟不上了，才恶补一下。自己却经常吹嘘，如果我玩用功读书，我也可以考到10%的啊。可是，殊不知，那最后的20%分数远比那80%的分数难拿太多。很少有事情是线性发展的。“差不多”可能真的差了很多。仅仅比别人好一点点是没有用的，必须强很多才能体现明显的优势。</p>\n<p>别人在玩，那可能是已经攻克了最困难的部分，而如果你只选择做简单的工作，那就不要用劳逸结合作为幌子。</p>\n<p>“差不多”是最好的自我麻痹。</p>\n<p><strong>想要打破差不多的状态，最好也最直接的办法就是先把一件事情做到足够好。有过一次类似的体验，你马上就能破除在其他事情上“差不多”的幻想，转而踏踏实实地认真做事。事情的发展多半类似，所以不要好高骛远，先把一件事情做好。</strong></p>\n<p>知易行难。写作在某种程度上也是体力活，只要你不断地写，就会越写越好。</p>\n<p>增加反思频率。一周一总结吧。回顾一次这周的得失，综合评估一下那些方面做得好，那些方面欠佳。</p>\n<p>能否拉开差距都取决于你是否肯硬着头皮把最难的部分啃下来。</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>比上不足，比下有余。</p>\n</blockquote>\n<p>这句话是常听我妈提起的。可是真的比下有余么？过度自信似乎是我们的天性。与此同时，我们又习惯性地低估他人。</p>\n<p><strong>对自己的定位没有清晰认识，一直选择回避问题，等到问题真暴露的时候，可能为时已晚了。</strong><br></p>","more":"<br>这一期我们谈论什么是落后。每个人都对于落后的定义可能都不同。无论是上学时的60分，还是工作中的绩效考评，都有自己的评价标准。<br>首先，要思考的是：<br>1.你定义的落后是什么？<br>2.你采用这个标准的理由是什么？<br>3.在这个标准下，你是否已经落后于他人了？<p></p>\n<h2 id=\"对上述问题我的回答\"><a href=\"#对上述问题我的回答\" class=\"headerlink\" title=\"对上述问题我的回答\"></a>对上述问题我的回答</h2><p>1.在我看来，我将自己是否掌握程度达到80%作为一个考核点，未达到则算落后。</p>\n<p>2.我之所以采取这样的标准是因为我想做前20%的人。</p>\n<p>3.在这个标准下，在很多方面我已经落后了。</p>\n<h2 id=\"再一步认知\"><a href=\"#再一步认知\" class=\"headerlink\" title=\"再一步认知\"></a>再一步认知</h2><p>我们通常凭感觉来判断是否达到该水平，可是感觉通常是有误差的。经常被用来证明的一点就是：</p>\n<blockquote>\n<p>接近90%的人认为自己的驾驶水平处于平均水平以上。</p>\n</blockquote>\n<p>宏观来看，这是不可能的。可落在自己头上的时候，“感觉自己就是平均水平以上啊”——这个关乎每个人都自认高于平均水准这事，有个专门的词，叫<strong>乌比冈湖效应</strong>。社会心理学借用这个词，指人的一种总觉得什么都高出平均水平的心理倾向，用另一种通俗的说法就是自我拉抬偏差。与此类似的另一种效应杜宁-克鲁格效应，“越差越牛逼，越强越谦虚”。说的就是能力欠缺的人有一种虚幻的自我优越感，错误得认为自己的真实情况更加优秀。</p>\n<p>细心观察我们周边的生活，就会发现这些心理学的偏差研究不是没有依据的。</p>\n<p>比如那些平时什么事情也做不好的人，最容易瞧不上别人，动不动就觉得自己比别人强，只不过自己不屑于去做而已。</p>\n<p>反而是那些真正处于领先位置的高手会格外的谦虚，甚至低估自己的能力。因为他们知道，到达这个阶段需要经历什么，付出什么，自然也就不会盲目骄傲。</p>\n<p>拿着这些效应去对比一下现实生活，再反观一下自己，或许是一种不错的提醒。</p>\n<p>更为深层的原因是这样的：</p>\n<p><strong>我们并不能感知整个世界，我们只能通过感知自己的周遭来判断自己是否处在平均水准以上。</strong></p>\n<p>一个井底之蛙在它的世界里处于平均水准以上有如何呢？</p>\n<p>在二八定律提出这一转眼，已经过去了一百多年。</p>\n<p>对于有些人来说，别说是20%，就连超过平均线，都足够给他们创造优越感了。<br>我们不可能也没必要每一件事都比别人做的好，但是不代表我们应该逃避自己面临的困难。</p>\n<p>还记得麻烦守恒定律么？如果这是你应该面对并解决的问题，它就一定不会凭空消失。</p>\n<p>总是拿着比下有余的借口去逃避，最终就会发现自己在这种假想的优越感中，和别人拉开巨大的差距。</p>\n<p>进入二十一世纪，有一个重大的变化正在揭示更为残酷的事实：</p>\n<p><strong>弄不好，百分之一之后全是落后。</strong></p>\n<p>在全球互联的今天，我们所感知到的世界不仅仅局限于我们周遭，通过自己手中的设备，我们每个人都可以尽量感知这个世界的全部。</p>\n<p>一方面，你能看到更多比你优秀的人，意识到自己和他们的差距。</p>\n<p>这对于一些人来说是一种正向的激励。他们想的是，还有这么多人在我前面，我还有这么多空间可以提升，那我一定要多加努力。而对于另一些人来说，这反而成为打击他们自信心的对比，还有那么多人比我优秀，我不过如此。</p>\n<p>另一方面，你也看到了许多不如你的人。<br>这对于那些喜欢“比下有余”的人来说，简直是最大的福音。如果在附近找不到比自己差的，那就利用网络去别的地方寻找，这个世界这么大，总归有比我差的人。</p>\n<p>其实网络能够带来的仅仅是更为客观，更为完整的信息，他能让你更清楚地认识到自己的位置。至于应该用一个什么样的态度去面对，随后又该如何调整，则取决于每一个人自己。</p>\n<p>现在大家都能看得到，原来那些成功的人(或者简单粗暴：赚到很多钱的人)，真的知道很多大家不知道的事情，自己不知道的方法。</p>\n<p><strong>当每个人都连接在一起的时候，对于知识的渴求是异常强烈的，因为差异明显可见。</strong><br>甚至于这种渴求已经成为了一种恐惧——害怕落后的恐惧。</p>\n<p>事实上确实应该恐惧。落后的百分比越来越高，以前百分之40算落后，如今到百分之二十，现在甚至很可能百分之一之后的都算落后。从李笑来老师的专栏里可以看到，6万多的订阅者每篇点击量只有40%~50%,而留言量更是少到5%。换句话说，有一半人是付了钱根本不看的，当要思考并且转换为文字的时候，有会筛选掉90%的读者。</p>\n<p>另外还有一个更为恐怖的趋势:机器人正在崛起，人工智能正在崛起，而大多数人正在走越来越没用的路上。</p>\n<p>也许这会使你焦虑，如果这种焦虑使用得当，我们可称之为“危机感”，可是至少，我已经有了两个阅读后改善的目标：</p>\n<p>1.早晚有一天，你要做到不再为了生活而出卖自己的时间。<br>2.早晚有一天，你要做到不落后，成为百分之二十，甚至于百分之一。</p>\n<p>不必担心自己选现在还不够好，你要做的可能只是保持耐心，把该做的事情做好即可。</p>\n<h2 id=\"再一步思考\"><a href=\"#再一步思考\" class=\"headerlink\" title=\"再一步思考\"></a>再一步思考</h2><p>1.你有没有哪一方面的能力处于身边群体中的前20%？如果有，是什么？如何做到的？<br>2.你有没有想过如何才能让自己某方面的能力逐步成长到处于身边群体中的前20%？除了下决心之外，你还有什么具体方法和步骤？<br>3.如果你已经有了危机感，能不能想出摆脱焦虑的方式？如何才能摆脱焦虑？<br>4.这一周，每天花三十分钟静下心来进行自我审视，想想有没有在哪个方面你自己有幻觉？误以为自己处于平均水平之上？</p>\n<h2 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h2><p>其实程非回答上述问题很难，过常挣扎。尽管不完善，但依然去尽力去思考。</p>\n<p>事实上，自己常常会有一种想法，某段时间突然觉得自己在学习上落下的东西很多，一顿补，回过头来发现周围人也不过这样，总会有一个小人跳出来麻痹自己：你看周围人都在玩，你为什么不玩一下放松一下呢？反正之后也会追上他们的。</p>\n<p>可能这就是<code>比下有余</code>最好的例子了。回顾学习之路，好像我永远只选择比下有余。自诩做到百分之80就不错了，为什么要死读书？别人玩我就不能玩么？适当的玩一下又怎么了？可惜，一玩就是很久。知道真的发现自己跟上课进度有点累了跟不上了，才恶补一下。自己却经常吹嘘，如果我玩用功读书，我也可以考到10%的啊。可是，殊不知，那最后的20%分数远比那80%的分数难拿太多。很少有事情是线性发展的。“差不多”可能真的差了很多。仅仅比别人好一点点是没有用的，必须强很多才能体现明显的优势。</p>\n<p>别人在玩，那可能是已经攻克了最困难的部分，而如果你只选择做简单的工作，那就不要用劳逸结合作为幌子。</p>\n<p>“差不多”是最好的自我麻痹。</p>\n<p><strong>想要打破差不多的状态，最好也最直接的办法就是先把一件事情做到足够好。有过一次类似的体验，你马上就能破除在其他事情上“差不多”的幻想，转而踏踏实实地认真做事。事情的发展多半类似，所以不要好高骛远，先把一件事情做好。</strong></p>\n<p>知易行难。写作在某种程度上也是体力活，只要你不断地写，就会越写越好。</p>\n<p>增加反思频率。一周一总结吧。回顾一次这周的得失，综合评估一下那些方面做得好，那些方面欠佳。</p>\n<p>能否拉开差距都取决于你是否肯硬着头皮把最难的部分啃下来。</p>"},{"title":"通向自由之路(6)元认知能力提高篇","date":"2016-11-02T12:56:50.000Z","_content":"停更有点久了。最近找到工作之后，心有点宽下来了。不过还是要跑啊。\n\n在上一篇认识元认知能力之后，李笑来老师讲到了有效提高元认知能力的三个方法：坐享，兴趣，反思。\n\n在内容开始之前，提醒自己：要有耐心，要有耐心，要有耐心。\n<!-- more -->\n## 坐享\n\n坐享是一个李笑来老师自己创造的词汇，为的是区别打坐，冥想等其他有宗教意味的词。\n\n这种练习方式很简单：\n* 静坐15分钟以上（设闹钟）\n* 找一个舒服的姿势。\n* 闭眼（有些人睁眼也可以做到）\n* 缓慢均匀的呼吸\n* 把你的注意力集中在呼吸上。\n\n刚开始挺不容易，会发现自己的注意力一不小心走到了其他事情上。但，这就是刻意练习的重点：**把所有注意力全部集中在一个点上。**\n没经验的你很快就会走神，开始注意其他事情，如窗外的杂音，胸腔的起伏等。\n\n正是这种不容易，才使得你的元认知能力被激活，然后你在反复使用它去调整你的注意力。把所有注意力都放在一个地方。\n\n你可以把“元认知能力”想象成大脑肌肉的一种，就好比我们身体差的时候，锻炼一阵子哑铃，肌肉就会有所增长。只要你认真尝试，最终所有人都能做到。\n刚刚开始的时候，甚至自己坐着坐着就睡着了，在有助于休息的活动中的前三名分别是：\n1.阅读 \n2.亲近自然 \n3.独处\n\n已有科学证据表明，坐享这种刻意训练，可以直接增大训练者的大脑皮层表面积，也就是构回增加的结果。\n调查人员之一的心理学家`Ben AldersonDay`说：**“人们在独处的时候，更容易将注意力放在自己的感觉、身体以及情绪上。”**\n\n知识就是力量。\n\n真理往往会被忘记。当我们把注意力集中在一处，并且开始主动不去思考时，我们的大脑会比平时更加活跃，能够产生更多的连接。\n\n实际上，这也是一种历史悠久的刻意训练方法，撇开宗教不讲，这也是一种朴素的刻意训练方式，一种简单、朴素、有效的“大脑体操”，。没必要神化它，自然而然地用就是了。\n\n有时候，在坐享的过程中，可能会产生一些幻觉。在过去称之为“走火入魔”,其实这只是大脑处于“主动放松”的状态，有些原本相互并没有联系的脑细胞产生了一些“意外的联系”，换种说法，就是“主动做梦”，但理智告诉你，这只是梦，不是现实。\n\n这些活动都是让自己安静下来，慢慢把注意力拉回到自身。\n\n\n## 兴趣\n虽然每个人的兴趣不同，但在做感兴趣的事的时候，很容易进入全神贯注的状态。\n\n全神贯注是另一个刻意训练元认知能力的有效方法——很违背直觉的有效方法：\n\n通过进入全身贯注状态而使元认知能力彻底放松......\n\n大多数人直至成年，并没有养成哪怕仅仅一个属于自己的真正兴趣。换句说法：**大多数人基本上没有什么事情感觉值得自己去(主动去)“全神贯注”地做......**\n\n全神贯注其实分为两种：主动的与被动的。被动的全神贯注是受到外界控制的，通过设计学甚至心理学来让人兴奋，上瘾。而主动的全身贯注相对于被动的，多出了智商一个维度：\n\n**专注于提升某个特定的技能。**\n\n那游戏和看小说算不算锻炼元认知呢？其实锻炼与否并不单纯取决于活动本身，而在于你是否“主动的全身贯注”。\n\n如果你刚刚开始锻炼你的元认知，其实可以用一个比较简单的衡量标准：\n\n**是否顺利。**\n\n不论是“可以练习”，还是“主动的全身贯注”都不回那么容易，至少不会一帆风顺。\n\n即使有兴趣支撑的全神贯注，也需要你主动克服一些困难才能继续下去。\n\n兴趣因人而异，在任何一项兴趣中，都有**“必须刻意练习才能获得进步的技能”**，要满足这个需求，那因兴趣而产生的全神贯注，才可能是主动的，才可能是对刻意训练元认知能力有帮助的。\n\n这里李笑来老师拿自己学吉他做了一个例子（看的我都有点想回去学二胡了），在全神贯注地磨练任何一项技能时，元认知能力彻底的放松，而注意力全部用来去感受每一个感官的刺激，进而调整自己的每个动作，甚至每个意识与理解，最终达到比前一刻更好的地步。在这个过程中大脑皮层更多的回路生成，更多动作变成下意识就能完成的动作......直至结束的那一瞬间，休息完毕且“精力充沛”的元认知能力又再一次的被激活，清楚地意识到刚才的一切，幸福感“突然而生”，又因为元认知能力的存在，那幸福感格外的强烈。从而每一次练习就是一次正反馈，让自己看到成果，进而几发更多的兴趣。\n\n所以，找到一个能磨练自己某项技能的，能让自己迅速进入“主动的全神贯注状态”的，乃至于“干脆停不下来”的兴趣，非常重要，甚至干脆是生命之中绝对“不可或缺”的内容。\n\n很少有人能够单凭兴趣，坚持把某件事情昨晚。缺乏刻意练习，很快就会碰到“玻璃顶”。实际上大多数人最终能够长期保留自己的兴趣，基本上是因为这个正反馈被启动了：**有兴趣——刻意练习——做的更好——更有兴趣——继续练习。**兴趣和练习其实是相辅相成的。\n\n\n\n## 反思\n\n所谓“日三省吾身”，这几乎是刻意训练元认知能力的最高手段。所以，这应该是人人天天要做的事情。\n\n每天花十分钟左右，反思一下自己的思路和思考结果，琢磨一下自己的想法有没有逻辑错误？琢磨一下自己的想法从何而来？又缘何走了那么个思路？有没有其他可能的思考结果？琢磨一下自己受到了那些因素的影响？琢磨一下那些因素究竟有没有根基，有没有道理？\n\n反思活动在最初常常是无疾而终的，只有在长时间去刻意练习之后，才会在某个阶段突然清晰起来，反思效率得到了极大的提升（大概与复利曲线是一个道理吧），做出修正选择的时候也变得果断了很多。\n\n刚刚开始反思的人也容易想不清楚。其实最好的反思方法就是记录。没人能一次就把问题想明白。多数人，尤其是刚开始反思的人都需要在一个问题上反复思考，反复琢磨，才会有一点点的进步。\n\n所以这个时候记录的必要性就体现出来了。\n\n因为没有多少人能够清晰的记得自己所想的每一个细节，也自然不知道应该如何修正。只有记录下来了，我们才有机会回顾，并知道自己到底在那些细节上犯了什么错误。\n\n最重要的是，**反思不仅仅是一种元认知能力的刻意锻炼方式，也是调整自己情绪的根本。**\n\n控制不好自己情绪也和元认知能力有关，“生气”与“知道自己生气”大有不同。我们平时说的“迁怒”，其实本质上就是因为自己不知道为什么生气。想着想着就乱了，乱了之后就不管对象，先发一通火再说。\n\n冷静常常并不是控制情绪的结果，而是“认清情绪来源，并找到解决方案的结果”。而认清情绪的来源，就是在调用元认知能力。\n\n每一次认清情绪的来源，就是一次元认知能力获得锻炼的最好机会。每个人都一样，最终会发现，反思最多的，肯定是被情绪左右之后的行为和决定。不过，其实用不了多少次，元认知能力的适时激活就会成为习惯，所谓的冷静，不过是这个习惯自然而然的结果。\n\n## 思考与行动\n\n最近一次情绪失控是在和阿媛打电话的过程中，自己总是会在电话中表现出一种对阿媛向我诉说一些烦恼时的不耐烦，甚至连自己都没有意识到自己的态度这么恶劣以至于阿媛越哄越伤心，主要根源就是在没有自己发现甚至认清这个确实存在的事实。其实，在家里的时候也会对父母表现出不耐烦，自己本意并不是这样，是想好好珍惜和父母在一起的每分每秒的，毕竟这样的时间总是在越来越少，父母老去的速度也总是比自己成长的速度快很多很多。\n论语有言：“子夏问孝，子曰：色难。有事,弟子服其劳,有酒食,先生馔,曾是以为孝乎?”不仅是对父母，对待自己身边的每一个该珍惜的人都是这样，尽管你的行动都是为他们好，可是你表现出的态度呢？实在好不到哪里去，甚至还反而更糟。关心并不是做表面文章，而是要有耐心，由心而生的实际行动。\n\n着实，自己应该重视自己的真实内心，由心而生，反思自己的言行，培养自己的兴趣，坐享自己所成，从而推己及人，得到元认知能力的真正提高。","source":"_posts/通向自由之路/通向自由之路(6)元认知能力提高篇.md","raw":"---\ntitle: 通向自由之路(6)元认知能力提高篇\ndate: 2016-11-02 20:56:50\ntags: \n- 通向自由之路\ncategories: 反思\n---\n停更有点久了。最近找到工作之后，心有点宽下来了。不过还是要跑啊。\n\n在上一篇认识元认知能力之后，李笑来老师讲到了有效提高元认知能力的三个方法：坐享，兴趣，反思。\n\n在内容开始之前，提醒自己：要有耐心，要有耐心，要有耐心。\n<!-- more -->\n## 坐享\n\n坐享是一个李笑来老师自己创造的词汇，为的是区别打坐，冥想等其他有宗教意味的词。\n\n这种练习方式很简单：\n* 静坐15分钟以上（设闹钟）\n* 找一个舒服的姿势。\n* 闭眼（有些人睁眼也可以做到）\n* 缓慢均匀的呼吸\n* 把你的注意力集中在呼吸上。\n\n刚开始挺不容易，会发现自己的注意力一不小心走到了其他事情上。但，这就是刻意练习的重点：**把所有注意力全部集中在一个点上。**\n没经验的你很快就会走神，开始注意其他事情，如窗外的杂音，胸腔的起伏等。\n\n正是这种不容易，才使得你的元认知能力被激活，然后你在反复使用它去调整你的注意力。把所有注意力都放在一个地方。\n\n你可以把“元认知能力”想象成大脑肌肉的一种，就好比我们身体差的时候，锻炼一阵子哑铃，肌肉就会有所增长。只要你认真尝试，最终所有人都能做到。\n刚刚开始的时候，甚至自己坐着坐着就睡着了，在有助于休息的活动中的前三名分别是：\n1.阅读 \n2.亲近自然 \n3.独处\n\n已有科学证据表明，坐享这种刻意训练，可以直接增大训练者的大脑皮层表面积，也就是构回增加的结果。\n调查人员之一的心理学家`Ben AldersonDay`说：**“人们在独处的时候，更容易将注意力放在自己的感觉、身体以及情绪上。”**\n\n知识就是力量。\n\n真理往往会被忘记。当我们把注意力集中在一处，并且开始主动不去思考时，我们的大脑会比平时更加活跃，能够产生更多的连接。\n\n实际上，这也是一种历史悠久的刻意训练方法，撇开宗教不讲，这也是一种朴素的刻意训练方式，一种简单、朴素、有效的“大脑体操”，。没必要神化它，自然而然地用就是了。\n\n有时候，在坐享的过程中，可能会产生一些幻觉。在过去称之为“走火入魔”,其实这只是大脑处于“主动放松”的状态，有些原本相互并没有联系的脑细胞产生了一些“意外的联系”，换种说法，就是“主动做梦”，但理智告诉你，这只是梦，不是现实。\n\n这些活动都是让自己安静下来，慢慢把注意力拉回到自身。\n\n\n## 兴趣\n虽然每个人的兴趣不同，但在做感兴趣的事的时候，很容易进入全神贯注的状态。\n\n全神贯注是另一个刻意训练元认知能力的有效方法——很违背直觉的有效方法：\n\n通过进入全身贯注状态而使元认知能力彻底放松......\n\n大多数人直至成年，并没有养成哪怕仅仅一个属于自己的真正兴趣。换句说法：**大多数人基本上没有什么事情感觉值得自己去(主动去)“全神贯注”地做......**\n\n全神贯注其实分为两种：主动的与被动的。被动的全神贯注是受到外界控制的，通过设计学甚至心理学来让人兴奋，上瘾。而主动的全身贯注相对于被动的，多出了智商一个维度：\n\n**专注于提升某个特定的技能。**\n\n那游戏和看小说算不算锻炼元认知呢？其实锻炼与否并不单纯取决于活动本身，而在于你是否“主动的全身贯注”。\n\n如果你刚刚开始锻炼你的元认知，其实可以用一个比较简单的衡量标准：\n\n**是否顺利。**\n\n不论是“可以练习”，还是“主动的全身贯注”都不回那么容易，至少不会一帆风顺。\n\n即使有兴趣支撑的全神贯注，也需要你主动克服一些困难才能继续下去。\n\n兴趣因人而异，在任何一项兴趣中，都有**“必须刻意练习才能获得进步的技能”**，要满足这个需求，那因兴趣而产生的全神贯注，才可能是主动的，才可能是对刻意训练元认知能力有帮助的。\n\n这里李笑来老师拿自己学吉他做了一个例子（看的我都有点想回去学二胡了），在全神贯注地磨练任何一项技能时，元认知能力彻底的放松，而注意力全部用来去感受每一个感官的刺激，进而调整自己的每个动作，甚至每个意识与理解，最终达到比前一刻更好的地步。在这个过程中大脑皮层更多的回路生成，更多动作变成下意识就能完成的动作......直至结束的那一瞬间，休息完毕且“精力充沛”的元认知能力又再一次的被激活，清楚地意识到刚才的一切，幸福感“突然而生”，又因为元认知能力的存在，那幸福感格外的强烈。从而每一次练习就是一次正反馈，让自己看到成果，进而几发更多的兴趣。\n\n所以，找到一个能磨练自己某项技能的，能让自己迅速进入“主动的全神贯注状态”的，乃至于“干脆停不下来”的兴趣，非常重要，甚至干脆是生命之中绝对“不可或缺”的内容。\n\n很少有人能够单凭兴趣，坚持把某件事情昨晚。缺乏刻意练习，很快就会碰到“玻璃顶”。实际上大多数人最终能够长期保留自己的兴趣，基本上是因为这个正反馈被启动了：**有兴趣——刻意练习——做的更好——更有兴趣——继续练习。**兴趣和练习其实是相辅相成的。\n\n\n\n## 反思\n\n所谓“日三省吾身”，这几乎是刻意训练元认知能力的最高手段。所以，这应该是人人天天要做的事情。\n\n每天花十分钟左右，反思一下自己的思路和思考结果，琢磨一下自己的想法有没有逻辑错误？琢磨一下自己的想法从何而来？又缘何走了那么个思路？有没有其他可能的思考结果？琢磨一下自己受到了那些因素的影响？琢磨一下那些因素究竟有没有根基，有没有道理？\n\n反思活动在最初常常是无疾而终的，只有在长时间去刻意练习之后，才会在某个阶段突然清晰起来，反思效率得到了极大的提升（大概与复利曲线是一个道理吧），做出修正选择的时候也变得果断了很多。\n\n刚刚开始反思的人也容易想不清楚。其实最好的反思方法就是记录。没人能一次就把问题想明白。多数人，尤其是刚开始反思的人都需要在一个问题上反复思考，反复琢磨，才会有一点点的进步。\n\n所以这个时候记录的必要性就体现出来了。\n\n因为没有多少人能够清晰的记得自己所想的每一个细节，也自然不知道应该如何修正。只有记录下来了，我们才有机会回顾，并知道自己到底在那些细节上犯了什么错误。\n\n最重要的是，**反思不仅仅是一种元认知能力的刻意锻炼方式，也是调整自己情绪的根本。**\n\n控制不好自己情绪也和元认知能力有关，“生气”与“知道自己生气”大有不同。我们平时说的“迁怒”，其实本质上就是因为自己不知道为什么生气。想着想着就乱了，乱了之后就不管对象，先发一通火再说。\n\n冷静常常并不是控制情绪的结果，而是“认清情绪来源，并找到解决方案的结果”。而认清情绪的来源，就是在调用元认知能力。\n\n每一次认清情绪的来源，就是一次元认知能力获得锻炼的最好机会。每个人都一样，最终会发现，反思最多的，肯定是被情绪左右之后的行为和决定。不过，其实用不了多少次，元认知能力的适时激活就会成为习惯，所谓的冷静，不过是这个习惯自然而然的结果。\n\n## 思考与行动\n\n最近一次情绪失控是在和阿媛打电话的过程中，自己总是会在电话中表现出一种对阿媛向我诉说一些烦恼时的不耐烦，甚至连自己都没有意识到自己的态度这么恶劣以至于阿媛越哄越伤心，主要根源就是在没有自己发现甚至认清这个确实存在的事实。其实，在家里的时候也会对父母表现出不耐烦，自己本意并不是这样，是想好好珍惜和父母在一起的每分每秒的，毕竟这样的时间总是在越来越少，父母老去的速度也总是比自己成长的速度快很多很多。\n论语有言：“子夏问孝，子曰：色难。有事,弟子服其劳,有酒食,先生馔,曾是以为孝乎?”不仅是对父母，对待自己身边的每一个该珍惜的人都是这样，尽管你的行动都是为他们好，可是你表现出的态度呢？实在好不到哪里去，甚至还反而更糟。关心并不是做表面文章，而是要有耐心，由心而生的实际行动。\n\n着实，自己应该重视自己的真实内心，由心而生，反思自己的言行，培养自己的兴趣，坐享自己所成，从而推己及人，得到元认知能力的真正提高。","slug":"通向自由之路/通向自由之路(6)元认知能力提高篇","published":1,"updated":"2019-03-22T14:44:36.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0y00al4l3n8wh6a4n2","content":"<p>停更有点久了。最近找到工作之后，心有点宽下来了。不过还是要跑啊。</p>\n<p>在上一篇认识元认知能力之后，李笑来老师讲到了有效提高元认知能力的三个方法：坐享，兴趣，反思。</p>\n<p>在内容开始之前，提醒自己：要有耐心，要有耐心，要有耐心。<br><a id=\"more\"></a></p>\n<h2 id=\"坐享\"><a href=\"#坐享\" class=\"headerlink\" title=\"坐享\"></a>坐享</h2><p>坐享是一个李笑来老师自己创造的词汇，为的是区别打坐，冥想等其他有宗教意味的词。</p>\n<p>这种练习方式很简单：</p>\n<ul>\n<li>静坐15分钟以上（设闹钟）</li>\n<li>找一个舒服的姿势。</li>\n<li>闭眼（有些人睁眼也可以做到）</li>\n<li>缓慢均匀的呼吸</li>\n<li>把你的注意力集中在呼吸上。</li>\n</ul>\n<p>刚开始挺不容易，会发现自己的注意力一不小心走到了其他事情上。但，这就是刻意练习的重点：<strong>把所有注意力全部集中在一个点上。</strong><br>没经验的你很快就会走神，开始注意其他事情，如窗外的杂音，胸腔的起伏等。</p>\n<p>正是这种不容易，才使得你的元认知能力被激活，然后你在反复使用它去调整你的注意力。把所有注意力都放在一个地方。</p>\n<p>你可以把“元认知能力”想象成大脑肌肉的一种，就好比我们身体差的时候，锻炼一阵子哑铃，肌肉就会有所增长。只要你认真尝试，最终所有人都能做到。<br>刚刚开始的时候，甚至自己坐着坐着就睡着了，在有助于休息的活动中的前三名分别是：<br>1.阅读<br>2.亲近自然<br>3.独处</p>\n<p>已有科学证据表明，坐享这种刻意训练，可以直接增大训练者的大脑皮层表面积，也就是构回增加的结果。<br>调查人员之一的心理学家<code>Ben AldersonDay</code>说：<strong>“人们在独处的时候，更容易将注意力放在自己的感觉、身体以及情绪上。”</strong></p>\n<p>知识就是力量。</p>\n<p>真理往往会被忘记。当我们把注意力集中在一处，并且开始主动不去思考时，我们的大脑会比平时更加活跃，能够产生更多的连接。</p>\n<p>实际上，这也是一种历史悠久的刻意训练方法，撇开宗教不讲，这也是一种朴素的刻意训练方式，一种简单、朴素、有效的“大脑体操”，。没必要神化它，自然而然地用就是了。</p>\n<p>有时候，在坐享的过程中，可能会产生一些幻觉。在过去称之为“走火入魔”,其实这只是大脑处于“主动放松”的状态，有些原本相互并没有联系的脑细胞产生了一些“意外的联系”，换种说法，就是“主动做梦”，但理智告诉你，这只是梦，不是现实。</p>\n<p>这些活动都是让自己安静下来，慢慢把注意力拉回到自身。</p>\n<h2 id=\"兴趣\"><a href=\"#兴趣\" class=\"headerlink\" title=\"兴趣\"></a>兴趣</h2><p>虽然每个人的兴趣不同，但在做感兴趣的事的时候，很容易进入全神贯注的状态。</p>\n<p>全神贯注是另一个刻意训练元认知能力的有效方法——很违背直觉的有效方法：</p>\n<p>通过进入全身贯注状态而使元认知能力彻底放松……</p>\n<p>大多数人直至成年，并没有养成哪怕仅仅一个属于自己的真正兴趣。换句说法：<strong>大多数人基本上没有什么事情感觉值得自己去(主动去)“全神贯注”地做……</strong></p>\n<p>全神贯注其实分为两种：主动的与被动的。被动的全神贯注是受到外界控制的，通过设计学甚至心理学来让人兴奋，上瘾。而主动的全身贯注相对于被动的，多出了智商一个维度：</p>\n<p><strong>专注于提升某个特定的技能。</strong></p>\n<p>那游戏和看小说算不算锻炼元认知呢？其实锻炼与否并不单纯取决于活动本身，而在于你是否“主动的全身贯注”。</p>\n<p>如果你刚刚开始锻炼你的元认知，其实可以用一个比较简单的衡量标准：</p>\n<p><strong>是否顺利。</strong></p>\n<p>不论是“可以练习”，还是“主动的全身贯注”都不回那么容易，至少不会一帆风顺。</p>\n<p>即使有兴趣支撑的全神贯注，也需要你主动克服一些困难才能继续下去。</p>\n<p>兴趣因人而异，在任何一项兴趣中，都有<strong>“必须刻意练习才能获得进步的技能”</strong>，要满足这个需求，那因兴趣而产生的全神贯注，才可能是主动的，才可能是对刻意训练元认知能力有帮助的。</p>\n<p>这里李笑来老师拿自己学吉他做了一个例子（看的我都有点想回去学二胡了），在全神贯注地磨练任何一项技能时，元认知能力彻底的放松，而注意力全部用来去感受每一个感官的刺激，进而调整自己的每个动作，甚至每个意识与理解，最终达到比前一刻更好的地步。在这个过程中大脑皮层更多的回路生成，更多动作变成下意识就能完成的动作……直至结束的那一瞬间，休息完毕且“精力充沛”的元认知能力又再一次的被激活，清楚地意识到刚才的一切，幸福感“突然而生”，又因为元认知能力的存在，那幸福感格外的强烈。从而每一次练习就是一次正反馈，让自己看到成果，进而几发更多的兴趣。</p>\n<p>所以，找到一个能磨练自己某项技能的，能让自己迅速进入“主动的全神贯注状态”的，乃至于“干脆停不下来”的兴趣，非常重要，甚至干脆是生命之中绝对“不可或缺”的内容。</p>\n<p>很少有人能够单凭兴趣，坚持把某件事情昨晚。缺乏刻意练习，很快就会碰到“玻璃顶”。实际上大多数人最终能够长期保留自己的兴趣，基本上是因为这个正反馈被启动了：<strong>有兴趣——刻意练习——做的更好——更有兴趣——继续练习。</strong>兴趣和练习其实是相辅相成的。</p>\n<h2 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h2><p>所谓“日三省吾身”，这几乎是刻意训练元认知能力的最高手段。所以，这应该是人人天天要做的事情。</p>\n<p>每天花十分钟左右，反思一下自己的思路和思考结果，琢磨一下自己的想法有没有逻辑错误？琢磨一下自己的想法从何而来？又缘何走了那么个思路？有没有其他可能的思考结果？琢磨一下自己受到了那些因素的影响？琢磨一下那些因素究竟有没有根基，有没有道理？</p>\n<p>反思活动在最初常常是无疾而终的，只有在长时间去刻意练习之后，才会在某个阶段突然清晰起来，反思效率得到了极大的提升（大概与复利曲线是一个道理吧），做出修正选择的时候也变得果断了很多。</p>\n<p>刚刚开始反思的人也容易想不清楚。其实最好的反思方法就是记录。没人能一次就把问题想明白。多数人，尤其是刚开始反思的人都需要在一个问题上反复思考，反复琢磨，才会有一点点的进步。</p>\n<p>所以这个时候记录的必要性就体现出来了。</p>\n<p>因为没有多少人能够清晰的记得自己所想的每一个细节，也自然不知道应该如何修正。只有记录下来了，我们才有机会回顾，并知道自己到底在那些细节上犯了什么错误。</p>\n<p>最重要的是，<strong>反思不仅仅是一种元认知能力的刻意锻炼方式，也是调整自己情绪的根本。</strong></p>\n<p>控制不好自己情绪也和元认知能力有关，“生气”与“知道自己生气”大有不同。我们平时说的“迁怒”，其实本质上就是因为自己不知道为什么生气。想着想着就乱了，乱了之后就不管对象，先发一通火再说。</p>\n<p>冷静常常并不是控制情绪的结果，而是“认清情绪来源，并找到解决方案的结果”。而认清情绪的来源，就是在调用元认知能力。</p>\n<p>每一次认清情绪的来源，就是一次元认知能力获得锻炼的最好机会。每个人都一样，最终会发现，反思最多的，肯定是被情绪左右之后的行为和决定。不过，其实用不了多少次，元认知能力的适时激活就会成为习惯，所谓的冷静，不过是这个习惯自然而然的结果。</p>\n<h2 id=\"思考与行动\"><a href=\"#思考与行动\" class=\"headerlink\" title=\"思考与行动\"></a>思考与行动</h2><p>最近一次情绪失控是在和阿媛打电话的过程中，自己总是会在电话中表现出一种对阿媛向我诉说一些烦恼时的不耐烦，甚至连自己都没有意识到自己的态度这么恶劣以至于阿媛越哄越伤心，主要根源就是在没有自己发现甚至认清这个确实存在的事实。其实，在家里的时候也会对父母表现出不耐烦，自己本意并不是这样，是想好好珍惜和父母在一起的每分每秒的，毕竟这样的时间总是在越来越少，父母老去的速度也总是比自己成长的速度快很多很多。<br>论语有言：“子夏问孝，子曰：色难。有事,弟子服其劳,有酒食,先生馔,曾是以为孝乎?”不仅是对父母，对待自己身边的每一个该珍惜的人都是这样，尽管你的行动都是为他们好，可是你表现出的态度呢？实在好不到哪里去，甚至还反而更糟。关心并不是做表面文章，而是要有耐心，由心而生的实际行动。</p>\n<p>着实，自己应该重视自己的真实内心，由心而生，反思自己的言行，培养自己的兴趣，坐享自己所成，从而推己及人，得到元认知能力的真正提高。</p>\n","site":{"data":{}},"excerpt":"<p>停更有点久了。最近找到工作之后，心有点宽下来了。不过还是要跑啊。</p>\n<p>在上一篇认识元认知能力之后，李笑来老师讲到了有效提高元认知能力的三个方法：坐享，兴趣，反思。</p>\n<p>在内容开始之前，提醒自己：要有耐心，要有耐心，要有耐心。<br></p>","more":"<p></p>\n<h2 id=\"坐享\"><a href=\"#坐享\" class=\"headerlink\" title=\"坐享\"></a>坐享</h2><p>坐享是一个李笑来老师自己创造的词汇，为的是区别打坐，冥想等其他有宗教意味的词。</p>\n<p>这种练习方式很简单：</p>\n<ul>\n<li>静坐15分钟以上（设闹钟）</li>\n<li>找一个舒服的姿势。</li>\n<li>闭眼（有些人睁眼也可以做到）</li>\n<li>缓慢均匀的呼吸</li>\n<li>把你的注意力集中在呼吸上。</li>\n</ul>\n<p>刚开始挺不容易，会发现自己的注意力一不小心走到了其他事情上。但，这就是刻意练习的重点：<strong>把所有注意力全部集中在一个点上。</strong><br>没经验的你很快就会走神，开始注意其他事情，如窗外的杂音，胸腔的起伏等。</p>\n<p>正是这种不容易，才使得你的元认知能力被激活，然后你在反复使用它去调整你的注意力。把所有注意力都放在一个地方。</p>\n<p>你可以把“元认知能力”想象成大脑肌肉的一种，就好比我们身体差的时候，锻炼一阵子哑铃，肌肉就会有所增长。只要你认真尝试，最终所有人都能做到。<br>刚刚开始的时候，甚至自己坐着坐着就睡着了，在有助于休息的活动中的前三名分别是：<br>1.阅读<br>2.亲近自然<br>3.独处</p>\n<p>已有科学证据表明，坐享这种刻意训练，可以直接增大训练者的大脑皮层表面积，也就是构回增加的结果。<br>调查人员之一的心理学家<code>Ben AldersonDay</code>说：<strong>“人们在独处的时候，更容易将注意力放在自己的感觉、身体以及情绪上。”</strong></p>\n<p>知识就是力量。</p>\n<p>真理往往会被忘记。当我们把注意力集中在一处，并且开始主动不去思考时，我们的大脑会比平时更加活跃，能够产生更多的连接。</p>\n<p>实际上，这也是一种历史悠久的刻意训练方法，撇开宗教不讲，这也是一种朴素的刻意训练方式，一种简单、朴素、有效的“大脑体操”，。没必要神化它，自然而然地用就是了。</p>\n<p>有时候，在坐享的过程中，可能会产生一些幻觉。在过去称之为“走火入魔”,其实这只是大脑处于“主动放松”的状态，有些原本相互并没有联系的脑细胞产生了一些“意外的联系”，换种说法，就是“主动做梦”，但理智告诉你，这只是梦，不是现实。</p>\n<p>这些活动都是让自己安静下来，慢慢把注意力拉回到自身。</p>\n<h2 id=\"兴趣\"><a href=\"#兴趣\" class=\"headerlink\" title=\"兴趣\"></a>兴趣</h2><p>虽然每个人的兴趣不同，但在做感兴趣的事的时候，很容易进入全神贯注的状态。</p>\n<p>全神贯注是另一个刻意训练元认知能力的有效方法——很违背直觉的有效方法：</p>\n<p>通过进入全身贯注状态而使元认知能力彻底放松……</p>\n<p>大多数人直至成年，并没有养成哪怕仅仅一个属于自己的真正兴趣。换句说法：<strong>大多数人基本上没有什么事情感觉值得自己去(主动去)“全神贯注”地做……</strong></p>\n<p>全神贯注其实分为两种：主动的与被动的。被动的全神贯注是受到外界控制的，通过设计学甚至心理学来让人兴奋，上瘾。而主动的全身贯注相对于被动的，多出了智商一个维度：</p>\n<p><strong>专注于提升某个特定的技能。</strong></p>\n<p>那游戏和看小说算不算锻炼元认知呢？其实锻炼与否并不单纯取决于活动本身，而在于你是否“主动的全身贯注”。</p>\n<p>如果你刚刚开始锻炼你的元认知，其实可以用一个比较简单的衡量标准：</p>\n<p><strong>是否顺利。</strong></p>\n<p>不论是“可以练习”，还是“主动的全身贯注”都不回那么容易，至少不会一帆风顺。</p>\n<p>即使有兴趣支撑的全神贯注，也需要你主动克服一些困难才能继续下去。</p>\n<p>兴趣因人而异，在任何一项兴趣中，都有<strong>“必须刻意练习才能获得进步的技能”</strong>，要满足这个需求，那因兴趣而产生的全神贯注，才可能是主动的，才可能是对刻意训练元认知能力有帮助的。</p>\n<p>这里李笑来老师拿自己学吉他做了一个例子（看的我都有点想回去学二胡了），在全神贯注地磨练任何一项技能时，元认知能力彻底的放松，而注意力全部用来去感受每一个感官的刺激，进而调整自己的每个动作，甚至每个意识与理解，最终达到比前一刻更好的地步。在这个过程中大脑皮层更多的回路生成，更多动作变成下意识就能完成的动作……直至结束的那一瞬间，休息完毕且“精力充沛”的元认知能力又再一次的被激活，清楚地意识到刚才的一切，幸福感“突然而生”，又因为元认知能力的存在，那幸福感格外的强烈。从而每一次练习就是一次正反馈，让自己看到成果，进而几发更多的兴趣。</p>\n<p>所以，找到一个能磨练自己某项技能的，能让自己迅速进入“主动的全神贯注状态”的，乃至于“干脆停不下来”的兴趣，非常重要，甚至干脆是生命之中绝对“不可或缺”的内容。</p>\n<p>很少有人能够单凭兴趣，坚持把某件事情昨晚。缺乏刻意练习，很快就会碰到“玻璃顶”。实际上大多数人最终能够长期保留自己的兴趣，基本上是因为这个正反馈被启动了：<strong>有兴趣——刻意练习——做的更好——更有兴趣——继续练习。</strong>兴趣和练习其实是相辅相成的。</p>\n<h2 id=\"反思\"><a href=\"#反思\" class=\"headerlink\" title=\"反思\"></a>反思</h2><p>所谓“日三省吾身”，这几乎是刻意训练元认知能力的最高手段。所以，这应该是人人天天要做的事情。</p>\n<p>每天花十分钟左右，反思一下自己的思路和思考结果，琢磨一下自己的想法有没有逻辑错误？琢磨一下自己的想法从何而来？又缘何走了那么个思路？有没有其他可能的思考结果？琢磨一下自己受到了那些因素的影响？琢磨一下那些因素究竟有没有根基，有没有道理？</p>\n<p>反思活动在最初常常是无疾而终的，只有在长时间去刻意练习之后，才会在某个阶段突然清晰起来，反思效率得到了极大的提升（大概与复利曲线是一个道理吧），做出修正选择的时候也变得果断了很多。</p>\n<p>刚刚开始反思的人也容易想不清楚。其实最好的反思方法就是记录。没人能一次就把问题想明白。多数人，尤其是刚开始反思的人都需要在一个问题上反复思考，反复琢磨，才会有一点点的进步。</p>\n<p>所以这个时候记录的必要性就体现出来了。</p>\n<p>因为没有多少人能够清晰的记得自己所想的每一个细节，也自然不知道应该如何修正。只有记录下来了，我们才有机会回顾，并知道自己到底在那些细节上犯了什么错误。</p>\n<p>最重要的是，<strong>反思不仅仅是一种元认知能力的刻意锻炼方式，也是调整自己情绪的根本。</strong></p>\n<p>控制不好自己情绪也和元认知能力有关，“生气”与“知道自己生气”大有不同。我们平时说的“迁怒”，其实本质上就是因为自己不知道为什么生气。想着想着就乱了，乱了之后就不管对象，先发一通火再说。</p>\n<p>冷静常常并不是控制情绪的结果，而是“认清情绪来源，并找到解决方案的结果”。而认清情绪的来源，就是在调用元认知能力。</p>\n<p>每一次认清情绪的来源，就是一次元认知能力获得锻炼的最好机会。每个人都一样，最终会发现，反思最多的，肯定是被情绪左右之后的行为和决定。不过，其实用不了多少次，元认知能力的适时激活就会成为习惯，所谓的冷静，不过是这个习惯自然而然的结果。</p>\n<h2 id=\"思考与行动\"><a href=\"#思考与行动\" class=\"headerlink\" title=\"思考与行动\"></a>思考与行动</h2><p>最近一次情绪失控是在和阿媛打电话的过程中，自己总是会在电话中表现出一种对阿媛向我诉说一些烦恼时的不耐烦，甚至连自己都没有意识到自己的态度这么恶劣以至于阿媛越哄越伤心，主要根源就是在没有自己发现甚至认清这个确实存在的事实。其实，在家里的时候也会对父母表现出不耐烦，自己本意并不是这样，是想好好珍惜和父母在一起的每分每秒的，毕竟这样的时间总是在越来越少，父母老去的速度也总是比自己成长的速度快很多很多。<br>论语有言：“子夏问孝，子曰：色难。有事,弟子服其劳,有酒食,先生馔,曾是以为孝乎?”不仅是对父母，对待自己身边的每一个该珍惜的人都是这样，尽管你的行动都是为他们好，可是你表现出的态度呢？实在好不到哪里去，甚至还反而更糟。关心并不是做表面文章，而是要有耐心，由心而生的实际行动。</p>\n<p>着实，自己应该重视自己的真实内心，由心而生，反思自己的言行，培养自己的兴趣，坐享自己所成，从而推己及人，得到元认知能力的真正提高。</p>"},{"title":"通向自由之路(5)元认知能力篇","date":"2016-10-09T15:56:50.000Z","_content":"\n>元认知能力(metacognition)：awareness and understanding of one's own thought processes.即对自己思考过程的认知与理解。\n\n认知能力好比是马，而元认知能力是马车。\n\n回想一下自己的生活，有多少次是马随意地拉着马车跑，而不顾马车夫的指令。这正是元认知能力的不够，导致无法好好控制认知带来的结果。\n\n<!-- more -->\n\n你的元认知能力被激活，开始发挥作用的过程中，你可能意识到的是：\n* 啊？之前我想的竟然都是错的\n* 啊？原来是这样的啊\n* 道理挺简单的嘛，为什么我之前竟然完全没有想到\n* 嗯！我知道了，我现在应该这样想才对\n* 嗯？我怎么又被带回去了呢？明明学过的道理怎么就忘了应用呢？\n* 唉，知易行难啊！我就不信我搞不定！\n\n“恍然大悟”的瞬间其实来的并不轻松。\n\n越是简单的事情越容易被忽略。因为我们总是以为自己已经理解了这些表层的意思，而不再去深挖其中的本质。\n\n当你有了“这么简单的道理，我怎么才明白”的感觉时，那层貌似简单的窗户纸才被你捅破。\n\n把复杂的原理用简单的方式讲清楚不容易。让别人意识到简单的东西，其实并没有那么简单则更加不容易。\n\n元认知能力的强弱，决定一个人每个方面的强弱，甚至不夸张的讲：\n\n**一个人的财富创造能力最终也只与元认知能力有关——其他都是附属因素。**\n\n尽管上面那个思考过程看起来非常简单，可就是这简单的思考，竟然是绝大多数人穷尽一生都没有学会的技能，甚至都没有想过应该习得、锻炼这种技能。\n\n从这个角度望去，古来教育在这个最重要的能力上贡献几近于零。又，竟然还是在它原本如此简单的情况下。\n\n“学习学习再学习”，意思是先要掌握学习的方法，再用合理的方法去学习。\n\n而我们教育中缺少的重要一环，就是把学生们的“元认知能力”培养起来。让大家知道，自己是大脑的主人，而不是反过来被大脑控制。\n（确实自身存在很多次被大脑控制的场景，尤其是忍不住想去打游戏，想放松自己的时候。）\n\n大多数人没有想明白的道理是：\n\n我们大脑可以有多个层次。\n\n持续升级自己的大脑，不断地站在更高的层级去控制下面的大脑，这才是我们作为人类进化最有效的手段。\n\n那么多人之所以容易受情绪干扰，脑子不清晰，其实是因为总是站在最底层与大脑纠缠，而从来没有想过自己能够有机会站在更高的层次去控制它。\n\n一个格外举足轻重的例子就是：“情商”。那些被认为“情商差”的人，本质上来看，其实就是无法正确理解别人的感受，这其实就是来源于元认知能力的欠缺。\n\n**一个连对自己的感受都不能完整正确的认知的人，怎么可能完整正确地理解他人的感受呢？**\n\n所谓的“将心比心”，的确是绝大多数人做不到的事情——因为大多数人其实并不了解自己的思考过程、思考原理、思考方式；更是因为大多数人从未认真审视过自己思考结果是否正确合理。\n\n所谓的情商和智商只是一些外在表现形式，而一个人能否在这些方面获得高分，则取决于他们是否对这些概念有本质的理解。\n\n看到智商高的人，总觉得人家天生聪明，可以轻松解开复杂的数学题目。而不会觉得，对方其实是知道了数字背后更深层次的原理。\n\n看到情商高的人，就会羡慕对方的社交能力，但真正本质的是对方能够洞察每个人内心的需求。\n\n元认知能力之所以重要，是因为它不光能帮你了解自己，同时还会让你更加了解别人。\n\n\n\n在《把时间当作朋友》中的副标题中提到的\"心智\"，指的就是具备足够元认知能力的大脑。\n\n* 时间总是在过后才显得飞快。。\n* 真的是这样呢，为什么会有这种感觉呢？\n* 若是这种感觉是真实的，那我为什么竟然忽略了这个事实？究竟错过了什么？\n* 我还需要纠正什么？\n\n元认知能力强的人，在阅读的时候，时时刻刻注意到自己的思考和思路，时时刻刻都在对自己的思考和思路进行“反思”、“校验”、“修订”，当然最重要的是：“升级”。\n\n每一个人的文字就是每个人的想法。\n\n你在读别人文字的时候，就是在那对方的思维方式和自己作对比。这其实也是一种锻炼元认知的过程。\n\n如果你有记录的习惯，阅读过去的文字就相当于和过去的自己做一个对比，反过来检验一下这段时间自己思维方式的变化，以及为什么有这样的变化。\n\n\n多去看别人的文字，同时自己也要多记录多回顾，这种习惯一旦形成威力是巨大的。\n\n所以，他们在读书的时候，他们读到的不仅仅是文字以及文字所阐述的道理，他们更多注意到的是**作者的思考方式**,作者的思考方式和自己的思考方式的不同，以及，若是作者的思考方式可取的话，自己的思路又该作何调整？这也就是同一本书读完，为什么极少数人却能非常成功——因为他们改良了自己的思考方式，从此可以“像一个科学家一样思考”······\n\n他们在上学的时候也是如此。大多数人只不过是在为了应付考试而疲于奔命，他们却学会了如何学习。在工作的时候，而不是疲于奔命，学会了如何有效地工作，如何有效地领导，如何有效地创造价值······在于他人交往中，大多数人都是在自说自话的时候，他们却可以成为“有效的聆听者”。\n\n最近二十年里，认知科学和脑科学长足发展，关于“成功学”的理论基础也有了很多次的升级。大量的研究结果表明，人与人之间的技能差异，证据确凿地来自于“刻意锻炼”(Deliberate Practice)。而一个人能够仰仗的就是元认知能力，反过来，**元认知能力也必然会在刻意锻炼中被不断增强**——现在你能想象人与人之间的差异有多大了么？\n\n有一种其实很普遍的病症，叫做抑郁症。今天，抑郁症的病因也没有一个清楚合理的完整解释，不过有一点却是达成共识的：元认知能力的提高，可以有效的防止抑郁症的发生。当然，这也是有效的治愈方法。\n\n元认知的提高在方方面面帮助到自己。\n\n比如和伴侣吵架，吵架大多数原因是因为沟通不足，不光是时间不足，还有深度的不足。\n\n除此之外，元认知能力还是你大脑的“食品质检员”。他能帮你筛选出\n那些真正有质量，能够帮你提升思维能力的养料，如果没有这种能力的把关，就相当于不顾自己的大脑饮食健康，最终没能有一个强健的大脑也是必然的事情。\n\n那，为什么说“一个人的财富创造能力最终也只与元认知能力有关——其他都是附属因素”呢？原因很简单：\n\n**你的财富创造能力取决于你能给别人创造多少真正的价值。**\n\n你的创造，只有你觉得有价值是，是没有什么意义的。要他人也认为有价值才可以，并且人数越多越好，人数越多，你创造价值就越高。\n\n再举一例，元认知能力差的人，性生活质量也会很差。因为元认知能力差的人不可能懂得如何照顾对方感受。\n\n于是，你只能通过不断地加强自己的“元认知能力”，以求自己的思考和思路越来越接近于正确、完整、高效。乃至于有一天，你随随便便创造出来的东西，都是真正有价值的，不仅对自己有价值，对他人也有价值，那时的财富，只不过是“顺手而得”的东西而已。\n\n这个专栏背后的科学基础只不过是两个特别简单的事实：\n* 元认知能力是一个人可拥有的最重要的能力。\n* 元认知能力不仅可以习得，还可以通过刻意训练长期持续的发展。\n\n其实我们不妨把大脑当做一块肌肉。\n\n没有人天生就拥有健硕的体格，也没有人天生就有强大的元认知能力，这些都是后天锻炼出来的。\n\n只要是肌肉都符合“用进废退”的规则。同理，优质的书籍和文章就是我们训练思维的工具。\n\n而且“健脑”和健身一样，其实是看得见的、实实在在的变化。\n\n我们每周都在更新观念，而所谓的“更新”，之所以可以成功，就是因为读者的元认知能力被激活，于是，能够意识到自己原来的想法是这样的，意识到这样和那样有什么不同，甚至，在对与错，好与坏，优和更优，差与更差之间反复选择的过程中，不断强化自己的元认知能力······\n\n还有一样的：\n\n我们不会着急到“想用一篇文章立刻改变自己”的地步——因为我们与他人不同，我们有足够的耐心。我们是一群决心要生活在未来的人。于是无以伦比的耐心必然来自于一个事实：\n\n我们知道我们想要改变的，能够改变的不是现在的自己，而是将来的自己。但是，现在要做的不是空想，而是践行。\n\n## 思考问题\n\n1.你觉得你的元认知能力强么？又，在思考哪些领域那些事情的时候，觉得自己更强？\n\n2.现在你已经知道元认知能力的重要性了，那么你觉得在思考哪些问题的时候，必须刻意运用自己的元认知能力？\n\n3.如果让你自己想，你能找得出哪些提升元认知能力的方式方法？\n\n4.你已经意识到了元认知能力的重要，那么你如何才能让你的亲人，挚友也认识到元认知能力的重要？\n\n5.观察周遭，你觉得谁的元认知能力更强？你能从他身上学到什么？\n\n6.很多时候，并不是他人不理解你，而是你自己没有想清楚、表达清楚，所以他人无法理解你。能想到一个自身的重要经历是这样的么？从中你应该得到怎样的反思？\n\n","source":"_posts/通向自由之路/通向自由之路(5)元认知能力篇.md","raw":"---\ntitle: 通向自由之路(5)元认知能力篇\ndate: 2016-10-09 23:56:50\ntags: \n- 通向自由之路\ncategories: 反思\n---\n\n>元认知能力(metacognition)：awareness and understanding of one's own thought processes.即对自己思考过程的认知与理解。\n\n认知能力好比是马，而元认知能力是马车。\n\n回想一下自己的生活，有多少次是马随意地拉着马车跑，而不顾马车夫的指令。这正是元认知能力的不够，导致无法好好控制认知带来的结果。\n\n<!-- more -->\n\n你的元认知能力被激活，开始发挥作用的过程中，你可能意识到的是：\n* 啊？之前我想的竟然都是错的\n* 啊？原来是这样的啊\n* 道理挺简单的嘛，为什么我之前竟然完全没有想到\n* 嗯！我知道了，我现在应该这样想才对\n* 嗯？我怎么又被带回去了呢？明明学过的道理怎么就忘了应用呢？\n* 唉，知易行难啊！我就不信我搞不定！\n\n“恍然大悟”的瞬间其实来的并不轻松。\n\n越是简单的事情越容易被忽略。因为我们总是以为自己已经理解了这些表层的意思，而不再去深挖其中的本质。\n\n当你有了“这么简单的道理，我怎么才明白”的感觉时，那层貌似简单的窗户纸才被你捅破。\n\n把复杂的原理用简单的方式讲清楚不容易。让别人意识到简单的东西，其实并没有那么简单则更加不容易。\n\n元认知能力的强弱，决定一个人每个方面的强弱，甚至不夸张的讲：\n\n**一个人的财富创造能力最终也只与元认知能力有关——其他都是附属因素。**\n\n尽管上面那个思考过程看起来非常简单，可就是这简单的思考，竟然是绝大多数人穷尽一生都没有学会的技能，甚至都没有想过应该习得、锻炼这种技能。\n\n从这个角度望去，古来教育在这个最重要的能力上贡献几近于零。又，竟然还是在它原本如此简单的情况下。\n\n“学习学习再学习”，意思是先要掌握学习的方法，再用合理的方法去学习。\n\n而我们教育中缺少的重要一环，就是把学生们的“元认知能力”培养起来。让大家知道，自己是大脑的主人，而不是反过来被大脑控制。\n（确实自身存在很多次被大脑控制的场景，尤其是忍不住想去打游戏，想放松自己的时候。）\n\n大多数人没有想明白的道理是：\n\n我们大脑可以有多个层次。\n\n持续升级自己的大脑，不断地站在更高的层级去控制下面的大脑，这才是我们作为人类进化最有效的手段。\n\n那么多人之所以容易受情绪干扰，脑子不清晰，其实是因为总是站在最底层与大脑纠缠，而从来没有想过自己能够有机会站在更高的层次去控制它。\n\n一个格外举足轻重的例子就是：“情商”。那些被认为“情商差”的人，本质上来看，其实就是无法正确理解别人的感受，这其实就是来源于元认知能力的欠缺。\n\n**一个连对自己的感受都不能完整正确的认知的人，怎么可能完整正确地理解他人的感受呢？**\n\n所谓的“将心比心”，的确是绝大多数人做不到的事情——因为大多数人其实并不了解自己的思考过程、思考原理、思考方式；更是因为大多数人从未认真审视过自己思考结果是否正确合理。\n\n所谓的情商和智商只是一些外在表现形式，而一个人能否在这些方面获得高分，则取决于他们是否对这些概念有本质的理解。\n\n看到智商高的人，总觉得人家天生聪明，可以轻松解开复杂的数学题目。而不会觉得，对方其实是知道了数字背后更深层次的原理。\n\n看到情商高的人，就会羡慕对方的社交能力，但真正本质的是对方能够洞察每个人内心的需求。\n\n元认知能力之所以重要，是因为它不光能帮你了解自己，同时还会让你更加了解别人。\n\n\n\n在《把时间当作朋友》中的副标题中提到的\"心智\"，指的就是具备足够元认知能力的大脑。\n\n* 时间总是在过后才显得飞快。。\n* 真的是这样呢，为什么会有这种感觉呢？\n* 若是这种感觉是真实的，那我为什么竟然忽略了这个事实？究竟错过了什么？\n* 我还需要纠正什么？\n\n元认知能力强的人，在阅读的时候，时时刻刻注意到自己的思考和思路，时时刻刻都在对自己的思考和思路进行“反思”、“校验”、“修订”，当然最重要的是：“升级”。\n\n每一个人的文字就是每个人的想法。\n\n你在读别人文字的时候，就是在那对方的思维方式和自己作对比。这其实也是一种锻炼元认知的过程。\n\n如果你有记录的习惯，阅读过去的文字就相当于和过去的自己做一个对比，反过来检验一下这段时间自己思维方式的变化，以及为什么有这样的变化。\n\n\n多去看别人的文字，同时自己也要多记录多回顾，这种习惯一旦形成威力是巨大的。\n\n所以，他们在读书的时候，他们读到的不仅仅是文字以及文字所阐述的道理，他们更多注意到的是**作者的思考方式**,作者的思考方式和自己的思考方式的不同，以及，若是作者的思考方式可取的话，自己的思路又该作何调整？这也就是同一本书读完，为什么极少数人却能非常成功——因为他们改良了自己的思考方式，从此可以“像一个科学家一样思考”······\n\n他们在上学的时候也是如此。大多数人只不过是在为了应付考试而疲于奔命，他们却学会了如何学习。在工作的时候，而不是疲于奔命，学会了如何有效地工作，如何有效地领导，如何有效地创造价值······在于他人交往中，大多数人都是在自说自话的时候，他们却可以成为“有效的聆听者”。\n\n最近二十年里，认知科学和脑科学长足发展，关于“成功学”的理论基础也有了很多次的升级。大量的研究结果表明，人与人之间的技能差异，证据确凿地来自于“刻意锻炼”(Deliberate Practice)。而一个人能够仰仗的就是元认知能力，反过来，**元认知能力也必然会在刻意锻炼中被不断增强**——现在你能想象人与人之间的差异有多大了么？\n\n有一种其实很普遍的病症，叫做抑郁症。今天，抑郁症的病因也没有一个清楚合理的完整解释，不过有一点却是达成共识的：元认知能力的提高，可以有效的防止抑郁症的发生。当然，这也是有效的治愈方法。\n\n元认知的提高在方方面面帮助到自己。\n\n比如和伴侣吵架，吵架大多数原因是因为沟通不足，不光是时间不足，还有深度的不足。\n\n除此之外，元认知能力还是你大脑的“食品质检员”。他能帮你筛选出\n那些真正有质量，能够帮你提升思维能力的养料，如果没有这种能力的把关，就相当于不顾自己的大脑饮食健康，最终没能有一个强健的大脑也是必然的事情。\n\n那，为什么说“一个人的财富创造能力最终也只与元认知能力有关——其他都是附属因素”呢？原因很简单：\n\n**你的财富创造能力取决于你能给别人创造多少真正的价值。**\n\n你的创造，只有你觉得有价值是，是没有什么意义的。要他人也认为有价值才可以，并且人数越多越好，人数越多，你创造价值就越高。\n\n再举一例，元认知能力差的人，性生活质量也会很差。因为元认知能力差的人不可能懂得如何照顾对方感受。\n\n于是，你只能通过不断地加强自己的“元认知能力”，以求自己的思考和思路越来越接近于正确、完整、高效。乃至于有一天，你随随便便创造出来的东西，都是真正有价值的，不仅对自己有价值，对他人也有价值，那时的财富，只不过是“顺手而得”的东西而已。\n\n这个专栏背后的科学基础只不过是两个特别简单的事实：\n* 元认知能力是一个人可拥有的最重要的能力。\n* 元认知能力不仅可以习得，还可以通过刻意训练长期持续的发展。\n\n其实我们不妨把大脑当做一块肌肉。\n\n没有人天生就拥有健硕的体格，也没有人天生就有强大的元认知能力，这些都是后天锻炼出来的。\n\n只要是肌肉都符合“用进废退”的规则。同理，优质的书籍和文章就是我们训练思维的工具。\n\n而且“健脑”和健身一样，其实是看得见的、实实在在的变化。\n\n我们每周都在更新观念，而所谓的“更新”，之所以可以成功，就是因为读者的元认知能力被激活，于是，能够意识到自己原来的想法是这样的，意识到这样和那样有什么不同，甚至，在对与错，好与坏，优和更优，差与更差之间反复选择的过程中，不断强化自己的元认知能力······\n\n还有一样的：\n\n我们不会着急到“想用一篇文章立刻改变自己”的地步——因为我们与他人不同，我们有足够的耐心。我们是一群决心要生活在未来的人。于是无以伦比的耐心必然来自于一个事实：\n\n我们知道我们想要改变的，能够改变的不是现在的自己，而是将来的自己。但是，现在要做的不是空想，而是践行。\n\n## 思考问题\n\n1.你觉得你的元认知能力强么？又，在思考哪些领域那些事情的时候，觉得自己更强？\n\n2.现在你已经知道元认知能力的重要性了，那么你觉得在思考哪些问题的时候，必须刻意运用自己的元认知能力？\n\n3.如果让你自己想，你能找得出哪些提升元认知能力的方式方法？\n\n4.你已经意识到了元认知能力的重要，那么你如何才能让你的亲人，挚友也认识到元认知能力的重要？\n\n5.观察周遭，你觉得谁的元认知能力更强？你能从他身上学到什么？\n\n6.很多时候，并不是他人不理解你，而是你自己没有想清楚、表达清楚，所以他人无法理解你。能想到一个自身的重要经历是这样的么？从中你应该得到怎样的反思？\n\n","slug":"通向自由之路/通向自由之路(5)元认知能力篇","published":1,"updated":"2019-03-22T14:44:36.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn0z00ao4l3nv0sijb0d","content":"<blockquote>\n<p>元认知能力(metacognition)：awareness and understanding of one’s own thought processes.即对自己思考过程的认知与理解。</p>\n</blockquote>\n<p>认知能力好比是马，而元认知能力是马车。</p>\n<p>回想一下自己的生活，有多少次是马随意地拉着马车跑，而不顾马车夫的指令。这正是元认知能力的不够，导致无法好好控制认知带来的结果。</p>\n<a id=\"more\"></a>\n<p>你的元认知能力被激活，开始发挥作用的过程中，你可能意识到的是：</p>\n<ul>\n<li>啊？之前我想的竟然都是错的</li>\n<li>啊？原来是这样的啊</li>\n<li>道理挺简单的嘛，为什么我之前竟然完全没有想到</li>\n<li>嗯！我知道了，我现在应该这样想才对</li>\n<li>嗯？我怎么又被带回去了呢？明明学过的道理怎么就忘了应用呢？</li>\n<li>唉，知易行难啊！我就不信我搞不定！</li>\n</ul>\n<p>“恍然大悟”的瞬间其实来的并不轻松。</p>\n<p>越是简单的事情越容易被忽略。因为我们总是以为自己已经理解了这些表层的意思，而不再去深挖其中的本质。</p>\n<p>当你有了“这么简单的道理，我怎么才明白”的感觉时，那层貌似简单的窗户纸才被你捅破。</p>\n<p>把复杂的原理用简单的方式讲清楚不容易。让别人意识到简单的东西，其实并没有那么简单则更加不容易。</p>\n<p>元认知能力的强弱，决定一个人每个方面的强弱，甚至不夸张的讲：</p>\n<p><strong>一个人的财富创造能力最终也只与元认知能力有关——其他都是附属因素。</strong></p>\n<p>尽管上面那个思考过程看起来非常简单，可就是这简单的思考，竟然是绝大多数人穷尽一生都没有学会的技能，甚至都没有想过应该习得、锻炼这种技能。</p>\n<p>从这个角度望去，古来教育在这个最重要的能力上贡献几近于零。又，竟然还是在它原本如此简单的情况下。</p>\n<p>“学习学习再学习”，意思是先要掌握学习的方法，再用合理的方法去学习。</p>\n<p>而我们教育中缺少的重要一环，就是把学生们的“元认知能力”培养起来。让大家知道，自己是大脑的主人，而不是反过来被大脑控制。<br>（确实自身存在很多次被大脑控制的场景，尤其是忍不住想去打游戏，想放松自己的时候。）</p>\n<p>大多数人没有想明白的道理是：</p>\n<p>我们大脑可以有多个层次。</p>\n<p>持续升级自己的大脑，不断地站在更高的层级去控制下面的大脑，这才是我们作为人类进化最有效的手段。</p>\n<p>那么多人之所以容易受情绪干扰，脑子不清晰，其实是因为总是站在最底层与大脑纠缠，而从来没有想过自己能够有机会站在更高的层次去控制它。</p>\n<p>一个格外举足轻重的例子就是：“情商”。那些被认为“情商差”的人，本质上来看，其实就是无法正确理解别人的感受，这其实就是来源于元认知能力的欠缺。</p>\n<p><strong>一个连对自己的感受都不能完整正确的认知的人，怎么可能完整正确地理解他人的感受呢？</strong></p>\n<p>所谓的“将心比心”，的确是绝大多数人做不到的事情——因为大多数人其实并不了解自己的思考过程、思考原理、思考方式；更是因为大多数人从未认真审视过自己思考结果是否正确合理。</p>\n<p>所谓的情商和智商只是一些外在表现形式，而一个人能否在这些方面获得高分，则取决于他们是否对这些概念有本质的理解。</p>\n<p>看到智商高的人，总觉得人家天生聪明，可以轻松解开复杂的数学题目。而不会觉得，对方其实是知道了数字背后更深层次的原理。</p>\n<p>看到情商高的人，就会羡慕对方的社交能力，但真正本质的是对方能够洞察每个人内心的需求。</p>\n<p>元认知能力之所以重要，是因为它不光能帮你了解自己，同时还会让你更加了解别人。</p>\n<p>在《把时间当作朋友》中的副标题中提到的”心智”，指的就是具备足够元认知能力的大脑。</p>\n<ul>\n<li>时间总是在过后才显得飞快。。</li>\n<li>真的是这样呢，为什么会有这种感觉呢？</li>\n<li>若是这种感觉是真实的，那我为什么竟然忽略了这个事实？究竟错过了什么？</li>\n<li>我还需要纠正什么？</li>\n</ul>\n<p>元认知能力强的人，在阅读的时候，时时刻刻注意到自己的思考和思路，时时刻刻都在对自己的思考和思路进行“反思”、“校验”、“修订”，当然最重要的是：“升级”。</p>\n<p>每一个人的文字就是每个人的想法。</p>\n<p>你在读别人文字的时候，就是在那对方的思维方式和自己作对比。这其实也是一种锻炼元认知的过程。</p>\n<p>如果你有记录的习惯，阅读过去的文字就相当于和过去的自己做一个对比，反过来检验一下这段时间自己思维方式的变化，以及为什么有这样的变化。</p>\n<p>多去看别人的文字，同时自己也要多记录多回顾，这种习惯一旦形成威力是巨大的。</p>\n<p>所以，他们在读书的时候，他们读到的不仅仅是文字以及文字所阐述的道理，他们更多注意到的是<strong>作者的思考方式</strong>,作者的思考方式和自己的思考方式的不同，以及，若是作者的思考方式可取的话，自己的思路又该作何调整？这也就是同一本书读完，为什么极少数人却能非常成功——因为他们改良了自己的思考方式，从此可以“像一个科学家一样思考”······</p>\n<p>他们在上学的时候也是如此。大多数人只不过是在为了应付考试而疲于奔命，他们却学会了如何学习。在工作的时候，而不是疲于奔命，学会了如何有效地工作，如何有效地领导，如何有效地创造价值······在于他人交往中，大多数人都是在自说自话的时候，他们却可以成为“有效的聆听者”。</p>\n<p>最近二十年里，认知科学和脑科学长足发展，关于“成功学”的理论基础也有了很多次的升级。大量的研究结果表明，人与人之间的技能差异，证据确凿地来自于“刻意锻炼”(Deliberate Practice)。而一个人能够仰仗的就是元认知能力，反过来，<strong>元认知能力也必然会在刻意锻炼中被不断增强</strong>——现在你能想象人与人之间的差异有多大了么？</p>\n<p>有一种其实很普遍的病症，叫做抑郁症。今天，抑郁症的病因也没有一个清楚合理的完整解释，不过有一点却是达成共识的：元认知能力的提高，可以有效的防止抑郁症的发生。当然，这也是有效的治愈方法。</p>\n<p>元认知的提高在方方面面帮助到自己。</p>\n<p>比如和伴侣吵架，吵架大多数原因是因为沟通不足，不光是时间不足，还有深度的不足。</p>\n<p>除此之外，元认知能力还是你大脑的“食品质检员”。他能帮你筛选出<br>那些真正有质量，能够帮你提升思维能力的养料，如果没有这种能力的把关，就相当于不顾自己的大脑饮食健康，最终没能有一个强健的大脑也是必然的事情。</p>\n<p>那，为什么说“一个人的财富创造能力最终也只与元认知能力有关——其他都是附属因素”呢？原因很简单：</p>\n<p><strong>你的财富创造能力取决于你能给别人创造多少真正的价值。</strong></p>\n<p>你的创造，只有你觉得有价值是，是没有什么意义的。要他人也认为有价值才可以，并且人数越多越好，人数越多，你创造价值就越高。</p>\n<p>再举一例，元认知能力差的人，性生活质量也会很差。因为元认知能力差的人不可能懂得如何照顾对方感受。</p>\n<p>于是，你只能通过不断地加强自己的“元认知能力”，以求自己的思考和思路越来越接近于正确、完整、高效。乃至于有一天，你随随便便创造出来的东西，都是真正有价值的，不仅对自己有价值，对他人也有价值，那时的财富，只不过是“顺手而得”的东西而已。</p>\n<p>这个专栏背后的科学基础只不过是两个特别简单的事实：</p>\n<ul>\n<li>元认知能力是一个人可拥有的最重要的能力。</li>\n<li>元认知能力不仅可以习得，还可以通过刻意训练长期持续的发展。</li>\n</ul>\n<p>其实我们不妨把大脑当做一块肌肉。</p>\n<p>没有人天生就拥有健硕的体格，也没有人天生就有强大的元认知能力，这些都是后天锻炼出来的。</p>\n<p>只要是肌肉都符合“用进废退”的规则。同理，优质的书籍和文章就是我们训练思维的工具。</p>\n<p>而且“健脑”和健身一样，其实是看得见的、实实在在的变化。</p>\n<p>我们每周都在更新观念，而所谓的“更新”，之所以可以成功，就是因为读者的元认知能力被激活，于是，能够意识到自己原来的想法是这样的，意识到这样和那样有什么不同，甚至，在对与错，好与坏，优和更优，差与更差之间反复选择的过程中，不断强化自己的元认知能力······</p>\n<p>还有一样的：</p>\n<p>我们不会着急到“想用一篇文章立刻改变自己”的地步——因为我们与他人不同，我们有足够的耐心。我们是一群决心要生活在未来的人。于是无以伦比的耐心必然来自于一个事实：</p>\n<p>我们知道我们想要改变的，能够改变的不是现在的自己，而是将来的自己。但是，现在要做的不是空想，而是践行。</p>\n<h2 id=\"思考问题\"><a href=\"#思考问题\" class=\"headerlink\" title=\"思考问题\"></a>思考问题</h2><p>1.你觉得你的元认知能力强么？又，在思考哪些领域那些事情的时候，觉得自己更强？</p>\n<p>2.现在你已经知道元认知能力的重要性了，那么你觉得在思考哪些问题的时候，必须刻意运用自己的元认知能力？</p>\n<p>3.如果让你自己想，你能找得出哪些提升元认知能力的方式方法？</p>\n<p>4.你已经意识到了元认知能力的重要，那么你如何才能让你的亲人，挚友也认识到元认知能力的重要？</p>\n<p>5.观察周遭，你觉得谁的元认知能力更强？你能从他身上学到什么？</p>\n<p>6.很多时候，并不是他人不理解你，而是你自己没有想清楚、表达清楚，所以他人无法理解你。能想到一个自身的重要经历是这样的么？从中你应该得到怎样的反思？</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p>元认知能力(metacognition)：awareness and understanding of one’s own thought processes.即对自己思考过程的认知与理解。</p>\n</blockquote>\n<p>认知能力好比是马，而元认知能力是马车。</p>\n<p>回想一下自己的生活，有多少次是马随意地拉着马车跑，而不顾马车夫的指令。这正是元认知能力的不够，导致无法好好控制认知带来的结果。</p>","more":"<p>你的元认知能力被激活，开始发挥作用的过程中，你可能意识到的是：</p>\n<ul>\n<li>啊？之前我想的竟然都是错的</li>\n<li>啊？原来是这样的啊</li>\n<li>道理挺简单的嘛，为什么我之前竟然完全没有想到</li>\n<li>嗯！我知道了，我现在应该这样想才对</li>\n<li>嗯？我怎么又被带回去了呢？明明学过的道理怎么就忘了应用呢？</li>\n<li>唉，知易行难啊！我就不信我搞不定！</li>\n</ul>\n<p>“恍然大悟”的瞬间其实来的并不轻松。</p>\n<p>越是简单的事情越容易被忽略。因为我们总是以为自己已经理解了这些表层的意思，而不再去深挖其中的本质。</p>\n<p>当你有了“这么简单的道理，我怎么才明白”的感觉时，那层貌似简单的窗户纸才被你捅破。</p>\n<p>把复杂的原理用简单的方式讲清楚不容易。让别人意识到简单的东西，其实并没有那么简单则更加不容易。</p>\n<p>元认知能力的强弱，决定一个人每个方面的强弱，甚至不夸张的讲：</p>\n<p><strong>一个人的财富创造能力最终也只与元认知能力有关——其他都是附属因素。</strong></p>\n<p>尽管上面那个思考过程看起来非常简单，可就是这简单的思考，竟然是绝大多数人穷尽一生都没有学会的技能，甚至都没有想过应该习得、锻炼这种技能。</p>\n<p>从这个角度望去，古来教育在这个最重要的能力上贡献几近于零。又，竟然还是在它原本如此简单的情况下。</p>\n<p>“学习学习再学习”，意思是先要掌握学习的方法，再用合理的方法去学习。</p>\n<p>而我们教育中缺少的重要一环，就是把学生们的“元认知能力”培养起来。让大家知道，自己是大脑的主人，而不是反过来被大脑控制。<br>（确实自身存在很多次被大脑控制的场景，尤其是忍不住想去打游戏，想放松自己的时候。）</p>\n<p>大多数人没有想明白的道理是：</p>\n<p>我们大脑可以有多个层次。</p>\n<p>持续升级自己的大脑，不断地站在更高的层级去控制下面的大脑，这才是我们作为人类进化最有效的手段。</p>\n<p>那么多人之所以容易受情绪干扰，脑子不清晰，其实是因为总是站在最底层与大脑纠缠，而从来没有想过自己能够有机会站在更高的层次去控制它。</p>\n<p>一个格外举足轻重的例子就是：“情商”。那些被认为“情商差”的人，本质上来看，其实就是无法正确理解别人的感受，这其实就是来源于元认知能力的欠缺。</p>\n<p><strong>一个连对自己的感受都不能完整正确的认知的人，怎么可能完整正确地理解他人的感受呢？</strong></p>\n<p>所谓的“将心比心”，的确是绝大多数人做不到的事情——因为大多数人其实并不了解自己的思考过程、思考原理、思考方式；更是因为大多数人从未认真审视过自己思考结果是否正确合理。</p>\n<p>所谓的情商和智商只是一些外在表现形式，而一个人能否在这些方面获得高分，则取决于他们是否对这些概念有本质的理解。</p>\n<p>看到智商高的人，总觉得人家天生聪明，可以轻松解开复杂的数学题目。而不会觉得，对方其实是知道了数字背后更深层次的原理。</p>\n<p>看到情商高的人，就会羡慕对方的社交能力，但真正本质的是对方能够洞察每个人内心的需求。</p>\n<p>元认知能力之所以重要，是因为它不光能帮你了解自己，同时还会让你更加了解别人。</p>\n<p>在《把时间当作朋友》中的副标题中提到的”心智”，指的就是具备足够元认知能力的大脑。</p>\n<ul>\n<li>时间总是在过后才显得飞快。。</li>\n<li>真的是这样呢，为什么会有这种感觉呢？</li>\n<li>若是这种感觉是真实的，那我为什么竟然忽略了这个事实？究竟错过了什么？</li>\n<li>我还需要纠正什么？</li>\n</ul>\n<p>元认知能力强的人，在阅读的时候，时时刻刻注意到自己的思考和思路，时时刻刻都在对自己的思考和思路进行“反思”、“校验”、“修订”，当然最重要的是：“升级”。</p>\n<p>每一个人的文字就是每个人的想法。</p>\n<p>你在读别人文字的时候，就是在那对方的思维方式和自己作对比。这其实也是一种锻炼元认知的过程。</p>\n<p>如果你有记录的习惯，阅读过去的文字就相当于和过去的自己做一个对比，反过来检验一下这段时间自己思维方式的变化，以及为什么有这样的变化。</p>\n<p>多去看别人的文字，同时自己也要多记录多回顾，这种习惯一旦形成威力是巨大的。</p>\n<p>所以，他们在读书的时候，他们读到的不仅仅是文字以及文字所阐述的道理，他们更多注意到的是<strong>作者的思考方式</strong>,作者的思考方式和自己的思考方式的不同，以及，若是作者的思考方式可取的话，自己的思路又该作何调整？这也就是同一本书读完，为什么极少数人却能非常成功——因为他们改良了自己的思考方式，从此可以“像一个科学家一样思考”······</p>\n<p>他们在上学的时候也是如此。大多数人只不过是在为了应付考试而疲于奔命，他们却学会了如何学习。在工作的时候，而不是疲于奔命，学会了如何有效地工作，如何有效地领导，如何有效地创造价值······在于他人交往中，大多数人都是在自说自话的时候，他们却可以成为“有效的聆听者”。</p>\n<p>最近二十年里，认知科学和脑科学长足发展，关于“成功学”的理论基础也有了很多次的升级。大量的研究结果表明，人与人之间的技能差异，证据确凿地来自于“刻意锻炼”(Deliberate Practice)。而一个人能够仰仗的就是元认知能力，反过来，<strong>元认知能力也必然会在刻意锻炼中被不断增强</strong>——现在你能想象人与人之间的差异有多大了么？</p>\n<p>有一种其实很普遍的病症，叫做抑郁症。今天，抑郁症的病因也没有一个清楚合理的完整解释，不过有一点却是达成共识的：元认知能力的提高，可以有效的防止抑郁症的发生。当然，这也是有效的治愈方法。</p>\n<p>元认知的提高在方方面面帮助到自己。</p>\n<p>比如和伴侣吵架，吵架大多数原因是因为沟通不足，不光是时间不足，还有深度的不足。</p>\n<p>除此之外，元认知能力还是你大脑的“食品质检员”。他能帮你筛选出<br>那些真正有质量，能够帮你提升思维能力的养料，如果没有这种能力的把关，就相当于不顾自己的大脑饮食健康，最终没能有一个强健的大脑也是必然的事情。</p>\n<p>那，为什么说“一个人的财富创造能力最终也只与元认知能力有关——其他都是附属因素”呢？原因很简单：</p>\n<p><strong>你的财富创造能力取决于你能给别人创造多少真正的价值。</strong></p>\n<p>你的创造，只有你觉得有价值是，是没有什么意义的。要他人也认为有价值才可以，并且人数越多越好，人数越多，你创造价值就越高。</p>\n<p>再举一例，元认知能力差的人，性生活质量也会很差。因为元认知能力差的人不可能懂得如何照顾对方感受。</p>\n<p>于是，你只能通过不断地加强自己的“元认知能力”，以求自己的思考和思路越来越接近于正确、完整、高效。乃至于有一天，你随随便便创造出来的东西，都是真正有价值的，不仅对自己有价值，对他人也有价值，那时的财富，只不过是“顺手而得”的东西而已。</p>\n<p>这个专栏背后的科学基础只不过是两个特别简单的事实：</p>\n<ul>\n<li>元认知能力是一个人可拥有的最重要的能力。</li>\n<li>元认知能力不仅可以习得，还可以通过刻意训练长期持续的发展。</li>\n</ul>\n<p>其实我们不妨把大脑当做一块肌肉。</p>\n<p>没有人天生就拥有健硕的体格，也没有人天生就有强大的元认知能力，这些都是后天锻炼出来的。</p>\n<p>只要是肌肉都符合“用进废退”的规则。同理，优质的书籍和文章就是我们训练思维的工具。</p>\n<p>而且“健脑”和健身一样，其实是看得见的、实实在在的变化。</p>\n<p>我们每周都在更新观念，而所谓的“更新”，之所以可以成功，就是因为读者的元认知能力被激活，于是，能够意识到自己原来的想法是这样的，意识到这样和那样有什么不同，甚至，在对与错，好与坏，优和更优，差与更差之间反复选择的过程中，不断强化自己的元认知能力······</p>\n<p>还有一样的：</p>\n<p>我们不会着急到“想用一篇文章立刻改变自己”的地步——因为我们与他人不同，我们有足够的耐心。我们是一群决心要生活在未来的人。于是无以伦比的耐心必然来自于一个事实：</p>\n<p>我们知道我们想要改变的，能够改变的不是现在的自己，而是将来的自己。但是，现在要做的不是空想，而是践行。</p>\n<h2 id=\"思考问题\"><a href=\"#思考问题\" class=\"headerlink\" title=\"思考问题\"></a>思考问题</h2><p>1.你觉得你的元认知能力强么？又，在思考哪些领域那些事情的时候，觉得自己更强？</p>\n<p>2.现在你已经知道元认知能力的重要性了，那么你觉得在思考哪些问题的时候，必须刻意运用自己的元认知能力？</p>\n<p>3.如果让你自己想，你能找得出哪些提升元认知能力的方式方法？</p>\n<p>4.你已经意识到了元认知能力的重要，那么你如何才能让你的亲人，挚友也认识到元认知能力的重要？</p>\n<p>5.观察周遭，你觉得谁的元认知能力更强？你能从他身上学到什么？</p>\n<p>6.很多时候，并不是他人不理解你，而是你自己没有想清楚、表达清楚，所以他人无法理解你。能想到一个自身的重要经历是这样的么？从中你应该得到怎样的反思？</p>"},{"title":"通向自由之路(8)所谓“坚持”","date":"2016-11-11T13:15:50.000Z","_content":"\n如果一件事儿你觉得需要努力、需要坚持才行，那这件事儿基本上从一开始就注定做不成了。\n\n<!-- more -->\n在钥匙篇中有提到说，钥匙在别处，我们可能就会知道，问题可能不在自己没有毅力，而是这个词压根不应该出现在你的操作系统里。一个脑子里满是“坚持”和“毅力”的人，恐怕永远都在纠结如何摆脱痛苦，而不会想着转变个角度，这件事或许就变成了快乐的事。\n\n这些都是我们从底层给自己挖的坑，光做一些表面功夫不足以解决这些问题。需要努力，需要坚持，说明你一开始“骨子里”就不愿意做。\n\n“骨子里”，并不是一个完全比喻的说法，我们的底层反应来自于内脑和脊髓连接处，也就是说那还真的是“大脑深处”(相对来看，“内心深处”就是一个相当落后的概念)。你骨子里不愿意做的事情，是不可能做好的，不可能做成的。不信你试试？反正这辈子都放弃那么多回了，再多一次无所谓的。\n\n我们的大脑都有遗忘痛苦的功能。早些日子做的胃镜，真的难受得要死，可是现在已经想不起那种难受和无力感了。而且随着时间月久远，记忆越模糊。\n时间和痛苦的程度都会决定我们的遗忘功能，这也是大脑为了保护我们所进化出的功能吧。\n\n现在你知道为什么自己做不好事情了吧？\n不论是学习一个知识，还是打磨一个技能，本质上都是要在你的脑子里留下“痕迹”。但是你开始的时候，就给它赋予了太多痛苦和坚持，大脑自然会想方设法帮你抹掉这部分记忆。\n\n**所以想要不放弃，首先就不要给自己“痛苦”的暗示。**\n\n\n所以，我磨练出了一个道理：\n\n**无论做什么事情，在开始之前，都要想尽一切办法为这个事情赋予重大的意义，甚至多重重大的意义。**\n\n喜欢读书的人，多半不是在坚持，对他们来说，读书是一种享受；喜欢运动的人，运动所产生的多巴胺，足以让他们享受这项运动。真的是这样，无论是跑步，还是打球，一边挥洒汗水，莫名的身体里从乏力又横生出一股力道来，脑子也变得清醒。\n\n学会、学好一门技能带来的则是重生的快感。和之前所说的多维相联系，你的世界就多了一个维度，你看到了过去不曾有的景象，你甚至会觉得自己又活了一遍。这种快感一旦体会过一次，没有人会停下来，别人想拦都拦不住。没有体会过这种快感的人，总是没办法想象为何对方可以坚持下去。\n\n这种做法就好比把背单词想作是赚钱，一个单词就相当于50块，这不就是等于捡钱么？一天就赚上他个5000元！对于你来说可能就不是，或许能够考入梦寐以求的大学才是足以激励你的目标。每前进一步，都让自己有“切实”的体会到成长的快感，即便这只是你设计出来的，也比你苦哈哈得想着要坚持强很多。所以你看，人和人之间的差异，往往只不过是一念之差，可实际上的价值差异，却是整个世界的差异。同样的事情，不同的人能给他赋予的意义是不同的，同一个人在不同阶段能够赋予的意义也是不同的。**重要的不是把关注点放在其他地方，而是要找到当下对自己最重要的意义，并把他平摊到每天的任务上。**这样才有可能让自己不停地去做这件事。\n\n一念一世界，这是很实在的道理。每周升级一个观念，就相当于每周穿越到了下一个“平行世界”，真的很爽，觉得自己在迭代，在更新，爽到停不下来。所以这样子，还需要坚持么？还需要努力么？你还觉得这两个概念有意义么？它们完全没用。\n\n成为别人家的孩子，其他人需要坚持、需要努力才行的事情，在你这个“别人家的孩子”的世界里，是“干脆停不下来的事”，是“谁不让我做我跟谁急的事儿”，这也就解释了为什么有些孩子会很主动积极地去做作业也好，练琴也罢，甚至时间被其他不重要的事情拖晚了都要自己吵着嚷着回家完成，也许其中有一部分原因就是自己有意识的主动想去做了，而并不是靠坚持，更不是装出来的，是真的在学习的时候，停不下来。当然时间也是其中一个要素之一。\n\n除了上面提到的“为它赋予很多意义”之外，还有很多其它的方法和技巧。\n\n当你决定习得某项技能的时候，在你已经想办法赋予它很多正面意义之后，还可以想尽一切办法为“没有它的存在”赋予很多负面意义。拿出一张纸去罗列，甚至可以罗列出很多：\n\n* 如果没有这项技能，那现在有什么事情我根本做不了？根本没有机会？\n\n* 进而，在将来会遇到什么样的困难？会失去什么样的机会？\n\n* 如果我最终竟然没有掌握这项技能，我就跟哪些人是一样的？他们生活究竟因此而有多么糟糕？\n\n不仅要罗列，还要展开想象，尽可能的把细节想象出来——相信我，这会吓到你的大脑（准确的说，是把那种你所需要的恐惧深深埋入你的潜意识），然后他就会在很多的时候自动工作了，催促你赶紧弄，否则它就会焦虑，他就会害怕......\n\n另一个尤为重要的技巧就是：\n\n想尽一切办法去寻找拥有这项技能的人以及人群，尽量与他们共度大量的时间；如果没办法一对一交流，起码也要时刻关注他们......\n\n**社交，从来就是学习的一部分。**\n\n如果你的朋友都是胖子，那么很可能发生的就是，你会慢慢被传染成“胖子”。首先，他们会影响你对胖子这个概念的影响；其次，会从日常饮食中无意识地保持一致。\n也就是所谓的近朱者赤，近墨者黑，深刻。\n\n这些判断上回极大地影响你的行为，你的感受，于是，很多在另外一个世界里“很艰难”、“很痛苦”、“很难坚持”的事情，在你的世界里都变成了“真好玩”，“停不下来”，“要是能多玩一会就好了”的事情......\n\n就算是仅仅相互见得到，相互知道对方的存在，对于学习者，追求进步者来说，都是巨大的价值。\n\n这也就是“镜像神经元”的作用，通俗的例子，就是别人打针你看着疼。这就让我想到了一句话：\n\n想象一下，在你的脚的大拇指的指甲和肉之间放一根针，用力地向墙踢去。\n\n嘶...好疼...脚下意识的回缩。仅仅是看描述的一句话就“真实”的疼的厉害了，这就是源于我们大脑神经元中的一部分“镜像神经元”所起的作用。猴子和鸟类的大脑里貌似也有。这些神经元会在我们看到别人行动的时候触发，这些神经元会“镜像”被观察者的行为，就好像自己在同样的行为似的。\n\n这就解释了为什么你看到别人打针自己会痛的原因。\n\n镜像神经元在推测对方行动意图的时候、理解对方行动目标的时候，总是被激烈地触发。反过来可能的猜测就是，那些总是无法猜测别人意图的人，无法理解别人行动目标的人，即，我们日常生活中经常说的“情商太差”的人，很可能就是镜像神经元数量太少了的结果。\n\n镜像神经元显然在学习能力方面也有着很大的作用。因为学习行为里的大部分就是模仿，普遍来看，模仿力强的人学习能力貌似同样也强。我们经常听到的一个概念：“夫妻相”，其实他们并不是一开始长得像（不排除长得像的人惺惺相惜），是长年累月的在一起，大脑里的镜像神经元不断地被激发，最红结果是表情很像......表情很像的人，脸部肌肉纹理会渐渐趋同，表现为夫妻相。所以，大多数的幸福夫妻常常是“相互学习”的一对。而在相互学习中，镜像神经元的数量和比例都在提高（这个结论很惊人）。\n\n自闭症也许就是镜像神经元数量过少导致的。研究中也指出，貌似在男女在镜像神经元比例上都存在着差异。有一项研究表明，由单亲母亲培养的孩子能够更容易的识别他人情绪的变化。\n这项研究结果实际上给我们带来了很多猜想，因为那些差异很可能是习得的，而不一定是天生的。所以：\n\n**镜像神经元的数量和比例很可能是可以通过某些方式提高的。**\n\n这也辅助证明了近二十年脑科学研究的一个定论：“大脑是可塑的。”\n\n稍微有点扯远了，这也就解释了为什么社交也是学习的一部分的原因所在。这次更新之后，是不是可以把之前的“努力”、“坚持”这些概念都废除了呢？\n\n\n## 总结\n\n无论做什么事情，单靠坚持这件事就是注定做不好的，要明白三个方面，一，在做之前明白自己做的目的和深远的影响；二，让自己去影响自己的潜意识；三、增加自己的有用社交，从而进一步相互学习更新大脑，真正有驱动力去完成每一件事。\n\n\n\n## 互动\n1.你有没有什么事情是自己做起来兴致盎然，别人却常常感叹自己学不会、坚持不下来的？\n2.你最近在“坚持”什么事情？马上开始试试？\n3.你现在知道为什么要尽量远离那些“负能量”的人了么？他们对你的影响可能比你能感受到的、能想象出来的大，且大出很多很多倍——因为那影响是“骨子里”的，深入你的潜意识的......于是，很多时候，你甚至会在被影响之后都不知道已经被深深地影响了，你说可怕不可怕？你有这样的经历么？评论下来看看？\n\n\n","source":"_posts/通向自由之路/通向自由之路(8)所谓“坚持”.md","raw":"---\ntitle: 通向自由之路(8)所谓“坚持”\ndate: 2016-11-11 21:15:50\ntags: \n- 通向自由之路\ncategories: 反思\n---\n\n如果一件事儿你觉得需要努力、需要坚持才行，那这件事儿基本上从一开始就注定做不成了。\n\n<!-- more -->\n在钥匙篇中有提到说，钥匙在别处，我们可能就会知道，问题可能不在自己没有毅力，而是这个词压根不应该出现在你的操作系统里。一个脑子里满是“坚持”和“毅力”的人，恐怕永远都在纠结如何摆脱痛苦，而不会想着转变个角度，这件事或许就变成了快乐的事。\n\n这些都是我们从底层给自己挖的坑，光做一些表面功夫不足以解决这些问题。需要努力，需要坚持，说明你一开始“骨子里”就不愿意做。\n\n“骨子里”，并不是一个完全比喻的说法，我们的底层反应来自于内脑和脊髓连接处，也就是说那还真的是“大脑深处”(相对来看，“内心深处”就是一个相当落后的概念)。你骨子里不愿意做的事情，是不可能做好的，不可能做成的。不信你试试？反正这辈子都放弃那么多回了，再多一次无所谓的。\n\n我们的大脑都有遗忘痛苦的功能。早些日子做的胃镜，真的难受得要死，可是现在已经想不起那种难受和无力感了。而且随着时间月久远，记忆越模糊。\n时间和痛苦的程度都会决定我们的遗忘功能，这也是大脑为了保护我们所进化出的功能吧。\n\n现在你知道为什么自己做不好事情了吧？\n不论是学习一个知识，还是打磨一个技能，本质上都是要在你的脑子里留下“痕迹”。但是你开始的时候，就给它赋予了太多痛苦和坚持，大脑自然会想方设法帮你抹掉这部分记忆。\n\n**所以想要不放弃，首先就不要给自己“痛苦”的暗示。**\n\n\n所以，我磨练出了一个道理：\n\n**无论做什么事情，在开始之前，都要想尽一切办法为这个事情赋予重大的意义，甚至多重重大的意义。**\n\n喜欢读书的人，多半不是在坚持，对他们来说，读书是一种享受；喜欢运动的人，运动所产生的多巴胺，足以让他们享受这项运动。真的是这样，无论是跑步，还是打球，一边挥洒汗水，莫名的身体里从乏力又横生出一股力道来，脑子也变得清醒。\n\n学会、学好一门技能带来的则是重生的快感。和之前所说的多维相联系，你的世界就多了一个维度，你看到了过去不曾有的景象，你甚至会觉得自己又活了一遍。这种快感一旦体会过一次，没有人会停下来，别人想拦都拦不住。没有体会过这种快感的人，总是没办法想象为何对方可以坚持下去。\n\n这种做法就好比把背单词想作是赚钱，一个单词就相当于50块，这不就是等于捡钱么？一天就赚上他个5000元！对于你来说可能就不是，或许能够考入梦寐以求的大学才是足以激励你的目标。每前进一步，都让自己有“切实”的体会到成长的快感，即便这只是你设计出来的，也比你苦哈哈得想着要坚持强很多。所以你看，人和人之间的差异，往往只不过是一念之差，可实际上的价值差异，却是整个世界的差异。同样的事情，不同的人能给他赋予的意义是不同的，同一个人在不同阶段能够赋予的意义也是不同的。**重要的不是把关注点放在其他地方，而是要找到当下对自己最重要的意义，并把他平摊到每天的任务上。**这样才有可能让自己不停地去做这件事。\n\n一念一世界，这是很实在的道理。每周升级一个观念，就相当于每周穿越到了下一个“平行世界”，真的很爽，觉得自己在迭代，在更新，爽到停不下来。所以这样子，还需要坚持么？还需要努力么？你还觉得这两个概念有意义么？它们完全没用。\n\n成为别人家的孩子，其他人需要坚持、需要努力才行的事情，在你这个“别人家的孩子”的世界里，是“干脆停不下来的事”，是“谁不让我做我跟谁急的事儿”，这也就解释了为什么有些孩子会很主动积极地去做作业也好，练琴也罢，甚至时间被其他不重要的事情拖晚了都要自己吵着嚷着回家完成，也许其中有一部分原因就是自己有意识的主动想去做了，而并不是靠坚持，更不是装出来的，是真的在学习的时候，停不下来。当然时间也是其中一个要素之一。\n\n除了上面提到的“为它赋予很多意义”之外，还有很多其它的方法和技巧。\n\n当你决定习得某项技能的时候，在你已经想办法赋予它很多正面意义之后，还可以想尽一切办法为“没有它的存在”赋予很多负面意义。拿出一张纸去罗列，甚至可以罗列出很多：\n\n* 如果没有这项技能，那现在有什么事情我根本做不了？根本没有机会？\n\n* 进而，在将来会遇到什么样的困难？会失去什么样的机会？\n\n* 如果我最终竟然没有掌握这项技能，我就跟哪些人是一样的？他们生活究竟因此而有多么糟糕？\n\n不仅要罗列，还要展开想象，尽可能的把细节想象出来——相信我，这会吓到你的大脑（准确的说，是把那种你所需要的恐惧深深埋入你的潜意识），然后他就会在很多的时候自动工作了，催促你赶紧弄，否则它就会焦虑，他就会害怕......\n\n另一个尤为重要的技巧就是：\n\n想尽一切办法去寻找拥有这项技能的人以及人群，尽量与他们共度大量的时间；如果没办法一对一交流，起码也要时刻关注他们......\n\n**社交，从来就是学习的一部分。**\n\n如果你的朋友都是胖子，那么很可能发生的就是，你会慢慢被传染成“胖子”。首先，他们会影响你对胖子这个概念的影响；其次，会从日常饮食中无意识地保持一致。\n也就是所谓的近朱者赤，近墨者黑，深刻。\n\n这些判断上回极大地影响你的行为，你的感受，于是，很多在另外一个世界里“很艰难”、“很痛苦”、“很难坚持”的事情，在你的世界里都变成了“真好玩”，“停不下来”，“要是能多玩一会就好了”的事情......\n\n就算是仅仅相互见得到，相互知道对方的存在，对于学习者，追求进步者来说，都是巨大的价值。\n\n这也就是“镜像神经元”的作用，通俗的例子，就是别人打针你看着疼。这就让我想到了一句话：\n\n想象一下，在你的脚的大拇指的指甲和肉之间放一根针，用力地向墙踢去。\n\n嘶...好疼...脚下意识的回缩。仅仅是看描述的一句话就“真实”的疼的厉害了，这就是源于我们大脑神经元中的一部分“镜像神经元”所起的作用。猴子和鸟类的大脑里貌似也有。这些神经元会在我们看到别人行动的时候触发，这些神经元会“镜像”被观察者的行为，就好像自己在同样的行为似的。\n\n这就解释了为什么你看到别人打针自己会痛的原因。\n\n镜像神经元在推测对方行动意图的时候、理解对方行动目标的时候，总是被激烈地触发。反过来可能的猜测就是，那些总是无法猜测别人意图的人，无法理解别人行动目标的人，即，我们日常生活中经常说的“情商太差”的人，很可能就是镜像神经元数量太少了的结果。\n\n镜像神经元显然在学习能力方面也有着很大的作用。因为学习行为里的大部分就是模仿，普遍来看，模仿力强的人学习能力貌似同样也强。我们经常听到的一个概念：“夫妻相”，其实他们并不是一开始长得像（不排除长得像的人惺惺相惜），是长年累月的在一起，大脑里的镜像神经元不断地被激发，最红结果是表情很像......表情很像的人，脸部肌肉纹理会渐渐趋同，表现为夫妻相。所以，大多数的幸福夫妻常常是“相互学习”的一对。而在相互学习中，镜像神经元的数量和比例都在提高（这个结论很惊人）。\n\n自闭症也许就是镜像神经元数量过少导致的。研究中也指出，貌似在男女在镜像神经元比例上都存在着差异。有一项研究表明，由单亲母亲培养的孩子能够更容易的识别他人情绪的变化。\n这项研究结果实际上给我们带来了很多猜想，因为那些差异很可能是习得的，而不一定是天生的。所以：\n\n**镜像神经元的数量和比例很可能是可以通过某些方式提高的。**\n\n这也辅助证明了近二十年脑科学研究的一个定论：“大脑是可塑的。”\n\n稍微有点扯远了，这也就解释了为什么社交也是学习的一部分的原因所在。这次更新之后，是不是可以把之前的“努力”、“坚持”这些概念都废除了呢？\n\n\n## 总结\n\n无论做什么事情，单靠坚持这件事就是注定做不好的，要明白三个方面，一，在做之前明白自己做的目的和深远的影响；二，让自己去影响自己的潜意识；三、增加自己的有用社交，从而进一步相互学习更新大脑，真正有驱动力去完成每一件事。\n\n\n\n## 互动\n1.你有没有什么事情是自己做起来兴致盎然，别人却常常感叹自己学不会、坚持不下来的？\n2.你最近在“坚持”什么事情？马上开始试试？\n3.你现在知道为什么要尽量远离那些“负能量”的人了么？他们对你的影响可能比你能感受到的、能想象出来的大，且大出很多很多倍——因为那影响是“骨子里”的，深入你的潜意识的......于是，很多时候，你甚至会在被影响之后都不知道已经被深深地影响了，你说可怕不可怕？你有这样的经历么？评论下来看看？\n\n\n","slug":"通向自由之路/通向自由之路(8)所谓“坚持”","published":1,"updated":"2019-03-22T14:44:36.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn1100as4l3nm3n2lkpq","content":"<p>如果一件事儿你觉得需要努力、需要坚持才行，那这件事儿基本上从一开始就注定做不成了。</p>\n<a id=\"more\"></a>\n<p>在钥匙篇中有提到说，钥匙在别处，我们可能就会知道，问题可能不在自己没有毅力，而是这个词压根不应该出现在你的操作系统里。一个脑子里满是“坚持”和“毅力”的人，恐怕永远都在纠结如何摆脱痛苦，而不会想着转变个角度，这件事或许就变成了快乐的事。</p>\n<p>这些都是我们从底层给自己挖的坑，光做一些表面功夫不足以解决这些问题。需要努力，需要坚持，说明你一开始“骨子里”就不愿意做。</p>\n<p>“骨子里”，并不是一个完全比喻的说法，我们的底层反应来自于内脑和脊髓连接处，也就是说那还真的是“大脑深处”(相对来看，“内心深处”就是一个相当落后的概念)。你骨子里不愿意做的事情，是不可能做好的，不可能做成的。不信你试试？反正这辈子都放弃那么多回了，再多一次无所谓的。</p>\n<p>我们的大脑都有遗忘痛苦的功能。早些日子做的胃镜，真的难受得要死，可是现在已经想不起那种难受和无力感了。而且随着时间月久远，记忆越模糊。<br>时间和痛苦的程度都会决定我们的遗忘功能，这也是大脑为了保护我们所进化出的功能吧。</p>\n<p>现在你知道为什么自己做不好事情了吧？<br>不论是学习一个知识，还是打磨一个技能，本质上都是要在你的脑子里留下“痕迹”。但是你开始的时候，就给它赋予了太多痛苦和坚持，大脑自然会想方设法帮你抹掉这部分记忆。</p>\n<p><strong>所以想要不放弃，首先就不要给自己“痛苦”的暗示。</strong></p>\n<p>所以，我磨练出了一个道理：</p>\n<p><strong>无论做什么事情，在开始之前，都要想尽一切办法为这个事情赋予重大的意义，甚至多重重大的意义。</strong></p>\n<p>喜欢读书的人，多半不是在坚持，对他们来说，读书是一种享受；喜欢运动的人，运动所产生的多巴胺，足以让他们享受这项运动。真的是这样，无论是跑步，还是打球，一边挥洒汗水，莫名的身体里从乏力又横生出一股力道来，脑子也变得清醒。</p>\n<p>学会、学好一门技能带来的则是重生的快感。和之前所说的多维相联系，你的世界就多了一个维度，你看到了过去不曾有的景象，你甚至会觉得自己又活了一遍。这种快感一旦体会过一次，没有人会停下来，别人想拦都拦不住。没有体会过这种快感的人，总是没办法想象为何对方可以坚持下去。</p>\n<p>这种做法就好比把背单词想作是赚钱，一个单词就相当于50块，这不就是等于捡钱么？一天就赚上他个5000元！对于你来说可能就不是，或许能够考入梦寐以求的大学才是足以激励你的目标。每前进一步，都让自己有“切实”的体会到成长的快感，即便这只是你设计出来的，也比你苦哈哈得想着要坚持强很多。所以你看，人和人之间的差异，往往只不过是一念之差，可实际上的价值差异，却是整个世界的差异。同样的事情，不同的人能给他赋予的意义是不同的，同一个人在不同阶段能够赋予的意义也是不同的。<strong>重要的不是把关注点放在其他地方，而是要找到当下对自己最重要的意义，并把他平摊到每天的任务上。</strong>这样才有可能让自己不停地去做这件事。</p>\n<p>一念一世界，这是很实在的道理。每周升级一个观念，就相当于每周穿越到了下一个“平行世界”，真的很爽，觉得自己在迭代，在更新，爽到停不下来。所以这样子，还需要坚持么？还需要努力么？你还觉得这两个概念有意义么？它们完全没用。</p>\n<p>成为别人家的孩子，其他人需要坚持、需要努力才行的事情，在你这个“别人家的孩子”的世界里，是“干脆停不下来的事”，是“谁不让我做我跟谁急的事儿”，这也就解释了为什么有些孩子会很主动积极地去做作业也好，练琴也罢，甚至时间被其他不重要的事情拖晚了都要自己吵着嚷着回家完成，也许其中有一部分原因就是自己有意识的主动想去做了，而并不是靠坚持，更不是装出来的，是真的在学习的时候，停不下来。当然时间也是其中一个要素之一。</p>\n<p>除了上面提到的“为它赋予很多意义”之外，还有很多其它的方法和技巧。</p>\n<p>当你决定习得某项技能的时候，在你已经想办法赋予它很多正面意义之后，还可以想尽一切办法为“没有它的存在”赋予很多负面意义。拿出一张纸去罗列，甚至可以罗列出很多：</p>\n<ul>\n<li><p>如果没有这项技能，那现在有什么事情我根本做不了？根本没有机会？</p>\n</li>\n<li><p>进而，在将来会遇到什么样的困难？会失去什么样的机会？</p>\n</li>\n<li><p>如果我最终竟然没有掌握这项技能，我就跟哪些人是一样的？他们生活究竟因此而有多么糟糕？</p>\n</li>\n</ul>\n<p>不仅要罗列，还要展开想象，尽可能的把细节想象出来——相信我，这会吓到你的大脑（准确的说，是把那种你所需要的恐惧深深埋入你的潜意识），然后他就会在很多的时候自动工作了，催促你赶紧弄，否则它就会焦虑，他就会害怕……</p>\n<p>另一个尤为重要的技巧就是：</p>\n<p>想尽一切办法去寻找拥有这项技能的人以及人群，尽量与他们共度大量的时间；如果没办法一对一交流，起码也要时刻关注他们……</p>\n<p><strong>社交，从来就是学习的一部分。</strong></p>\n<p>如果你的朋友都是胖子，那么很可能发生的就是，你会慢慢被传染成“胖子”。首先，他们会影响你对胖子这个概念的影响；其次，会从日常饮食中无意识地保持一致。<br>也就是所谓的近朱者赤，近墨者黑，深刻。</p>\n<p>这些判断上回极大地影响你的行为，你的感受，于是，很多在另外一个世界里“很艰难”、“很痛苦”、“很难坚持”的事情，在你的世界里都变成了“真好玩”，“停不下来”，“要是能多玩一会就好了”的事情……</p>\n<p>就算是仅仅相互见得到，相互知道对方的存在，对于学习者，追求进步者来说，都是巨大的价值。</p>\n<p>这也就是“镜像神经元”的作用，通俗的例子，就是别人打针你看着疼。这就让我想到了一句话：</p>\n<p>想象一下，在你的脚的大拇指的指甲和肉之间放一根针，用力地向墙踢去。</p>\n<p>嘶…好疼…脚下意识的回缩。仅仅是看描述的一句话就“真实”的疼的厉害了，这就是源于我们大脑神经元中的一部分“镜像神经元”所起的作用。猴子和鸟类的大脑里貌似也有。这些神经元会在我们看到别人行动的时候触发，这些神经元会“镜像”被观察者的行为，就好像自己在同样的行为似的。</p>\n<p>这就解释了为什么你看到别人打针自己会痛的原因。</p>\n<p>镜像神经元在推测对方行动意图的时候、理解对方行动目标的时候，总是被激烈地触发。反过来可能的猜测就是，那些总是无法猜测别人意图的人，无法理解别人行动目标的人，即，我们日常生活中经常说的“情商太差”的人，很可能就是镜像神经元数量太少了的结果。</p>\n<p>镜像神经元显然在学习能力方面也有着很大的作用。因为学习行为里的大部分就是模仿，普遍来看，模仿力强的人学习能力貌似同样也强。我们经常听到的一个概念：“夫妻相”，其实他们并不是一开始长得像（不排除长得像的人惺惺相惜），是长年累月的在一起，大脑里的镜像神经元不断地被激发，最红结果是表情很像……表情很像的人，脸部肌肉纹理会渐渐趋同，表现为夫妻相。所以，大多数的幸福夫妻常常是“相互学习”的一对。而在相互学习中，镜像神经元的数量和比例都在提高（这个结论很惊人）。</p>\n<p>自闭症也许就是镜像神经元数量过少导致的。研究中也指出，貌似在男女在镜像神经元比例上都存在着差异。有一项研究表明，由单亲母亲培养的孩子能够更容易的识别他人情绪的变化。<br>这项研究结果实际上给我们带来了很多猜想，因为那些差异很可能是习得的，而不一定是天生的。所以：</p>\n<p><strong>镜像神经元的数量和比例很可能是可以通过某些方式提高的。</strong></p>\n<p>这也辅助证明了近二十年脑科学研究的一个定论：“大脑是可塑的。”</p>\n<p>稍微有点扯远了，这也就解释了为什么社交也是学习的一部分的原因所在。这次更新之后，是不是可以把之前的“努力”、“坚持”这些概念都废除了呢？</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>无论做什么事情，单靠坚持这件事就是注定做不好的，要明白三个方面，一，在做之前明白自己做的目的和深远的影响；二，让自己去影响自己的潜意识；三、增加自己的有用社交，从而进一步相互学习更新大脑，真正有驱动力去完成每一件事。</p>\n<h2 id=\"互动\"><a href=\"#互动\" class=\"headerlink\" title=\"互动\"></a>互动</h2><p>1.你有没有什么事情是自己做起来兴致盎然，别人却常常感叹自己学不会、坚持不下来的？<br>2.你最近在“坚持”什么事情？马上开始试试？<br>3.你现在知道为什么要尽量远离那些“负能量”的人了么？他们对你的影响可能比你能感受到的、能想象出来的大，且大出很多很多倍——因为那影响是“骨子里”的，深入你的潜意识的……于是，很多时候，你甚至会在被影响之后都不知道已经被深深地影响了，你说可怕不可怕？你有这样的经历么？评论下来看看？</p>\n","site":{"data":{}},"excerpt":"<p>如果一件事儿你觉得需要努力、需要坚持才行，那这件事儿基本上从一开始就注定做不成了。</p>","more":"<p>在钥匙篇中有提到说，钥匙在别处，我们可能就会知道，问题可能不在自己没有毅力，而是这个词压根不应该出现在你的操作系统里。一个脑子里满是“坚持”和“毅力”的人，恐怕永远都在纠结如何摆脱痛苦，而不会想着转变个角度，这件事或许就变成了快乐的事。</p>\n<p>这些都是我们从底层给自己挖的坑，光做一些表面功夫不足以解决这些问题。需要努力，需要坚持，说明你一开始“骨子里”就不愿意做。</p>\n<p>“骨子里”，并不是一个完全比喻的说法，我们的底层反应来自于内脑和脊髓连接处，也就是说那还真的是“大脑深处”(相对来看，“内心深处”就是一个相当落后的概念)。你骨子里不愿意做的事情，是不可能做好的，不可能做成的。不信你试试？反正这辈子都放弃那么多回了，再多一次无所谓的。</p>\n<p>我们的大脑都有遗忘痛苦的功能。早些日子做的胃镜，真的难受得要死，可是现在已经想不起那种难受和无力感了。而且随着时间月久远，记忆越模糊。<br>时间和痛苦的程度都会决定我们的遗忘功能，这也是大脑为了保护我们所进化出的功能吧。</p>\n<p>现在你知道为什么自己做不好事情了吧？<br>不论是学习一个知识，还是打磨一个技能，本质上都是要在你的脑子里留下“痕迹”。但是你开始的时候，就给它赋予了太多痛苦和坚持，大脑自然会想方设法帮你抹掉这部分记忆。</p>\n<p><strong>所以想要不放弃，首先就不要给自己“痛苦”的暗示。</strong></p>\n<p>所以，我磨练出了一个道理：</p>\n<p><strong>无论做什么事情，在开始之前，都要想尽一切办法为这个事情赋予重大的意义，甚至多重重大的意义。</strong></p>\n<p>喜欢读书的人，多半不是在坚持，对他们来说，读书是一种享受；喜欢运动的人，运动所产生的多巴胺，足以让他们享受这项运动。真的是这样，无论是跑步，还是打球，一边挥洒汗水，莫名的身体里从乏力又横生出一股力道来，脑子也变得清醒。</p>\n<p>学会、学好一门技能带来的则是重生的快感。和之前所说的多维相联系，你的世界就多了一个维度，你看到了过去不曾有的景象，你甚至会觉得自己又活了一遍。这种快感一旦体会过一次，没有人会停下来，别人想拦都拦不住。没有体会过这种快感的人，总是没办法想象为何对方可以坚持下去。</p>\n<p>这种做法就好比把背单词想作是赚钱，一个单词就相当于50块，这不就是等于捡钱么？一天就赚上他个5000元！对于你来说可能就不是，或许能够考入梦寐以求的大学才是足以激励你的目标。每前进一步，都让自己有“切实”的体会到成长的快感，即便这只是你设计出来的，也比你苦哈哈得想着要坚持强很多。所以你看，人和人之间的差异，往往只不过是一念之差，可实际上的价值差异，却是整个世界的差异。同样的事情，不同的人能给他赋予的意义是不同的，同一个人在不同阶段能够赋予的意义也是不同的。<strong>重要的不是把关注点放在其他地方，而是要找到当下对自己最重要的意义，并把他平摊到每天的任务上。</strong>这样才有可能让自己不停地去做这件事。</p>\n<p>一念一世界，这是很实在的道理。每周升级一个观念，就相当于每周穿越到了下一个“平行世界”，真的很爽，觉得自己在迭代，在更新，爽到停不下来。所以这样子，还需要坚持么？还需要努力么？你还觉得这两个概念有意义么？它们完全没用。</p>\n<p>成为别人家的孩子，其他人需要坚持、需要努力才行的事情，在你这个“别人家的孩子”的世界里，是“干脆停不下来的事”，是“谁不让我做我跟谁急的事儿”，这也就解释了为什么有些孩子会很主动积极地去做作业也好，练琴也罢，甚至时间被其他不重要的事情拖晚了都要自己吵着嚷着回家完成，也许其中有一部分原因就是自己有意识的主动想去做了，而并不是靠坚持，更不是装出来的，是真的在学习的时候，停不下来。当然时间也是其中一个要素之一。</p>\n<p>除了上面提到的“为它赋予很多意义”之外，还有很多其它的方法和技巧。</p>\n<p>当你决定习得某项技能的时候，在你已经想办法赋予它很多正面意义之后，还可以想尽一切办法为“没有它的存在”赋予很多负面意义。拿出一张纸去罗列，甚至可以罗列出很多：</p>\n<ul>\n<li><p>如果没有这项技能，那现在有什么事情我根本做不了？根本没有机会？</p>\n</li>\n<li><p>进而，在将来会遇到什么样的困难？会失去什么样的机会？</p>\n</li>\n<li><p>如果我最终竟然没有掌握这项技能，我就跟哪些人是一样的？他们生活究竟因此而有多么糟糕？</p>\n</li>\n</ul>\n<p>不仅要罗列，还要展开想象，尽可能的把细节想象出来——相信我，这会吓到你的大脑（准确的说，是把那种你所需要的恐惧深深埋入你的潜意识），然后他就会在很多的时候自动工作了，催促你赶紧弄，否则它就会焦虑，他就会害怕……</p>\n<p>另一个尤为重要的技巧就是：</p>\n<p>想尽一切办法去寻找拥有这项技能的人以及人群，尽量与他们共度大量的时间；如果没办法一对一交流，起码也要时刻关注他们……</p>\n<p><strong>社交，从来就是学习的一部分。</strong></p>\n<p>如果你的朋友都是胖子，那么很可能发生的就是，你会慢慢被传染成“胖子”。首先，他们会影响你对胖子这个概念的影响；其次，会从日常饮食中无意识地保持一致。<br>也就是所谓的近朱者赤，近墨者黑，深刻。</p>\n<p>这些判断上回极大地影响你的行为，你的感受，于是，很多在另外一个世界里“很艰难”、“很痛苦”、“很难坚持”的事情，在你的世界里都变成了“真好玩”，“停不下来”，“要是能多玩一会就好了”的事情……</p>\n<p>就算是仅仅相互见得到，相互知道对方的存在，对于学习者，追求进步者来说，都是巨大的价值。</p>\n<p>这也就是“镜像神经元”的作用，通俗的例子，就是别人打针你看着疼。这就让我想到了一句话：</p>\n<p>想象一下，在你的脚的大拇指的指甲和肉之间放一根针，用力地向墙踢去。</p>\n<p>嘶…好疼…脚下意识的回缩。仅仅是看描述的一句话就“真实”的疼的厉害了，这就是源于我们大脑神经元中的一部分“镜像神经元”所起的作用。猴子和鸟类的大脑里貌似也有。这些神经元会在我们看到别人行动的时候触发，这些神经元会“镜像”被观察者的行为，就好像自己在同样的行为似的。</p>\n<p>这就解释了为什么你看到别人打针自己会痛的原因。</p>\n<p>镜像神经元在推测对方行动意图的时候、理解对方行动目标的时候，总是被激烈地触发。反过来可能的猜测就是，那些总是无法猜测别人意图的人，无法理解别人行动目标的人，即，我们日常生活中经常说的“情商太差”的人，很可能就是镜像神经元数量太少了的结果。</p>\n<p>镜像神经元显然在学习能力方面也有着很大的作用。因为学习行为里的大部分就是模仿，普遍来看，模仿力强的人学习能力貌似同样也强。我们经常听到的一个概念：“夫妻相”，其实他们并不是一开始长得像（不排除长得像的人惺惺相惜），是长年累月的在一起，大脑里的镜像神经元不断地被激发，最红结果是表情很像……表情很像的人，脸部肌肉纹理会渐渐趋同，表现为夫妻相。所以，大多数的幸福夫妻常常是“相互学习”的一对。而在相互学习中，镜像神经元的数量和比例都在提高（这个结论很惊人）。</p>\n<p>自闭症也许就是镜像神经元数量过少导致的。研究中也指出，貌似在男女在镜像神经元比例上都存在着差异。有一项研究表明，由单亲母亲培养的孩子能够更容易的识别他人情绪的变化。<br>这项研究结果实际上给我们带来了很多猜想，因为那些差异很可能是习得的，而不一定是天生的。所以：</p>\n<p><strong>镜像神经元的数量和比例很可能是可以通过某些方式提高的。</strong></p>\n<p>这也辅助证明了近二十年脑科学研究的一个定论：“大脑是可塑的。”</p>\n<p>稍微有点扯远了，这也就解释了为什么社交也是学习的一部分的原因所在。这次更新之后，是不是可以把之前的“努力”、“坚持”这些概念都废除了呢？</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>无论做什么事情，单靠坚持这件事就是注定做不好的，要明白三个方面，一，在做之前明白自己做的目的和深远的影响；二，让自己去影响自己的潜意识；三、增加自己的有用社交，从而进一步相互学习更新大脑，真正有驱动力去完成每一件事。</p>\n<h2 id=\"互动\"><a href=\"#互动\" class=\"headerlink\" title=\"互动\"></a>互动</h2><p>1.你有没有什么事情是自己做起来兴致盎然，别人却常常感叹自己学不会、坚持不下来的？<br>2.你最近在“坚持”什么事情？马上开始试试？<br>3.你现在知道为什么要尽量远离那些“负能量”的人了么？他们对你的影响可能比你能感受到的、能想象出来的大，且大出很多很多倍——因为那影响是“骨子里”的，深入你的潜意识的……于是，很多时候，你甚至会在被影响之后都不知道已经被深深地影响了，你说可怕不可怕？你有这样的经历么？评论下来看看？</p>"},{"title":"正则表达式学习小结","date":"2016-07-22T04:22:50.000Z","_content":"## 正则表达式\n\n最近在学PHP，js时需要用到正则表达式，尽管在学Python时学了一些但是不够系统。每次看到繁琐的正则，就浅尝辄止。在此做一个总结，以便自己后续的学习。\n<!-- more -->\n### 什么是正则表达式\n\n正则表达式`(regular expression)`描述了一种字符串匹配的模式，按照某种规则去匹配符合条件的字符串。\n\n### 为什么使用正则表达式？\n\n通过使用正则表达式，可以：\n\n* **测试字符串内的模式。**\n\t例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。\n\n* **查找，替换文本。**\n \t可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。\n\n* **基于模式匹配从字符串中提取子字符串。**\n    可以查找文档内或输入域内特定的文本。\n\n## 正则表达式语法\n\n正则表达式由两种基本字符类型组成：\n - 原义文本字符\n - 元字符\n\n元字符是正则表达式中有特殊含义的非字母字符。\n\n### 普通字符\n\n普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。\n\n### 非打印字符\n\n|字符|描述\n|-----------|:-----------------|\n|\\cx|匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的'c'字符。|\n|\\f\t|匹配一个换页符。等价于 \\x0c 和 \\cL。|\n|\\n\t|匹配一个换行符。等价于 \\x0a 和 \\cJ。|\n|\\r\t|匹配一个回车符。等价于 \\x0d 和 \\cM。|\n|\\s\t|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。|\n|\\S\t|匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。|\n|\\t\t|匹配一个制表符。等价于 \\x09 和 \\cI。|\n|\\v\t|匹配一个垂直制表符。等价于 \\x0b 和 \\cK。|\n\n### 特别字符\n\n所谓特殊字符，就是一些有特殊含义的字符，如上面说的\"\\*.txt\"中的\\*，简单的说就是表示任何字符串的意思。如果要查找文件名中有＊的文件，则需要对＊进行转义，即在其前加一个\\。ls \\*.txt。正则表达式有以下特殊字符。\n\n|特别字符|描述\n|-----------|:------------------|\n|$ |匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。|\n|( )|标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\\( `和 `\\)`。|\n|*\t|匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 `\\*`。|\n|+\t|匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 `\\+`。|\n|.\t|匹配除换行符 \\n之外的任何`单`字符。要匹配 .，请使用 \\。|\n|[\t|标记一个中括号表达式的开始。要匹配 [，请使用 `\\[`。|\n|?\t|匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。|\n|\\\t|将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '`\\\\`' 匹配 \"\\\"，而 '`\\(`' 则匹配 \"`(`\"。|\n|^\t|匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 `\\^`。|\n|{\t|标记限定符表达式的开始。要匹配 {，请使用 `\\{`。|\n|丨 |指明两项之间的一个选择。要匹配 丨，请使用 `\\丨`。|\n \n> 在表格里输入`|`尝试过`\\|`，但可以用中文gun来假装一下哈哈哈哈\n\n### 限定符\n\n限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或{n}或{n,}或{n,m}共6种。\n*、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。\n\n|字符\t|描述\n|-----------|:------------------|\n|*\t|匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。|\n|+\t|匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。|\n|?\t|匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 或 \"does\" 中的\"do\" 。? 等价于 {0,1}。|\n|{n}\t|n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。|\n|{n,}|\tn 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。|\n|{n,m}|\tm 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。|\n\n### 定位符\n\n用来描述字符串或单词的边界。\n\n^和$分别指字符串的开始与结束。\n\n\\b描述单词的前或后边界。\n\n\\B表示非单词边界。\n\n**注：不能对定位符使用限定符。**\n\n\n\n## 操作符优先级\n\n转义符 > 圆括号和方括号 > 限定符 > 位置和顺序 > “或”操作\n\n## 一些匹配规则\n\n我们可以用`[]`来构建一个简单的类。所谓的类就是指符合某些特性的对象，即匹配方括号内任意一个都可。 当在一组方括号里使用^是，它表示“非”或“排除”的意思，常常用来剔除某个字符。即反向类。另外，还给我们提供了范围类，连字号可以表示一个字符的范围，[a-z]即匹配所有的小写字母。\n\n下面举一些例子：\n\n>[a-z] //匹配所有的小写字母 \n[A-Z] //匹配所有的大写字母 \n[a-zA-Z] //匹配所有的字母 \n[0-9] //匹配所有的数字 \n[0-9\\.\\-] //匹配所有的数字，句号和减号 \n[ \\f\\r\\t\\n] //匹配所有的白字符\n\\d\t匹配一个数字字符。等价于 [0-9]。\n\\D\t匹配一个非数字字符。等价于 [^0-9]。\n\n另外，特殊字符\".\"等价`[^\\r\\n]`在正规表达式中用来表示除了回车换行之外的所有字符。\n\n\"\\d\"等价`[0-9]`在正规表达式中用来表示数字字符。\n\n\"\\D\"等价`[^0-9]`在正规表达式中用来表示非数字字符。\n\n\"\\s\"等价`[\\t\\n\\x0B\\f\\r]`在正规表达式中用来表示空白符。\n\n\"\\S\"等价`[^\\t\\n\\x0B\\f\\r]`在正规表达式中用来表示非空白符。\n\n\"\\w\"等价`[a-zA-Z_0-9]`在正规表达式中用来表示数字字母下划线。\n\n\"\\W\"等价`[^a-zA-Z_0-9]`在正规表达式中用来表示非单词字符。\n\n### 量词\n\n到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。\n如：\n\n>^a{4}$ aaaa\n^a{2,}$ 包含多于两个a的字符串 \n^a{1,3}$ a,aa或aaa\n\n这些例子描述了花括号的三种不同的用法。一个数字，{x}的意思是“前面的字符或字符簇只出现x次”；一个数字加逗号，{x,}的意思是“前面的内容出现x或更多的次数”，之前所说的`+`即表示比配一次或多次，等同于{1,}；两个用逗号分隔的数字，{x,y}表示“前面的内容至少出现x次，但不超过y次”。\n\n>^[a-zA-Z0-9_]{1,}$ //所有包含一个以上的字母、数字或下划线的字符串 \n^[0-9]{1,}$ //所有的正数 \n^\\-{0,1}[0-9]{1,}$ //所有的整数 \n^\\-{0,1}[0-9]{0,}\\.{0,1}[0-9]{0,}$ //所有的小数\n\n\n另外，`？`字符表示出现零次或一次(最多出现一次)；\n\n`+`字符表示出现一次或多次(至少出现一次);\n\n`*`字符表示出现零次或多次(任意次)；\n\n### 分组\n\n在某些情况，如果想匹配apple3次，估计大家会这样写：`apple{3}`\n\n可是查找结果却是：\n![错误查找实例](http://i1.buimg.com/567571/fb6925e616192838.png)\n\n因此，我们需要用到`()`分组。应该写成`(apple){3}`\n\n查找结果就是：![正确实例](http://i1.buimg.com/567571/0b326d402a10b11e.png)\n\n### 选择\n\n用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用`?:`放在第一个选项前来消除这种副作用。\n\n### 反向引用\n\n对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左至右所遇到的内容存储。存储子匹配的缓冲区编号从 1 开始，连续编号直至最大 99 个子表达式。每个缓冲区都可以使用 '\\n' 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。\n\n可以在分组内加上非捕获元字符 '?:', '?=', or '?!' 来忽略对相关匹配的保存。\n\n(?:pattern) \n匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。\n\n### 前瞻\n\n正则表达式从文本头部向尾部开始解析，文本尾部方向称为`前`。\n\n**前瞻**就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾则相反。正向前瞻和负向前瞻就是判断一个正则之后还没有完，还需要在符合一个条件。\n\n符合和不符合特定断言称之为**肯定/正向**匹配和**否定/反向**匹配。\n\n正向前瞻　exp(?=assert)\n\n反向前瞻　exp(?!assert)\n\n正向后顾　exp(?<=assert)\n\n反向后顾　exp(?<\\!assert)\n\n(js不支持后顾)\n\nexp为原正则部分，assert部分即断言部分也是正则表达式，`?=`和`?!`，前者为正向前瞻，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向前瞻，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。\n\n## javascript 中正则表达式的应用\n\njs中通过内置对象**REGEXP**支持正则表达式。\n有两种方法实例化RegExp对象：\n\t1.字面量　var reg = / \\bis\\b /g;\n\t2.构造函数　var reg = new RegExp ('\\\\bis\\\\b','g');/\\*在Js中\\也是特殊字符所以需要转义,第一个是正则表达式文本，第二个字符串是标志位，g，全局匹配\\*/\n\n### javascript中正则表达式对象的属性\n\ng：global　全局匹配，不添加，匹配到第一个为止\n\ni：ignore case　不分大小写\n\nm: multiple lines 多行搜索，使^变为新的行首\n\nlastIndex：是当前表达式匹配内容的最后一个字符的下一个位置\n\nsource：正则表达式的文本字符串\n\n### javascript中正则对象本身的方法\n\n#### RegExp.prototype.test(str)\n\n 作用：用于测试字符串参数中是否存在匹配正则表达式模式的字符串\n 符合返回`true`,否则返回`false`\n 调用实例：\n \n ```\n var reg = / \\bis\\b /g;\n reg.test(str);\n ```\n \n 但当使用全局g属性标识时，会修改lastIndex值，在匹配到最后一项之后会重置为0，因此会出现结果为反复的循环true、false，出现结果不稳定\n\n 其实test的本意，其实就是测试能否匹配上。\n\n#### RegExp.prototype.exec(str)\n 作用：使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果。\n 如果没有匹配到的文本则返回null，否则返回一个结果数组。\n 此数组有两个属性，\n \t1.index：声明匹配文本的第一个字符的位置\n \t2.input：存放被检索的字符串`string`\n \n 在非全局调用时，返回数组：\n \n 第一个元素是与正则表达式相匹配的文本\n \n 第二个元素是与RegExpObject的第一个子表达式相匹配到的文本\n \n 第三个元素是与RegExpObject的第二个子表达式相匹配到的文本，以此类推\n \n### javascript中字符串的方法 \n\n#### String.prototype.search(reg)\n\n 作用：用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。\n 方法返回第一个匹配结果 index，查找不到返回-1\n 不执行全局匹配，忽略g，总是从字符串的开始进行搜索。\n\n#### String.prototype.match(reg)\n\n 作用：用于检索字符串，以找到一个或多个与regxp匹配的文本\n regxp是否具有标志位g对结果影响很大\n\n 在非全局调用时，返回数组，没有匹配到的文本则返回null\n\n 返回数组第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本\n\n 除了常规的数组元素之外，返回的数组还含有2个对象属性\n \t1.index：声明匹配文本的第一个字符的位置\n \t2.input：声明对stringObject的引用\n\n 而在全局调用时，返回的数组存放的是字符串中所有的匹配子串，而且也没有index和input属性，就告诉你匹配结果。\n\n#### String.prototype.split(reg)\n\n 作用：我们经常用split来把字符串分割为字符数组，而在一些复杂的情况下我们可以用正则表达式来分割。\n\n#### String.prototype.replace(reg)\n\n 作用：替换内容,三种方法。\n replace(str,replaceStr)\n replace(reg,replaceStr)\n replace(reg,function)　如将a1b2c3替换为a2b3c4\n \n##### function(match,group,index,origin)参数含义\n \n function会在每次匹配替换时调用，有4个参数\n \t1.匹配字符串\n \t2.正则表达式分组内容，没有分组则没有参数\n \t3.匹配项在字符串中的index\n \t4.原字符串\n\n\n------\n正则表达式测试工具：https://regexper.com\n","source":"_posts/通用杂货/正则表达式.md","raw":"---\ntitle: 正则表达式学习小结\ndate: 2016-07-22 12:22:50\ntags: \n- 正则表达式\ncategories: 总结\n---\n## 正则表达式\n\n最近在学PHP，js时需要用到正则表达式，尽管在学Python时学了一些但是不够系统。每次看到繁琐的正则，就浅尝辄止。在此做一个总结，以便自己后续的学习。\n<!-- more -->\n### 什么是正则表达式\n\n正则表达式`(regular expression)`描述了一种字符串匹配的模式，按照某种规则去匹配符合条件的字符串。\n\n### 为什么使用正则表达式？\n\n通过使用正则表达式，可以：\n\n* **测试字符串内的模式。**\n\t例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。\n\n* **查找，替换文本。**\n \t可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。\n\n* **基于模式匹配从字符串中提取子字符串。**\n    可以查找文档内或输入域内特定的文本。\n\n## 正则表达式语法\n\n正则表达式由两种基本字符类型组成：\n - 原义文本字符\n - 元字符\n\n元字符是正则表达式中有特殊含义的非字母字符。\n\n### 普通字符\n\n普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。\n\n### 非打印字符\n\n|字符|描述\n|-----------|:-----------------|\n|\\cx|匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的'c'字符。|\n|\\f\t|匹配一个换页符。等价于 \\x0c 和 \\cL。|\n|\\n\t|匹配一个换行符。等价于 \\x0a 和 \\cJ。|\n|\\r\t|匹配一个回车符。等价于 \\x0d 和 \\cM。|\n|\\s\t|匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。|\n|\\S\t|匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。|\n|\\t\t|匹配一个制表符。等价于 \\x09 和 \\cI。|\n|\\v\t|匹配一个垂直制表符。等价于 \\x0b 和 \\cK。|\n\n### 特别字符\n\n所谓特殊字符，就是一些有特殊含义的字符，如上面说的\"\\*.txt\"中的\\*，简单的说就是表示任何字符串的意思。如果要查找文件名中有＊的文件，则需要对＊进行转义，即在其前加一个\\。ls \\*.txt。正则表达式有以下特殊字符。\n\n|特别字符|描述\n|-----------|:------------------|\n|$ |匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\\n' 或 '\\r'。要匹配 $ 字符本身，请使用 \\$。|\n|( )|标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 `\\( `和 `\\)`。|\n|*\t|匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 `\\*`。|\n|+\t|匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 `\\+`。|\n|.\t|匹配除换行符 \\n之外的任何`单`字符。要匹配 .，请使用 \\。|\n|[\t|标记一个中括号表达式的开始。要匹配 [，请使用 `\\[`。|\n|?\t|匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。|\n|\\\t|将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\\n' 匹配换行符。序列 '`\\\\`' 匹配 \"\\\"，而 '`\\(`' 则匹配 \"`(`\"。|\n|^\t|匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 `\\^`。|\n|{\t|标记限定符表达式的开始。要匹配 {，请使用 `\\{`。|\n|丨 |指明两项之间的一个选择。要匹配 丨，请使用 `\\丨`。|\n \n> 在表格里输入`|`尝试过`\\|`，但可以用中文gun来假装一下哈哈哈哈\n\n### 限定符\n\n限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或{n}或{n,}或{n,m}共6种。\n*、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。\n\n|字符\t|描述\n|-----------|:------------------|\n|*\t|匹配前面的子表达式零次或多次。例如，zo* 能匹配 \"z\" 以及 \"zoo\"。* 等价于{0,}。|\n|+\t|匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 \"zo\" 以及 \"zoo\"，但不能匹配 \"z\"。+ 等价于 {1,}。|\n|?\t|匹配前面的子表达式零次或一次。例如，\"do(es)?\" 可以匹配 \"do\" 或 \"does\" 中的\"do\" 。? 等价于 {0,1}。|\n|{n}\t|n 是一个非负整数。匹配确定的 n 次。例如，'o{2}' 不能匹配 \"Bob\" 中的 'o'，但是能匹配 \"food\" 中的两个 o。|\n|{n,}|\tn 是一个非负整数。至少匹配n 次。例如，'o{2,}' 不能匹配 \"Bob\" 中的 'o'，但能匹配 \"foooood\" 中的所有 o。'o{1,}' 等价于 'o+'。'o{0,}' 则等价于 'o*'。|\n|{n,m}|\tm 和 n 均为非负整数，其中n <= m。最少匹配 n 次且最多匹配 m 次。例如，\"o{1,3}\" 将匹配 \"fooooood\" 中的前三个 o。'o{0,1}' 等价于 'o?'。请注意在逗号和两个数之间不能有空格。|\n\n### 定位符\n\n用来描述字符串或单词的边界。\n\n^和$分别指字符串的开始与结束。\n\n\\b描述单词的前或后边界。\n\n\\B表示非单词边界。\n\n**注：不能对定位符使用限定符。**\n\n\n\n## 操作符优先级\n\n转义符 > 圆括号和方括号 > 限定符 > 位置和顺序 > “或”操作\n\n## 一些匹配规则\n\n我们可以用`[]`来构建一个简单的类。所谓的类就是指符合某些特性的对象，即匹配方括号内任意一个都可。 当在一组方括号里使用^是，它表示“非”或“排除”的意思，常常用来剔除某个字符。即反向类。另外，还给我们提供了范围类，连字号可以表示一个字符的范围，[a-z]即匹配所有的小写字母。\n\n下面举一些例子：\n\n>[a-z] //匹配所有的小写字母 \n[A-Z] //匹配所有的大写字母 \n[a-zA-Z] //匹配所有的字母 \n[0-9] //匹配所有的数字 \n[0-9\\.\\-] //匹配所有的数字，句号和减号 \n[ \\f\\r\\t\\n] //匹配所有的白字符\n\\d\t匹配一个数字字符。等价于 [0-9]。\n\\D\t匹配一个非数字字符。等价于 [^0-9]。\n\n另外，特殊字符\".\"等价`[^\\r\\n]`在正规表达式中用来表示除了回车换行之外的所有字符。\n\n\"\\d\"等价`[0-9]`在正规表达式中用来表示数字字符。\n\n\"\\D\"等价`[^0-9]`在正规表达式中用来表示非数字字符。\n\n\"\\s\"等价`[\\t\\n\\x0B\\f\\r]`在正规表达式中用来表示空白符。\n\n\"\\S\"等价`[^\\t\\n\\x0B\\f\\r]`在正规表达式中用来表示非空白符。\n\n\"\\w\"等价`[a-zA-Z_0-9]`在正规表达式中用来表示数字字母下划线。\n\n\"\\W\"等价`[^a-zA-Z_0-9]`在正规表达式中用来表示非单词字符。\n\n### 量词\n\n到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。\n如：\n\n>^a{4}$ aaaa\n^a{2,}$ 包含多于两个a的字符串 \n^a{1,3}$ a,aa或aaa\n\n这些例子描述了花括号的三种不同的用法。一个数字，{x}的意思是“前面的字符或字符簇只出现x次”；一个数字加逗号，{x,}的意思是“前面的内容出现x或更多的次数”，之前所说的`+`即表示比配一次或多次，等同于{1,}；两个用逗号分隔的数字，{x,y}表示“前面的内容至少出现x次，但不超过y次”。\n\n>^[a-zA-Z0-9_]{1,}$ //所有包含一个以上的字母、数字或下划线的字符串 \n^[0-9]{1,}$ //所有的正数 \n^\\-{0,1}[0-9]{1,}$ //所有的整数 \n^\\-{0,1}[0-9]{0,}\\.{0,1}[0-9]{0,}$ //所有的小数\n\n\n另外，`？`字符表示出现零次或一次(最多出现一次)；\n\n`+`字符表示出现一次或多次(至少出现一次);\n\n`*`字符表示出现零次或多次(任意次)；\n\n### 分组\n\n在某些情况，如果想匹配apple3次，估计大家会这样写：`apple{3}`\n\n可是查找结果却是：\n![错误查找实例](http://i1.buimg.com/567571/fb6925e616192838.png)\n\n因此，我们需要用到`()`分组。应该写成`(apple){3}`\n\n查找结果就是：![正确实例](http://i1.buimg.com/567571/0b326d402a10b11e.png)\n\n### 选择\n\n用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用`?:`放在第一个选项前来消除这种副作用。\n\n### 反向引用\n\n对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左至右所遇到的内容存储。存储子匹配的缓冲区编号从 1 开始，连续编号直至最大 99 个子表达式。每个缓冲区都可以使用 '\\n' 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。\n\n可以在分组内加上非捕获元字符 '?:', '?=', or '?!' 来忽略对相关匹配的保存。\n\n(?:pattern) \n匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 \"或\" 字符 (|) 来组合一个模式的各个部分是很有用。例如， 'industr(?:y|ies) 就是一个比 'industry|industries' 更简略的表达式。\n\n### 前瞻\n\n正则表达式从文本头部向尾部开始解析，文本尾部方向称为`前`。\n\n**前瞻**就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾则相反。正向前瞻和负向前瞻就是判断一个正则之后还没有完，还需要在符合一个条件。\n\n符合和不符合特定断言称之为**肯定/正向**匹配和**否定/反向**匹配。\n\n正向前瞻　exp(?=assert)\n\n反向前瞻　exp(?!assert)\n\n正向后顾　exp(?<=assert)\n\n反向后顾　exp(?<\\!assert)\n\n(js不支持后顾)\n\nexp为原正则部分，assert部分即断言部分也是正则表达式，`?=`和`?!`，前者为正向前瞻，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向前瞻，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。\n\n## javascript 中正则表达式的应用\n\njs中通过内置对象**REGEXP**支持正则表达式。\n有两种方法实例化RegExp对象：\n\t1.字面量　var reg = / \\bis\\b /g;\n\t2.构造函数　var reg = new RegExp ('\\\\bis\\\\b','g');/\\*在Js中\\也是特殊字符所以需要转义,第一个是正则表达式文本，第二个字符串是标志位，g，全局匹配\\*/\n\n### javascript中正则表达式对象的属性\n\ng：global　全局匹配，不添加，匹配到第一个为止\n\ni：ignore case　不分大小写\n\nm: multiple lines 多行搜索，使^变为新的行首\n\nlastIndex：是当前表达式匹配内容的最后一个字符的下一个位置\n\nsource：正则表达式的文本字符串\n\n### javascript中正则对象本身的方法\n\n#### RegExp.prototype.test(str)\n\n 作用：用于测试字符串参数中是否存在匹配正则表达式模式的字符串\n 符合返回`true`,否则返回`false`\n 调用实例：\n \n ```\n var reg = / \\bis\\b /g;\n reg.test(str);\n ```\n \n 但当使用全局g属性标识时，会修改lastIndex值，在匹配到最后一项之后会重置为0，因此会出现结果为反复的循环true、false，出现结果不稳定\n\n 其实test的本意，其实就是测试能否匹配上。\n\n#### RegExp.prototype.exec(str)\n 作用：使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果。\n 如果没有匹配到的文本则返回null，否则返回一个结果数组。\n 此数组有两个属性，\n \t1.index：声明匹配文本的第一个字符的位置\n \t2.input：存放被检索的字符串`string`\n \n 在非全局调用时，返回数组：\n \n 第一个元素是与正则表达式相匹配的文本\n \n 第二个元素是与RegExpObject的第一个子表达式相匹配到的文本\n \n 第三个元素是与RegExpObject的第二个子表达式相匹配到的文本，以此类推\n \n### javascript中字符串的方法 \n\n#### String.prototype.search(reg)\n\n 作用：用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。\n 方法返回第一个匹配结果 index，查找不到返回-1\n 不执行全局匹配，忽略g，总是从字符串的开始进行搜索。\n\n#### String.prototype.match(reg)\n\n 作用：用于检索字符串，以找到一个或多个与regxp匹配的文本\n regxp是否具有标志位g对结果影响很大\n\n 在非全局调用时，返回数组，没有匹配到的文本则返回null\n\n 返回数组第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本\n\n 除了常规的数组元素之外，返回的数组还含有2个对象属性\n \t1.index：声明匹配文本的第一个字符的位置\n \t2.input：声明对stringObject的引用\n\n 而在全局调用时，返回的数组存放的是字符串中所有的匹配子串，而且也没有index和input属性，就告诉你匹配结果。\n\n#### String.prototype.split(reg)\n\n 作用：我们经常用split来把字符串分割为字符数组，而在一些复杂的情况下我们可以用正则表达式来分割。\n\n#### String.prototype.replace(reg)\n\n 作用：替换内容,三种方法。\n replace(str,replaceStr)\n replace(reg,replaceStr)\n replace(reg,function)　如将a1b2c3替换为a2b3c4\n \n##### function(match,group,index,origin)参数含义\n \n function会在每次匹配替换时调用，有4个参数\n \t1.匹配字符串\n \t2.正则表达式分组内容，没有分组则没有参数\n \t3.匹配项在字符串中的index\n \t4.原字符串\n\n\n------\n正则表达式测试工具：https://regexper.com\n","slug":"通用杂货/正则表达式","published":1,"updated":"2019-03-22T14:44:36.742Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn1200av4l3n5377gstg","content":"<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>最近在学PHP，js时需要用到正则表达式，尽管在学Python时学了一些但是不够系统。每次看到繁琐的正则，就浅尝辄止。在此做一个总结，以便自己后续的学习。<br><a id=\"more\"></a></p>\n<h3 id=\"什么是正则表达式\"><a href=\"#什么是正则表达式\" class=\"headerlink\" title=\"什么是正则表达式\"></a>什么是正则表达式</h3><p>正则表达式<code>(regular expression)</code>描述了一种字符串匹配的模式，按照某种规则去匹配符合条件的字符串。</p>\n<h3 id=\"为什么使用正则表达式？\"><a href=\"#为什么使用正则表达式？\" class=\"headerlink\" title=\"为什么使用正则表达式？\"></a>为什么使用正则表达式？</h3><p>通过使用正则表达式，可以：</p>\n<ul>\n<li><p><strong>测试字符串内的模式。</strong><br>  例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</p>\n</li>\n<li><p><strong>查找，替换文本。</strong><br>   可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</p>\n</li>\n<li><p><strong>基于模式匹配从字符串中提取子字符串。</strong><br>  可以查找文档内或输入域内特定的文本。</p>\n</li>\n</ul>\n<h2 id=\"正则表达式语法\"><a href=\"#正则表达式语法\" class=\"headerlink\" title=\"正则表达式语法\"></a>正则表达式语法</h2><p>正则表达式由两种基本字符类型组成：</p>\n<ul>\n<li>原义文本字符</li>\n<li>元字符</li>\n</ul>\n<p>元字符是正则表达式中有特殊含义的非字母字符。</p>\n<h3 id=\"普通字符\"><a href=\"#普通字符\" class=\"headerlink\" title=\"普通字符\"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>\n<h3 id=\"非打印字符\"><a href=\"#非打印字符\" class=\"headerlink\" title=\"非打印字符\"></a>非打印字符</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\cx</td>\n<td style=\"text-align:left\">匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的’c’字符。</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td style=\"text-align:left\">匹配一个换页符。等价于 \\x0c 和 \\cL。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td style=\"text-align:left\">匹配一个换行符。等价于 \\x0a 和 \\cJ。</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td style=\"text-align:left\">匹配一个回车符。等价于 \\x0d 和 \\cM。</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td style=\"text-align:left\">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td style=\"text-align:left\">匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td style=\"text-align:left\">匹配一个制表符。等价于 \\x09 和 \\cI。</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td style=\"text-align:left\">匹配一个垂直制表符。等价于 \\x0b 和 \\cK。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"特别字符\"><a href=\"#特别字符\" class=\"headerlink\" title=\"特别字符\"></a>特别字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的”*.txt”中的*，简单的说就是表示任何字符串的意思。如果要查找文件名中有＊的文件，则需要对＊进行转义，即在其前加一个\\。ls *.txt。正则表达式有以下特殊字符。</p>\n<table>\n<thead>\n<tr>\n<th>特别字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$</td>\n<td style=\"text-align:left\">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。</td>\n</tr>\n<tr>\n<td>( )</td>\n<td style=\"text-align:left\">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\\(</code>和 <code>\\)</code>。</td>\n</tr>\n<tr>\n<td>*</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 `\\</em>`。</td>\n</tr>\n<tr>\n<td>+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 <code>\\+</code>。</td>\n</tr>\n<tr>\n<td>.</td>\n<td style=\"text-align:left\">匹配除换行符 \\n之外的任何<code>单</code>字符。要匹配 .，请使用 \\。</td>\n</tr>\n<tr>\n<td>[</td>\n<td style=\"text-align:left\">标记一个中括号表达式的开始。要匹配 [，请使用 <code>\\[</code>。</td>\n</tr>\n<tr>\n<td>?</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。</td>\n</tr>\n<tr>\n<td>\\</td>\n<td style=\"text-align:left\">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘<code>\\\\</code>‘ 匹配 “\\”，而 ‘<code>\\(</code>‘ 则匹配 “<code>(</code>“。</td>\n</tr>\n<tr>\n<td>^</td>\n<td style=\"text-align:left\">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 <code>\\^</code>。</td>\n</tr>\n<tr>\n<td>{</td>\n<td style=\"text-align:left\">标记限定符表达式的开始。要匹配 {，请使用 <code>\\{</code>。</td>\n</tr>\n<tr>\n<td>丨</td>\n<td style=\"text-align:left\">指明两项之间的一个选择。要匹配 丨，请使用 <code>\\丨</code>。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>在表格里输入<code>|</code>尝试过<code>\\|</code>，但可以用中文gun来假装一下哈哈哈哈</p>\n</blockquote>\n<h3 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有<em>或+或?或{n}或{n,}或{n,m}共6种。\n</em>、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>\n</tr>\n<tr>\n<td>+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>\n</tr>\n<tr>\n<td>?</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td style=\"text-align:left\">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td style=\"text-align:left\">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td style=\"text-align:left\">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"定位符\"><a href=\"#定位符\" class=\"headerlink\" title=\"定位符\"></a>定位符</h3><p>用来描述字符串或单词的边界。</p>\n<p>^和$分别指字符串的开始与结束。</p>\n<p>\\b描述单词的前或后边界。</p>\n<p>\\B表示非单词边界。</p>\n<p><strong>注：不能对定位符使用限定符。</strong></p>\n<h2 id=\"操作符优先级\"><a href=\"#操作符优先级\" class=\"headerlink\" title=\"操作符优先级\"></a>操作符优先级</h2><p>转义符 &gt; 圆括号和方括号 &gt; 限定符 &gt; 位置和顺序 &gt; “或”操作</p>\n<h2 id=\"一些匹配规则\"><a href=\"#一些匹配规则\" class=\"headerlink\" title=\"一些匹配规则\"></a>一些匹配规则</h2><p>我们可以用<code>[]</code>来构建一个简单的类。所谓的类就是指符合某些特性的对象，即匹配方括号内任意一个都可。 当在一组方括号里使用^是，它表示“非”或“排除”的意思，常常用来剔除某个字符。即反向类。另外，还给我们提供了范围类，连字号可以表示一个字符的范围，[a-z]即匹配所有的小写字母。</p>\n<p>下面举一些例子：</p>\n<blockquote>\n<p>[a-z] //匹配所有的小写字母<br>[A-Z] //匹配所有的大写字母<br>[a-zA-Z] //匹配所有的字母<br>[0-9] //匹配所有的数字<br>[0-9.-] //匹配所有的数字，句号和减号<br>[ \\f\\r\\t\\n] //匹配所有的白字符<br>\\d    匹配一个数字字符。等价于 [0-9]。<br>\\D    匹配一个非数字字符。等价于 [^0-9]。</p>\n</blockquote>\n<p>另外，特殊字符”.”等价<code>[^\\r\\n]</code>在正规表达式中用来表示除了回车换行之外的所有字符。</p>\n<p>“\\d”等价<code>[0-9]</code>在正规表达式中用来表示数字字符。</p>\n<p>“\\D”等价<code>[^0-9]</code>在正规表达式中用来表示非数字字符。</p>\n<p>“\\s”等价<code>[\\t\\n\\x0B\\f\\r]</code>在正规表达式中用来表示空白符。</p>\n<p>“\\S”等价<code>[^\\t\\n\\x0B\\f\\r]</code>在正规表达式中用来表示非空白符。</p>\n<p>“\\w”等价<code>[a-zA-Z_0-9]</code>在正规表达式中用来表示数字字母下划线。</p>\n<p>“\\W”等价<code>[^a-zA-Z_0-9]</code>在正规表达式中用来表示非单词字符。</p>\n<h3 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h3><p>到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。<br>如：</p>\n<blockquote>\n<p>^a{4}$ aaaa<br>^a{2,}$ 包含多于两个a的字符串<br>^a{1,3}$ a,aa或aaa</p>\n</blockquote>\n<p>这些例子描述了花括号的三种不同的用法。一个数字，{x}的意思是“前面的字符或字符簇只出现x次”；一个数字加逗号，{x,}的意思是“前面的内容出现x或更多的次数”，之前所说的<code>+</code>即表示比配一次或多次，等同于{1,}；两个用逗号分隔的数字，{x,y}表示“前面的内容至少出现x次，但不超过y次”。</p>\n<blockquote>\n<p>^[a-zA-Z0-9_]{1,}$ //所有包含一个以上的字母、数字或下划线的字符串<br>^[0-9]{1,}$ //所有的正数<br>^-{0,1}[0-9]{1,}$ //所有的整数<br>^-{0,1}[0-9]{0,}.{0,1}[0-9]{0,}$ //所有的小数</p>\n</blockquote>\n<p>另外，<code>？</code>字符表示出现零次或一次(最多出现一次)；</p>\n<p><code>+</code>字符表示出现一次或多次(至少出现一次);</p>\n<p><code>*</code>字符表示出现零次或多次(任意次)；</p>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>在某些情况，如果想匹配apple3次，估计大家会这样写：<code>apple{3}</code></p>\n<p>可是查找结果却是：<br><img src=\"http://i1.buimg.com/567571/fb6925e616192838.png\" alt=\"错误查找实例\"></p>\n<p>因此，我们需要用到<code>()</code>分组。应该写成<code>(apple){3}</code></p>\n<p>查找结果就是：<img src=\"http://i1.buimg.com/567571/0b326d402a10b11e.png\" alt=\"正确实例\"></p>\n<h3 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h3><p>用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用<code>?:</code>放在第一个选项前来消除这种副作用。</p>\n<h3 id=\"反向引用\"><a href=\"#反向引用\" class=\"headerlink\" title=\"反向引用\"></a>反向引用</h3><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左至右所遇到的内容存储。存储子匹配的缓冲区编号从 1 开始，连续编号直至最大 99 个子表达式。每个缓冲区都可以使用 ‘\\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p>\n<p>可以在分组内加上非捕获元字符 ‘?:’, ‘?=’, or ‘?!’ 来忽略对相关匹配的保存。</p>\n<p>(?:pattern)<br>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</p>\n<h3 id=\"前瞻\"><a href=\"#前瞻\" class=\"headerlink\" title=\"前瞻\"></a>前瞻</h3><p>正则表达式从文本头部向尾部开始解析，文本尾部方向称为<code>前</code>。</p>\n<p><strong>前瞻</strong>就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾则相反。正向前瞻和负向前瞻就是判断一个正则之后还没有完，还需要在符合一个条件。</p>\n<p>符合和不符合特定断言称之为<strong>肯定/正向</strong>匹配和<strong>否定/反向</strong>匹配。</p>\n<p>正向前瞻　exp(?=assert)</p>\n<p>反向前瞻　exp(?!assert)</p>\n<p>正向后顾　exp(?&lt;=assert)</p>\n<p>反向后顾　exp(?&lt;!assert)</p>\n<p>(js不支持后顾)</p>\n<p>exp为原正则部分，assert部分即断言部分也是正则表达式，<code>?=</code>和<code>?!</code>，前者为正向前瞻，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向前瞻，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p>\n<h2 id=\"javascript-中正则表达式的应用\"><a href=\"#javascript-中正则表达式的应用\" class=\"headerlink\" title=\"javascript 中正则表达式的应用\"></a>javascript 中正则表达式的应用</h2><p>js中通过内置对象<strong>REGEXP</strong>支持正则表达式。<br>有两种方法实例化RegExp对象：<br>    1.字面量　var reg = / \\bis\\b /g;<br>    2.构造函数　var reg = new RegExp (‘\\bis\\b’,’g’);/*在Js中\\也是特殊字符所以需要转义,第一个是正则表达式文本，第二个字符串是标志位，g，全局匹配*/</p>\n<h3 id=\"javascript中正则表达式对象的属性\"><a href=\"#javascript中正则表达式对象的属性\" class=\"headerlink\" title=\"javascript中正则表达式对象的属性\"></a>javascript中正则表达式对象的属性</h3><p>g：global　全局匹配，不添加，匹配到第一个为止</p>\n<p>i：ignore case　不分大小写</p>\n<p>m: multiple lines 多行搜索，使^变为新的行首</p>\n<p>lastIndex：是当前表达式匹配内容的最后一个字符的下一个位置</p>\n<p>source：正则表达式的文本字符串</p>\n<h3 id=\"javascript中正则对象本身的方法\"><a href=\"#javascript中正则对象本身的方法\" class=\"headerlink\" title=\"javascript中正则对象本身的方法\"></a>javascript中正则对象本身的方法</h3><h4 id=\"RegExp-prototype-test-str\"><a href=\"#RegExp-prototype-test-str\" class=\"headerlink\" title=\"RegExp.prototype.test(str)\"></a>RegExp.prototype.test(str)</h4><p> 作用：用于测试字符串参数中是否存在匹配正则表达式模式的字符串<br> 符合返回<code>true</code>,否则返回<code>false</code><br> 调用实例：</p>\n <figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">reg</span> = / \\bis\\b /<span class=\"keyword\">g</span>;</span><br><span class=\"line\"><span class=\"keyword\">reg</span>.<span class=\"keyword\">test</span>(str);</span><br></pre></td></tr></table></figure>\n<p> 但当使用全局g属性标识时，会修改lastIndex值，在匹配到最后一项之后会重置为0，因此会出现结果为反复的循环true、false，出现结果不稳定</p>\n<p> 其实test的本意，其实就是测试能否匹配上。</p>\n<h4 id=\"RegExp-prototype-exec-str\"><a href=\"#RegExp-prototype-exec-str\" class=\"headerlink\" title=\"RegExp.prototype.exec(str)\"></a>RegExp.prototype.exec(str)</h4><p> 作用：使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果。<br> 如果没有匹配到的文本则返回null，否则返回一个结果数组。<br> 此数组有两个属性，<br>     1.index：声明匹配文本的第一个字符的位置<br>     2.input：存放被检索的字符串<code>string</code></p>\n<p> 在非全局调用时，返回数组：</p>\n<p> 第一个元素是与正则表达式相匹配的文本</p>\n<p> 第二个元素是与RegExpObject的第一个子表达式相匹配到的文本</p>\n<p> 第三个元素是与RegExpObject的第二个子表达式相匹配到的文本，以此类推</p>\n<h3 id=\"javascript中字符串的方法\"><a href=\"#javascript中字符串的方法\" class=\"headerlink\" title=\"javascript中字符串的方法\"></a>javascript中字符串的方法</h3><h4 id=\"String-prototype-search-reg\"><a href=\"#String-prototype-search-reg\" class=\"headerlink\" title=\"String.prototype.search(reg)\"></a>String.prototype.search(reg)</h4><p> 作用：用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。<br> 方法返回第一个匹配结果 index，查找不到返回-1<br> 不执行全局匹配，忽略g，总是从字符串的开始进行搜索。</p>\n<h4 id=\"String-prototype-match-reg\"><a href=\"#String-prototype-match-reg\" class=\"headerlink\" title=\"String.prototype.match(reg)\"></a>String.prototype.match(reg)</h4><p> 作用：用于检索字符串，以找到一个或多个与regxp匹配的文本<br> regxp是否具有标志位g对结果影响很大</p>\n<p> 在非全局调用时，返回数组，没有匹配到的文本则返回null</p>\n<p> 返回数组第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本</p>\n<p> 除了常规的数组元素之外，返回的数组还含有2个对象属性<br>     1.index：声明匹配文本的第一个字符的位置<br>     2.input：声明对stringObject的引用</p>\n<p> 而在全局调用时，返回的数组存放的是字符串中所有的匹配子串，而且也没有index和input属性，就告诉你匹配结果。</p>\n<h4 id=\"String-prototype-split-reg\"><a href=\"#String-prototype-split-reg\" class=\"headerlink\" title=\"String.prototype.split(reg)\"></a>String.prototype.split(reg)</h4><p> 作用：我们经常用split来把字符串分割为字符数组，而在一些复杂的情况下我们可以用正则表达式来分割。</p>\n<h4 id=\"String-prototype-replace-reg\"><a href=\"#String-prototype-replace-reg\" class=\"headerlink\" title=\"String.prototype.replace(reg)\"></a>String.prototype.replace(reg)</h4><p> 作用：替换内容,三种方法。<br> replace(str,replaceStr)<br> replace(reg,replaceStr)<br> replace(reg,function)　如将a1b2c3替换为a2b3c4</p>\n<h5 id=\"function-match-group-index-origin-参数含义\"><a href=\"#function-match-group-index-origin-参数含义\" class=\"headerlink\" title=\"function(match,group,index,origin)参数含义\"></a>function(match,group,index,origin)参数含义</h5><p> function会在每次匹配替换时调用，有4个参数<br>     1.匹配字符串<br>     2.正则表达式分组内容，没有分组则没有参数<br>     3.匹配项在字符串中的index<br>     4.原字符串</p>\n<hr>\n<p>正则表达式测试工具：<a href=\"https://regexper.com\" target=\"_blank\" rel=\"noopener\">https://regexper.com</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>最近在学PHP，js时需要用到正则表达式，尽管在学Python时学了一些但是不够系统。每次看到繁琐的正则，就浅尝辄止。在此做一个总结，以便自己后续的学习。<br></p>","more":"<p></p>\n<h3 id=\"什么是正则表达式\"><a href=\"#什么是正则表达式\" class=\"headerlink\" title=\"什么是正则表达式\"></a>什么是正则表达式</h3><p>正则表达式<code>(regular expression)</code>描述了一种字符串匹配的模式，按照某种规则去匹配符合条件的字符串。</p>\n<h3 id=\"为什么使用正则表达式？\"><a href=\"#为什么使用正则表达式？\" class=\"headerlink\" title=\"为什么使用正则表达式？\"></a>为什么使用正则表达式？</h3><p>通过使用正则表达式，可以：</p>\n<ul>\n<li><p><strong>测试字符串内的模式。</strong><br>  例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</p>\n</li>\n<li><p><strong>查找，替换文本。</strong><br>   可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</p>\n</li>\n<li><p><strong>基于模式匹配从字符串中提取子字符串。</strong><br>  可以查找文档内或输入域内特定的文本。</p>\n</li>\n</ul>\n<h2 id=\"正则表达式语法\"><a href=\"#正则表达式语法\" class=\"headerlink\" title=\"正则表达式语法\"></a>正则表达式语法</h2><p>正则表达式由两种基本字符类型组成：</p>\n<ul>\n<li>原义文本字符</li>\n<li>元字符</li>\n</ul>\n<p>元字符是正则表达式中有特殊含义的非字母字符。</p>\n<h3 id=\"普通字符\"><a href=\"#普通字符\" class=\"headerlink\" title=\"普通字符\"></a>普通字符</h3><p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。</p>\n<h3 id=\"非打印字符\"><a href=\"#非打印字符\" class=\"headerlink\" title=\"非打印字符\"></a>非打印字符</h3><table>\n<thead>\n<tr>\n<th>字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>\\cx</td>\n<td style=\"text-align:left\">匹配由x指明的控制字符。例如，\\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的’c’字符。</td>\n</tr>\n<tr>\n<td>\\f</td>\n<td style=\"text-align:left\">匹配一个换页符。等价于 \\x0c 和 \\cL。</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td style=\"text-align:left\">匹配一个换行符。等价于 \\x0a 和 \\cJ。</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td style=\"text-align:left\">匹配一个回车符。等价于 \\x0d 和 \\cM。</td>\n</tr>\n<tr>\n<td>\\s</td>\n<td style=\"text-align:left\">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\S</td>\n<td style=\"text-align:left\">匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td style=\"text-align:left\">匹配一个制表符。等价于 \\x09 和 \\cI。</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td style=\"text-align:left\">匹配一个垂直制表符。等价于 \\x0b 和 \\cK。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"特别字符\"><a href=\"#特别字符\" class=\"headerlink\" title=\"特别字符\"></a>特别字符</h3><p>所谓特殊字符，就是一些有特殊含义的字符，如上面说的”*.txt”中的*，简单的说就是表示任何字符串的意思。如果要查找文件名中有＊的文件，则需要对＊进行转义，即在其前加一个\\。ls *.txt。正则表达式有以下特殊字符。</p>\n<table>\n<thead>\n<tr>\n<th>特别字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$</td>\n<td style=\"text-align:left\">匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。</td>\n</tr>\n<tr>\n<td>( )</td>\n<td style=\"text-align:left\">标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 <code>\\(</code>和 <code>\\)</code>。</td>\n</tr>\n<tr>\n<td>*</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次。要匹配 <em> 字符，请使用 `\\</em>`。</td>\n</tr>\n<tr>\n<td>+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 <code>\\+</code>。</td>\n</tr>\n<tr>\n<td>.</td>\n<td style=\"text-align:left\">匹配除换行符 \\n之外的任何<code>单</code>字符。要匹配 .，请使用 \\。</td>\n</tr>\n<tr>\n<td>[</td>\n<td style=\"text-align:left\">标记一个中括号表达式的开始。要匹配 [，请使用 <code>\\[</code>。</td>\n</tr>\n<tr>\n<td>?</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \\?。</td>\n</tr>\n<tr>\n<td>\\</td>\n<td style=\"text-align:left\">将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘<code>\\\\</code>‘ 匹配 “\\”，而 ‘<code>\\(</code>‘ 则匹配 “<code>(</code>“。</td>\n</tr>\n<tr>\n<td>^</td>\n<td style=\"text-align:left\">匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 <code>\\^</code>。</td>\n</tr>\n<tr>\n<td>{</td>\n<td style=\"text-align:left\">标记限定符表达式的开始。要匹配 {，请使用 <code>\\{</code>。</td>\n</tr>\n<tr>\n<td>丨</td>\n<td style=\"text-align:left\">指明两项之间的一个选择。要匹配 丨，请使用 <code>\\丨</code>。</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>在表格里输入<code>|</code>尝试过<code>\\|</code>，但可以用中文gun来假装一下哈哈哈哈</p>\n</blockquote>\n<h3 id=\"限定符\"><a href=\"#限定符\" class=\"headerlink\" title=\"限定符\"></a>限定符</h3><p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有<em>或+或?或{n}或{n,}或{n,m}共6种。\n</em>、+和?限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。</p>\n<table>\n<thead>\n<tr>\n<th>字符</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>*</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td>\n</tr>\n<tr>\n<td>+</td>\n<td style=\"text-align:left\">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td>\n</tr>\n<tr>\n<td>?</td>\n<td style=\"text-align:left\">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</td>\n</tr>\n<tr>\n<td>{n}</td>\n<td style=\"text-align:left\">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td>\n</tr>\n<tr>\n<td>{n,}</td>\n<td style=\"text-align:left\">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td>\n</tr>\n<tr>\n<td>{n,m}</td>\n<td style=\"text-align:left\">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"定位符\"><a href=\"#定位符\" class=\"headerlink\" title=\"定位符\"></a>定位符</h3><p>用来描述字符串或单词的边界。</p>\n<p>^和$分别指字符串的开始与结束。</p>\n<p>\\b描述单词的前或后边界。</p>\n<p>\\B表示非单词边界。</p>\n<p><strong>注：不能对定位符使用限定符。</strong></p>\n<h2 id=\"操作符优先级\"><a href=\"#操作符优先级\" class=\"headerlink\" title=\"操作符优先级\"></a>操作符优先级</h2><p>转义符 &gt; 圆括号和方括号 &gt; 限定符 &gt; 位置和顺序 &gt; “或”操作</p>\n<h2 id=\"一些匹配规则\"><a href=\"#一些匹配规则\" class=\"headerlink\" title=\"一些匹配规则\"></a>一些匹配规则</h2><p>我们可以用<code>[]</code>来构建一个简单的类。所谓的类就是指符合某些特性的对象，即匹配方括号内任意一个都可。 当在一组方括号里使用^是，它表示“非”或“排除”的意思，常常用来剔除某个字符。即反向类。另外，还给我们提供了范围类，连字号可以表示一个字符的范围，[a-z]即匹配所有的小写字母。</p>\n<p>下面举一些例子：</p>\n<blockquote>\n<p>[a-z] //匹配所有的小写字母<br>[A-Z] //匹配所有的大写字母<br>[a-zA-Z] //匹配所有的字母<br>[0-9] //匹配所有的数字<br>[0-9.-] //匹配所有的数字，句号和减号<br>[ \\f\\r\\t\\n] //匹配所有的白字符<br>\\d    匹配一个数字字符。等价于 [0-9]。<br>\\D    匹配一个非数字字符。等价于 [^0-9]。</p>\n</blockquote>\n<p>另外，特殊字符”.”等价<code>[^\\r\\n]</code>在正规表达式中用来表示除了回车换行之外的所有字符。</p>\n<p>“\\d”等价<code>[0-9]</code>在正规表达式中用来表示数字字符。</p>\n<p>“\\D”等价<code>[^0-9]</code>在正规表达式中用来表示非数字字符。</p>\n<p>“\\s”等价<code>[\\t\\n\\x0B\\f\\r]</code>在正规表达式中用来表示空白符。</p>\n<p>“\\S”等价<code>[^\\t\\n\\x0B\\f\\r]</code>在正规表达式中用来表示非空白符。</p>\n<p>“\\w”等价<code>[a-zA-Z_0-9]</code>在正规表达式中用来表示数字字母下划线。</p>\n<p>“\\W”等价<code>[^a-zA-Z_0-9]</code>在正规表达式中用来表示非单词字符。</p>\n<h3 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h3><p>到现在为止，你已经知道如何去匹配一个字母或数字，但更多的情况下，可能要匹配一个单词或一组数字。一个单词有若干个字母组成，一组数字有若干个单数组成。跟在字符或字符簇后面的花括号({})用来确定前面的内容的重复出现的次数。<br>如：</p>\n<blockquote>\n<p>^a{4}$ aaaa<br>^a{2,}$ 包含多于两个a的字符串<br>^a{1,3}$ a,aa或aaa</p>\n</blockquote>\n<p>这些例子描述了花括号的三种不同的用法。一个数字，{x}的意思是“前面的字符或字符簇只出现x次”；一个数字加逗号，{x,}的意思是“前面的内容出现x或更多的次数”，之前所说的<code>+</code>即表示比配一次或多次，等同于{1,}；两个用逗号分隔的数字，{x,y}表示“前面的内容至少出现x次，但不超过y次”。</p>\n<blockquote>\n<p>^[a-zA-Z0-9_]{1,}$ //所有包含一个以上的字母、数字或下划线的字符串<br>^[0-9]{1,}$ //所有的正数<br>^-{0,1}[0-9]{1,}$ //所有的整数<br>^-{0,1}[0-9]{0,}.{0,1}[0-9]{0,}$ //所有的小数</p>\n</blockquote>\n<p>另外，<code>？</code>字符表示出现零次或一次(最多出现一次)；</p>\n<p><code>+</code>字符表示出现一次或多次(至少出现一次);</p>\n<p><code>*</code>字符表示出现零次或多次(任意次)；</p>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><p>在某些情况，如果想匹配apple3次，估计大家会这样写：<code>apple{3}</code></p>\n<p>可是查找结果却是：<br><img src=\"http://i1.buimg.com/567571/fb6925e616192838.png\" alt=\"错误查找实例\"></p>\n<p>因此，我们需要用到<code>()</code>分组。应该写成<code>(apple){3}</code></p>\n<p>查找结果就是：<img src=\"http://i1.buimg.com/567571/0b326d402a10b11e.png\" alt=\"正确实例\"></p>\n<h3 id=\"选择\"><a href=\"#选择\" class=\"headerlink\" title=\"选择\"></a>选择</h3><p>用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，是相关的匹配会被缓存，此时可用<code>?:</code>放在第一个选项前来消除这种副作用。</p>\n<h3 id=\"反向引用\"><a href=\"#反向引用\" class=\"headerlink\" title=\"反向引用\"></a>反向引用</h3><p>对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左至右所遇到的内容存储。存储子匹配的缓冲区编号从 1 开始，连续编号直至最大 99 个子表达式。每个缓冲区都可以使用 ‘\\n’ 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。</p>\n<p>可以在分组内加上非捕获元字符 ‘?:’, ‘?=’, or ‘?!’ 来忽略对相关匹配的保存。</p>\n<p>(?:pattern)<br>匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。</p>\n<h3 id=\"前瞻\"><a href=\"#前瞻\" class=\"headerlink\" title=\"前瞻\"></a>前瞻</h3><p>正则表达式从文本头部向尾部开始解析，文本尾部方向称为<code>前</code>。</p>\n<p><strong>前瞻</strong>就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾则相反。正向前瞻和负向前瞻就是判断一个正则之后还没有完，还需要在符合一个条件。</p>\n<p>符合和不符合特定断言称之为<strong>肯定/正向</strong>匹配和<strong>否定/反向</strong>匹配。</p>\n<p>正向前瞻　exp(?=assert)</p>\n<p>反向前瞻　exp(?!assert)</p>\n<p>正向后顾　exp(?&lt;=assert)</p>\n<p>反向后顾　exp(?&lt;!assert)</p>\n<p>(js不支持后顾)</p>\n<p>exp为原正则部分，assert部分即断言部分也是正则表达式，<code>?=</code>和<code>?!</code>，前者为正向前瞻，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向前瞻，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。</p>\n<h2 id=\"javascript-中正则表达式的应用\"><a href=\"#javascript-中正则表达式的应用\" class=\"headerlink\" title=\"javascript 中正则表达式的应用\"></a>javascript 中正则表达式的应用</h2><p>js中通过内置对象<strong>REGEXP</strong>支持正则表达式。<br>有两种方法实例化RegExp对象：<br>    1.字面量　var reg = / \\bis\\b /g;<br>    2.构造函数　var reg = new RegExp (‘\\bis\\b’,’g’);/*在Js中\\也是特殊字符所以需要转义,第一个是正则表达式文本，第二个字符串是标志位，g，全局匹配*/</p>\n<h3 id=\"javascript中正则表达式对象的属性\"><a href=\"#javascript中正则表达式对象的属性\" class=\"headerlink\" title=\"javascript中正则表达式对象的属性\"></a>javascript中正则表达式对象的属性</h3><p>g：global　全局匹配，不添加，匹配到第一个为止</p>\n<p>i：ignore case　不分大小写</p>\n<p>m: multiple lines 多行搜索，使^变为新的行首</p>\n<p>lastIndex：是当前表达式匹配内容的最后一个字符的下一个位置</p>\n<p>source：正则表达式的文本字符串</p>\n<h3 id=\"javascript中正则对象本身的方法\"><a href=\"#javascript中正则对象本身的方法\" class=\"headerlink\" title=\"javascript中正则对象本身的方法\"></a>javascript中正则对象本身的方法</h3><h4 id=\"RegExp-prototype-test-str\"><a href=\"#RegExp-prototype-test-str\" class=\"headerlink\" title=\"RegExp.prototype.test(str)\"></a>RegExp.prototype.test(str)</h4><p> 作用：用于测试字符串参数中是否存在匹配正则表达式模式的字符串<br> 符合返回<code>true</code>,否则返回<code>false</code><br> 调用实例：</p>\n <figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"keyword\">reg</span> = / \\bis\\b /<span class=\"keyword\">g</span>;</span><br><span class=\"line\"><span class=\"keyword\">reg</span>.<span class=\"keyword\">test</span>(str);</span><br></pre></td></tr></table></figure>\n<p> 但当使用全局g属性标识时，会修改lastIndex值，在匹配到最后一项之后会重置为0，因此会出现结果为反复的循环true、false，出现结果不稳定</p>\n<p> 其实test的本意，其实就是测试能否匹配上。</p>\n<h4 id=\"RegExp-prototype-exec-str\"><a href=\"#RegExp-prototype-exec-str\" class=\"headerlink\" title=\"RegExp.prototype.exec(str)\"></a>RegExp.prototype.exec(str)</h4><p> 作用：使用正则表达式模式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果。<br> 如果没有匹配到的文本则返回null，否则返回一个结果数组。<br> 此数组有两个属性，<br>     1.index：声明匹配文本的第一个字符的位置<br>     2.input：存放被检索的字符串<code>string</code></p>\n<p> 在非全局调用时，返回数组：</p>\n<p> 第一个元素是与正则表达式相匹配的文本</p>\n<p> 第二个元素是与RegExpObject的第一个子表达式相匹配到的文本</p>\n<p> 第三个元素是与RegExpObject的第二个子表达式相匹配到的文本，以此类推</p>\n<h3 id=\"javascript中字符串的方法\"><a href=\"#javascript中字符串的方法\" class=\"headerlink\" title=\"javascript中字符串的方法\"></a>javascript中字符串的方法</h3><h4 id=\"String-prototype-search-reg\"><a href=\"#String-prototype-search-reg\" class=\"headerlink\" title=\"String.prototype.search(reg)\"></a>String.prototype.search(reg)</h4><p> 作用：用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串。<br> 方法返回第一个匹配结果 index，查找不到返回-1<br> 不执行全局匹配，忽略g，总是从字符串的开始进行搜索。</p>\n<h4 id=\"String-prototype-match-reg\"><a href=\"#String-prototype-match-reg\" class=\"headerlink\" title=\"String.prototype.match(reg)\"></a>String.prototype.match(reg)</h4><p> 作用：用于检索字符串，以找到一个或多个与regxp匹配的文本<br> regxp是否具有标志位g对结果影响很大</p>\n<p> 在非全局调用时，返回数组，没有匹配到的文本则返回null</p>\n<p> 返回数组第一个元素存放的是匹配文本，而其余的元素存放的是与正则表达式的子表达式匹配的文本</p>\n<p> 除了常规的数组元素之外，返回的数组还含有2个对象属性<br>     1.index：声明匹配文本的第一个字符的位置<br>     2.input：声明对stringObject的引用</p>\n<p> 而在全局调用时，返回的数组存放的是字符串中所有的匹配子串，而且也没有index和input属性，就告诉你匹配结果。</p>\n<h4 id=\"String-prototype-split-reg\"><a href=\"#String-prototype-split-reg\" class=\"headerlink\" title=\"String.prototype.split(reg)\"></a>String.prototype.split(reg)</h4><p> 作用：我们经常用split来把字符串分割为字符数组，而在一些复杂的情况下我们可以用正则表达式来分割。</p>\n<h4 id=\"String-prototype-replace-reg\"><a href=\"#String-prototype-replace-reg\" class=\"headerlink\" title=\"String.prototype.replace(reg)\"></a>String.prototype.replace(reg)</h4><p> 作用：替换内容,三种方法。<br> replace(str,replaceStr)<br> replace(reg,replaceStr)<br> replace(reg,function)　如将a1b2c3替换为a2b3c4</p>\n<h5 id=\"function-match-group-index-origin-参数含义\"><a href=\"#function-match-group-index-origin-参数含义\" class=\"headerlink\" title=\"function(match,group,index,origin)参数含义\"></a>function(match,group,index,origin)参数含义</h5><p> function会在每次匹配替换时调用，有4个参数<br>     1.匹配字符串<br>     2.正则表达式分组内容，没有分组则没有参数<br>     3.匹配项在字符串中的index<br>     4.原字符串</p>\n<hr>\n<p>正则表达式测试工具：<a href=\"https://regexper.com\" target=\"_blank\" rel=\"noopener\">https://regexper.com</a></p>"},{"title":"排序性能比较","date":"2016-10-25T13:22:50.000Z","_content":"常见的算法思想有：分治法(繁分为简)、贪心法相对比较满意的解去运算，而不考虑所有的情况)、穷举法(全列出)、递归法(返回本身)、递推法(按照规律求解)、回溯法(退上一步)、动态规划法(寻找最优解)，迭代法(由旧推新)，分支界限法(问题分支分界)。\n<!-- more -->\n所谓排序，就是讲原来无序的一个序列重新排列成有序序列。\n\n**常见的排序算法，包括：冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序和队排序。**冒泡排序、选择排序、插入排序的时间复杂度为O(n^2),希尔排序的时间复杂度为O(n^1.25)，快速排序、归并排序和堆排序的时间复杂度为O(nlog2(n))。\n\n性能的好坏，看重其稳定性。所谓的稳定性，是指代排序的两个或两个以上相同的项，在排序前后这些相同的项相对位置有没有发生变化。\n\n如果要求不能重复，则排序结果是唯一的，那么选择的排序方法稳定与否就无关紧要。如果可以冲去，就要根据实际需求来选择。\n\n那么哪些排序算法是不稳定的呢？\n\n**“快些选堆”**：其中“快”指的是快速排序，“些”值得书希尔排序，“选”指的是选择排序，“堆”指的是堆排序，这四种是不稳定的，其他是稳定的。\n\n\n## 排序算法分类\n\n1.插入类排序\n即在一个已经有序的序列中，插入一个新数。这类排序有：直接排序、折半排序、希尔排序。\n\n2.交换类排序\n这类方法的核心是“交换”，即每趟排都是通过一系列的“交换”来完成的。这类排序有冒泡排序、快速排序。\n\n3.选择类排序\n该方法的核心是“选择”，即每趟排序都选出一个最小（或最大）的记录，把它和序列中的第一个（或最后一个）记录交换，这样最小（或最大）的记录到位。这类排序有：选择排序、堆排序。\n\n4.归并类排序\n所谓归并，就是将两个或两个以上的有序序列合并成一个新的有序序列。这类排序有：（二路）归并排序。\n\n5.基数类排序\n此类方法较为特别，是基于多关键字排序的思想，把一个逻辑关键字拆分成多个关键字。\n\n## 排序算法分析\n本文主要分析的排序算法有：冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、堆排序。\n\n### 插入排序\n算法思想：每趟将一个待排序的关键字，按照其关键字值的大小插入到已经排好的部分序列的适当位置上，直到插入完成。由大到小排，后往前插。空间复杂度O(1)。\n\n```\n'''insertion sort'''\ndef insertion_sort(sort_list):\n    iter_len = len(sort_list)\n    if iter_len<2:\n        return sort_list\n    for i in range(1,iter_len):\n        key = sort_list[i]\n        location = i\n        for j in range(i-1,-1,-1):\n            if sort_list[j]>key:\n                sort_list[j+1] = sort_list[j]\n                location = j\n        sort_list[location] = key\n    return sort_list\n\n```\n### 希尔排序\n\n算法思想：希尔排序又叫做缩小增量排序，是将待排序的序列按某种规则分成几个子序列，分别对这几个子序列进行插入排序，其中这一规则就是增量。如可以使用增量为总长的一半，再一半，直至1来分格序列，且每一趟希尔排序的增量都是逐渐缩小的，希尔排序的每趟排序都会使得整个序列变得更加有序，等整个序列基本有序了，再使用一趟插入排序，这样会更有效率，这就是希尔排序的思想。\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ndef shell_sort(sort_list):\n    iter_len = len(sort_list)\n    if iter_len < 2:\n        return sort_list\n    gap = iter_len / 2\n    while gap > 0:\n        for i in range(0, gap):\n            for j in range(i + gap, iter_len, gap):\n                if (sort_list[j] < sort_list[j - gap]):\n                    key = sort_list[j]\n                    k = j - gap\n                    while k >= 0 and sort_list[k]>key:\n                        sort_list[k + gap] = sort_list[k]\n                        k -= gap\n\n                    sort_list[k + gap] = key\n        gap /= 2\n\n    return sort_list\n\n```\n### 冒泡排序\n\n算法思想：相邻两个数逐次比较，选出大的往下走，小的上浮，每一趟遍历将最大的沉到最后。时间复杂度O(n^2)。\n```\ndef bubble_sort(sort_list):\n    iter_len = len(sort_list)\n    if iter_len<2:\n        return sort_list\n    for i in range(iter_len-1):\n        for j in range(iter_len-1-i):\n            if sort_list[j]>sort_list[j+1]:\n                sort_list[j],sort_list[j+1]=sort_list[j+1],sort_list[j]\n\n    return sort_list\n```\n### 快速排序\n算法思想：一趟快速排序是以一个枢轴，将序列分成两部分，枢轴的一边比它小（或小于等于），另一边比它大（或大于等于）。\n\n一遍快速排序结果：\n1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；\n2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；\n3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；\n4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；\n5）重复第3、4步，直到i=j；\n\n算法性能：快速排序最好情况下时间复杂度为O(nlogn)，待排序列越接近无序，则该算法效率越高，在最坏情况下时间复杂度为O(n*n)，待排序列越接 近有序，则该算法效率越低，算法的平均时间复杂度为O(nlogn)。就平均时间而言，快速排序是所有排序算法中最好的。该算法的空间复杂度为 O(logn)，快速排序是递归进行的，需要栈的辅助，因此需要的辅助空间比前面几类排序方法要多。\n\n快速排序的效率和选取的“枢轴”有关，选取的枢轴越接近中间值，算法效率就越高，因此为了提高算法效率，可以在第一次选取“枢轴”时做文章，\n```\n#!/usr/bin/env lowython\n# -*- coding: utf-8 -*-\nclass quick_sort(object):\n    def _partition(self, alist, low, high):\n        i, j = low, high\n        x = alist[low]\n        while i < j:\n            while i < j and alist[j] >= x:\n                j -= 1\n            if i < j:\n                alist[i] = alist[j]\n                i += 1\n            while i < j and alist[i] <= x:\n                i += 1\n            if i < j:\n                alist[j] = alist[i]\n                j -= 1\n        alist[i] = x\n        return i\n\n    def _quicksort(self, alist, low, high):\n        if low < high:\n            q = self._partition(alist, low, high)\n            self._quicksort(alist, low, q - 1)\n            self._quicksort(alist, q + 1, high)\n\n    def __call__(self, sort_list):\n        self._quicksort(sort_list, 0, len(sort_list) - 1)\n        return sort_list\n\n```\n在快速排序中，需要使用递归来分别处理左右子段，递归深度可以理解为系统栈自动保存的深度，先处理短的分段再处理长的分段，可以减少时间复杂度。\n\n如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完。短的优先的话，他是作为一个整体保存在栈中的，所以递归栈中的保留数据少一些。\n### 选择排序\n算法思想：该算法的主要动作就是“选择”，采用简单的选择方式，从头至尾顺序扫描序列，找出最小的一个记录，和第一个记录交换，接着从剩下的记录中继续这种选择和交换，最终使序列有序。\n```\ndef selection_sort(sort_list):\n    iter_len = len(sort_list)\n    if iter_len<2:\n        return sort_list\n    for i in range(iter_len-1):\n        smallest = sort_list[i]\n        location = i\n        for j in range(i+1,iter_len):\n            if sort_list[j]<smallest:\n                smallest = sort_list[j]\n                location = j\n        if i !=location:\n            sort_list[i],sort_list[location]= sort_list[location],sort_list[i]\n    return sort_list\n\n```\n\n### 堆排序\n\n算法思想：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] >= A[i]。\n\n根据堆的定义，其根节点的值是最大（或最小），因此将一个无序序列 调整为一个堆，就可以找出这个序列的最大（或最小）值，然后将找出的这个值交换到序列的最后（或最前），这样有序序列元素增加1个，无序序列中元素减少1 个，对新的无序序列重复这样的操作，就实现了序列排序。堆排序中最关键的操作是将序列调整为堆，整个排序的过程就是通过不断调整使得不符合堆定义的完全二叉树变为符合堆定义的完全二叉树的过程。\n\n```\nclass heap_sort(object):\n    def _max_heapify(self, alist, i, heap_size=None):\n        length = len(alist)\n        if heap_size is None:\n            heap_size = length\n        l = 2 * i + 1\n        r = 2 * i + 2\n        largest = i\n        if l < heap_size and alist[l] > alist[i]:\n            largest = l\n        if l < heap_size and alist[r] > alist[i]:\n            largest = r\n        if largest != i:\n            alist[i], alist[largest] = alist[largest], alist[i]\n            self._max_heapify(alist, largest, heap_size)\n\n    def _build_max_heap(self, alist):\n        root_end = int(len(alist) / 2)\n        for i in range(root_end-1,-1,-1):\n            self._max_heapify(alist,i)\n\n    def __call__(self, sort_list):\n        self._build_max_heap(sort_list)\n        heap_size = len(sort_list)\n        for i in range(len(sort_list)-1,0,-1):\n            sort_list[0],sort_list[i]=sort_list[i],sort_list[0]\n            heap_size -=1\n            self._max_heapify(sort_list, 0, heap_size)\n        return sort_list\n\n```\n\n### 归并排序\n算法思想：归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n\n归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。\n\n```\nclass merge_sort(object):\n    def _erge(self, alist, p, q, r):\n        left = alist[p:q + 1]\n        right = alist[q + 1:r + 1]\n        for i in range(p, r + 1):\n            if len(left) > 0 and len(right) > 0:\n                if left[0] <= right[0]:\n                    alist[i] = left.pop(0)\n                else:\n                    alist[i] = right.pop(0)\n            elif len(right) == 0:\n                alist[i] = left.pop(0)\n            elif len(left) == 0:\n                alist[i] = right.pop(0)\n\n    def _merge_sort(self, alist, p, r):\n        if p < r:\n            q = int((p + r) / 2)\n            self._merge_sort(alist, p, q)\n            self._merge_sort(alist, q + 1, r)\n            self._merge(alist, p, q, r)\n\n    def __call__(self, sort_list):\n        self._merge_sort(sort_list, 0, len(sort_list) - 1)\n        return sort_list\n\n```\n### 基数排序\n算法思想：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。\n\n```\nimport math\ndef radix_sort(lists, radix=10):\n    k = int(math.ceil(math.log(max(lists), radix)))\n    bucket = [[] for i in range(radix)]\n    for i in range(1, k+1):\n        for j in lists:\n            bucket[j/(radix**(i-1)) % (radix**i)].append(j)\n        del lists[:]\n        for z in bucket:\n            lists += z\n            del z[:]\n    return lists\n```\n### 一些结论\n（1）快速排序、希尔排序、归并排序、堆排序的平均时间为O(nlogn)，其他的为O(n*n)。\n\n（2）快速排序、希尔排序、选择排序、堆排序不稳定，其他的稳定。\n\n（3）经过一趟排序能够保证一个元素到达最终位置的是冒泡排序、快速排序、选择排序、堆排序。\n\n（4）元素比较次数和原始序列无关的是选择排序、折半插入排序。\n\n（5）排序趟数和原始序列有关的是交换类排序。\n\n（6）直接插入排序和折半插入排序的区别是寻找插入位置的方式不同，一个是按顺序查找方式，另一个是按折半查找方式。\n\n----\n参考资料：\n[博客园](http://www.cnblogs.com/twobin)\n\n[宁哥的小站](http://www.lining0806.com/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/)\n\n[八大排序算法的Python实现](http://blog.2liang.me/2015/09/24/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84Python%E5%AE%9E%E7%8E%B0/)","source":"_posts/通用杂货/排序性能比较.md","raw":"---\ntitle: 排序性能比较\ndate: 2016-10-25 21:22:50\ntags: \n- 算法\ncategories: 总结\n---\n常见的算法思想有：分治法(繁分为简)、贪心法相对比较满意的解去运算，而不考虑所有的情况)、穷举法(全列出)、递归法(返回本身)、递推法(按照规律求解)、回溯法(退上一步)、动态规划法(寻找最优解)，迭代法(由旧推新)，分支界限法(问题分支分界)。\n<!-- more -->\n所谓排序，就是讲原来无序的一个序列重新排列成有序序列。\n\n**常见的排序算法，包括：冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序和队排序。**冒泡排序、选择排序、插入排序的时间复杂度为O(n^2),希尔排序的时间复杂度为O(n^1.25)，快速排序、归并排序和堆排序的时间复杂度为O(nlog2(n))。\n\n性能的好坏，看重其稳定性。所谓的稳定性，是指代排序的两个或两个以上相同的项，在排序前后这些相同的项相对位置有没有发生变化。\n\n如果要求不能重复，则排序结果是唯一的，那么选择的排序方法稳定与否就无关紧要。如果可以冲去，就要根据实际需求来选择。\n\n那么哪些排序算法是不稳定的呢？\n\n**“快些选堆”**：其中“快”指的是快速排序，“些”值得书希尔排序，“选”指的是选择排序，“堆”指的是堆排序，这四种是不稳定的，其他是稳定的。\n\n\n## 排序算法分类\n\n1.插入类排序\n即在一个已经有序的序列中，插入一个新数。这类排序有：直接排序、折半排序、希尔排序。\n\n2.交换类排序\n这类方法的核心是“交换”，即每趟排都是通过一系列的“交换”来完成的。这类排序有冒泡排序、快速排序。\n\n3.选择类排序\n该方法的核心是“选择”，即每趟排序都选出一个最小（或最大）的记录，把它和序列中的第一个（或最后一个）记录交换，这样最小（或最大）的记录到位。这类排序有：选择排序、堆排序。\n\n4.归并类排序\n所谓归并，就是将两个或两个以上的有序序列合并成一个新的有序序列。这类排序有：（二路）归并排序。\n\n5.基数类排序\n此类方法较为特别，是基于多关键字排序的思想，把一个逻辑关键字拆分成多个关键字。\n\n## 排序算法分析\n本文主要分析的排序算法有：冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、堆排序。\n\n### 插入排序\n算法思想：每趟将一个待排序的关键字，按照其关键字值的大小插入到已经排好的部分序列的适当位置上，直到插入完成。由大到小排，后往前插。空间复杂度O(1)。\n\n```\n'''insertion sort'''\ndef insertion_sort(sort_list):\n    iter_len = len(sort_list)\n    if iter_len<2:\n        return sort_list\n    for i in range(1,iter_len):\n        key = sort_list[i]\n        location = i\n        for j in range(i-1,-1,-1):\n            if sort_list[j]>key:\n                sort_list[j+1] = sort_list[j]\n                location = j\n        sort_list[location] = key\n    return sort_list\n\n```\n### 希尔排序\n\n算法思想：希尔排序又叫做缩小增量排序，是将待排序的序列按某种规则分成几个子序列，分别对这几个子序列进行插入排序，其中这一规则就是增量。如可以使用增量为总长的一半，再一半，直至1来分格序列，且每一趟希尔排序的增量都是逐渐缩小的，希尔排序的每趟排序都会使得整个序列变得更加有序，等整个序列基本有序了，再使用一趟插入排序，这样会更有效率，这就是希尔排序的思想。\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ndef shell_sort(sort_list):\n    iter_len = len(sort_list)\n    if iter_len < 2:\n        return sort_list\n    gap = iter_len / 2\n    while gap > 0:\n        for i in range(0, gap):\n            for j in range(i + gap, iter_len, gap):\n                if (sort_list[j] < sort_list[j - gap]):\n                    key = sort_list[j]\n                    k = j - gap\n                    while k >= 0 and sort_list[k]>key:\n                        sort_list[k + gap] = sort_list[k]\n                        k -= gap\n\n                    sort_list[k + gap] = key\n        gap /= 2\n\n    return sort_list\n\n```\n### 冒泡排序\n\n算法思想：相邻两个数逐次比较，选出大的往下走，小的上浮，每一趟遍历将最大的沉到最后。时间复杂度O(n^2)。\n```\ndef bubble_sort(sort_list):\n    iter_len = len(sort_list)\n    if iter_len<2:\n        return sort_list\n    for i in range(iter_len-1):\n        for j in range(iter_len-1-i):\n            if sort_list[j]>sort_list[j+1]:\n                sort_list[j],sort_list[j+1]=sort_list[j+1],sort_list[j]\n\n    return sort_list\n```\n### 快速排序\n算法思想：一趟快速排序是以一个枢轴，将序列分成两部分，枢轴的一边比它小（或小于等于），另一边比它大（或大于等于）。\n\n一遍快速排序结果：\n1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；\n2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；\n3）从j开始向前搜索，即由后开始向前搜索(j--)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；\n4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；\n5）重复第3、4步，直到i=j；\n\n算法性能：快速排序最好情况下时间复杂度为O(nlogn)，待排序列越接近无序，则该算法效率越高，在最坏情况下时间复杂度为O(n*n)，待排序列越接 近有序，则该算法效率越低，算法的平均时间复杂度为O(nlogn)。就平均时间而言，快速排序是所有排序算法中最好的。该算法的空间复杂度为 O(logn)，快速排序是递归进行的，需要栈的辅助，因此需要的辅助空间比前面几类排序方法要多。\n\n快速排序的效率和选取的“枢轴”有关，选取的枢轴越接近中间值，算法效率就越高，因此为了提高算法效率，可以在第一次选取“枢轴”时做文章，\n```\n#!/usr/bin/env lowython\n# -*- coding: utf-8 -*-\nclass quick_sort(object):\n    def _partition(self, alist, low, high):\n        i, j = low, high\n        x = alist[low]\n        while i < j:\n            while i < j and alist[j] >= x:\n                j -= 1\n            if i < j:\n                alist[i] = alist[j]\n                i += 1\n            while i < j and alist[i] <= x:\n                i += 1\n            if i < j:\n                alist[j] = alist[i]\n                j -= 1\n        alist[i] = x\n        return i\n\n    def _quicksort(self, alist, low, high):\n        if low < high:\n            q = self._partition(alist, low, high)\n            self._quicksort(alist, low, q - 1)\n            self._quicksort(alist, q + 1, high)\n\n    def __call__(self, sort_list):\n        self._quicksort(sort_list, 0, len(sort_list) - 1)\n        return sort_list\n\n```\n在快速排序中，需要使用递归来分别处理左右子段，递归深度可以理解为系统栈自动保存的深度，先处理短的分段再处理长的分段，可以减少时间复杂度。\n\n如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完。短的优先的话，他是作为一个整体保存在栈中的，所以递归栈中的保留数据少一些。\n### 选择排序\n算法思想：该算法的主要动作就是“选择”，采用简单的选择方式，从头至尾顺序扫描序列，找出最小的一个记录，和第一个记录交换，接着从剩下的记录中继续这种选择和交换，最终使序列有序。\n```\ndef selection_sort(sort_list):\n    iter_len = len(sort_list)\n    if iter_len<2:\n        return sort_list\n    for i in range(iter_len-1):\n        smallest = sort_list[i]\n        location = i\n        for j in range(i+1,iter_len):\n            if sort_list[j]<smallest:\n                smallest = sort_list[j]\n                location = j\n        if i !=location:\n            sort_list[i],sort_list[location]= sort_list[location],sort_list[i]\n    return sort_list\n\n```\n\n### 堆排序\n\n算法思想：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] >= A[i]。\n\n根据堆的定义，其根节点的值是最大（或最小），因此将一个无序序列 调整为一个堆，就可以找出这个序列的最大（或最小）值，然后将找出的这个值交换到序列的最后（或最前），这样有序序列元素增加1个，无序序列中元素减少1 个，对新的无序序列重复这样的操作，就实现了序列排序。堆排序中最关键的操作是将序列调整为堆，整个排序的过程就是通过不断调整使得不符合堆定义的完全二叉树变为符合堆定义的完全二叉树的过程。\n\n```\nclass heap_sort(object):\n    def _max_heapify(self, alist, i, heap_size=None):\n        length = len(alist)\n        if heap_size is None:\n            heap_size = length\n        l = 2 * i + 1\n        r = 2 * i + 2\n        largest = i\n        if l < heap_size and alist[l] > alist[i]:\n            largest = l\n        if l < heap_size and alist[r] > alist[i]:\n            largest = r\n        if largest != i:\n            alist[i], alist[largest] = alist[largest], alist[i]\n            self._max_heapify(alist, largest, heap_size)\n\n    def _build_max_heap(self, alist):\n        root_end = int(len(alist) / 2)\n        for i in range(root_end-1,-1,-1):\n            self._max_heapify(alist,i)\n\n    def __call__(self, sort_list):\n        self._build_max_heap(sort_list)\n        heap_size = len(sort_list)\n        for i in range(len(sort_list)-1,0,-1):\n            sort_list[0],sort_list[i]=sort_list[i],sort_list[0]\n            heap_size -=1\n            self._max_heapify(sort_list, 0, heap_size)\n        return sort_list\n\n```\n\n### 归并排序\n算法思想：归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n\n归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。\n\n```\nclass merge_sort(object):\n    def _erge(self, alist, p, q, r):\n        left = alist[p:q + 1]\n        right = alist[q + 1:r + 1]\n        for i in range(p, r + 1):\n            if len(left) > 0 and len(right) > 0:\n                if left[0] <= right[0]:\n                    alist[i] = left.pop(0)\n                else:\n                    alist[i] = right.pop(0)\n            elif len(right) == 0:\n                alist[i] = left.pop(0)\n            elif len(left) == 0:\n                alist[i] = right.pop(0)\n\n    def _merge_sort(self, alist, p, r):\n        if p < r:\n            q = int((p + r) / 2)\n            self._merge_sort(alist, p, q)\n            self._merge_sort(alist, q + 1, r)\n            self._merge(alist, p, q, r)\n\n    def __call__(self, sort_list):\n        self._merge_sort(sort_list, 0, len(sort_list) - 1)\n        return sort_list\n\n```\n### 基数排序\n算法思想：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。\n\n```\nimport math\ndef radix_sort(lists, radix=10):\n    k = int(math.ceil(math.log(max(lists), radix)))\n    bucket = [[] for i in range(radix)]\n    for i in range(1, k+1):\n        for j in lists:\n            bucket[j/(radix**(i-1)) % (radix**i)].append(j)\n        del lists[:]\n        for z in bucket:\n            lists += z\n            del z[:]\n    return lists\n```\n### 一些结论\n（1）快速排序、希尔排序、归并排序、堆排序的平均时间为O(nlogn)，其他的为O(n*n)。\n\n（2）快速排序、希尔排序、选择排序、堆排序不稳定，其他的稳定。\n\n（3）经过一趟排序能够保证一个元素到达最终位置的是冒泡排序、快速排序、选择排序、堆排序。\n\n（4）元素比较次数和原始序列无关的是选择排序、折半插入排序。\n\n（5）排序趟数和原始序列有关的是交换类排序。\n\n（6）直接插入排序和折半插入排序的区别是寻找插入位置的方式不同，一个是按顺序查找方式，另一个是按折半查找方式。\n\n----\n参考资料：\n[博客园](http://www.cnblogs.com/twobin)\n\n[宁哥的小站](http://www.lining0806.com/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/)\n\n[八大排序算法的Python实现](http://blog.2liang.me/2015/09/24/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84Python%E5%AE%9E%E7%8E%B0/)","slug":"通用杂货/排序性能比较","published":1,"updated":"2019-03-22T14:44:36.741Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn1400az4l3nv5y4wahd","content":"<p>常见的算法思想有：分治法(繁分为简)、贪心法相对比较满意的解去运算，而不考虑所有的情况)、穷举法(全列出)、递归法(返回本身)、递推法(按照规律求解)、回溯法(退上一步)、动态规划法(寻找最优解)，迭代法(由旧推新)，分支界限法(问题分支分界)。<br><a id=\"more\"></a><br>所谓排序，就是讲原来无序的一个序列重新排列成有序序列。</p>\n<p><strong>常见的排序算法，包括：冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序和队排序。</strong>冒泡排序、选择排序、插入排序的时间复杂度为O(n^2),希尔排序的时间复杂度为O(n^1.25)，快速排序、归并排序和堆排序的时间复杂度为O(nlog2(n))。</p>\n<p>性能的好坏，看重其稳定性。所谓的稳定性，是指代排序的两个或两个以上相同的项，在排序前后这些相同的项相对位置有没有发生变化。</p>\n<p>如果要求不能重复，则排序结果是唯一的，那么选择的排序方法稳定与否就无关紧要。如果可以冲去，就要根据实际需求来选择。</p>\n<p>那么哪些排序算法是不稳定的呢？</p>\n<p><strong>“快些选堆”</strong>：其中“快”指的是快速排序，“些”值得书希尔排序，“选”指的是选择排序，“堆”指的是堆排序，这四种是不稳定的，其他是稳定的。</p>\n<h2 id=\"排序算法分类\"><a href=\"#排序算法分类\" class=\"headerlink\" title=\"排序算法分类\"></a>排序算法分类</h2><p>1.插入类排序<br>即在一个已经有序的序列中，插入一个新数。这类排序有：直接排序、折半排序、希尔排序。</p>\n<p>2.交换类排序<br>这类方法的核心是“交换”，即每趟排都是通过一系列的“交换”来完成的。这类排序有冒泡排序、快速排序。</p>\n<p>3.选择类排序<br>该方法的核心是“选择”，即每趟排序都选出一个最小（或最大）的记录，把它和序列中的第一个（或最后一个）记录交换，这样最小（或最大）的记录到位。这类排序有：选择排序、堆排序。</p>\n<p>4.归并类排序<br>所谓归并，就是将两个或两个以上的有序序列合并成一个新的有序序列。这类排序有：（二路）归并排序。</p>\n<p>5.基数类排序<br>此类方法较为特别，是基于多关键字排序的思想，把一个逻辑关键字拆分成多个关键字。</p>\n<h2 id=\"排序算法分析\"><a href=\"#排序算法分析\" class=\"headerlink\" title=\"排序算法分析\"></a>排序算法分析</h2><p>本文主要分析的排序算法有：冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、堆排序。</p>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>算法思想：每趟将一个待排序的关键字，按照其关键字值的大小插入到已经排好的部分序列的适当位置上，直到插入完成。由大到小排，后往前插。空间复杂度O(1)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'''insertion sort'''</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insertion_sort</span><span class=\"params\">(sort_list)</span>:</span></span><br><span class=\"line\">    iter_len = len(sort_list)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> iter_len&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,iter_len):</span><br><span class=\"line\">        key = sort_list[i]</span><br><span class=\"line\">        location = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> sort_list[j]&gt;key:</span><br><span class=\"line\">                sort_list[j+<span class=\"number\">1</span>] = sort_list[j]</span><br><span class=\"line\">                location = j</span><br><span class=\"line\">        sort_list[location] = key</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>算法思想：希尔排序又叫做缩小增量排序，是将待排序的序列按某种规则分成几个子序列，分别对这几个子序列进行插入排序，其中这一规则就是增量。如可以使用增量为总长的一半，再一半，直至1来分格序列，且每一趟希尔排序的增量都是逐渐缩小的，希尔排序的每趟排序都会使得整个序列变得更加有序，等整个序列基本有序了，再使用一趟插入排序，这样会更有效率，这就是希尔排序的思想。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shell_sort</span><span class=\"params\">(sort_list)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    iter_len = len(sort_list)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> iter_len &lt; <span class=\"number\">2</span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br><span class=\"line\">    gap = iter_len / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> gap &gt; <span class=\"number\">0</span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, gap)<span class=\"symbol\">:</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i + gap, iter_len, gap)<span class=\"symbol\">:</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sort_list[j] &lt; sort_list[j - gap])<span class=\"symbol\">:</span></span><br><span class=\"line\">                    key = sort_list[j]</span><br><span class=\"line\">                    k = j - gap</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> k &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> sort_list[k]&gt;<span class=\"symbol\">key:</span></span><br><span class=\"line\">                        sort_list[k + gap] = sort_list[k]</span><br><span class=\"line\">                        k -= gap</span><br><span class=\"line\"></span><br><span class=\"line\">                    sort_list[k + gap] = key</span><br><span class=\"line\">        gap /= <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>算法思想：相邻两个数逐次比较，选出大的往下走，小的上浮，每一趟遍历将最大的沉到最后。时间复杂度O(n^2)。<br><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def bubble_sort(sort_list):</span><br><span class=\"line\">    iter_len = len(sort_list)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> iter_len&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">i</span> in range(iter_len<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"built_in\">j</span> in range(iter_len<span class=\"number\">-1</span>-<span class=\"built_in\">i</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> sort_list[<span class=\"built_in\">j</span>]&gt;sort_list[<span class=\"built_in\">j</span>+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                sort_list[<span class=\"built_in\">j</span>],sort_list[<span class=\"built_in\">j</span>+<span class=\"number\">1</span>]=sort_list[<span class=\"built_in\">j</span>+<span class=\"number\">1</span>],sort_list[<span class=\"built_in\">j</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>算法思想：一趟快速排序是以一个枢轴，将序列分成两部分，枢轴的一边比它小（或小于等于），另一边比它大（或大于等于）。</p>\n<p>一遍快速排序结果：<br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>5）重复第3、4步，直到i=j；</p>\n<p>算法性能：快速排序最好情况下时间复杂度为O(nlogn)，待排序列越接近无序，则该算法效率越高，在最坏情况下时间复杂度为O(n*n)，待排序列越接 近有序，则该算法效率越低，算法的平均时间复杂度为O(nlogn)。就平均时间而言，快速排序是所有排序算法中最好的。该算法的空间复杂度为 O(logn)，快速排序是递归进行的，需要栈的辅助，因此需要的辅助空间比前面几类排序方法要多。</p>\n<p>快速排序的效率和选取的“枢轴”有关，选取的枢轴越接近中间值，算法效率就越高，因此为了提高算法效率，可以在第一次选取“枢轴”时做文章，<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env lowython</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">quick_sort</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_partition</span><span class=\"params\">(<span class=\"keyword\">self</span>, alist, low, high)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        i, j = low, high</span><br><span class=\"line\">        x = alist[low]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; <span class=\"symbol\">j:</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; j <span class=\"keyword\">and</span> alist[j] &gt;= <span class=\"symbol\">x:</span></span><br><span class=\"line\">                j -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt; <span class=\"symbol\">j:</span></span><br><span class=\"line\">                alist[i] = alist[j]</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; j <span class=\"keyword\">and</span> alist[i] &lt;= <span class=\"symbol\">x:</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt; <span class=\"symbol\">j:</span></span><br><span class=\"line\">                alist[j] = alist[i]</span><br><span class=\"line\">                j -= <span class=\"number\">1</span></span><br><span class=\"line\">        alist[i] = x</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_quicksort</span><span class=\"params\">(<span class=\"keyword\">self</span>, alist, low, high)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> low &lt; <span class=\"symbol\">high:</span></span><br><span class=\"line\">            q = <span class=\"keyword\">self</span>._partition(alist, low, high)</span><br><span class=\"line\">            <span class=\"keyword\">self</span>._quicksort(alist, low, q - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">self</span>._quicksort(alist, q + <span class=\"number\">1</span>, high)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(<span class=\"keyword\">self</span>, sort_list)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>._quicksort(sort_list, <span class=\"number\">0</span>, len(sort_list) - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure></p>\n<p>在快速排序中，需要使用递归来分别处理左右子段，递归深度可以理解为系统栈自动保存的深度，先处理短的分段再处理长的分段，可以减少时间复杂度。</p>\n<p>如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完。短的优先的话，他是作为一个整体保存在栈中的，所以递归栈中的保留数据少一些。</p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>算法思想：该算法的主要动作就是“选择”，采用简单的选择方式，从头至尾顺序扫描序列，找出最小的一个记录，和第一个记录交换，接着从剩下的记录中继续这种选择和交换，最终使序列有序。<br><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def selection_sort(sort_list):</span><br><span class=\"line\">    iter_len = len(sort_list)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> iter_len&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">i</span> in range(iter_len<span class=\"number\">-1</span>):</span><br><span class=\"line\">        smallest = sort_list[<span class=\"built_in\">i</span>]</span><br><span class=\"line\">        location = <span class=\"built_in\">i</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"built_in\">j</span> in range(<span class=\"built_in\">i</span>+<span class=\"number\">1</span>,iter_len):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> sort_list[<span class=\"built_in\">j</span>]&lt;smallest:</span><br><span class=\"line\">                smallest = sort_list[<span class=\"built_in\">j</span>]</span><br><span class=\"line\">                location = <span class=\"built_in\">j</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">i</span> !=location:</span><br><span class=\"line\">            sort_list[<span class=\"built_in\">i</span>],sort_list[location]= sort_list[location],sort_list[<span class=\"built_in\">i</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><p>算法思想：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。</p>\n<p>根据堆的定义，其根节点的值是最大（或最小），因此将一个无序序列 调整为一个堆，就可以找出这个序列的最大（或最小）值，然后将找出的这个值交换到序列的最后（或最前），这样有序序列元素增加1个，无序序列中元素减少1 个，对新的无序序列重复这样的操作，就实现了序列排序。堆排序中最关键的操作是将序列调整为堆，整个排序的过程就是通过不断调整使得不符合堆定义的完全二叉树变为符合堆定义的完全二叉树的过程。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">heap_sort</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_max_heapify</span><span class=\"params\">(<span class=\"keyword\">self</span>, alist, i, heap_size=None)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        length = len(alist)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> heap_size is <span class=\"symbol\">None:</span></span><br><span class=\"line\">            heap_size = length</span><br><span class=\"line\">        l = <span class=\"number\">2</span> * i + <span class=\"number\">1</span></span><br><span class=\"line\">        r = <span class=\"number\">2</span> * i + <span class=\"number\">2</span></span><br><span class=\"line\">        largest = i</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l &lt; heap_size <span class=\"keyword\">and</span> alist[l] &gt; alist[i]<span class=\"symbol\">:</span></span><br><span class=\"line\">            largest = l</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l &lt; heap_size <span class=\"keyword\">and</span> alist[r] &gt; alist[i]<span class=\"symbol\">:</span></span><br><span class=\"line\">            largest = r</span><br><span class=\"line\">        <span class=\"keyword\">if</span> largest != <span class=\"symbol\">i:</span></span><br><span class=\"line\">            alist[i], alist[largest] = alist[largest], alist[i]</span><br><span class=\"line\">            <span class=\"keyword\">self</span>._max_heapify(alist, largest, heap_size)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_build_max_heap</span><span class=\"params\">(<span class=\"keyword\">self</span>, alist)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        root_end = int(len(alist) / <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(root_end-<span class=\"number\">1</span>,-<span class=\"number\">1</span>,-<span class=\"number\">1</span>)<span class=\"symbol\">:</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>._max_heapify(alist,i)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(<span class=\"keyword\">self</span>, sort_list)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>._build_max_heap(sort_list)</span><br><span class=\"line\">        heap_size = len(sort_list)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(sort_list)-<span class=\"number\">1</span>,<span class=\"number\">0</span>,-<span class=\"number\">1</span>)<span class=\"symbol\">:</span></span><br><span class=\"line\">            sort_list[<span class=\"number\">0</span>],sort_list[i]=sort_list[i],sort_list[<span class=\"number\">0</span>]</span><br><span class=\"line\">            heap_size -=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>._max_heapify(sort_list, <span class=\"number\">0</span>, heap_size)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>算法思想：归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>\n<p>归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class merge_sort(object):</span><br><span class=\"line\">    def _erge(self, alist, <span class=\"keyword\">p</span>, q, r):</span><br><span class=\"line\">        <span class=\"keyword\">left</span> = alist[<span class=\"keyword\">p</span>:q + <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">right</span> = alist[q + <span class=\"number\">1</span>:r + <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i in <span class=\"built_in\">range</span>(<span class=\"keyword\">p</span>, r + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(<span class=\"keyword\">left</span>) &gt; <span class=\"number\">0</span> <span class=\"built_in\">and</span> <span class=\"built_in\">len</span>(<span class=\"keyword\">right</span>) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">left</span>[<span class=\"number\">0</span>] &lt;= <span class=\"keyword\">right</span>[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                    alist[i] = <span class=\"keyword\">left</span>.<span class=\"keyword\">pop</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    alist[i] = <span class=\"keyword\">right</span>.<span class=\"keyword\">pop</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">            elif <span class=\"built_in\">len</span>(<span class=\"keyword\">right</span>) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                alist[i] = <span class=\"keyword\">left</span>.<span class=\"keyword\">pop</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">            elif <span class=\"built_in\">len</span>(<span class=\"keyword\">left</span>) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                alist[i] = <span class=\"keyword\">right</span>.<span class=\"keyword\">pop</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    def _merge_sort(self, alist, <span class=\"keyword\">p</span>, r):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">p</span> &lt; r:</span><br><span class=\"line\">            q = <span class=\"keyword\">int</span>((<span class=\"keyword\">p</span> + r) / <span class=\"number\">2</span>)</span><br><span class=\"line\">            self._merge_sort(alist, <span class=\"keyword\">p</span>, q)</span><br><span class=\"line\">            self._merge_sort(alist, q + <span class=\"number\">1</span>, r)</span><br><span class=\"line\">            self._merge(alist, <span class=\"keyword\">p</span>, q, r)</span><br><span class=\"line\"></span><br><span class=\"line\">    def __call__(self, sort_list):</span><br><span class=\"line\">        self._merge_sort(sort_list, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(sort_list) - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><p>算法思想：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\">def radix_sort(lists, <span class=\"built_in\">radix</span>=<span class=\"number\">10</span>):</span><br><span class=\"line\">    k = <span class=\"built_in\">int</span>(math.ceil(math.<span class=\"built_in\">log</span>(<span class=\"built_in\">max</span>(lists), <span class=\"built_in\">radix</span>)))</span><br><span class=\"line\">    bucket = [[] for i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">radix</span>)]</span><br><span class=\"line\">    for i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, k+<span class=\"number\">1</span>):</span><br><span class=\"line\">        for j <span class=\"keyword\">in</span> lists:</span><br><span class=\"line\">            bucket[j/(<span class=\"built_in\">radix</span>**(i-<span class=\"number\">1</span>)) % (<span class=\"built_in\">radix</span>**i)].append(j)</span><br><span class=\"line\">        del lists[:]</span><br><span class=\"line\">        for z <span class=\"keyword\">in</span> bucket:</span><br><span class=\"line\">            lists += z</span><br><span class=\"line\">            del z[:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h3 id=\"一些结论\"><a href=\"#一些结论\" class=\"headerlink\" title=\"一些结论\"></a>一些结论</h3><p>（1）快速排序、希尔排序、归并排序、堆排序的平均时间为O(nlogn)，其他的为O(n*n)。</p>\n<p>（2）快速排序、希尔排序、选择排序、堆排序不稳定，其他的稳定。</p>\n<p>（3）经过一趟排序能够保证一个元素到达最终位置的是冒泡排序、快速排序、选择排序、堆排序。</p>\n<p>（4）元素比较次数和原始序列无关的是选择排序、折半插入排序。</p>\n<p>（5）排序趟数和原始序列有关的是交换类排序。</p>\n<p>（6）直接插入排序和折半插入排序的区别是寻找插入位置的方式不同，一个是按顺序查找方式，另一个是按折半查找方式。</p>\n<hr>\n<p>参考资料：<br><a href=\"http://www.cnblogs.com/twobin\" target=\"_blank\" rel=\"noopener\">博客园</a></p>\n<p><a href=\"http://www.lining0806.com/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/\" target=\"_blank\" rel=\"noopener\">宁哥的小站</a></p>\n<p><a href=\"http://blog.2liang.me/2015/09/24/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84Python%E5%AE%9E%E7%8E%B0/\" target=\"_blank\" rel=\"noopener\">八大排序算法的Python实现</a></p>\n","site":{"data":{}},"excerpt":"<p>常见的算法思想有：分治法(繁分为简)、贪心法相对比较满意的解去运算，而不考虑所有的情况)、穷举法(全列出)、递归法(返回本身)、递推法(按照规律求解)、回溯法(退上一步)、动态规划法(寻找最优解)，迭代法(由旧推新)，分支界限法(问题分支分界)。<br></p>","more":"<br>所谓排序，就是讲原来无序的一个序列重新排列成有序序列。<p></p>\n<p><strong>常见的排序算法，包括：冒泡排序、选择排序、插入排序、快速排序、归并排序、希尔排序和队排序。</strong>冒泡排序、选择排序、插入排序的时间复杂度为O(n^2),希尔排序的时间复杂度为O(n^1.25)，快速排序、归并排序和堆排序的时间复杂度为O(nlog2(n))。</p>\n<p>性能的好坏，看重其稳定性。所谓的稳定性，是指代排序的两个或两个以上相同的项，在排序前后这些相同的项相对位置有没有发生变化。</p>\n<p>如果要求不能重复，则排序结果是唯一的，那么选择的排序方法稳定与否就无关紧要。如果可以冲去，就要根据实际需求来选择。</p>\n<p>那么哪些排序算法是不稳定的呢？</p>\n<p><strong>“快些选堆”</strong>：其中“快”指的是快速排序，“些”值得书希尔排序，“选”指的是选择排序，“堆”指的是堆排序，这四种是不稳定的，其他是稳定的。</p>\n<h2 id=\"排序算法分类\"><a href=\"#排序算法分类\" class=\"headerlink\" title=\"排序算法分类\"></a>排序算法分类</h2><p>1.插入类排序<br>即在一个已经有序的序列中，插入一个新数。这类排序有：直接排序、折半排序、希尔排序。</p>\n<p>2.交换类排序<br>这类方法的核心是“交换”，即每趟排都是通过一系列的“交换”来完成的。这类排序有冒泡排序、快速排序。</p>\n<p>3.选择类排序<br>该方法的核心是“选择”，即每趟排序都选出一个最小（或最大）的记录，把它和序列中的第一个（或最后一个）记录交换，这样最小（或最大）的记录到位。这类排序有：选择排序、堆排序。</p>\n<p>4.归并类排序<br>所谓归并，就是将两个或两个以上的有序序列合并成一个新的有序序列。这类排序有：（二路）归并排序。</p>\n<p>5.基数类排序<br>此类方法较为特别，是基于多关键字排序的思想，把一个逻辑关键字拆分成多个关键字。</p>\n<h2 id=\"排序算法分析\"><a href=\"#排序算法分析\" class=\"headerlink\" title=\"排序算法分析\"></a>排序算法分析</h2><p>本文主要分析的排序算法有：冒泡排序、选择排序、插入排序、希尔排序、快速排序、归并排序、堆排序。</p>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>算法思想：每趟将一个待排序的关键字，按照其关键字值的大小插入到已经排好的部分序列的适当位置上，直到插入完成。由大到小排，后往前插。空间复杂度O(1)。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'''insertion sort'''</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insertion_sort</span><span class=\"params\">(sort_list)</span>:</span></span><br><span class=\"line\">    iter_len = len(sort_list)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> iter_len&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,iter_len):</span><br><span class=\"line\">        key = sort_list[i]</span><br><span class=\"line\">        location = i</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-1</span>,<span class=\"number\">-1</span>,<span class=\"number\">-1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> sort_list[j]&gt;key:</span><br><span class=\"line\">                sort_list[j+<span class=\"number\">1</span>] = sort_list[j]</span><br><span class=\"line\">                location = j</span><br><span class=\"line\">        sort_list[location] = key</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>算法思想：希尔排序又叫做缩小增量排序，是将待排序的序列按某种规则分成几个子序列，分别对这几个子序列进行插入排序，其中这一规则就是增量。如可以使用增量为总长的一半，再一半，直至1来分格序列，且每一趟希尔排序的增量都是逐渐缩小的，希尔排序的每趟排序都会使得整个序列变得更加有序，等整个序列基本有序了，再使用一趟插入排序，这样会更有效率，这就是希尔排序的思想。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">shell_sort</span><span class=\"params\">(sort_list)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    iter_len = len(sort_list)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> iter_len &lt; <span class=\"number\">2</span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br><span class=\"line\">    gap = iter_len / <span class=\"number\">2</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> gap &gt; <span class=\"number\">0</span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, gap)<span class=\"symbol\">:</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i + gap, iter_len, gap)<span class=\"symbol\">:</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (sort_list[j] &lt; sort_list[j - gap])<span class=\"symbol\">:</span></span><br><span class=\"line\">                    key = sort_list[j]</span><br><span class=\"line\">                    k = j - gap</span><br><span class=\"line\">                    <span class=\"keyword\">while</span> k &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> sort_list[k]&gt;<span class=\"symbol\">key:</span></span><br><span class=\"line\">                        sort_list[k + gap] = sort_list[k]</span><br><span class=\"line\">                        k -= gap</span><br><span class=\"line\"></span><br><span class=\"line\">                    sort_list[k + gap] = key</span><br><span class=\"line\">        gap /= <span class=\"number\">2</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><p>算法思想：相邻两个数逐次比较，选出大的往下走，小的上浮，每一趟遍历将最大的沉到最后。时间复杂度O(n^2)。<br><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def bubble_sort(sort_list):</span><br><span class=\"line\">    iter_len = len(sort_list)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> iter_len&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">i</span> in range(iter_len<span class=\"number\">-1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"built_in\">j</span> in range(iter_len<span class=\"number\">-1</span>-<span class=\"built_in\">i</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> sort_list[<span class=\"built_in\">j</span>]&gt;sort_list[<span class=\"built_in\">j</span>+<span class=\"number\">1</span>]:</span><br><span class=\"line\">                sort_list[<span class=\"built_in\">j</span>],sort_list[<span class=\"built_in\">j</span>+<span class=\"number\">1</span>]=sort_list[<span class=\"built_in\">j</span>+<span class=\"number\">1</span>],sort_list[<span class=\"built_in\">j</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><p>算法思想：一趟快速排序是以一个枢轴，将序列分成两部分，枢轴的一边比它小（或小于等于），另一边比它大（或大于等于）。</p>\n<p>一遍快速排序结果：<br>1）设置两个变量i、j，排序开始的时候：i=0，j=N-1；<br>2）以第一个数组元素作为关键数据，赋值给key，即key=A[0]；<br>3）从j开始向前搜索，即由后开始向前搜索(j–)，找到第一个小于key的值A[j]，将A[j]和A[i]互换；<br>4）从i开始向后搜索，即由前开始向后搜索(i++)，找到第一个大于key的A[i]，将A[i]和A[j]互换；<br>5）重复第3、4步，直到i=j；</p>\n<p>算法性能：快速排序最好情况下时间复杂度为O(nlogn)，待排序列越接近无序，则该算法效率越高，在最坏情况下时间复杂度为O(n*n)，待排序列越接 近有序，则该算法效率越低，算法的平均时间复杂度为O(nlogn)。就平均时间而言，快速排序是所有排序算法中最好的。该算法的空间复杂度为 O(logn)，快速排序是递归进行的，需要栈的辅助，因此需要的辅助空间比前面几类排序方法要多。</p>\n<p>快速排序的效率和选取的“枢轴”有关，选取的枢轴越接近中间值，算法效率就越高，因此为了提高算法效率，可以在第一次选取“枢轴”时做文章，<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env lowython</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">quick_sort</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_partition</span><span class=\"params\">(<span class=\"keyword\">self</span>, alist, low, high)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        i, j = low, high</span><br><span class=\"line\">        x = alist[low]</span><br><span class=\"line\">        <span class=\"keyword\">while</span> i &lt; <span class=\"symbol\">j:</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; j <span class=\"keyword\">and</span> alist[j] &gt;= <span class=\"symbol\">x:</span></span><br><span class=\"line\">                j -= <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt; <span class=\"symbol\">j:</span></span><br><span class=\"line\">                alist[i] = alist[j]</span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> i &lt; j <span class=\"keyword\">and</span> alist[i] &lt;= <span class=\"symbol\">x:</span></span><br><span class=\"line\">                i += <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> i &lt; <span class=\"symbol\">j:</span></span><br><span class=\"line\">                alist[j] = alist[i]</span><br><span class=\"line\">                j -= <span class=\"number\">1</span></span><br><span class=\"line\">        alist[i] = x</span><br><span class=\"line\">        <span class=\"keyword\">return</span> i</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_quicksort</span><span class=\"params\">(<span class=\"keyword\">self</span>, alist, low, high)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> low &lt; <span class=\"symbol\">high:</span></span><br><span class=\"line\">            q = <span class=\"keyword\">self</span>._partition(alist, low, high)</span><br><span class=\"line\">            <span class=\"keyword\">self</span>._quicksort(alist, low, q - <span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"keyword\">self</span>._quicksort(alist, q + <span class=\"number\">1</span>, high)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(<span class=\"keyword\">self</span>, sort_list)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>._quicksort(sort_list, <span class=\"number\">0</span>, len(sort_list) - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure></p>\n<p>在快速排序中，需要使用递归来分别处理左右子段，递归深度可以理解为系统栈自动保存的深度，先处理短的分段再处理长的分段，可以减少时间复杂度。</p>\n<p>如果按长的递归优先的话，那么短的递归会一直保存在栈中，直到长的处理完。短的优先的话，他是作为一个整体保存在栈中的，所以递归栈中的保留数据少一些。</p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>算法思想：该算法的主要动作就是“选择”，采用简单的选择方式，从头至尾顺序扫描序列，找出最小的一个记录，和第一个记录交换，接着从剩下的记录中继续这种选择和交换，最终使序列有序。<br><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def selection_sort(sort_list):</span><br><span class=\"line\">    iter_len = len(sort_list)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> iter_len&lt;<span class=\"number\">2</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">i</span> in range(iter_len<span class=\"number\">-1</span>):</span><br><span class=\"line\">        smallest = sort_list[<span class=\"built_in\">i</span>]</span><br><span class=\"line\">        location = <span class=\"built_in\">i</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> <span class=\"built_in\">j</span> in range(<span class=\"built_in\">i</span>+<span class=\"number\">1</span>,iter_len):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> sort_list[<span class=\"built_in\">j</span>]&lt;smallest:</span><br><span class=\"line\">                smallest = sort_list[<span class=\"built_in\">j</span>]</span><br><span class=\"line\">                location = <span class=\"built_in\">j</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">i</span> !=location:</span><br><span class=\"line\">            sort_list[<span class=\"built_in\">i</span>],sort_list[location]= sort_list[location],sort_list[<span class=\"built_in\">i</span>]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><p>算法思想：堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。可以利用数组的特点快速定位指定索引的元素。堆分为大根堆和小根堆，是完全二叉树。大根堆的要求是每个节点的值都不大于其父节点的值，即A[PARENT[i]] &gt;= A[i]。</p>\n<p>根据堆的定义，其根节点的值是最大（或最小），因此将一个无序序列 调整为一个堆，就可以找出这个序列的最大（或最小）值，然后将找出的这个值交换到序列的最后（或最前），这样有序序列元素增加1个，无序序列中元素减少1 个，对新的无序序列重复这样的操作，就实现了序列排序。堆排序中最关键的操作是将序列调整为堆，整个排序的过程就是通过不断调整使得不符合堆定义的完全二叉树变为符合堆定义的完全二叉树的过程。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">heap_sort</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_max_heapify</span><span class=\"params\">(<span class=\"keyword\">self</span>, alist, i, heap_size=None)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        length = len(alist)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> heap_size is <span class=\"symbol\">None:</span></span><br><span class=\"line\">            heap_size = length</span><br><span class=\"line\">        l = <span class=\"number\">2</span> * i + <span class=\"number\">1</span></span><br><span class=\"line\">        r = <span class=\"number\">2</span> * i + <span class=\"number\">2</span></span><br><span class=\"line\">        largest = i</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l &lt; heap_size <span class=\"keyword\">and</span> alist[l] &gt; alist[i]<span class=\"symbol\">:</span></span><br><span class=\"line\">            largest = l</span><br><span class=\"line\">        <span class=\"keyword\">if</span> l &lt; heap_size <span class=\"keyword\">and</span> alist[r] &gt; alist[i]<span class=\"symbol\">:</span></span><br><span class=\"line\">            largest = r</span><br><span class=\"line\">        <span class=\"keyword\">if</span> largest != <span class=\"symbol\">i:</span></span><br><span class=\"line\">            alist[i], alist[largest] = alist[largest], alist[i]</span><br><span class=\"line\">            <span class=\"keyword\">self</span>._max_heapify(alist, largest, heap_size)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">_build_max_heap</span><span class=\"params\">(<span class=\"keyword\">self</span>, alist)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        root_end = int(len(alist) / <span class=\"number\">2</span>)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(root_end-<span class=\"number\">1</span>,-<span class=\"number\">1</span>,-<span class=\"number\">1</span>)<span class=\"symbol\">:</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>._max_heapify(alist,i)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(<span class=\"keyword\">self</span>, sort_list)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>._build_max_heap(sort_list)</span><br><span class=\"line\">        heap_size = len(sort_list)</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(sort_list)-<span class=\"number\">1</span>,<span class=\"number\">0</span>,-<span class=\"number\">1</span>)<span class=\"symbol\">:</span></span><br><span class=\"line\">            sort_list[<span class=\"number\">0</span>],sort_list[i]=sort_list[i],sort_list[<span class=\"number\">0</span>]</span><br><span class=\"line\">            heap_size -=<span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">self</span>._max_heapify(sort_list, <span class=\"number\">0</span>, heap_size)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure>\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><p>算法思想：归并排序是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>\n<p>归并过程为：比较a[i]和a[j]的大小，若a[i]≤a[j]，则将第一个有序表中的元素a[i]复制到r[k]中，并令i和k分别加上1；否则将第二个有序表中的元素a[j]复制到r[k]中，并令j和k分别加上1，如此循环下去，直到其中一个有序表取完，然后再将另一个有序表中剩余的元素复制到r中从下标k到下标t的单元。归并排序的算法我们通常用递归实现，先把待排序区间[s,t]以中点二分，接着把左边子区间排序，再把右边子区间排序，最后把左区间和右区间用一次归并操作合并成有序的区间[s,t]。</p>\n<figure class=\"highlight vim\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class merge_sort(object):</span><br><span class=\"line\">    def _erge(self, alist, <span class=\"keyword\">p</span>, q, r):</span><br><span class=\"line\">        <span class=\"keyword\">left</span> = alist[<span class=\"keyword\">p</span>:q + <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">right</span> = alist[q + <span class=\"number\">1</span>:r + <span class=\"number\">1</span>]</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i in <span class=\"built_in\">range</span>(<span class=\"keyword\">p</span>, r + <span class=\"number\">1</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"built_in\">len</span>(<span class=\"keyword\">left</span>) &gt; <span class=\"number\">0</span> <span class=\"built_in\">and</span> <span class=\"built_in\">len</span>(<span class=\"keyword\">right</span>) &gt; <span class=\"number\">0</span>:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> <span class=\"keyword\">left</span>[<span class=\"number\">0</span>] &lt;= <span class=\"keyword\">right</span>[<span class=\"number\">0</span>]:</span><br><span class=\"line\">                    alist[i] = <span class=\"keyword\">left</span>.<span class=\"keyword\">pop</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    alist[i] = <span class=\"keyword\">right</span>.<span class=\"keyword\">pop</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">            elif <span class=\"built_in\">len</span>(<span class=\"keyword\">right</span>) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                alist[i] = <span class=\"keyword\">left</span>.<span class=\"keyword\">pop</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\">            elif <span class=\"built_in\">len</span>(<span class=\"keyword\">left</span>) == <span class=\"number\">0</span>:</span><br><span class=\"line\">                alist[i] = <span class=\"keyword\">right</span>.<span class=\"keyword\">pop</span>(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    def _merge_sort(self, alist, <span class=\"keyword\">p</span>, r):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">p</span> &lt; r:</span><br><span class=\"line\">            q = <span class=\"keyword\">int</span>((<span class=\"keyword\">p</span> + r) / <span class=\"number\">2</span>)</span><br><span class=\"line\">            self._merge_sort(alist, <span class=\"keyword\">p</span>, q)</span><br><span class=\"line\">            self._merge_sort(alist, q + <span class=\"number\">1</span>, r)</span><br><span class=\"line\">            self._merge(alist, <span class=\"keyword\">p</span>, q, r)</span><br><span class=\"line\"></span><br><span class=\"line\">    def __call__(self, sort_list):</span><br><span class=\"line\">        self._merge_sort(sort_list, <span class=\"number\">0</span>, <span class=\"built_in\">len</span>(sort_list) - <span class=\"number\">1</span>)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> sort_list</span><br></pre></td></tr></table></figure>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><p>算法思想：基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin sort，顾名思义，它是透过键值的部份资讯，将要排序的元素分配至某些“桶”中，藉以达到排序的作用，基数排序法是属于稳定性的排序，其时间复杂度为O (nlog(r)m)，其中r为所采取的基数，而m为堆数，在某些时候，基数排序法的效率高于其它的稳定性排序法。</p>\n<figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> math</span><br><span class=\"line\">def radix_sort(lists, <span class=\"built_in\">radix</span>=<span class=\"number\">10</span>):</span><br><span class=\"line\">    k = <span class=\"built_in\">int</span>(math.ceil(math.<span class=\"built_in\">log</span>(<span class=\"built_in\">max</span>(lists), <span class=\"built_in\">radix</span>)))</span><br><span class=\"line\">    bucket = [[] for i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"built_in\">radix</span>)]</span><br><span class=\"line\">    for i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>, k+<span class=\"number\">1</span>):</span><br><span class=\"line\">        for j <span class=\"keyword\">in</span> lists:</span><br><span class=\"line\">            bucket[j/(<span class=\"built_in\">radix</span>**(i-<span class=\"number\">1</span>)) % (<span class=\"built_in\">radix</span>**i)].append(j)</span><br><span class=\"line\">        del lists[:]</span><br><span class=\"line\">        for z <span class=\"keyword\">in</span> bucket:</span><br><span class=\"line\">            lists += z</span><br><span class=\"line\">            del z[:]</span><br><span class=\"line\">    <span class=\"keyword\">return</span> lists</span><br></pre></td></tr></table></figure>\n<h3 id=\"一些结论\"><a href=\"#一些结论\" class=\"headerlink\" title=\"一些结论\"></a>一些结论</h3><p>（1）快速排序、希尔排序、归并排序、堆排序的平均时间为O(nlogn)，其他的为O(n*n)。</p>\n<p>（2）快速排序、希尔排序、选择排序、堆排序不稳定，其他的稳定。</p>\n<p>（3）经过一趟排序能够保证一个元素到达最终位置的是冒泡排序、快速排序、选择排序、堆排序。</p>\n<p>（4）元素比较次数和原始序列无关的是选择排序、折半插入排序。</p>\n<p>（5）排序趟数和原始序列有关的是交换类排序。</p>\n<p>（6）直接插入排序和折半插入排序的区别是寻找插入位置的方式不同，一个是按顺序查找方式，另一个是按折半查找方式。</p>\n<hr>\n<p>参考资料：<br><a href=\"http://www.cnblogs.com/twobin\" target=\"_blank\" rel=\"noopener\">博客园</a></p>\n<p><a href=\"http://www.lining0806.com/%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/\" target=\"_blank\" rel=\"noopener\">宁哥的小站</a></p>\n<p><a href=\"http://blog.2liang.me/2015/09/24/%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84Python%E5%AE%9E%E7%8E%B0/\" target=\"_blank\" rel=\"noopener\">八大排序算法的Python实现</a></p>"},{"title":"互联网协议入门(1)","date":"2016-08-27T02:22:50.000Z","_content":"\n\n之前看了阮一峰大神的博客之后，想从中进行学习总结。便一边看一边自己复制简化了一些内容到自己的博客里来，以便自己后续的学习和整理。\n\n## 概述\n\n互联网的核心是一系列协议，总称为\"互联网协议\"（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。\n<!-- more -->\n### 五层模型\n\n互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。\n\n![五层](http://i4.buimg.com/567571/b29044e367423af1.png)\n\n### 层与协议\n\n每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。\n大家都遵守的规则，就叫做\"协议\"（protocol）。\n互联网的每一层，都定义了很多协议。这些协议的总称，就叫做\"互联网协议\"（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。\n\n## 物理层(实体层)\n\n电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。这就叫做\"实体层\"，它就是把电脑连接起来的物理手段。**它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。**\n\n## 链路层\n\n单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？\n这就是\"链接层\"的功能，**它在\"实体层\"的上方，确定了0和1的分组方式。**\n\n### 以太网协议\n\n早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做\"以太网\"（Ethernet）的协议，占据了主导地位。\n\n以太网规定，一组电信号构成一个数据包，叫做\"帧\"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。\n\n![帧](http://image.beekka.com/blog/201205/bg2012052904.png)\n\n\"标头\"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；\"数据\"则是数据包的具体内容。\n\"标头\"的长度，固定为18字节。\"数据\"的长度，最短为46字节，最长为1500字节。因此，整个\"帧\"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。\n\n\n### MAC地址\n上面提到，以太网数据包的\"标头\"，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？\n\n以太网规定，连入网络的所有设备，都必须具有\"网卡\"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。\n\n每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。\n\n![MAC地址](http://image.beekka.com/blog/201205/bg2012052906.png)\n\n前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。\n\n### 广播\n首先，一块网卡怎么会知道另一块网卡的MAC地址？\n\n回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。\n\n其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？\n回答是以太网采用了一种很\"原始\"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。\n\n![广播](http://image.beekka.com/blog/201205/bg2012052907.png)\n上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的\"标头\"，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做\"广播\"（broadcasting）。\n\n## 网络层\n\n### 网络层的由来\n\n互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。\n如果用广播的办法，有一个重大的缺点。会造成人手一包，用户一多，这是一场灾难。\n\n因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用\"路由\"方式发送。（\"路由\"的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文暂不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。\n\n**这就导致了\"网络层\"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做\"网络地址\"，简称\"网址\"。**\n\n于是，\"网络层\"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。\n\n网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。\n\n### IP协议\n\n规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。\n\n目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。IP协议的特性:\n\n* 不可靠（unreliable）：IP 协议不能保证数据报能成功地到达目的地，它仅提供传输服务。当发生某种错误时，IP 协议会丢弃该数据报。传输的可靠性全由上层协议来提供。\n\n* 无连接（connectionless）：IP 协议对每个数据报的处理是相互独立的。这也说明， IP 数据报可以不按发送顺序接收。如果发送方向接收方发送了两个连续的数据报（先是 A，然后是 B），每个数据报可以选择不同的路线，因此 B 可能在 A 到达之前先到达。\n\n\n\n习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。\n\n互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。\n\n那么，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。\n\n那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数\"子网掩码\"（subnet mask）。\n\n所谓\"子网掩码\"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。\n\n知道\"子网掩码\"，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。\n\n比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。\n\n总结一下，IP协议的作用主要有两个，**一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。**\n\n### IP数据包\n\n根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。\n\n但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？\n回答是不需要，我们可以把IP数据包直接放进以太网数据包的\"数据\"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：**上层的变动完全不涉及下层的结构。**\n![IP数据包格式](http://image.beekka.com/blog/201205/bg2012052910.png)\nIP数据包的\"标头\"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的\"数据\"部分，最长为65,515字节。前面说过，以太网数据包的\"数据\"部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。\n\n### ARP协议\n\n因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。\n\n所以，我们需要一种机制，能够从IP地址得到MAC地址。\n\n这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的\"网关\"（gateway），让网关去处理。\n\n第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个\"广播\"地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。\n\n总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。\n\n## 传输层\n\n### 传输层的由来\n\n有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。\n\n接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？\n\n也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做\"端口\"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。\n\n\"端口\"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。\n\n服务器的默认程序一般都是通过人们所熟知的端口号来识别的。例如，对于每个 TCP/IP 实现来说，SMTP（简单邮件传输协议）服务器的 TCP 端口号都是 25，FTP（文件传输协议）服务器的 TCP 端口号都是 21，TFTP(简单文件传输协议)服务器的 UDP 端口号都是 69。任何 TCP/IP 实现所提供的服务都用众所周知的 1－1023 之间的端口号。这些人们所熟知的端口号由 Internet 端口号分配机构（Internet Assigned Numbers Authority, IANA）来管理。\n\n**\"传输层\"的功能，就是建立\"端口到端口\"的通信。**相比之下，\"网络层\"的功能是建立\"主机到主机\"的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做\"套接字\"（socket）。有了它，就可以进行网络应用程序开发了。\n\n### UDP协议\n\n现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。\n所以整个以太网数据包现在变成了下面这样：\n![IP数据包格式](http://image.beekka.com/blog/201205/bg2012052912.png)\n\n### TCP协议\n\nUDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。\n\n为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。\n\n因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。\n\nTCP数据包和UDP数据包一样，都是内嵌在IP数据包的\"数据\"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。\n\n## 应用层\n\n应用程序收到\"传输层\"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。\n\n**\"应用层\"的作用，就是规定应用程序的数据格式。**\n\n举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了\"应用层\"。\n这是最高的一层，直接面对用户。它的数据就放在TCP数据包的\"数据\"部分。因此，现在的以太网的数据包就变成下面这样。\n\n\n![以太网的数据包](http://image.beekka.com/blog/201205/bg2012052913.png)\n\n## 封装与分用\n\n封装：当应用程序发送数据的时候，数据在协议层次当中从顶向下通过每一层，每一层都会对数据增加一些首部或尾部信息，这样的信息称之为协议数据单元（Protocol Data Unit，缩写为PDU），在分层协议系统里，在指定的协议层上传送的数据单元，包含了该层的协议控制信息和用户信息。\n\n分用：当主机收到一个数据帧时，数据就从协议层底向上升，通过每一层时，检查并去掉对应层次的报文首部或尾部，与封装过程正好相反。\n\n## RFC\n\nRFC（Request for Comment）文档是所有以太网协议的正式标准，并在其官网上面公布，由 IETF 标准协会制定。大量的 RFC 并不是正式的标准，出版的目的只是为了提供信息。RFC 的篇幅不一，从几页到几百页不等。每一种协议都用一个数字来标识，如 RFC 3720 是 iSCSI 协议的标准，数字越大说是 RFC 的内容越新或者是对应的协议（标准）出现的比较晚。\n\n所有的 RFC 文档都可以从网络上找到，其官网为IETF。在网站上面可以通过分类以及搜索快速找到目标协议的 RFC 文档。目前在 IETF 网站上面的 RFC 文档有数千个，但是我们不需要全部掌握，在工作或学习中如果遇到可以找到对应的解释，理论与实际结合会有更好地效果，单纯阅读 RFC 的效果一般。\n\n\n## 下篇预告\n\n至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。\n下一篇，将会讲从用户的角度，我反过来，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。\n\n----------\n参考：\n\n[阮一峰 （@ruanyf）](http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)\n[实验楼](https://www.shiyanlou.com)","source":"_posts/WEB交互/互联网协议入门(1).md","raw":"---\ntitle: 互联网协议入门(1)\ndate: 2016-08-27 10:22:50\ntags: \n- 协议\ncategories: 总结\n---\n\n\n之前看了阮一峰大神的博客之后，想从中进行学习总结。便一边看一边自己复制简化了一些内容到自己的博客里来，以便自己后续的学习和整理。\n\n## 概述\n\n互联网的核心是一系列协议，总称为\"互联网协议\"（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。\n<!-- more -->\n### 五层模型\n\n互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。\n\n![五层](http://i4.buimg.com/567571/b29044e367423af1.png)\n\n### 层与协议\n\n每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。\n大家都遵守的规则，就叫做\"协议\"（protocol）。\n互联网的每一层，都定义了很多协议。这些协议的总称，就叫做\"互联网协议\"（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。\n\n## 物理层(实体层)\n\n电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。这就叫做\"实体层\"，它就是把电脑连接起来的物理手段。**它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。**\n\n## 链路层\n\n单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？\n这就是\"链接层\"的功能，**它在\"实体层\"的上方，确定了0和1的分组方式。**\n\n### 以太网协议\n\n早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做\"以太网\"（Ethernet）的协议，占据了主导地位。\n\n以太网规定，一组电信号构成一个数据包，叫做\"帧\"（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。\n\n![帧](http://image.beekka.com/blog/201205/bg2012052904.png)\n\n\"标头\"包含数据包的一些说明项，比如发送者、接受者、数据类型等等；\"数据\"则是数据包的具体内容。\n\"标头\"的长度，固定为18字节。\"数据\"的长度，最短为46字节，最长为1500字节。因此，整个\"帧\"最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。\n\n\n### MAC地址\n上面提到，以太网数据包的\"标头\"，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？\n\n以太网规定，连入网络的所有设备，都必须具有\"网卡\"接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。\n\n每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。\n\n![MAC地址](http://image.beekka.com/blog/201205/bg2012052906.png)\n\n前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。\n\n### 广播\n首先，一块网卡怎么会知道另一块网卡的MAC地址？\n\n回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。\n\n其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？\n回答是以太网采用了一种很\"原始\"的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。\n\n![广播](http://image.beekka.com/blog/201205/bg2012052907.png)\n上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的\"标头\"，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做\"广播\"（broadcasting）。\n\n## 网络层\n\n### 网络层的由来\n\n互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。\n如果用广播的办法，有一个重大的缺点。会造成人手一包，用户一多，这是一场灾难。\n\n因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用\"路由\"方式发送。（\"路由\"的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文暂不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。\n\n**这就导致了\"网络层\"的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做\"网络地址\"，简称\"网址\"。**\n\n于是，\"网络层\"出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。\n\n网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。\n\n### IP协议\n\n规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。\n\n目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。IP协议的特性:\n\n* 不可靠（unreliable）：IP 协议不能保证数据报能成功地到达目的地，它仅提供传输服务。当发生某种错误时，IP 协议会丢弃该数据报。传输的可靠性全由上层协议来提供。\n\n* 无连接（connectionless）：IP 协议对每个数据报的处理是相互独立的。这也说明， IP 数据报可以不按发送顺序接收。如果发送方向接收方发送了两个连续的数据报（先是 A，然后是 B），每个数据报可以选择不同的路线，因此 B 可能在 A 到达之前先到达。\n\n\n\n习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。\n\n互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。\n\n那么，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。\n\n那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数\"子网掩码\"（subnet mask）。\n\n所谓\"子网掩码\"，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。\n\n知道\"子网掩码\"，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。\n\n比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。\n\n总结一下，IP协议的作用主要有两个，**一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。**\n\n### IP数据包\n\n根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。\n\n但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？\n回答是不需要，我们可以把IP数据包直接放进以太网数据包的\"数据\"部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：**上层的变动完全不涉及下层的结构。**\n![IP数据包格式](http://image.beekka.com/blog/201205/bg2012052910.png)\nIP数据包的\"标头\"部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的\"数据\"部分，最长为65,515字节。前面说过，以太网数据包的\"数据\"部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。\n\n### ARP协议\n\n因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。\n\n所以，我们需要一种机制，能够从IP地址得到MAC地址。\n\n这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的\"网关\"（gateway），让网关去处理。\n\n第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个\"广播\"地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。\n\n总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。\n\n## 传输层\n\n### 传输层的由来\n\n有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。\n\n接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？\n\n也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做\"端口\"（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。\n\n\"端口\"是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。\n\n服务器的默认程序一般都是通过人们所熟知的端口号来识别的。例如，对于每个 TCP/IP 实现来说，SMTP（简单邮件传输协议）服务器的 TCP 端口号都是 25，FTP（文件传输协议）服务器的 TCP 端口号都是 21，TFTP(简单文件传输协议)服务器的 UDP 端口号都是 69。任何 TCP/IP 实现所提供的服务都用众所周知的 1－1023 之间的端口号。这些人们所熟知的端口号由 Internet 端口号分配机构（Internet Assigned Numbers Authority, IANA）来管理。\n\n**\"传输层\"的功能，就是建立\"端口到端口\"的通信。**相比之下，\"网络层\"的功能是建立\"主机到主机\"的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做\"套接字\"（socket）。有了它，就可以进行网络应用程序开发了。\n\n### UDP协议\n\n现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。\n所以整个以太网数据包现在变成了下面这样：\n![IP数据包格式](http://image.beekka.com/blog/201205/bg2012052912.png)\n\n### TCP协议\n\nUDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。\n\n为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。\n\n因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。\n\nTCP数据包和UDP数据包一样，都是内嵌在IP数据包的\"数据\"部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。\n\n## 应用层\n\n应用程序收到\"传输层\"的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。\n\n**\"应用层\"的作用，就是规定应用程序的数据格式。**\n\n举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了\"应用层\"。\n这是最高的一层，直接面对用户。它的数据就放在TCP数据包的\"数据\"部分。因此，现在的以太网的数据包就变成下面这样。\n\n\n![以太网的数据包](http://image.beekka.com/blog/201205/bg2012052913.png)\n\n## 封装与分用\n\n封装：当应用程序发送数据的时候，数据在协议层次当中从顶向下通过每一层，每一层都会对数据增加一些首部或尾部信息，这样的信息称之为协议数据单元（Protocol Data Unit，缩写为PDU），在分层协议系统里，在指定的协议层上传送的数据单元，包含了该层的协议控制信息和用户信息。\n\n分用：当主机收到一个数据帧时，数据就从协议层底向上升，通过每一层时，检查并去掉对应层次的报文首部或尾部，与封装过程正好相反。\n\n## RFC\n\nRFC（Request for Comment）文档是所有以太网协议的正式标准，并在其官网上面公布，由 IETF 标准协会制定。大量的 RFC 并不是正式的标准，出版的目的只是为了提供信息。RFC 的篇幅不一，从几页到几百页不等。每一种协议都用一个数字来标识，如 RFC 3720 是 iSCSI 协议的标准，数字越大说是 RFC 的内容越新或者是对应的协议（标准）出现的比较晚。\n\n所有的 RFC 文档都可以从网络上找到，其官网为IETF。在网站上面可以通过分类以及搜索快速找到目标协议的 RFC 文档。目前在 IETF 网站上面的 RFC 文档有数千个，但是我们不需要全部掌握，在工作或学习中如果遇到可以找到对应的解释，理论与实际结合会有更好地效果，单纯阅读 RFC 的效果一般。\n\n\n## 下篇预告\n\n至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。\n下一篇，将会讲从用户的角度，我反过来，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。\n\n----------\n参考：\n\n[阮一峰 （@ruanyf）](http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html)\n[实验楼](https://www.shiyanlou.com)","slug":"WEB交互/互联网协议入门(1)","published":1,"updated":"2019-03-22T14:44:36.720Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn2m00bh4l3n7l224047","content":"<p>之前看了阮一峰大神的博客之后，想从中进行学习总结。便一边看一边自己复制简化了一些内容到自己的博客里来，以便自己后续的学习和整理。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。<br><a id=\"more\"></a></p>\n<h3 id=\"五层模型\"><a href=\"#五层模型\" class=\"headerlink\" title=\"五层模型\"></a>五层模型</h3><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p>\n<p><img src=\"http://i4.buimg.com/567571/b29044e367423af1.png\" alt=\"五层\"></p>\n<h3 id=\"层与协议\"><a href=\"#层与协议\" class=\"headerlink\" title=\"层与协议\"></a>层与协议</h3><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。<br>大家都遵守的规则，就叫做”协议”（protocol）。<br>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p>\n<h2 id=\"物理层-实体层\"><a href=\"#物理层-实体层\" class=\"headerlink\" title=\"物理层(实体层)\"></a>物理层(实体层)</h2><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。这就叫做”实体层”，它就是把电脑连接起来的物理手段。<strong>它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</strong></p>\n<h2 id=\"链路层\"><a href=\"#链路层\" class=\"headerlink\" title=\"链路层\"></a>链路层</h2><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？<br>这就是”链接层”的功能，<strong>它在”实体层”的上方，确定了0和1的分组方式。</strong></p>\n<h3 id=\"以太网协议\"><a href=\"#以太网协议\" class=\"headerlink\" title=\"以太网协议\"></a>以太网协议</h3><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p>\n<p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p>\n<p><img src=\"http://image.beekka.com/blog/201205/bg2012052904.png\" alt=\"帧\"></p>\n<p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。<br>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>\n<h3 id=\"MAC地址\"><a href=\"#MAC地址\" class=\"headerlink\" title=\"MAC地址\"></a>MAC地址</h3><p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p>\n<p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p>\n<p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p>\n<p><img src=\"http://image.beekka.com/blog/201205/bg2012052906.png\" alt=\"MAC地址\"></p>\n<p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>\n<h3 id=\"广播\"><a href=\"#广播\" class=\"headerlink\" title=\"广播\"></a>广播</h3><p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p>\n<p>回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。</p>\n<p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？<br>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p>\n<p><img src=\"http://image.beekka.com/blog/201205/bg2012052907.png\" alt=\"广播\"><br>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><h3 id=\"网络层的由来\"><a href=\"#网络层的由来\" class=\"headerlink\" title=\"网络层的由来\"></a>网络层的由来</h3><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。<br>如果用广播的办法，有一个重大的缺点。会造成人手一包，用户一多，这是一场灾难。</p>\n<p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文暂不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>\n<p><strong>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</strong></p>\n<p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p>\n<p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p>\n<h3 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p>\n<p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。IP协议的特性:</p>\n<ul>\n<li><p>不可靠（unreliable）：IP 协议不能保证数据报能成功地到达目的地，它仅提供传输服务。当发生某种错误时，IP 协议会丢弃该数据报。传输的可靠性全由上层协议来提供。</p>\n</li>\n<li><p>无连接（connectionless）：IP 协议对每个数据报的处理是相互独立的。这也说明， IP 数据报可以不按发送顺序接收。如果发送方向接收方发送了两个连续的数据报（先是 A，然后是 B），每个数据报可以选择不同的路线，因此 B 可能在 A 到达之前先到达。</p>\n</li>\n</ul>\n<p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p>\n<p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p>\n<p>那么，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p>\n<p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。</p>\n<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>\n<p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>\n<p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p>\n<p>总结一下，IP协议的作用主要有两个，<strong>一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</strong></p>\n<h3 id=\"IP数据包\"><a href=\"#IP数据包\" class=\"headerlink\" title=\"IP数据包\"></a>IP数据包</h3><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p>\n<p>但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？<br>回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：<strong>上层的变动完全不涉及下层的结构。</strong><br><img src=\"http://image.beekka.com/blog/201205/bg2012052910.png\" alt=\"IP数据包格式\"><br>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>\n<h3 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h3><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p>\n<p>所以，我们需要一种机制，能够从IP地址得到MAC地址。</p>\n<p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p>\n<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p>\n<p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p>\n<h2 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h2><h3 id=\"传输层的由来\"><a href=\"#传输层的由来\" class=\"headerlink\" title=\"传输层的由来\"></a>传输层的由来</h3><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p>\n<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>\n<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>\n<p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>\n<p>服务器的默认程序一般都是通过人们所熟知的端口号来识别的。例如，对于每个 TCP/IP 实现来说，SMTP（简单邮件传输协议）服务器的 TCP 端口号都是 25，FTP（文件传输协议）服务器的 TCP 端口号都是 21，TFTP(简单文件传输协议)服务器的 UDP 端口号都是 69。任何 TCP/IP 实现所提供的服务都用众所周知的 1－1023 之间的端口号。这些人们所熟知的端口号由 Internet 端口号分配机构（Internet Assigned Numbers Authority, IANA）来管理。</p>\n<p><strong>“传输层”的功能，就是建立”端口到端口”的通信。</strong>相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>\n<h3 id=\"UDP协议\"><a href=\"#UDP协议\" class=\"headerlink\" title=\"UDP协议\"></a>UDP协议</h3><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。<br>所以整个以太网数据包现在变成了下面这样：<br><img src=\"http://image.beekka.com/blog/201205/bg2012052912.png\" alt=\"IP数据包格式\"></p>\n<h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p>\n<p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>\n<p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p>\n<p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p>\n<p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p>\n<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。<br>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。</p>\n<p><img src=\"http://image.beekka.com/blog/201205/bg2012052913.png\" alt=\"以太网的数据包\"></p>\n<h2 id=\"封装与分用\"><a href=\"#封装与分用\" class=\"headerlink\" title=\"封装与分用\"></a>封装与分用</h2><p>封装：当应用程序发送数据的时候，数据在协议层次当中从顶向下通过每一层，每一层都会对数据增加一些首部或尾部信息，这样的信息称之为协议数据单元（Protocol Data Unit，缩写为PDU），在分层协议系统里，在指定的协议层上传送的数据单元，包含了该层的协议控制信息和用户信息。</p>\n<p>分用：当主机收到一个数据帧时，数据就从协议层底向上升，通过每一层时，检查并去掉对应层次的报文首部或尾部，与封装过程正好相反。</p>\n<h2 id=\"RFC\"><a href=\"#RFC\" class=\"headerlink\" title=\"RFC\"></a>RFC</h2><p>RFC（Request for Comment）文档是所有以太网协议的正式标准，并在其官网上面公布，由 IETF 标准协会制定。大量的 RFC 并不是正式的标准，出版的目的只是为了提供信息。RFC 的篇幅不一，从几页到几百页不等。每一种协议都用一个数字来标识，如 RFC 3720 是 iSCSI 协议的标准，数字越大说是 RFC 的内容越新或者是对应的协议（标准）出现的比较晚。</p>\n<p>所有的 RFC 文档都可以从网络上找到，其官网为IETF。在网站上面可以通过分类以及搜索快速找到目标协议的 RFC 文档。目前在 IETF 网站上面的 RFC 文档有数千个，但是我们不需要全部掌握，在工作或学习中如果遇到可以找到对应的解释，理论与实际结合会有更好地效果，单纯阅读 RFC 的效果一般。</p>\n<h2 id=\"下篇预告\"><a href=\"#下篇预告\" class=\"headerlink\" title=\"下篇预告\"></a>下篇预告</h2><p>至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。<br>下一篇，将会讲从用户的角度，我反过来，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。</p>\n<hr>\n<p>参考：</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html\" target=\"_blank\" rel=\"noopener\">阮一峰 （@ruanyf）</a><br><a href=\"https://www.shiyanlou.com\" target=\"_blank\" rel=\"noopener\">实验楼</a></p>\n","site":{"data":{}},"excerpt":"<p>之前看了阮一峰大神的博客之后，想从中进行学习总结。便一边看一边自己复制简化了一些内容到自己的博客里来，以便自己后续的学习和整理。</p>\n<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>互联网的核心是一系列协议，总称为”互联网协议”（Internet Protocol Suite）。它们对电脑如何连接和组网，做出了详尽的规定。理解了这些协议，就理解了互联网的原理。<br></p>","more":"<p></p>\n<h3 id=\"五层模型\"><a href=\"#五层模型\" class=\"headerlink\" title=\"五层模型\"></a>五层模型</h3><p>互联网的实现，分成好几层。每一层都有自己的功能，就像建筑物一样，每一层都靠下一层支持。要理解互联网，必须从最下层开始，自下而上理解每一层的功能。</p>\n<p><img src=\"http://i4.buimg.com/567571/b29044e367423af1.png\" alt=\"五层\"></p>\n<h3 id=\"层与协议\"><a href=\"#层与协议\" class=\"headerlink\" title=\"层与协议\"></a>层与协议</h3><p>每一层都是为了完成一种功能。为了实现这些功能，就需要大家都遵守共同的规则。<br>大家都遵守的规则，就叫做”协议”（protocol）。<br>互联网的每一层，都定义了很多协议。这些协议的总称，就叫做”互联网协议”（Internet Protocol Suite）。它们是互联网的核心，下面介绍每一层的功能，主要就是介绍每一层的主要协议。</p>\n<h2 id=\"物理层-实体层\"><a href=\"#物理层-实体层\" class=\"headerlink\" title=\"物理层(实体层)\"></a>物理层(实体层)</h2><p>电脑要组网，第一件事要干什么？当然是先把电脑连起来，可以用光缆、电缆、双绞线、无线电波等方式。这就叫做”实体层”，它就是把电脑连接起来的物理手段。<strong>它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。</strong></p>\n<h2 id=\"链路层\"><a href=\"#链路层\" class=\"headerlink\" title=\"链路层\"></a>链路层</h2><p>单纯的0和1没有任何意义，必须规定解读方式：多少个电信号算一组？每个信号位有何意义？<br>这就是”链接层”的功能，<strong>它在”实体层”的上方，确定了0和1的分组方式。</strong></p>\n<h3 id=\"以太网协议\"><a href=\"#以太网协议\" class=\"headerlink\" title=\"以太网协议\"></a>以太网协议</h3><p>早期的时候，每家公司都有自己的电信号分组方式。逐渐地，一种叫做”以太网”（Ethernet）的协议，占据了主导地位。</p>\n<p>以太网规定，一组电信号构成一个数据包，叫做”帧”（Frame）。每一帧分成两个部分：标头（Head）和数据（Data）。</p>\n<p><img src=\"http://image.beekka.com/blog/201205/bg2012052904.png\" alt=\"帧\"></p>\n<p>“标头”包含数据包的一些说明项，比如发送者、接受者、数据类型等等；”数据”则是数据包的具体内容。<br>“标头”的长度，固定为18字节。”数据”的长度，最短为46字节，最长为1500字节。因此，整个”帧”最短为64字节，最长为1518字节。如果数据很长，就必须分割成多个帧进行发送。</p>\n<h3 id=\"MAC地址\"><a href=\"#MAC地址\" class=\"headerlink\" title=\"MAC地址\"></a>MAC地址</h3><p>上面提到，以太网数据包的”标头”，包含了发送者和接受者的信息。那么，发送者和接受者是如何标识呢？</p>\n<p>以太网规定，连入网络的所有设备，都必须具有”网卡”接口。数据包必须是从一块网卡，传送到另一块网卡。网卡的地址，就是数据包的发送地址和接收地址，这叫做MAC地址。</p>\n<p>每块网卡出厂的时候，都有一个全世界独一无二的MAC地址，长度是48个二进制位，通常用12个十六进制数表示。</p>\n<p><img src=\"http://image.beekka.com/blog/201205/bg2012052906.png\" alt=\"MAC地址\"></p>\n<p>前6个十六进制数是厂商编号，后6个是该厂商的网卡流水号。有了MAC地址，就可以定位网卡和数据包的路径了。</p>\n<h3 id=\"广播\"><a href=\"#广播\" class=\"headerlink\" title=\"广播\"></a>广播</h3><p>首先，一块网卡怎么会知道另一块网卡的MAC地址？</p>\n<p>回答是有一种ARP协议，可以解决这个问题。这个留到后面介绍，这里只需要知道，以太网数据包必须知道接收方的MAC地址，然后才能发送。</p>\n<p>其次，就算有了MAC地址，系统怎样才能把数据包准确送到接收方？<br>回答是以太网采用了一种很”原始”的方式，它不是把数据包准确送到接收方，而是向本网络内所有计算机发送，让每台计算机自己判断，是否为接收方。</p>\n<p><img src=\"http://image.beekka.com/blog/201205/bg2012052907.png\" alt=\"广播\"><br>上图中，1号计算机向2号计算机发送一个数据包，同一个子网络的3号、4号、5号计算机都会收到这个包。它们读取这个包的”标头”，找到接收方的MAC地址，然后与自身的MAC地址相比较，如果两者相同，就接受这个包，做进一步处理，否则就丢弃这个包。这种发送方式就叫做”广播”（broadcasting）。</p>\n<h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><h3 id=\"网络层的由来\"><a href=\"#网络层的由来\" class=\"headerlink\" title=\"网络层的由来\"></a>网络层的由来</h3><p>互联网是无数子网络共同组成的一个巨型网络，很像想象上海和洛杉矶的电脑会在同一个子网络，这几乎是不可能的。<br>如果用广播的办法，有一个重大的缺点。会造成人手一包，用户一多，这是一场灾难。</p>\n<p>因此，必须找到一种方法，能够区分哪些MAC地址属于同一个子网络，哪些不是。如果是同一个子网络，就采用广播方式发送，否则就采用”路由”方式发送。（”路由”的意思，就是指如何向不同的子网络分发数据包，这是一个很大的主题，本文暂不涉及。）遗憾的是，MAC地址本身无法做到这一点。它只与厂商有关，与所处网络无关。</p>\n<p><strong>这就导致了”网络层”的诞生。它的作用是引进一套新的地址，使得我们能够区分不同的计算机是否属于同一个子网络。这套地址就叫做”网络地址”，简称”网址”。</strong></p>\n<p>于是，”网络层”出现以后，每台计算机有了两种地址，一种是MAC地址，另一种是网络地址。两种地址之间没有任何联系，MAC地址是绑定在网卡上的，网络地址则是管理员分配的，它们只是随机组合在一起。</p>\n<p>网络地址帮助我们确定计算机所在的子网络，MAC地址则将数据包送到该子网络中的目标网卡。因此，从逻辑上可以推断，必定是先处理网络地址，然后再处理MAC地址。</p>\n<h3 id=\"IP协议\"><a href=\"#IP协议\" class=\"headerlink\" title=\"IP协议\"></a>IP协议</h3><p>规定网络地址的协议，叫做IP协议。它所定义的地址，就被称为IP地址。</p>\n<p>目前，广泛采用的是IP协议第四版，简称IPv4。这个版本规定，网络地址由32个二进制位组成。IP协议的特性:</p>\n<ul>\n<li><p>不可靠（unreliable）：IP 协议不能保证数据报能成功地到达目的地，它仅提供传输服务。当发生某种错误时，IP 协议会丢弃该数据报。传输的可靠性全由上层协议来提供。</p>\n</li>\n<li><p>无连接（connectionless）：IP 协议对每个数据报的处理是相互独立的。这也说明， IP 数据报可以不按发送顺序接收。如果发送方向接收方发送了两个连续的数据报（先是 A，然后是 B），每个数据报可以选择不同的路线，因此 B 可能在 A 到达之前先到达。</p>\n</li>\n</ul>\n<p>习惯上，我们用分成四段的十进制数表示IP地址，从0.0.0.0一直到255.255.255.255。</p>\n<p>互联网上的每一台计算机，都会分配到一个IP地址。这个地址分成两个部分，前一部分代表网络，后一部分代表主机。比如，IP地址172.16.254.1，这是一个32位的地址，假定它的网络部分是前24位（172.16.254），那么主机部分就是后8位（最后的那个1）。处于同一个子网络的电脑，它们IP地址的网络部分必定是相同的，也就是说172.16.254.2应该与172.16.254.1处在同一个子网络。</p>\n<p>那么，问题在于单单从IP地址，我们无法判断网络部分。还是以172.16.254.1为例，它的网络部分，到底是前24位，还是前16位，甚至前28位，从IP地址上是看不出来的。</p>\n<p>那么，怎样才能从IP地址，判断两台计算机是否属于同一个子网络呢？这就要用到另一个参数”子网掩码”（subnet mask）。</p>\n<p>所谓”子网掩码”，就是表示子网络特征的一个参数。它在形式上等同于IP地址，也是一个32位二进制数字，它的网络部分全部为1，主机部分全部为0。比如，IP地址172.16.254.1，如果已知网络部分是前24位，主机部分是后8位，那么子网络掩码就是11111111.11111111.11111111.00000000，写成十进制就是255.255.255.0。</p>\n<p>知道”子网掩码”，我们就能判断，任意两个IP地址是否处在同一个子网络。方法是将两个IP地址与子网掩码分别进行AND运算（两个数位都为1，运算结果为1，否则为0），然后比较结果是否相同，如果是的话，就表明它们在同一个子网络中，否则就不是。</p>\n<p>比如，已知IP地址172.16.254.1和172.16.254.233的子网掩码都是255.255.255.0，请问它们是否在同一个子网络？两者与子网掩码分别进行AND运算，结果都是172.16.254.0，因此它们在同一个子网络。</p>\n<p>总结一下，IP协议的作用主要有两个，<strong>一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</strong></p>\n<h3 id=\"IP数据包\"><a href=\"#IP数据包\" class=\"headerlink\" title=\"IP数据包\"></a>IP数据包</h3><p>根据IP协议发送的数据，就叫做IP数据包。不难想象，其中必定包括IP地址信息。</p>\n<p>但是前面说过，以太网数据包只包含MAC地址，并没有IP地址的栏位。那么是否需要修改数据定义，再添加一个栏位呢？<br>回答是不需要，我们可以把IP数据包直接放进以太网数据包的”数据”部分，因此完全不用修改以太网的规格。这就是互联网分层结构的好处：<strong>上层的变动完全不涉及下层的结构。</strong><br><img src=\"http://image.beekka.com/blog/201205/bg2012052910.png\" alt=\"IP数据包格式\"><br>IP数据包的”标头”部分的长度为20到60字节，整个数据包的总长度最大为65,535字节。因此，理论上，一个IP数据包的”数据”部分，最长为65,515字节。前面说过，以太网数据包的”数据”部分，最长只有1500字节。因此，如果IP数据包超过了1500字节，它就需要分割成几个以太网数据包，分开发送了。</p>\n<h3 id=\"ARP协议\"><a href=\"#ARP协议\" class=\"headerlink\" title=\"ARP协议\"></a>ARP协议</h3><p>因为IP数据包是放在以太网数据包里发送的，所以我们必须同时知道两个地址，一个是对方的MAC地址，另一个是对方的IP地址。通常情况下，对方的IP地址是已知的（后文会解释），但是我们不知道它的MAC地址。</p>\n<p>所以，我们需要一种机制，能够从IP地址得到MAC地址。</p>\n<p>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p>\n<p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p>\n<p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p>\n<h2 id=\"传输层\"><a href=\"#传输层\" class=\"headerlink\" title=\"传输层\"></a>传输层</h2><h3 id=\"传输层的由来\"><a href=\"#传输层的由来\" class=\"headerlink\" title=\"传输层的由来\"></a>传输层的由来</h3><p>有了MAC地址和IP地址，我们已经可以在互联网上任意两台主机上建立通信。</p>\n<p>接下来的问题是，同一台主机上有许多程序都需要用到网络，比如，你一边浏览网页，一边与朋友在线聊天。当一个数据包从互联网上发来的时候，你怎么知道，它是表示网页的内容，还是表示在线聊天的内容？</p>\n<p>也就是说，我们还需要一个参数，表示这个数据包到底供哪个程序（进程）使用。这个参数就叫做”端口”（port），它其实是每一个使用网卡的程序的编号。每个数据包都发到主机的特定端口，所以不同的程序就能取到自己所需要的数据。</p>\n<p>“端口”是0到65535之间的一个整数，正好16个二进制位。0到1023的端口被系统占用，用户只能选用大于1023的端口。不管是浏览网页还是在线聊天，应用程序会随机选用一个端口，然后与服务器的相应端口联系。</p>\n<p>服务器的默认程序一般都是通过人们所熟知的端口号来识别的。例如，对于每个 TCP/IP 实现来说，SMTP（简单邮件传输协议）服务器的 TCP 端口号都是 25，FTP（文件传输协议）服务器的 TCP 端口号都是 21，TFTP(简单文件传输协议)服务器的 UDP 端口号都是 69。任何 TCP/IP 实现所提供的服务都用众所周知的 1－1023 之间的端口号。这些人们所熟知的端口号由 Internet 端口号分配机构（Internet Assigned Numbers Authority, IANA）来管理。</p>\n<p><strong>“传输层”的功能，就是建立”端口到端口”的通信。</strong>相比之下，”网络层”的功能是建立”主机到主机”的通信。只要确定主机和端口，我们就能实现程序之间的交流。因此，Unix系统就把主机+端口，叫做”套接字”（socket）。有了它，就可以进行网络应用程序开发了。</p>\n<h3 id=\"UDP协议\"><a href=\"#UDP协议\" class=\"headerlink\" title=\"UDP协议\"></a>UDP协议</h3><p>现在，我们必须在数据包中加入端口信息，这就需要新的协议。最简单的实现叫做UDP协议，它的格式几乎就是在数据前面，加上端口号。<br>所以整个以太网数据包现在变成了下面这样：<br><img src=\"http://image.beekka.com/blog/201205/bg2012052912.png\" alt=\"IP数据包格式\"></p>\n<h3 id=\"TCP协议\"><a href=\"#TCP协议\" class=\"headerlink\" title=\"TCP协议\"></a>TCP协议</h3><p>UDP协议的优点是比较简单，容易实现，但是缺点是可靠性较差，一旦数据包发出，无法知道对方是否收到。</p>\n<p>为了解决这个问题，提高网络可靠性，TCP协议就诞生了。这个协议非常复杂，但可以近似认为，它就是有确认机制的UDP协议，每发出一个数据包都要求确认。如果有一个数据包遗失，就收不到确认，发出方就知道有必要重发这个数据包了。</p>\n<p>因此，TCP协议能够确保数据不会遗失。它的缺点是过程复杂、实现困难、消耗较多的资源。</p>\n<p>TCP数据包和UDP数据包一样，都是内嵌在IP数据包的”数据”部分。TCP数据包没有长度限制，理论上可以无限长，但是为了保证网络的效率，通常TCP数据包的长度不会超过IP数据包的长度，以确保单个TCP数据包不必再分割。</p>\n<h2 id=\"应用层\"><a href=\"#应用层\" class=\"headerlink\" title=\"应用层\"></a>应用层</h2><p>应用程序收到”传输层”的数据，接下来就要进行解读。由于互联网是开放架构，数据来源五花八门，必须事先规定好格式，否则根本无法解读。</p>\n<p><strong>“应用层”的作用，就是规定应用程序的数据格式。</strong></p>\n<p>举例来说，TCP协议可以为各种各样的程序传递数据，比如Email、WWW、FTP等等。那么，必须有不同协议规定电子邮件、网页、FTP数据的格式，这些应用程序协议就构成了”应用层”。<br>这是最高的一层，直接面对用户。它的数据就放在TCP数据包的”数据”部分。因此，现在的以太网的数据包就变成下面这样。</p>\n<p><img src=\"http://image.beekka.com/blog/201205/bg2012052913.png\" alt=\"以太网的数据包\"></p>\n<h2 id=\"封装与分用\"><a href=\"#封装与分用\" class=\"headerlink\" title=\"封装与分用\"></a>封装与分用</h2><p>封装：当应用程序发送数据的时候，数据在协议层次当中从顶向下通过每一层，每一层都会对数据增加一些首部或尾部信息，这样的信息称之为协议数据单元（Protocol Data Unit，缩写为PDU），在分层协议系统里，在指定的协议层上传送的数据单元，包含了该层的协议控制信息和用户信息。</p>\n<p>分用：当主机收到一个数据帧时，数据就从协议层底向上升，通过每一层时，检查并去掉对应层次的报文首部或尾部，与封装过程正好相反。</p>\n<h2 id=\"RFC\"><a href=\"#RFC\" class=\"headerlink\" title=\"RFC\"></a>RFC</h2><p>RFC（Request for Comment）文档是所有以太网协议的正式标准，并在其官网上面公布，由 IETF 标准协会制定。大量的 RFC 并不是正式的标准，出版的目的只是为了提供信息。RFC 的篇幅不一，从几页到几百页不等。每一种协议都用一个数字来标识，如 RFC 3720 是 iSCSI 协议的标准，数字越大说是 RFC 的内容越新或者是对应的协议（标准）出现的比较晚。</p>\n<p>所有的 RFC 文档都可以从网络上找到，其官网为IETF。在网站上面可以通过分类以及搜索快速找到目标协议的 RFC 文档。目前在 IETF 网站上面的 RFC 文档有数千个，但是我们不需要全部掌握，在工作或学习中如果遇到可以找到对应的解释，理论与实际结合会有更好地效果，单纯阅读 RFC 的效果一般。</p>\n<h2 id=\"下篇预告\"><a href=\"#下篇预告\" class=\"headerlink\" title=\"下篇预告\"></a>下篇预告</h2><p>至此，整个互联网的五层结构，自下而上全部讲完了。这是从系统的角度，解释互联网是如何构成的。<br>下一篇，将会讲从用户的角度，我反过来，自上而下看看这个结构是如何发挥作用，完成一次网络数据交换的。</p>\n<hr>\n<p>参考：</p>\n<p><a href=\"http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html\" target=\"_blank\" rel=\"noopener\">阮一峰 （@ruanyf）</a><br><a href=\"https://www.shiyanlou.com\" target=\"_blank\" rel=\"noopener\">实验楼</a></p>"},{"title":"初探python(1)基础知识","date":"2016-09-13T14:14:50.000Z","_content":"\n**人生苦短，我用Python**\n\n\n## Python是一种怎么样的语言？\n\n### Python诞生\n\nPython是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。\n\n龟叔给Python的定位是**“优雅”、“明确”、“简单”**，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。\n\n![龟叔](http://i2.buimg.com/567571/b65ae576e4e3215e.jpg)\n<!-- more -->\n它常被成为`胶水语言`。能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写。\n\nPython具有丰富和强大的库。提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作`内置电池（batteries included）`。除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。\n\n### Python适合开发的应用\n\n* 网络应用，包括网站、后台服务等等；\n\n* 许多日常需要的小工具，包括系统管理员需要的脚本任务等等；\n\n* 把其他语言开发的程序再包装起来，方便使用。\n\n###　Python的缺点\n\n其一，**便是运行速度慢**。因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。\n\n其二，**代码不能加密**。凡是编译型的语言，发布的是编译后的机器码如`.exe`，而解释型的语言，则必须把源码发布出去。\n\n## 侧重点杂记\n\n请务必注意，Python程序是*大小写*敏感的并且对于*缩进*要求严格，如果写错了大小写，程序会报错。如果直接复制粘贴，会导致缩进存在问题。\n\n`# -*- coding=utf-8 -*-`　用以开头声明编码方式，输出中文\n\n`#`用来注释,其他每一行都是一个语句，当语句以冒号“:”结尾时，缩进的语句视为代码块。\n\n在讲Python之前，先讲一下一些Sublime的用法。\n\n### Sublime基础用法\n\nSublime作为我最常用的编辑器，不得不提一下其对于Python编程的一些快捷键。\n```\nctrl+b　//运行python程序\n\nctrl+c　//停止运行\n\nctrl+/　//全体注释/取消注释\n\nctrl+[　//全体不缩进\n\nalt+num　//切换标签页\n```\n### 输入与输出\n\n输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。\n\n`raw_input()`和`print`是在命令行下面最基本的输入和输出。\n\n`raw_input()`调用时可填入空内显示一个字符串，用来做提示信息。\n\n### 数据类型\n\nPython支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”。\n\n如果字符串内部既包含'又包含\"怎么办？可以用转义字符`\\`来标识`。\n\n转义字符`\\`可以转义很多字符，比如`\\n`表示换行，`\\t`表示制表符，字符`\\`本身也要转义，所以`\\\\`表示的字符就是\\。Python还允许用`r''`表示''内部的字符串默认不转义\n\nPython允许用`'''`的格式表示多行内容\n\n空值是Python里一个特殊的值，用`None`表示。与0不同。\n\nPython支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。\n\n整数：一般意义上的数，包含十进制(无前缀),八进制(0开头)，十六进制(0x开头),二进制(0b开头)\n\n长整数：无限大小的数,表示范围和内存有关\n\n浮点数：小数或用e/E(10的幂)表示的幂,默认，浮点数学缺乏精确性,可以使用decimal\n\n### 变量\n\n变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。\n\n```\na = 'ABC'\n\n```\n以上，Python解释器干了两件事情：\n\n1.在内存中创建了一个'ABC'的字符串；\n\n2.在内存中创建了一个名为a的变量，并把它指向'ABC'。\n\n也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据。而之后执行\n```\na='XYZ'\n```\n\nb的值不会受到影响。\n\n### 常量\n\n在Python中，通常用全部大写的变量名表示常量。一般不改变其值，不过硬要改变也可，只不过违背了命名规则。\n\n### 题外话：字符编码\n\n在讲字符串之前，先提一下字符串编码的问题。\n\n因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。\n\n由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为`ASCII`编码，比如大写字母A的编码是65，小写字母z的编码是122。\n\n但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和`ASCII`编码冲突，所以，中国制定了`GB2312`编码，用来把中文编进去。\n\n当然世界上还有其他国家，这么多语言，各国有各国的标准，如果一个文本里出现多种语言的话，就会乱码。\n\n`Unicode`应运而生。`Unicode`把所有语言都统一到一套编码里，这样就不会再有乱码问题了。最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持`Unicode`。\n\n新的问题又出现了：如果统一成`Unicode`编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用`Unicode`编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。\n\n所以，本着节约的精神，又出现了把`Unicode`编码转化为“可变长编码”的`UTF-8`编码。`UTF-8`编码把一个`Unicode`字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用`UTF-8`编码就能节省空间.\n\n另外，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。\n\n搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：\n\n在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。\n\n用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。\n\n浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。\n\n当看到`<meta charset=\"UTF-8\" />`的信息时，也就意味着该网页正是用的UTF-8编码。\n\n### 字符串\n因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码。Python提供了ord()和chr()函数，可以把字母和对应的数字相互转换。\n\nPython在后来添加了对Unicode的支持，以Unicode表示的字符串用u'...'表示。\n\n在Python 3.x版本中，把'xxx'和u'xxx'统一成Unicode编码，即写不写前缀u都是一样的，而以字节形式表示的字符串则必须加上b前缀：b'xxx'。\n\n在字符串前加r，例r'xxx'，表示不转义字符串。\n\n把u'xxx'转换为UTF-8编码的'xxx'用`encode('utf-8')`方法。反之则用`decode('utf-8')`。\n\n由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n' a test module '\n__author__ = 'zjbao123'\n```\n第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；\n\n第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。\n\n此外，任何模块代码的第一个字符串都被视为模块的文档注释。\n\n使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名。\n#### 字符串处理\n在`PEP8`即Python编码样式指南中，要求每行不能超过80个字符，但在长字符串中如何做到呢？\n\n可以通过反斜杠、带逗号“,”的圆括号“()”、或者额外的加号“+”来完成换行。但对于多行字符串，这些解决方案都不够优雅。Python有个多行字符串记号，即三个引号，但这样无法换行后保持缩进。\n \n还有一个方法，那就是不带逗号的圆括号。我不知道为什么这种方式能工作，但能用就行。\n```\nmy_long_text = (\"We are no longer the knights who say Ni! \"        \n\"We are now the knights who say ekki-ekki-\"        \n\"ekki-p'tang-zoom-boing-z'nourrwringmm!\")\nprint(my_long_text)\n```\n另外，python还提供了很多的字符串处理方式：\n```\n全部大写：str.upper()\n全部小写：str.lower()\n大小写互换：str.swapcase()\n首字母大写，其余小写：str.capitalize()\n首字母大写：str.title()\n获取固定长度，右对齐，左边不够用空格补齐：str.ljust(width)\n获取固定长度，左对齐，右边不够用空格补齐：str.rjust(width)\n获取固定长度，中间对齐，两边不够用空格补齐：str.center(width)\n获取固定长度，右对齐，左边不足用0补齐:str.zfill(width)\n\n搜索指定字符串，没有返回-1：str.find('t')\n指定起始位置搜索：str.find('t',start)\n指定起始及结束位置搜索：str.find('t',start,end)\n从右边开始查找：str.rfind('t')\n搜索到多少个指定字符串：str.count('t')\n上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回-1\n\n替换old为new：str.replace('old','new')\n替换指定次数的old为new：str.replace('old','new',maxReplaceTimes)\n\n去两边空格：str.strip()\n去左空格：str.lstrip()\n去右空格：str.rstrip()\n去两边字符串：str.strip('d')，相应的也有lstrip，rstrip\n\n分隔:split()\n\n是否以start开头：str.startswith('start')\n是否以end结尾：str.endswith('end')\n是否全为字母或数字：str.isalnum()\n是否全字母：str.isalpha()\n是否全数字：str.isdigit()\n是否全小写：str.islower()\n是否全大写：str.isupper()\n```\n### 格式化\n\n%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。\n\n如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串。\n\n|格式\t|描述\n|-----------|:-----------------|\n|%%\t|百分号标记 #就是输出一个%|\n|%c|\t字符及其ASCII码|\n|%s|\t字符串|\n|%d|\t有符号整数(十进制)|\n|%u|\t无符号整数(十进制)|\n|%o|\t无符号整数(八进制)|\n|%x|\t无符号整数(十六进制)|\n|%X|\t无符号整数(十六进制大写字符)|\n|%e|\t浮点数字(科学计数法)|\n|%E|\t浮点数字(科学计数法，用E代替e)|\n|%f|\t浮点数字(用小数点符号)|\n|%g|\t浮点数字(根据值的大小采用%e或%f)|\n|%G|\t浮点数字(类似于%g)|\n|%p|\t指针(用十六进制打印值的内存地址)|\n|%n|\t存储输出字符的数量放进参数列表的下一个变量中|\n|%r|\t自加引号的字符串，再现他所代表的任意对象|\n\n\n当`%`为普通字符需要用`%%`转义。\n举个例子：\n```\n'%2d-%02d\"%(3.14,6)\n' 3-06'\n\"%9.2f\"%12.345\n    12.35\n\"%09.2f\"%12.345\n000012.35\n```\n可以在\"%\"和字母之间插进数字表示最大场宽。\n例如: %3d 表示输出3位整型数, 不够3位右对齐。\n表示输出场宽为9的浮点数, 其中小数位为2, 整数位为6,\n小数点占一位, 不够9位右对齐。\n`%09.2f`其中小数位为2, 整数位为6,小数点占一位, 不够9位零补齐。\n\n### 循环\n循环for语言有所不同，其他略有改动，条件不用加括号，并且每条判断要加`：`，之后的语句需要有缩进。\n```\nif　else　elif \nfor..in　依次把列表内每个元素列出来\nrange(i)　0 到 i-1 的整数\nwhile \nctrl+c 可退出循环\n```\n\n### list\nPython内置的一种数据类型是列表：list，这是一种有序的集合，可以随时添加和删除其中的元素。用`[ ]`表示。\n\nlist是一种有序的集合，可以随时添加（insert（i，“hello”））和删除（pop（i））其中的元素。\n\n如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素。以此类推，可以有-2，-3\n```\nfor index, item in enumerate(mylist):\n  print(index, item)\n```\n#### 列表推导\n[表达式 for 变量 in 列表]    或者  [表达式 for 变量 in 列表 if 条件]\n\n### tuple\n另一种有序列表叫元组: tuple,用`（）`表示。一旦初始化后不可修改，安全性好。\n\n另外，有两个特例需注意。空的元组定义为（），单个元素的元组（i，）（与（i）数学意义相区别）\n\n嵌套list可变为可变的元组。那要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。\n\nlist和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。\n\n\n### 字典\nPython内置了字典：dict的支持，dict全称dictionary，用`{}`表示。在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度，但占用内存多。\n\n一对一存储，后来的值会冲掉之前的值。\n\n如果字典里没有这个值，则会报错。那么事先可通过 in 来查找 或 get（\"hello\",-1）不存在返回-1。\n\npop(key)　删除，对应value也会删除\n\ndict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。\n\ndict是用空间来换取时间的一种方法。\n\n用键访问值的一种写法：\n```\n{'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[\"0\"]\n```\n#### 字典推导\n字典推导尤其是在交换键和值十分管用。\n```\nmy_phrase = [\"No\", \"one\", \"expects\", \"the\", \"Spanish\", \"Inquisition\"]\nmy_dict = {key: value for value, key in enumerate(my_phrase)}\nprint(my_dict)\nreversed_dict = {value: key for key, value in my_dict.items()}\nprint(reversed_dict)\n```\n### set\n\nset是无序和无重复的交集，用`([ ])`表示。set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n\n通过add(key),remove(key)方法可以增删key。\n\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。\n\nset和dict的唯一区别仅在于没有存储对应的value。\n\n### 再议不可变对象\n\nstr是不变对象，而list是可变对象。\n```\na='ABC'\na.replace('a', 'A')\n//'Abc'\na\n//'abc'\n```\n\na是变量，而'abc'才是字符串对象！有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'。\n\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/python/初探python(1)基础知识.md","raw":"---\ntitle: 初探python(1)基础知识\ndate: 2016-09-13 22:14:50\ntags: \n- python\n- python教程\ncategories: 总结\n---\n\n**人生苦短，我用Python**\n\n\n## Python是一种怎么样的语言？\n\n### Python诞生\n\nPython是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。\n\n龟叔给Python的定位是**“优雅”、“明确”、“简单”**，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。\n\n![龟叔](http://i2.buimg.com/567571/b65ae576e4e3215e.jpg)\n<!-- more -->\n它常被成为`胶水语言`。能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写。\n\nPython具有丰富和强大的库。提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作`内置电池（batteries included）`。除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。\n\n### Python适合开发的应用\n\n* 网络应用，包括网站、后台服务等等；\n\n* 许多日常需要的小工具，包括系统管理员需要的脚本任务等等；\n\n* 把其他语言开发的程序再包装起来，方便使用。\n\n###　Python的缺点\n\n其一，**便是运行速度慢**。因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。\n\n其二，**代码不能加密**。凡是编译型的语言，发布的是编译后的机器码如`.exe`，而解释型的语言，则必须把源码发布出去。\n\n## 侧重点杂记\n\n请务必注意，Python程序是*大小写*敏感的并且对于*缩进*要求严格，如果写错了大小写，程序会报错。如果直接复制粘贴，会导致缩进存在问题。\n\n`# -*- coding=utf-8 -*-`　用以开头声明编码方式，输出中文\n\n`#`用来注释,其他每一行都是一个语句，当语句以冒号“:”结尾时，缩进的语句视为代码块。\n\n在讲Python之前，先讲一下一些Sublime的用法。\n\n### Sublime基础用法\n\nSublime作为我最常用的编辑器，不得不提一下其对于Python编程的一些快捷键。\n```\nctrl+b　//运行python程序\n\nctrl+c　//停止运行\n\nctrl+/　//全体注释/取消注释\n\nctrl+[　//全体不缩进\n\nalt+num　//切换标签页\n```\n### 输入与输出\n\n输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。\n\n`raw_input()`和`print`是在命令行下面最基本的输入和输出。\n\n`raw_input()`调用时可填入空内显示一个字符串，用来做提示信息。\n\n### 数据类型\n\nPython支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”。\n\n如果字符串内部既包含'又包含\"怎么办？可以用转义字符`\\`来标识`。\n\n转义字符`\\`可以转义很多字符，比如`\\n`表示换行，`\\t`表示制表符，字符`\\`本身也要转义，所以`\\\\`表示的字符就是\\。Python还允许用`r''`表示''内部的字符串默认不转义\n\nPython允许用`'''`的格式表示多行内容\n\n空值是Python里一个特殊的值，用`None`表示。与0不同。\n\nPython支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。\n\n整数：一般意义上的数，包含十进制(无前缀),八进制(0开头)，十六进制(0x开头),二进制(0b开头)\n\n长整数：无限大小的数,表示范围和内存有关\n\n浮点数：小数或用e/E(10的幂)表示的幂,默认，浮点数学缺乏精确性,可以使用decimal\n\n### 变量\n\n变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。\n\n```\na = 'ABC'\n\n```\n以上，Python解释器干了两件事情：\n\n1.在内存中创建了一个'ABC'的字符串；\n\n2.在内存中创建了一个名为a的变量，并把它指向'ABC'。\n\n也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据。而之后执行\n```\na='XYZ'\n```\n\nb的值不会受到影响。\n\n### 常量\n\n在Python中，通常用全部大写的变量名表示常量。一般不改变其值，不过硬要改变也可，只不过违背了命名规则。\n\n### 题外话：字符编码\n\n在讲字符串之前，先提一下字符串编码的问题。\n\n因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。\n\n由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为`ASCII`编码，比如大写字母A的编码是65，小写字母z的编码是122。\n\n但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和`ASCII`编码冲突，所以，中国制定了`GB2312`编码，用来把中文编进去。\n\n当然世界上还有其他国家，这么多语言，各国有各国的标准，如果一个文本里出现多种语言的话，就会乱码。\n\n`Unicode`应运而生。`Unicode`把所有语言都统一到一套编码里，这样就不会再有乱码问题了。最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持`Unicode`。\n\n新的问题又出现了：如果统一成`Unicode`编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用`Unicode`编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。\n\n所以，本着节约的精神，又出现了把`Unicode`编码转化为“可变长编码”的`UTF-8`编码。`UTF-8`编码把一个`Unicode`字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用`UTF-8`编码就能节省空间.\n\n另外，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。\n\n搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：\n\n在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。\n\n用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。\n\n浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。\n\n当看到`<meta charset=\"UTF-8\" />`的信息时，也就意味着该网页正是用的UTF-8编码。\n\n### 字符串\n因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码。Python提供了ord()和chr()函数，可以把字母和对应的数字相互转换。\n\nPython在后来添加了对Unicode的支持，以Unicode表示的字符串用u'...'表示。\n\n在Python 3.x版本中，把'xxx'和u'xxx'统一成Unicode编码，即写不写前缀u都是一样的，而以字节形式表示的字符串则必须加上b前缀：b'xxx'。\n\n在字符串前加r，例r'xxx'，表示不转义字符串。\n\n把u'xxx'转换为UTF-8编码的'xxx'用`encode('utf-8')`方法。反之则用`decode('utf-8')`。\n\n由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：\n```\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n' a test module '\n__author__ = 'zjbao123'\n```\n第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；\n\n第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。\n\n此外，任何模块代码的第一个字符串都被视为模块的文档注释。\n\n使用__author__变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名。\n#### 字符串处理\n在`PEP8`即Python编码样式指南中，要求每行不能超过80个字符，但在长字符串中如何做到呢？\n\n可以通过反斜杠、带逗号“,”的圆括号“()”、或者额外的加号“+”来完成换行。但对于多行字符串，这些解决方案都不够优雅。Python有个多行字符串记号，即三个引号，但这样无法换行后保持缩进。\n \n还有一个方法，那就是不带逗号的圆括号。我不知道为什么这种方式能工作，但能用就行。\n```\nmy_long_text = (\"We are no longer the knights who say Ni! \"        \n\"We are now the knights who say ekki-ekki-\"        \n\"ekki-p'tang-zoom-boing-z'nourrwringmm!\")\nprint(my_long_text)\n```\n另外，python还提供了很多的字符串处理方式：\n```\n全部大写：str.upper()\n全部小写：str.lower()\n大小写互换：str.swapcase()\n首字母大写，其余小写：str.capitalize()\n首字母大写：str.title()\n获取固定长度，右对齐，左边不够用空格补齐：str.ljust(width)\n获取固定长度，左对齐，右边不够用空格补齐：str.rjust(width)\n获取固定长度，中间对齐，两边不够用空格补齐：str.center(width)\n获取固定长度，右对齐，左边不足用0补齐:str.zfill(width)\n\n搜索指定字符串，没有返回-1：str.find('t')\n指定起始位置搜索：str.find('t',start)\n指定起始及结束位置搜索：str.find('t',start,end)\n从右边开始查找：str.rfind('t')\n搜索到多少个指定字符串：str.count('t')\n上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回-1\n\n替换old为new：str.replace('old','new')\n替换指定次数的old为new：str.replace('old','new',maxReplaceTimes)\n\n去两边空格：str.strip()\n去左空格：str.lstrip()\n去右空格：str.rstrip()\n去两边字符串：str.strip('d')，相应的也有lstrip，rstrip\n\n分隔:split()\n\n是否以start开头：str.startswith('start')\n是否以end结尾：str.endswith('end')\n是否全为字母或数字：str.isalnum()\n是否全字母：str.isalpha()\n是否全数字：str.isdigit()\n是否全小写：str.islower()\n是否全大写：str.isupper()\n```\n### 格式化\n\n%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。\n\n如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串。\n\n|格式\t|描述\n|-----------|:-----------------|\n|%%\t|百分号标记 #就是输出一个%|\n|%c|\t字符及其ASCII码|\n|%s|\t字符串|\n|%d|\t有符号整数(十进制)|\n|%u|\t无符号整数(十进制)|\n|%o|\t无符号整数(八进制)|\n|%x|\t无符号整数(十六进制)|\n|%X|\t无符号整数(十六进制大写字符)|\n|%e|\t浮点数字(科学计数法)|\n|%E|\t浮点数字(科学计数法，用E代替e)|\n|%f|\t浮点数字(用小数点符号)|\n|%g|\t浮点数字(根据值的大小采用%e或%f)|\n|%G|\t浮点数字(类似于%g)|\n|%p|\t指针(用十六进制打印值的内存地址)|\n|%n|\t存储输出字符的数量放进参数列表的下一个变量中|\n|%r|\t自加引号的字符串，再现他所代表的任意对象|\n\n\n当`%`为普通字符需要用`%%`转义。\n举个例子：\n```\n'%2d-%02d\"%(3.14,6)\n' 3-06'\n\"%9.2f\"%12.345\n    12.35\n\"%09.2f\"%12.345\n000012.35\n```\n可以在\"%\"和字母之间插进数字表示最大场宽。\n例如: %3d 表示输出3位整型数, 不够3位右对齐。\n表示输出场宽为9的浮点数, 其中小数位为2, 整数位为6,\n小数点占一位, 不够9位右对齐。\n`%09.2f`其中小数位为2, 整数位为6,小数点占一位, 不够9位零补齐。\n\n### 循环\n循环for语言有所不同，其他略有改动，条件不用加括号，并且每条判断要加`：`，之后的语句需要有缩进。\n```\nif　else　elif \nfor..in　依次把列表内每个元素列出来\nrange(i)　0 到 i-1 的整数\nwhile \nctrl+c 可退出循环\n```\n\n### list\nPython内置的一种数据类型是列表：list，这是一种有序的集合，可以随时添加和删除其中的元素。用`[ ]`表示。\n\nlist是一种有序的集合，可以随时添加（insert（i，“hello”））和删除（pop（i））其中的元素。\n\n如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素。以此类推，可以有-2，-3\n```\nfor index, item in enumerate(mylist):\n  print(index, item)\n```\n#### 列表推导\n[表达式 for 变量 in 列表]    或者  [表达式 for 变量 in 列表 if 条件]\n\n### tuple\n另一种有序列表叫元组: tuple,用`（）`表示。一旦初始化后不可修改，安全性好。\n\n另外，有两个特例需注意。空的元组定义为（），单个元素的元组（i，）（与（i）数学意义相区别）\n\n嵌套list可变为可变的元组。那要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。\n\nlist和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。\n\n\n### 字典\nPython内置了字典：dict的支持，dict全称dictionary，用`{}`表示。在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度，但占用内存多。\n\n一对一存储，后来的值会冲掉之前的值。\n\n如果字典里没有这个值，则会报错。那么事先可通过 in 来查找 或 get（\"hello\",-1）不存在返回-1。\n\npop(key)　删除，对应value也会删除\n\ndict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。\n\ndict是用空间来换取时间的一种方法。\n\n用键访问值的一种写法：\n```\n{'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}[\"0\"]\n```\n#### 字典推导\n字典推导尤其是在交换键和值十分管用。\n```\nmy_phrase = [\"No\", \"one\", \"expects\", \"the\", \"Spanish\", \"Inquisition\"]\nmy_dict = {key: value for value, key in enumerate(my_phrase)}\nprint(my_dict)\nreversed_dict = {value: key for key, value in my_dict.items()}\nprint(reversed_dict)\n```\n### set\n\nset是无序和无重复的交集，用`([ ])`表示。set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n\n通过add(key),remove(key)方法可以增删key。\n\nset可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。\n\nset和dict的唯一区别仅在于没有存储对应的value。\n\n### 再议不可变对象\n\nstr是不变对象，而list是可变对象。\n```\na='ABC'\na.replace('a', 'A')\n//'Abc'\na\n//'abc'\n```\n\na是变量，而'abc'才是字符串对象！有些时候，我们经常说，对象a的内容是'abc'，但其实是指，a本身是一个变量，它指向的对象的内容才是'abc'。\n\n\n\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"python/初探python(1)基础知识","published":1,"updated":"2019-03-22T14:44:36.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn2n00bi4l3nnkq04fm3","content":"<p><strong>人生苦短，我用Python</strong></p>\n<h2 id=\"Python是一种怎么样的语言？\"><a href=\"#Python是一种怎么样的语言？\" class=\"headerlink\" title=\"Python是一种怎么样的语言？\"></a>Python是一种怎么样的语言？</h2><h3 id=\"Python诞生\"><a href=\"#Python诞生\" class=\"headerlink\" title=\"Python诞生\"></a>Python诞生</h3><p>Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。</p>\n<p>龟叔给Python的定位是<strong>“优雅”、“明确”、“简单”</strong>，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。</p>\n<p><img src=\"http://i2.buimg.com/567571/b65ae576e4e3215e.jpg\" alt=\"龟叔\"><br><a id=\"more\"></a><br>它常被成为<code>胶水语言</code>。能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写。</p>\n<p>Python具有丰富和强大的库。提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作<code>内置电池（batteries included）</code>。除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。</p>\n<h3 id=\"Python适合开发的应用\"><a href=\"#Python适合开发的应用\" class=\"headerlink\" title=\"Python适合开发的应用\"></a>Python适合开发的应用</h3><ul>\n<li><p>网络应用，包括网站、后台服务等等；</p>\n</li>\n<li><p>许多日常需要的小工具，包括系统管理员需要的脚本任务等等；</p>\n</li>\n<li><p>把其他语言开发的程序再包装起来，方便使用。</p>\n</li>\n</ul>\n<p>###　Python的缺点</p>\n<p>其一，<strong>便是运行速度慢</strong>。因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。</p>\n<p>其二，<strong>代码不能加密</strong>。凡是编译型的语言，发布的是编译后的机器码如<code>.exe</code>，而解释型的语言，则必须把源码发布出去。</p>\n<h2 id=\"侧重点杂记\"><a href=\"#侧重点杂记\" class=\"headerlink\" title=\"侧重点杂记\"></a>侧重点杂记</h2><p>请务必注意，Python程序是<em>大小写</em>敏感的并且对于<em>缩进</em>要求严格，如果写错了大小写，程序会报错。如果直接复制粘贴，会导致缩进存在问题。</p>\n<p><code># -*- coding=utf-8 -*-</code>　用以开头声明编码方式，输出中文</p>\n<p><code>#</code>用来注释,其他每一行都是一个语句，当语句以冒号“:”结尾时，缩进的语句视为代码块。</p>\n<p>在讲Python之前，先讲一下一些Sublime的用法。</p>\n<h3 id=\"Sublime基础用法\"><a href=\"#Sublime基础用法\" class=\"headerlink\" title=\"Sublime基础用法\"></a>Sublime基础用法</h3><p>Sublime作为我最常用的编辑器，不得不提一下其对于Python编程的一些快捷键。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctrl+<span class=\"selector-tag\">b</span>　<span class=\"comment\">//运行python程序</span></span><br><span class=\"line\"></span><br><span class=\"line\">ctrl+c　<span class=\"comment\">//停止运行</span></span><br><span class=\"line\"></span><br><span class=\"line\">ctrl+/　<span class=\"comment\">//全体注释/取消注释</span></span><br><span class=\"line\"></span><br><span class=\"line\">ctrl+[　<span class=\"comment\">//全体不缩进</span></span><br><span class=\"line\"></span><br><span class=\"line\">alt+num　<span class=\"comment\">//切换标签页</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"输入与输出\"><a href=\"#输入与输出\" class=\"headerlink\" title=\"输入与输出\"></a>输入与输出</h3><p>输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。</p>\n<p><code>raw_input()</code>和<code>print</code>是在命令行下面最基本的输入和输出。</p>\n<p><code>raw_input()</code>调用时可填入空内显示一个字符串，用来做提示信息。</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”。</p>\n<p>如果字符串内部既包含’又包含”怎么办？可以用转义字符<code>\\</code>来标识`。</p>\n<p>转义字符<code>\\</code>可以转义很多字符，比如<code>\\n</code>表示换行，<code>\\t</code>表示制表符，字符<code>\\</code>本身也要转义，所以<code>\\\\</code>表示的字符就是\\。Python还允许用<code>r&#39;&#39;</code>表示’’内部的字符串默认不转义</p>\n<p>Python允许用<code>&#39;&#39;&#39;</code>的格式表示多行内容</p>\n<p>空值是Python里一个特殊的值，用<code>None</code>表示。与0不同。</p>\n<p>Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p>\n<p>整数：一般意义上的数，包含十进制(无前缀),八进制(0开头)，十六进制(0x开头),二进制(0b开头)</p>\n<p>长整数：无限大小的数,表示范围和内存有关</p>\n<p>浮点数：小数或用e/E(10的幂)表示的幂,默认，浮点数学缺乏精确性,可以使用decimal</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">a</span> = <span class=\"string\">'ABC'</span></span><br></pre></td></tr></table></figure>\n<p>以上，Python解释器干了两件事情：</p>\n<p>1.在内存中创建了一个’ABC’的字符串；</p>\n<p>2.在内存中创建了一个名为a的变量，并把它指向’ABC’。</p>\n<p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据。而之后执行<br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">a</span>=<span class=\"string\">'XYZ'</span></span><br></pre></td></tr></table></figure></p>\n<p>b的值不会受到影响。</p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>在Python中，通常用全部大写的变量名表示常量。一般不改变其值，不过硬要改变也可，只不过违背了命名规则。</p>\n<h3 id=\"题外话：字符编码\"><a href=\"#题外话：字符编码\" class=\"headerlink\" title=\"题外话：字符编码\"></a>题外话：字符编码</h3><p>在讲字符串之前，先提一下字符串编码的问题。</p>\n<p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p>\n<p>由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码，比如大写字母A的编码是65，小写字母z的编码是122。</p>\n<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和<code>ASCII</code>编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去。</p>\n<p>当然世界上还有其他国家，这么多语言，各国有各国的标准，如果一个文本里出现多种语言的话，就会乱码。</p>\n<p><code>Unicode</code>应运而生。<code>Unicode</code>把所有语言都统一到一套编码里，这样就不会再有乱码问题了。最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持<code>Unicode</code>。</p>\n<p>新的问题又出现了：如果统一成<code>Unicode</code>编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用<code>Unicode</code>编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>\n<p>所以，本着节约的精神，又出现了把<code>Unicode</code>编码转化为“可变长编码”的<code>UTF-8</code>编码。<code>UTF-8</code>编码把一个<code>Unicode</code>字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用<code>UTF-8</code>编码就能节省空间.</p>\n<p>另外，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p>\n<p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p>\n<p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p>\n<p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p>\n<p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。</p>\n<p>当看到<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息时，也就意味着该网页正是用的UTF-8编码。</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码。Python提供了ord()和chr()函数，可以把字母和对应的数字相互转换。</p>\n<p>Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示。</p>\n<p>在Python 3.x版本中，把’xxx’和u’xxx’统一成Unicode编码，即写不写前缀u都是一样的，而以字节形式表示的字符串则必须加上b前缀：b’xxx’。</p>\n<p>在字符串前加r，例r’xxx’，表示不转义字符串。</p>\n<p>把u’xxx’转换为UTF-8编码的’xxx’用<code>encode(&#39;utf-8&#39;)</code>方法。反之则用<code>decode(&#39;utf-8&#39;)</code>。</p>\n<p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：<br><figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"meta\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"string\">' a test module '</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br></pre></td></tr></table></figure></p>\n<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p>\n<p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p>\n<p>此外，任何模块代码的第一个字符串都被视为模块的文档注释。</p>\n<p>使用<strong>author</strong>变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名。</p>\n<h4 id=\"字符串处理\"><a href=\"#字符串处理\" class=\"headerlink\" title=\"字符串处理\"></a>字符串处理</h4><p>在<code>PEP8</code>即Python编码样式指南中，要求每行不能超过80个字符，但在长字符串中如何做到呢？</p>\n<p>可以通过反斜杠、带逗号“,”的圆括号“()”、或者额外的加号“+”来完成换行。但对于多行字符串，这些解决方案都不够优雅。Python有个多行字符串记号，即三个引号，但这样无法换行后保持缩进。</p>\n<p>还有一个方法，那就是不带逗号的圆括号。我不知道为什么这种方式能工作，但能用就行。<br><figure class=\"highlight smalltalk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_long_text = (<span class=\"comment\">\"We are no longer the knights who say Ni! \"</span>        </span><br><span class=\"line\"><span class=\"comment\">\"We are now the knights who say ekki-ekki-\"</span>        </span><br><span class=\"line\"><span class=\"comment\">\"ekki-p'tang-zoom-boing-z'nourrwringmm!\"</span>)</span><br><span class=\"line\">print(my_long_text)</span><br></pre></td></tr></table></figure></p>\n<p>另外，python还提供了很多的字符串处理方式：<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">全部大写：<span class=\"built_in\">str</span>.upper()</span><br><span class=\"line\">全部小写：<span class=\"built_in\">str</span>.lower()</span><br><span class=\"line\">大小写互换：<span class=\"built_in\">str</span>.swapcase()</span><br><span class=\"line\">首字母大写，其余小写：<span class=\"built_in\">str</span>.capitalize()</span><br><span class=\"line\">首字母大写：<span class=\"built_in\">str</span>.title()</span><br><span class=\"line\">获取固定长度，右对齐，左边不够用空格补齐：<span class=\"built_in\">str</span>.ljust(<span class=\"built_in\">width</span>)</span><br><span class=\"line\">获取固定长度，左对齐，右边不够用空格补齐：<span class=\"built_in\">str</span>.rjust(<span class=\"built_in\">width</span>)</span><br><span class=\"line\">获取固定长度，中间对齐，两边不够用空格补齐：<span class=\"built_in\">str</span>.center(<span class=\"built_in\">width</span>)</span><br><span class=\"line\">获取固定长度，右对齐，左边不足用<span class=\"number\">0</span>补齐:<span class=\"built_in\">str</span>.zfill(<span class=\"built_in\">width</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">搜索指定字符串，没有返回<span class=\"number\">-1</span>：<span class=\"built_in\">str</span>.find(<span class=\"string\">'t'</span>)</span><br><span class=\"line\">指定起始位置搜索：<span class=\"built_in\">str</span>.find(<span class=\"string\">'t'</span>,start)</span><br><span class=\"line\">指定起始及结束位置搜索：<span class=\"built_in\">str</span>.find(<span class=\"string\">'t'</span>,start,end)</span><br><span class=\"line\">从右边开始查找：<span class=\"built_in\">str</span>.rfind(<span class=\"string\">'t'</span>)</span><br><span class=\"line\">搜索到多少个指定字符串：<span class=\"built_in\">str</span>.count(<span class=\"string\">'t'</span>)</span><br><span class=\"line\">上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回<span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">替换old为<span class=\"keyword\">new</span>：<span class=\"built_in\">str</span>.replace(<span class=\"string\">'old'</span>,<span class=\"string\">'new'</span>)</span><br><span class=\"line\">替换指定次数的old为<span class=\"keyword\">new</span>：<span class=\"built_in\">str</span>.replace(<span class=\"string\">'old'</span>,<span class=\"string\">'new'</span>,maxReplaceTimes)</span><br><span class=\"line\"></span><br><span class=\"line\">去两边空格：<span class=\"built_in\">str</span>.strip()</span><br><span class=\"line\">去左空格：<span class=\"built_in\">str</span>.lstrip()</span><br><span class=\"line\">去右空格：<span class=\"built_in\">str</span>.rstrip()</span><br><span class=\"line\">去两边字符串：<span class=\"built_in\">str</span>.strip(<span class=\"string\">'d'</span>)，相应的也有lstrip，rstrip</span><br><span class=\"line\"></span><br><span class=\"line\">分隔:<span class=\"built_in\">split</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">是否以start开头：<span class=\"built_in\">str</span>.startswith(<span class=\"string\">'start'</span>)</span><br><span class=\"line\">是否以end结尾：<span class=\"built_in\">str</span>.endswith(<span class=\"string\">'end'</span>)</span><br><span class=\"line\">是否全为字母或数字：<span class=\"built_in\">str</span>.isalnum()</span><br><span class=\"line\">是否全字母：<span class=\"built_in\">str</span>.isalpha()</span><br><span class=\"line\">是否全数字：<span class=\"built_in\">str</span>.isdigit()</span><br><span class=\"line\">是否全小写：<span class=\"built_in\">str</span>.islower()</span><br><span class=\"line\">是否全大写：<span class=\"built_in\">str</span>.isupper()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h3><p>%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</p>\n<p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串。</p>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%%</td>\n<td style=\"text-align:left\">百分号标记 #就是输出一个%</td>\n</tr>\n<tr>\n<td>%c</td>\n<td style=\"text-align:left\">字符及其ASCII码</td>\n</tr>\n<tr>\n<td>%s</td>\n<td style=\"text-align:left\">字符串</td>\n</tr>\n<tr>\n<td>%d</td>\n<td style=\"text-align:left\">有符号整数(十进制)</td>\n</tr>\n<tr>\n<td>%u</td>\n<td style=\"text-align:left\">无符号整数(十进制)</td>\n</tr>\n<tr>\n<td>%o</td>\n<td style=\"text-align:left\">无符号整数(八进制)</td>\n</tr>\n<tr>\n<td>%x</td>\n<td style=\"text-align:left\">无符号整数(十六进制)</td>\n</tr>\n<tr>\n<td>%X</td>\n<td style=\"text-align:left\">无符号整数(十六进制大写字符)</td>\n</tr>\n<tr>\n<td>%e</td>\n<td style=\"text-align:left\">浮点数字(科学计数法)</td>\n</tr>\n<tr>\n<td>%E</td>\n<td style=\"text-align:left\">浮点数字(科学计数法，用E代替e)</td>\n</tr>\n<tr>\n<td>%f</td>\n<td style=\"text-align:left\">浮点数字(用小数点符号)</td>\n</tr>\n<tr>\n<td>%g</td>\n<td style=\"text-align:left\">浮点数字(根据值的大小采用%e或%f)</td>\n</tr>\n<tr>\n<td>%G</td>\n<td style=\"text-align:left\">浮点数字(类似于%g)</td>\n</tr>\n<tr>\n<td>%p</td>\n<td style=\"text-align:left\">指针(用十六进制打印值的内存地址)</td>\n</tr>\n<tr>\n<td>%n</td>\n<td style=\"text-align:left\">存储输出字符的数量放进参数列表的下一个变量中</td>\n</tr>\n<tr>\n<td>%r</td>\n<td style=\"text-align:left\">自加引号的字符串，再现他所代表的任意对象</td>\n</tr>\n</tbody>\n</table>\n<p>当<code>%</code>为普通字符需要用<code>%%</code>转义。<br>举个例子：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'%<span class=\"number\">2</span>d-%<span class=\"number\">02</span>d<span class=\"string\">\"%(3.14,6)</span></span><br><span class=\"line\"><span class=\"string\">' 3-06'</span></span><br><span class=\"line\"><span class=\"string\">\"</span>%<span class=\"number\">9.2</span>f<span class=\"string\">\"%12.345</span></span><br><span class=\"line\"><span class=\"string\">    12.35</span></span><br><span class=\"line\"><span class=\"string\">\"</span>%<span class=\"number\">09.2</span>f<span class=\"string\">\"%12.345</span></span><br><span class=\"line\"><span class=\"string\">000012.35</span></span><br></pre></td></tr></table></figure></p>\n<p>可以在”%”和字母之间插进数字表示最大场宽。<br>例如: %3d 表示输出3位整型数, 不够3位右对齐。<br>表示输出场宽为9的浮点数, 其中小数位为2, 整数位为6,<br>小数点占一位, 不够9位右对齐。<br><code>%09.2f</code>其中小数位为2, 整数位为6,小数点占一位, 不够9位零补齐。</p>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><p>循环for语言有所不同，其他略有改动，条件不用加括号，并且每条判断要加<code>：</code>，之后的语句需要有缩进。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>　<span class=\"keyword\">else</span>　elif </span><br><span class=\"line\"><span class=\"keyword\">for</span>.<span class=\"selector-class\">.in</span>　依次把列表内每个元素列出来</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">range</span><span class=\"params\">(i)</span></span>　<span class=\"number\">0</span> 到 i-<span class=\"number\">1</span> 的整数</span><br><span class=\"line\">while </span><br><span class=\"line\">ctrl+c 可退出循环</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>Python内置的一种数据类型是列表：list，这是一种有序的集合，可以随时添加和删除其中的元素。用<code>[ ]</code>表示。</p>\n<p>list是一种有序的集合，可以随时添加（insert（i，“hello”））和删除（pop（i））其中的元素。</p>\n<p>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素。以此类推，可以有-2，-3<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> index, <span class=\"built_in\">item</span> <span class=\"keyword\">in</span> enumerate(mylist):</span><br><span class=\"line\">  print(index, <span class=\"built_in\">item</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"列表推导\"><a href=\"#列表推导\" class=\"headerlink\" title=\"列表推导\"></a>列表推导</h4><p>[表达式 for 变量 in 列表]    或者  [表达式 for 变量 in 列表 if 条件]</p>\n<h3 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h3><p>另一种有序列表叫元组: tuple,用<code>（）</code>表示。一旦初始化后不可修改，安全性好。</p>\n<p>另外，有两个特例需注意。空的元组定义为（），单个元素的元组（i，）（与（i）数学意义相区别）</p>\n<p>嵌套list可变为可变的元组。那要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p>\n<p>list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。</p>\n<h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><p>Python内置了字典：dict的支持，dict全称dictionary，用<code>{}</code>表示。在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度，但占用内存多。</p>\n<p>一对一存储，后来的值会冲掉之前的值。</p>\n<p>如果字典里没有这个值，则会报错。那么事先可通过 in 来查找 或 get（”hello”,-1）不存在返回-1。</p>\n<p>pop(key)　删除，对应value也会删除</p>\n<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。</p>\n<p>dict是用空间来换取时间的一种方法。</p>\n<p>用键访问值的一种写法：<br><figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'0'</span>: <span class=\"number\">0</span>, <span class=\"string\">'1'</span>: <span class=\"number\">1</span>, <span class=\"string\">'2'</span>: <span class=\"number\">2</span>, <span class=\"string\">'3'</span>: <span class=\"number\">3</span>, <span class=\"string\">'4'</span>: <span class=\"number\">4</span>, <span class=\"string\">'5'</span>: <span class=\"number\">5</span>, <span class=\"string\">'6'</span>: <span class=\"number\">6</span>, <span class=\"string\">'7'</span>: <span class=\"number\">7</span>, <span class=\"string\">'8'</span>: <span class=\"number\">8</span>, <span class=\"string\">'9'</span>: <span class=\"number\">9</span>&#125;[<span class=\"string\">\"0\"</span>]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"字典推导\"><a href=\"#字典推导\" class=\"headerlink\" title=\"字典推导\"></a>字典推导</h4><p>字典推导尤其是在交换键和值十分管用。<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_phrase = [<span class=\"string\">\"No\"</span>, <span class=\"string\">\"one\"</span>, <span class=\"string\">\"expects\"</span>, <span class=\"string\">\"the\"</span>, <span class=\"string\">\"Spanish\"</span>, <span class=\"string\">\"Inquisition\"</span>]</span><br><span class=\"line\">my_dict = <span class=\"built_in\">&#123;key</span>: <span class=\"keyword\">value</span> <span class=\"keyword\">for</span> <span class=\"keyword\">value</span>,<span class=\"built_in\"> key</span> <span class=\"keyword\">in</span> enumerate(my_phrase)&#125;</span><br><span class=\"line\">print(my_dict)</span><br><span class=\"line\">reversed_dict = &#123;value:<span class=\"built_in\"> key</span> <span class=\"keyword\">for</span><span class=\"built_in\"> key</span>, <span class=\"keyword\">value</span> <span class=\"keyword\">in</span> my_dict.items()&#125;</span><br><span class=\"line\">print(reversed_dict)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p>set是无序和无重复的交集，用<code>([ ])</code>表示。set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>\n<p>通过add(key),remove(key)方法可以增删key。</p>\n<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。</p>\n<p>set和dict的唯一区别仅在于没有存储对应的value。</p>\n<h3 id=\"再议不可变对象\"><a href=\"#再议不可变对象\" class=\"headerlink\" title=\"再议不可变对象\"></a>再议不可变对象</h3><p>str是不变对象，而list是可变对象。<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">a</span>=<span class=\"string\">'ABC'</span></span><br><span class=\"line\"><span class=\"keyword\">a</span>.<span class=\"built_in\">replace</span>(<span class=\"string\">'a'</span>, <span class=\"string\">'A'</span>)</span><br><span class=\"line\">//<span class=\"string\">'Abc'</span></span><br><span class=\"line\"><span class=\"keyword\">a</span></span><br><span class=\"line\">//<span class=\"string\">'abc'</span></span><br></pre></td></tr></table></figure></p>\n<p>a是变量，而’abc’才是字符串对象！有些时候，我们经常说，对象a的内容是’abc’，但其实是指，a本身是一个变量，它指向的对象的内容才是’abc’。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p><strong>人生苦短，我用Python</strong></p>\n<h2 id=\"Python是一种怎么样的语言？\"><a href=\"#Python是一种怎么样的语言？\" class=\"headerlink\" title=\"Python是一种怎么样的语言？\"></a>Python是一种怎么样的语言？</h2><h3 id=\"Python诞生\"><a href=\"#Python诞生\" class=\"headerlink\" title=\"Python诞生\"></a>Python诞生</h3><p>Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。</p>\n<p>龟叔给Python的定位是<strong>“优雅”、“明确”、“简单”</strong>，所以Python程序看上去总是简单易懂，初学者学Python，不但入门容易，而且将来深入下去，可以编写那些非常非常复杂的程序。</p>\n<p><img src=\"http://i2.buimg.com/567571/b65ae576e4e3215e.jpg\" alt=\"龟叔\"><br></p>","more":"<br>它常被成为<code>胶水语言</code>。能够把用其他语言制作的各种模块（尤其是C/C++）很轻松地联结在一起。常见的一种应用情形是，使用Python快速生成程序的原型（有时甚至是程序的最终界面），然后对其中有特别要求的部分，用更合适的语言改写。<p></p>\n<p>Python具有丰富和强大的库。提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作<code>内置电池（batteries included）</code>。除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。</p>\n<h3 id=\"Python适合开发的应用\"><a href=\"#Python适合开发的应用\" class=\"headerlink\" title=\"Python适合开发的应用\"></a>Python适合开发的应用</h3><ul>\n<li><p>网络应用，包括网站、后台服务等等；</p>\n</li>\n<li><p>许多日常需要的小工具，包括系统管理员需要的脚本任务等等；</p>\n</li>\n<li><p>把其他语言开发的程序再包装起来，方便使用。</p>\n</li>\n</ul>\n<p>###　Python的缺点</p>\n<p>其一，<strong>便是运行速度慢</strong>。因为Python是解释型语言，你的代码在执行时会一行一行地翻译成CPU能理解的机器码，这个翻译过程非常耗时，所以很慢。而C程序是运行前直接编译成CPU能执行的机器码，所以非常快。</p>\n<p>其二，<strong>代码不能加密</strong>。凡是编译型的语言，发布的是编译后的机器码如<code>.exe</code>，而解释型的语言，则必须把源码发布出去。</p>\n<h2 id=\"侧重点杂记\"><a href=\"#侧重点杂记\" class=\"headerlink\" title=\"侧重点杂记\"></a>侧重点杂记</h2><p>请务必注意，Python程序是<em>大小写</em>敏感的并且对于<em>缩进</em>要求严格，如果写错了大小写，程序会报错。如果直接复制粘贴，会导致缩进存在问题。</p>\n<p><code># -*- coding=utf-8 -*-</code>　用以开头声明编码方式，输出中文</p>\n<p><code>#</code>用来注释,其他每一行都是一个语句，当语句以冒号“:”结尾时，缩进的语句视为代码块。</p>\n<p>在讲Python之前，先讲一下一些Sublime的用法。</p>\n<h3 id=\"Sublime基础用法\"><a href=\"#Sublime基础用法\" class=\"headerlink\" title=\"Sublime基础用法\"></a>Sublime基础用法</h3><p>Sublime作为我最常用的编辑器，不得不提一下其对于Python编程的一些快捷键。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ctrl+<span class=\"selector-tag\">b</span>　<span class=\"comment\">//运行python程序</span></span><br><span class=\"line\"></span><br><span class=\"line\">ctrl+c　<span class=\"comment\">//停止运行</span></span><br><span class=\"line\"></span><br><span class=\"line\">ctrl+/　<span class=\"comment\">//全体注释/取消注释</span></span><br><span class=\"line\"></span><br><span class=\"line\">ctrl+[　<span class=\"comment\">//全体不缩进</span></span><br><span class=\"line\"></span><br><span class=\"line\">alt+num　<span class=\"comment\">//切换标签页</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"输入与输出\"><a href=\"#输入与输出\" class=\"headerlink\" title=\"输入与输出\"></a>输入与输出</h3><p>输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。</p>\n<p><code>raw_input()</code>和<code>print</code>是在命令行下面最基本的输入和输出。</p>\n<p><code>raw_input()</code>调用时可填入空内显示一个字符串，用来做提示信息。</p>\n<h3 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h3><p>Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”。</p>\n<p>如果字符串内部既包含’又包含”怎么办？可以用转义字符<code>\\</code>来标识`。</p>\n<p>转义字符<code>\\</code>可以转义很多字符，比如<code>\\n</code>表示换行，<code>\\t</code>表示制表符，字符<code>\\</code>本身也要转义，所以<code>\\\\</code>表示的字符就是\\。Python还允许用<code>r&#39;&#39;</code>表示’’内部的字符串默认不转义</p>\n<p>Python允许用<code>&#39;&#39;&#39;</code>的格式表示多行内容</p>\n<p>空值是Python里一个特殊的值，用<code>None</code>表示。与0不同。</p>\n<p>Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p>\n<p>整数：一般意义上的数，包含十进制(无前缀),八进制(0开头)，十六进制(0x开头),二进制(0b开头)</p>\n<p>长整数：无限大小的数,表示范围和内存有关</p>\n<p>浮点数：小数或用e/E(10的幂)表示的幂,默认，浮点数学缺乏精确性,可以使用decimal</p>\n<h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><p>变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">a</span> = <span class=\"string\">'ABC'</span></span><br></pre></td></tr></table></figure>\n<p>以上，Python解释器干了两件事情：</p>\n<p>1.在内存中创建了一个’ABC’的字符串；</p>\n<p>2.在内存中创建了一个名为a的变量，并把它指向’ABC’。</p>\n<p>也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据。而之后执行<br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">a</span>=<span class=\"string\">'XYZ'</span></span><br></pre></td></tr></table></figure></p>\n<p>b的值不会受到影响。</p>\n<h3 id=\"常量\"><a href=\"#常量\" class=\"headerlink\" title=\"常量\"></a>常量</h3><p>在Python中，通常用全部大写的变量名表示常量。一般不改变其值，不过硬要改变也可，只不过违背了命名规则。</p>\n<h3 id=\"题外话：字符编码\"><a href=\"#题外话：字符编码\" class=\"headerlink\" title=\"题外话：字符编码\"></a>题外话：字符编码</h3><p>在讲字符串之前，先提一下字符串编码的问题。</p>\n<p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p>\n<p>由于计算机是美国人发明的，因此，最早只有127个字母被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为<code>ASCII</code>编码，比如大写字母A的编码是65，小写字母z的编码是122。</p>\n<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和<code>ASCII</code>编码冲突，所以，中国制定了<code>GB2312</code>编码，用来把中文编进去。</p>\n<p>当然世界上还有其他国家，这么多语言，各国有各国的标准，如果一个文本里出现多种语言的话，就会乱码。</p>\n<p><code>Unicode</code>应运而生。<code>Unicode</code>把所有语言都统一到一套编码里，这样就不会再有乱码问题了。最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持<code>Unicode</code>。</p>\n<p>新的问题又出现了：如果统一成<code>Unicode</code>编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用<code>Unicode</code>编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>\n<p>所以，本着节约的精神，又出现了把<code>Unicode</code>编码转化为“可变长编码”的<code>UTF-8</code>编码。<code>UTF-8</code>编码把一个<code>Unicode</code>字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用<code>UTF-8</code>编码就能节省空间.</p>\n<p>另外，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。</p>\n<p>搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：</p>\n<p>在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。</p>\n<p>用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件。</p>\n<p>浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器。</p>\n<p>当看到<code>&lt;meta charset=&quot;UTF-8&quot; /&gt;</code>的信息时，也就意味着该网页正是用的UTF-8编码。</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>因为Python的诞生比Unicode标准发布的时间还要早，所以最早的Python只支持ASCII编码。Python提供了ord()和chr()函数，可以把字母和对应的数字相互转换。</p>\n<p>Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示。</p>\n<p>在Python 3.x版本中，把’xxx’和u’xxx’统一成Unicode编码，即写不写前缀u都是一样的，而以字节形式表示的字符串则必须加上b前缀：b’xxx’。</p>\n<p>在字符串前加r，例r’xxx’，表示不转义字符串。</p>\n<p>把u’xxx’转换为UTF-8编码的’xxx’用<code>encode(&#39;utf-8&#39;)</code>方法。反之则用<code>decode(&#39;utf-8&#39;)</code>。</p>\n<p>由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：<br><figure class=\"highlight vala\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/usr/bin/env python</span></span><br><span class=\"line\"><span class=\"meta\"># -*- coding: utf-8 -*-</span></span><br><span class=\"line\"><span class=\"string\">' a test module '</span></span><br><span class=\"line\">__author__ = <span class=\"string\">'zjbao123'</span></span><br></pre></td></tr></table></figure></p>\n<p>第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；</p>\n<p>第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。</p>\n<p>此外，任何模块代码的第一个字符串都被视为模块的文档注释。</p>\n<p>使用<strong>author</strong>变量把作者写进去，这样当你公开源代码后别人就可以瞻仰你的大名。</p>\n<h4 id=\"字符串处理\"><a href=\"#字符串处理\" class=\"headerlink\" title=\"字符串处理\"></a>字符串处理</h4><p>在<code>PEP8</code>即Python编码样式指南中，要求每行不能超过80个字符，但在长字符串中如何做到呢？</p>\n<p>可以通过反斜杠、带逗号“,”的圆括号“()”、或者额外的加号“+”来完成换行。但对于多行字符串，这些解决方案都不够优雅。Python有个多行字符串记号，即三个引号，但这样无法换行后保持缩进。</p>\n<p>还有一个方法，那就是不带逗号的圆括号。我不知道为什么这种方式能工作，但能用就行。<br><figure class=\"highlight smalltalk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_long_text = (<span class=\"comment\">\"We are no longer the knights who say Ni! \"</span>        </span><br><span class=\"line\"><span class=\"comment\">\"We are now the knights who say ekki-ekki-\"</span>        </span><br><span class=\"line\"><span class=\"comment\">\"ekki-p'tang-zoom-boing-z'nourrwringmm!\"</span>)</span><br><span class=\"line\">print(my_long_text)</span><br></pre></td></tr></table></figure></p>\n<p>另外，python还提供了很多的字符串处理方式：<br><figure class=\"highlight processing\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">全部大写：<span class=\"built_in\">str</span>.upper()</span><br><span class=\"line\">全部小写：<span class=\"built_in\">str</span>.lower()</span><br><span class=\"line\">大小写互换：<span class=\"built_in\">str</span>.swapcase()</span><br><span class=\"line\">首字母大写，其余小写：<span class=\"built_in\">str</span>.capitalize()</span><br><span class=\"line\">首字母大写：<span class=\"built_in\">str</span>.title()</span><br><span class=\"line\">获取固定长度，右对齐，左边不够用空格补齐：<span class=\"built_in\">str</span>.ljust(<span class=\"built_in\">width</span>)</span><br><span class=\"line\">获取固定长度，左对齐，右边不够用空格补齐：<span class=\"built_in\">str</span>.rjust(<span class=\"built_in\">width</span>)</span><br><span class=\"line\">获取固定长度，中间对齐，两边不够用空格补齐：<span class=\"built_in\">str</span>.center(<span class=\"built_in\">width</span>)</span><br><span class=\"line\">获取固定长度，右对齐，左边不足用<span class=\"number\">0</span>补齐:<span class=\"built_in\">str</span>.zfill(<span class=\"built_in\">width</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">搜索指定字符串，没有返回<span class=\"number\">-1</span>：<span class=\"built_in\">str</span>.find(<span class=\"string\">'t'</span>)</span><br><span class=\"line\">指定起始位置搜索：<span class=\"built_in\">str</span>.find(<span class=\"string\">'t'</span>,start)</span><br><span class=\"line\">指定起始及结束位置搜索：<span class=\"built_in\">str</span>.find(<span class=\"string\">'t'</span>,start,end)</span><br><span class=\"line\">从右边开始查找：<span class=\"built_in\">str</span>.rfind(<span class=\"string\">'t'</span>)</span><br><span class=\"line\">搜索到多少个指定字符串：<span class=\"built_in\">str</span>.count(<span class=\"string\">'t'</span>)</span><br><span class=\"line\">上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回<span class=\"number\">-1</span></span><br><span class=\"line\"></span><br><span class=\"line\">替换old为<span class=\"keyword\">new</span>：<span class=\"built_in\">str</span>.replace(<span class=\"string\">'old'</span>,<span class=\"string\">'new'</span>)</span><br><span class=\"line\">替换指定次数的old为<span class=\"keyword\">new</span>：<span class=\"built_in\">str</span>.replace(<span class=\"string\">'old'</span>,<span class=\"string\">'new'</span>,maxReplaceTimes)</span><br><span class=\"line\"></span><br><span class=\"line\">去两边空格：<span class=\"built_in\">str</span>.strip()</span><br><span class=\"line\">去左空格：<span class=\"built_in\">str</span>.lstrip()</span><br><span class=\"line\">去右空格：<span class=\"built_in\">str</span>.rstrip()</span><br><span class=\"line\">去两边字符串：<span class=\"built_in\">str</span>.strip(<span class=\"string\">'d'</span>)，相应的也有lstrip，rstrip</span><br><span class=\"line\"></span><br><span class=\"line\">分隔:<span class=\"built_in\">split</span>()</span><br><span class=\"line\"></span><br><span class=\"line\">是否以start开头：<span class=\"built_in\">str</span>.startswith(<span class=\"string\">'start'</span>)</span><br><span class=\"line\">是否以end结尾：<span class=\"built_in\">str</span>.endswith(<span class=\"string\">'end'</span>)</span><br><span class=\"line\">是否全为字母或数字：<span class=\"built_in\">str</span>.isalnum()</span><br><span class=\"line\">是否全字母：<span class=\"built_in\">str</span>.isalpha()</span><br><span class=\"line\">是否全数字：<span class=\"built_in\">str</span>.isdigit()</span><br><span class=\"line\">是否全小写：<span class=\"built_in\">str</span>.islower()</span><br><span class=\"line\">是否全大写：<span class=\"built_in\">str</span>.isupper()</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"格式化\"><a href=\"#格式化\" class=\"headerlink\" title=\"格式化\"></a>格式化</h3><p>%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。</p>\n<p>如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串。</p>\n<table>\n<thead>\n<tr>\n<th>格式</th>\n<th style=\"text-align:left\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>%%</td>\n<td style=\"text-align:left\">百分号标记 #就是输出一个%</td>\n</tr>\n<tr>\n<td>%c</td>\n<td style=\"text-align:left\">字符及其ASCII码</td>\n</tr>\n<tr>\n<td>%s</td>\n<td style=\"text-align:left\">字符串</td>\n</tr>\n<tr>\n<td>%d</td>\n<td style=\"text-align:left\">有符号整数(十进制)</td>\n</tr>\n<tr>\n<td>%u</td>\n<td style=\"text-align:left\">无符号整数(十进制)</td>\n</tr>\n<tr>\n<td>%o</td>\n<td style=\"text-align:left\">无符号整数(八进制)</td>\n</tr>\n<tr>\n<td>%x</td>\n<td style=\"text-align:left\">无符号整数(十六进制)</td>\n</tr>\n<tr>\n<td>%X</td>\n<td style=\"text-align:left\">无符号整数(十六进制大写字符)</td>\n</tr>\n<tr>\n<td>%e</td>\n<td style=\"text-align:left\">浮点数字(科学计数法)</td>\n</tr>\n<tr>\n<td>%E</td>\n<td style=\"text-align:left\">浮点数字(科学计数法，用E代替e)</td>\n</tr>\n<tr>\n<td>%f</td>\n<td style=\"text-align:left\">浮点数字(用小数点符号)</td>\n</tr>\n<tr>\n<td>%g</td>\n<td style=\"text-align:left\">浮点数字(根据值的大小采用%e或%f)</td>\n</tr>\n<tr>\n<td>%G</td>\n<td style=\"text-align:left\">浮点数字(类似于%g)</td>\n</tr>\n<tr>\n<td>%p</td>\n<td style=\"text-align:left\">指针(用十六进制打印值的内存地址)</td>\n</tr>\n<tr>\n<td>%n</td>\n<td style=\"text-align:left\">存储输出字符的数量放进参数列表的下一个变量中</td>\n</tr>\n<tr>\n<td>%r</td>\n<td style=\"text-align:left\">自加引号的字符串，再现他所代表的任意对象</td>\n</tr>\n</tbody>\n</table>\n<p>当<code>%</code>为普通字符需要用<code>%%</code>转义。<br>举个例子：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'%<span class=\"number\">2</span>d-%<span class=\"number\">02</span>d<span class=\"string\">\"%(3.14,6)</span></span><br><span class=\"line\"><span class=\"string\">' 3-06'</span></span><br><span class=\"line\"><span class=\"string\">\"</span>%<span class=\"number\">9.2</span>f<span class=\"string\">\"%12.345</span></span><br><span class=\"line\"><span class=\"string\">    12.35</span></span><br><span class=\"line\"><span class=\"string\">\"</span>%<span class=\"number\">09.2</span>f<span class=\"string\">\"%12.345</span></span><br><span class=\"line\"><span class=\"string\">000012.35</span></span><br></pre></td></tr></table></figure></p>\n<p>可以在”%”和字母之间插进数字表示最大场宽。<br>例如: %3d 表示输出3位整型数, 不够3位右对齐。<br>表示输出场宽为9的浮点数, 其中小数位为2, 整数位为6,<br>小数点占一位, 不够9位右对齐。<br><code>%09.2f</code>其中小数位为2, 整数位为6,小数点占一位, 不够9位零补齐。</p>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><p>循环for语言有所不同，其他略有改动，条件不用加括号，并且每条判断要加<code>：</code>，之后的语句需要有缩进。<br><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>　<span class=\"keyword\">else</span>　elif </span><br><span class=\"line\"><span class=\"keyword\">for</span>.<span class=\"selector-class\">.in</span>　依次把列表内每个元素列出来</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">range</span><span class=\"params\">(i)</span></span>　<span class=\"number\">0</span> 到 i-<span class=\"number\">1</span> 的整数</span><br><span class=\"line\">while </span><br><span class=\"line\">ctrl+c 可退出循环</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>Python内置的一种数据类型是列表：list，这是一种有序的集合，可以随时添加和删除其中的元素。用<code>[ ]</code>表示。</p>\n<p>list是一种有序的集合，可以随时添加（insert（i，“hello”））和删除（pop（i））其中的元素。</p>\n<p>如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素。以此类推，可以有-2，-3<br><figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> index, <span class=\"built_in\">item</span> <span class=\"keyword\">in</span> enumerate(mylist):</span><br><span class=\"line\">  print(index, <span class=\"built_in\">item</span>)</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"列表推导\"><a href=\"#列表推导\" class=\"headerlink\" title=\"列表推导\"></a>列表推导</h4><p>[表达式 for 变量 in 列表]    或者  [表达式 for 变量 in 列表 if 条件]</p>\n<h3 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h3><p>另一种有序列表叫元组: tuple,用<code>（）</code>表示。一旦初始化后不可修改，安全性好。</p>\n<p>另外，有两个特例需注意。空的元组定义为（），单个元素的元组（i，）（与（i）数学意义相区别）</p>\n<p>嵌套list可变为可变的元组。那要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。</p>\n<p>list和tuple是Python内置的有序集合，一个可变，一个不可变。根据需要来选择使用它们。</p>\n<h3 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h3><p>Python内置了字典：dict的支持，dict全称dictionary，用<code>{}</code>表示。在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度，但占用内存多。</p>\n<p>一对一存储，后来的值会冲掉之前的值。</p>\n<p>如果字典里没有这个值，则会报错。那么事先可通过 in 来查找 或 get（”hello”,-1）不存在返回-1。</p>\n<p>pop(key)　删除，对应value也会删除</p>\n<p>dict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。</p>\n<p>dict是用空间来换取时间的一种方法。</p>\n<p>用键访问值的一种写法：<br><figure class=\"highlight prolog\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"string\">'0'</span>: <span class=\"number\">0</span>, <span class=\"string\">'1'</span>: <span class=\"number\">1</span>, <span class=\"string\">'2'</span>: <span class=\"number\">2</span>, <span class=\"string\">'3'</span>: <span class=\"number\">3</span>, <span class=\"string\">'4'</span>: <span class=\"number\">4</span>, <span class=\"string\">'5'</span>: <span class=\"number\">5</span>, <span class=\"string\">'6'</span>: <span class=\"number\">6</span>, <span class=\"string\">'7'</span>: <span class=\"number\">7</span>, <span class=\"string\">'8'</span>: <span class=\"number\">8</span>, <span class=\"string\">'9'</span>: <span class=\"number\">9</span>&#125;[<span class=\"string\">\"0\"</span>]</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"字典推导\"><a href=\"#字典推导\" class=\"headerlink\" title=\"字典推导\"></a>字典推导</h4><p>字典推导尤其是在交换键和值十分管用。<br><figure class=\"highlight xquery\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">my_phrase = [<span class=\"string\">\"No\"</span>, <span class=\"string\">\"one\"</span>, <span class=\"string\">\"expects\"</span>, <span class=\"string\">\"the\"</span>, <span class=\"string\">\"Spanish\"</span>, <span class=\"string\">\"Inquisition\"</span>]</span><br><span class=\"line\">my_dict = <span class=\"built_in\">&#123;key</span>: <span class=\"keyword\">value</span> <span class=\"keyword\">for</span> <span class=\"keyword\">value</span>,<span class=\"built_in\"> key</span> <span class=\"keyword\">in</span> enumerate(my_phrase)&#125;</span><br><span class=\"line\">print(my_dict)</span><br><span class=\"line\">reversed_dict = &#123;value:<span class=\"built_in\"> key</span> <span class=\"keyword\">for</span><span class=\"built_in\"> key</span>, <span class=\"keyword\">value</span> <span class=\"keyword\">in</span> my_dict.items()&#125;</span><br><span class=\"line\">print(reversed_dict)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><p>set是无序和无重复的交集，用<code>([ ])</code>表示。set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。</p>\n<p>通过add(key),remove(key)方法可以增删key。</p>\n<p>set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作。</p>\n<p>set和dict的唯一区别仅在于没有存储对应的value。</p>\n<h3 id=\"再议不可变对象\"><a href=\"#再议不可变对象\" class=\"headerlink\" title=\"再议不可变对象\"></a>再议不可变对象</h3><p>str是不变对象，而list是可变对象。<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">a</span>=<span class=\"string\">'ABC'</span></span><br><span class=\"line\"><span class=\"keyword\">a</span>.<span class=\"built_in\">replace</span>(<span class=\"string\">'a'</span>, <span class=\"string\">'A'</span>)</span><br><span class=\"line\">//<span class=\"string\">'Abc'</span></span><br><span class=\"line\"><span class=\"keyword\">a</span></span><br><span class=\"line\">//<span class=\"string\">'abc'</span></span><br></pre></td></tr></table></figure></p>\n<p>a是变量，而’abc’才是字符串对象！有些时候，我们经常说，对象a的内容是’abc’，但其实是指，a本身是一个变量，它指向的对象的内容才是’abc’。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"初探python(10)进程与线程","date":"2016-10-20T08:55:30.000Z","_content":"\n\n的确，线程和进程的知识有点繁，耐下性子先过一遍吧。\n## 什么是多进程和多线程\n\n对于操作系统来说，一个任务就是一个进程（Process）。\n多进程的操作系统轮流让各个进程交替执行，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。\n<!-- more -->\n真正的并行执行多进程只能在多核CPU上实现，但是，由于进程数量远远多于CPU的核心数量，所以，操作系统也会自动把很多进程轮流调度到每个核心上执行。\n\n在一个进程内部有些还不是干一件事，像Word可以有多件事同时干，就需要运行多个子任务，我们把子任务称之为“线程”（Thread）。\n\n由于每个进程至少要干一件事，所以至少有一个线程。操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。\n\n那python要同时执行执行多个任务的话，多任务的实现有3种方式：\n\n多进程模式；\n多线程模式；\n多进程+多线程模式。\n\n多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。\n\n## 多进程\n\n### fork\nUnix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。\n\n子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。\n```\nimport os\n\nprint 'Process (%s) start...' % os.getpid()\npid = os.fork()\nif pid==0:\n    print 'I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid())\nelse:\n    print 'I (%s) just created a child process (%s).' % (os.getpid(), pid)\n```\n有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。\n\n### multiprocessing\n\n但我用的是Windows系统，由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。`multiprocessing`模块就是跨平台版本的多进程模块。\n```\nfrom multiprocessing import Process\nimport os\n\ndef run_proc(name):\n    print 'Run child process %s (%s)...' % (name, os.getpid())\nif __name__ == '__main__':\n    print 'Run parent process %s...' % os.getpid()\n    p = Process(target=run_proc, args=('test',))\n    print 'child process will start ...'\n    p.start()\n    p.join()\n    print 'Process end.'\n```\n创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。\n\njoin()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。\n\n###　Pool\n如果要启动大量的子进程，可以用进程池的方式批量创建子进程：\n```\nfrom multiprocessing import Pool\nimport os, time, random\n\ndef long_time_task(name):\n    print 'Run task %s (%s)...' % (name, os.getpid())\n    start = time.time()\n    time.sleep(random.random() * 3)\n    end = time.time()\n    print 'Task %s runs %0.2f seconds.' % (name, (end - start))\n\nif __name__=='__main__':\n    print 'Parent process %s.' % os.getpid()\n    p = Pool()\n    for i in range(5):\n        p.apply_async(long_time_task, args=(i,))\n    print 'Waiting for all subprocesses done...'\n    p.close()\n    p.join()\n    print 'All subprocesses done.'\n\n```\n\n由于Pool的默认大小是CPU的核数。task一次性执行4个，其他的要等之前的执行完才能执行，如果改成:\n```\np = Pool(5)\n```\n\n### 进程间通信\n\nPython的`multiprocessing`模块包装了底层的机制，提供了`Queue`、`Pipes`等多种方式来交换数据。\n\n我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：\n\n```\nfrom multiprocessing import Process,Queue\nimport os,time,random\n\n\n# 写数据进程执行的代码:\ndef write(q):\n    for value in ['A','B','C']:\n        print 'Put %s to queue...' %value\n        q.put(value)\n        time.sleep(random.random())\n\n\n# 读数据进程执行的代码:\ndef read(q):\n    while True:\n        value = q.get(True)\n        print 'Get %s from queue.' % value\n\nif __name__ =='__main__':\n    # 父进程创建Queue，并传给各个子进程：\n    q = Queue()\n    pw = Process(target=write, args=(q,))\n    pr = Process(target=read, args=(q,))\n    # 启动子进程pw，写入:\n    pw.start()\n    # 启动子进程pw，读出:\n    pr.start()\n    pw.join()\n    # pr进程无限循环，强制终止\n    pr.terminate()\n\n```\n\n##　多线程\n由于线程是操作系统直接支持的执行单元，因此，python高级语言通常都内置多线程的支持，并且Python的线程是真正的Posix Thread（可移植操作系统接口 线程），而不是模拟出来的线程。\n\nPython的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。\n\n启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：\n```\nimport time, threading\n\ndef loop():\n    print 'thread %s is running ... ' % threading.current_thread().name\n    n = 0\n    while n <5:\n        n += 1\n        print 'thread %s => %s' % (threading.current_thread().name,n)\n        time.sleep(1)\n    print 'thread %s ended' % threading.current_thread().name\n\nprint 'thread %s is running ...' % threading.current_thread().name\nt = threading.Thread(target=loop, name='LoopThread')\nt.start()\nt.join()\nprint 'thread %s ended' % threading.current_thread().name\n```\n由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个`current_thread()`函数，它永远返回当前线程的实例。主线程实例的名字叫`MainThread`，子线程的名字在创建时指定，我们用`LoopThread`命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为`Thread-1`，`Thread-2`……\n\n\n\n### Lock\n多线程和多进程最大的不同在于:\n* 多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响;\n* 多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改。\n\n因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。\n\n所以，我们必须确保一个线程在修改变量的时候，别的线程一定不能改。\n```\nimport time, threading\n\nbalance = 0\nlock = threading.Lock()\n\n\ndef change_it(n):\n    global balance\n    balance = balance - n\n    balance = balance + n\n\ndef run_thread(n):\n    for i in range(1000):\n        lock.acquire()\n        try:\n            change_it(i)\n        finally:\n            lock.release()\n\nthread1 = threading.Thread(target=run_thread, args=(5,))\nthread2 = threading.Thread(target=run_thread, args=(8,))\n\nthread1.start()\nthread2.start()\nthread1.join()\nthread2.join()\nprint balance\n```\n\n### 多核CPU\n\n如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。\n\n如果写一个死循环的话，会出现什么情况呢？\n\n打开Mac OS X的Activity Monitor，或者Windows的Task Manager，都可以监控某个进程的CPU使用率。\n\n我们可以监控到一个死循环线程会100%占用一个CPU。\n\n启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有160%，但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？\n\n因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。\n\nGIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。\n\n所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。\n\n不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。\n\n## ThreadLocal\n正如上面所说，在多线程环境下，对于全局变量的修改必须加锁，因此，一个线程使用局部变量只有线程自己看得到，不会影响其他线程。\n\n但局部变量也有问题。就是在传递的时候非常麻烦。尽管是局部变量，但是每个函数都要用它，因此必须传进去。用全局变量又会影响其他进程，不能共享。\n```\nglobal_dict = {}\n\ndef std_thread(name):\n    std = Student(name)\n    # 把std放到全局变量global_dict中：\n    global_dict[threading.current_thread()] = std\n    do_task_1()\n    do_task_2()\n\ndef do_task_1():\n    # 不传入std，而是根据当前线程查找：\n    std = global_dict[threading.current_thread()]\n    ...\n\ndef do_task_2():\n    # 任何函数都可以查找出当前线程的std变量：\n    std = global_dict[threading.current_thread()]\n```\n如果用一个全局变量`dict`来存放所有的`Student`对象，然后以`thread`自身作为`key`获得线程对应的`student`,这样就消除了`std`对象在每层函数中传递问题，但是还是不够简单。\n\n`ThreadLocal`就是来自动帮你做这些事情的，不用查找`dict`。\n```\nimport threading\n\n# 创建全局ThreadLocal对象:\nlocal_school = threading.local()\n\ndef process_student():\n    print 'Hello, %s (in %s)' % (local_school.student, threading.current_thread().name)\n\ndef process_thread(name):\n    # 绑定ThreadLocal的student:\n    local_school.student = name\n    process_student()\n\nt1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')\nt2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n```\n全局变量`local_school`是一个`ThreadLocal`对象，每个`Thread`对它都可以读写`student`属性，但互不影响。你可以把`local_school`看成全局变量，但每个属性如`local_school.student`都是线程的局部变量，可以任意读写而不互相干扰，也不用管理锁的问题，`ThreadLocal`内部会进行处理。\n\n可以理解为全局变量`local_school`是一个`dict`，不但可以用`local_school.student`，还可以绑定其他变量，如`local_school.teacher`等等。\n\n`ThreadLocal`最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。\n\n### 进程 vs. 线程\n\n现在我们来讨论一下这两种方式的优缺点。\n\n首先，要实现多任务，通常我们会设计`Master-Worker`模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。\n\n自然，主的就是Master，其他进程/线程就是Worker\n\n多进程最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程（当然主进程挂了所有子进程都挂了，但是Master进程只负责分配任务，挂掉的概率低）。著名的Apache最早就是采用多进程模式。\n\n多进程的缺点就是创建进程的代价大，在Unix/Linu系统下，用`fork`调用还行，在Windows下创建进程就开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都是问题。\n\n多线程模式通常比多进程要快一些，但是也快不到哪里去，而且，多线程模式致命的缺点就是任何一个线程挂掉都直接可能造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出现了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作体统会强制结束整个进程。\n\n在Windows下，多线程的效率要比多进程高，所以微软的IIS服务器默认采用多线程模式，为了缓解这个问题，IIS和Apache现在又有多线程+多进程的混合模式，真是把问题越搞越复杂。\n\n### 线程切换\n\n无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？\n\n任务之间切换是有代价的。比如你从语文切换到数学，要收拾桌子上的语文书（这叫保存现场），然后打开数学课本（这叫准备新环境），才能开始做数学作业。操作系统在切换进程/线程也是需要时间的，它需要先保存当前执行的现场环境(CPU寄存器状态、内存页等)然后，把新任务的执行环境准备好(恢复上次的寄存器状态，切换内存页等)，才能开始执行。这个切换虽然快，但也需要时间，操作系统在任务多的时候可能主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口没反应，系统处于假死状态。\n\n所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果笑来急剧下降，所有任务都做不好。\n\n### 计算密集型 vs IO密集型\n\n是否采用多任务的第二个考虑是任务的类型。我们可以吧任务分为计算密集型和IO密集型。\n\n计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要高效利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。\n\n计算密集型任务主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务，多余计算密集型任务最好用C语言编写。\n\n第二种任务类型就是IO密集型，涉及到网络、磁盘IO任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成(因为IO的速度远远低于CPU和内存的速度)。对于IO密集型任务，任务越多，CPU效率越高，但也有个限度。常见的大部分任务都是IO密集型任务，比如Web应用。\n\nIO密集型任务执行期间，99%的时间都花在了IO上，花在CPU的时间爱你很少，对于IO密集型任务，最适合的语言就是开发效率最高(代码量最少)的语言，脚本语言是首选，C最差。\n\n### 异步IO\n考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程汇总大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。\n\n现代操作系统多IO操作已经做了巨大的改进，最大的特点就是支持异步IO，如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效的支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常有效。用异步IO编程模型来实现多任务是一个主要的趋势。\n\n对应到python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。\n\n协程我们后续会提到。\n\n### 分布式进程\n\n在process和thread中，应当优先选process，因为process更稳定，而且，process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。\n\nPython的`multiprocessing`模块不但支持多进程，其中`managers`子模块还支持把多进程分布到多台机器上。一个服务进程可以作为跳度者，将任务分布到其他多个进程中，依靠网络通信。由于`managers`模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。\n\n举个例子：如果我们已经有一个通过`Queue`通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望吧发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？\n\n原有的`Queue`可以继续使用，但是，通过`managers`模块把`Queue`通过网络暴Queue露出去，就可以让其他机器的进程访问`Queue`了。\n\n我们先看服务进程，服务进程负责启动`Queue`，把`Queue`注册到网络上，然后往`Queue`里面写任务：\n```\n'分布式进程 -- 服务器端'\n\nimport random, multiprocessing\nfrom multiprocessing.managers import BaseManager\nfrom multiprocessing import freeze_support\n\n\n# 从BaseManager继承的QueueManager:\nclass QueueManager(BaseManager):\n    pass\n\n\n# 发送任务的队列:\ntask_queue = multiprocessing.Queue()\n# 接收结果的队列:\nresult_queue = multiprocessing.Queue()\n\n# 为解决__main__.<lambda> not found问题\ndef get_task_queue():\n    return task_queue\n\n# 为解决__main__.<lambda> not found问题\ndef get_result_queue():\n    return result_queue\n\n\n# 把两个Queue都注册到网络上, callable参数关联了Queue对象:\nQueueManager.register('get_task_queue', callable=get_task_queue)\nQueueManager.register('get_result_queue', callable=get_result_queue)\n# 绑定端口5000, 设置验证码'abc':\nmanager = QueueManager(address=('127.0.0.1', 5000), authkey='abc')\n\n\ndef communicate():\n    # 获得通过网络访问的Queue对象:\n    task = manager.get_task_queue()\n    result = manager.get_result_queue()\n\n    # 放几个任务进去:\n    for i in range(10):\n        n = random.randint(0, 10000)\n        print('Put task %d...' % n)\n        task.put(n)\n\n    # 从result队列读取结果:\n    print('Try get results...')\n    for i in range(10):\n        r = result.get(timeout=10)\n        print('Result: %s' % r)\n\n    # 关闭:\n    manager.shutdown()\n\n\nif __name__ == '__main__':\n    freeze_support()\n    # 启动Queue:\n    manager.start()\n    communicate()\n\n```\n请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到`Queue`不可以直接对原始的`task_queue`进行操作，那样就绕过了`QueueManager`的封装，必须通过`manager.get_task_queue()`获得的`Queue`接口添加。\n```\nimport time, sys, Queue\nfrom multiprocessing.managers import BaseManager\n\n# 创建类似的QueueManager:\nclass QueueManager(BaseManager):\n    pass\n\n# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:\nQueueManager.register('get_task_queue')\nQueueManager.register('get_result_queue')\n\n# 连接到服务器，也就是运行taskmanager.py的机器:\nserver_addr = '127.0.0.1'\nprint('Connect to server %s...' % server_addr)\n# 端口和验证码注意保持与taskmanager.py设置的完全一致:\nm = QueueManager(address=(server_addr, 5000), authkey='abc')\n# 从网络连接:\nm.connect()\n# 获取Queue的对象:\ntask = m.get_task_queue()\nresult = m.get_result_queue()\n# 从task队列取任务,并把结果写入result队列:\nfor i in range(10):\n    try:\n        n = task.get(timeout=1)\n        print('run task %d * %d...' % (n, n))\n        r = '%d * %d = %d' % (n, n, n*n)\n        time.sleep(1)\n        result.put(r)\n    except Queue.Empty:\n        print('task queue is empty.')\n# 处理结束:\nprint('worker exit.')\n```\n任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。\n\n先执行服务器端，再执行worker端，可以实现master端和worker端的分布式计算了。\n\n另外，发现`worker.py`根本没有创建`Queue`，所以，`Queue`对象存储在`manager.py`进程中。\n\n而`queue`之所以可以通过网络访问，是通过`queueManager`实现的。由于`queueManager`管理的不知一个`Queue`，所以，要给每个Queue的网络调用接口起个名字，比如`get_task_queue`。\n\n而`authkey`为了保证两台机器之间正常通信，不被其他机器干扰，做验证码用。\n\n注意`Queue`的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","source":"_posts/python/初探python(10)进程与线程.md","raw":"---\ntitle: 初探python(10)进程与线程\ndate: 2016-10-20 16:55:30\ntags: \n- python\n- python教程\ncategories: 总结\n---\n\n\n的确，线程和进程的知识有点繁，耐下性子先过一遍吧。\n## 什么是多进程和多线程\n\n对于操作系统来说，一个任务就是一个进程（Process）。\n多进程的操作系统轮流让各个进程交替执行，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。\n<!-- more -->\n真正的并行执行多进程只能在多核CPU上实现，但是，由于进程数量远远多于CPU的核心数量，所以，操作系统也会自动把很多进程轮流调度到每个核心上执行。\n\n在一个进程内部有些还不是干一件事，像Word可以有多件事同时干，就需要运行多个子任务，我们把子任务称之为“线程”（Thread）。\n\n由于每个进程至少要干一件事，所以至少有一个线程。操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。\n\n那python要同时执行执行多个任务的话，多任务的实现有3种方式：\n\n多进程模式；\n多线程模式；\n多进程+多线程模式。\n\n多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。\n\n## 多进程\n\n### fork\nUnix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。\n\n子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。\n```\nimport os\n\nprint 'Process (%s) start...' % os.getpid()\npid = os.fork()\nif pid==0:\n    print 'I am child process (%s) and my parent is %s.' % (os.getpid(), os.getppid())\nelse:\n    print 'I (%s) just created a child process (%s).' % (os.getpid(), pid)\n```\n有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。\n\n### multiprocessing\n\n但我用的是Windows系统，由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。`multiprocessing`模块就是跨平台版本的多进程模块。\n```\nfrom multiprocessing import Process\nimport os\n\ndef run_proc(name):\n    print 'Run child process %s (%s)...' % (name, os.getpid())\nif __name__ == '__main__':\n    print 'Run parent process %s...' % os.getpid()\n    p = Process(target=run_proc, args=('test',))\n    print 'child process will start ...'\n    p.start()\n    p.join()\n    print 'Process end.'\n```\n创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。\n\njoin()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。\n\n###　Pool\n如果要启动大量的子进程，可以用进程池的方式批量创建子进程：\n```\nfrom multiprocessing import Pool\nimport os, time, random\n\ndef long_time_task(name):\n    print 'Run task %s (%s)...' % (name, os.getpid())\n    start = time.time()\n    time.sleep(random.random() * 3)\n    end = time.time()\n    print 'Task %s runs %0.2f seconds.' % (name, (end - start))\n\nif __name__=='__main__':\n    print 'Parent process %s.' % os.getpid()\n    p = Pool()\n    for i in range(5):\n        p.apply_async(long_time_task, args=(i,))\n    print 'Waiting for all subprocesses done...'\n    p.close()\n    p.join()\n    print 'All subprocesses done.'\n\n```\n\n由于Pool的默认大小是CPU的核数。task一次性执行4个，其他的要等之前的执行完才能执行，如果改成:\n```\np = Pool(5)\n```\n\n### 进程间通信\n\nPython的`multiprocessing`模块包装了底层的机制，提供了`Queue`、`Pipes`等多种方式来交换数据。\n\n我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：\n\n```\nfrom multiprocessing import Process,Queue\nimport os,time,random\n\n\n# 写数据进程执行的代码:\ndef write(q):\n    for value in ['A','B','C']:\n        print 'Put %s to queue...' %value\n        q.put(value)\n        time.sleep(random.random())\n\n\n# 读数据进程执行的代码:\ndef read(q):\n    while True:\n        value = q.get(True)\n        print 'Get %s from queue.' % value\n\nif __name__ =='__main__':\n    # 父进程创建Queue，并传给各个子进程：\n    q = Queue()\n    pw = Process(target=write, args=(q,))\n    pr = Process(target=read, args=(q,))\n    # 启动子进程pw，写入:\n    pw.start()\n    # 启动子进程pw，读出:\n    pr.start()\n    pw.join()\n    # pr进程无限循环，强制终止\n    pr.terminate()\n\n```\n\n##　多线程\n由于线程是操作系统直接支持的执行单元，因此，python高级语言通常都内置多线程的支持，并且Python的线程是真正的Posix Thread（可移植操作系统接口 线程），而不是模拟出来的线程。\n\nPython的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。\n\n启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：\n```\nimport time, threading\n\ndef loop():\n    print 'thread %s is running ... ' % threading.current_thread().name\n    n = 0\n    while n <5:\n        n += 1\n        print 'thread %s => %s' % (threading.current_thread().name,n)\n        time.sleep(1)\n    print 'thread %s ended' % threading.current_thread().name\n\nprint 'thread %s is running ...' % threading.current_thread().name\nt = threading.Thread(target=loop, name='LoopThread')\nt.start()\nt.join()\nprint 'thread %s ended' % threading.current_thread().name\n```\n由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个`current_thread()`函数，它永远返回当前线程的实例。主线程实例的名字叫`MainThread`，子线程的名字在创建时指定，我们用`LoopThread`命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为`Thread-1`，`Thread-2`……\n\n\n\n### Lock\n多线程和多进程最大的不同在于:\n* 多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响;\n* 多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改。\n\n因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。\n\n所以，我们必须确保一个线程在修改变量的时候，别的线程一定不能改。\n```\nimport time, threading\n\nbalance = 0\nlock = threading.Lock()\n\n\ndef change_it(n):\n    global balance\n    balance = balance - n\n    balance = balance + n\n\ndef run_thread(n):\n    for i in range(1000):\n        lock.acquire()\n        try:\n            change_it(i)\n        finally:\n            lock.release()\n\nthread1 = threading.Thread(target=run_thread, args=(5,))\nthread2 = threading.Thread(target=run_thread, args=(8,))\n\nthread1.start()\nthread2.start()\nthread1.join()\nthread2.join()\nprint balance\n```\n\n### 多核CPU\n\n如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。\n\n如果写一个死循环的话，会出现什么情况呢？\n\n打开Mac OS X的Activity Monitor，或者Windows的Task Manager，都可以监控某个进程的CPU使用率。\n\n我们可以监控到一个死循环线程会100%占用一个CPU。\n\n启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有160%，但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？\n\n因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。\n\nGIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。\n\n所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。\n\n不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。\n\n## ThreadLocal\n正如上面所说，在多线程环境下，对于全局变量的修改必须加锁，因此，一个线程使用局部变量只有线程自己看得到，不会影响其他线程。\n\n但局部变量也有问题。就是在传递的时候非常麻烦。尽管是局部变量，但是每个函数都要用它，因此必须传进去。用全局变量又会影响其他进程，不能共享。\n```\nglobal_dict = {}\n\ndef std_thread(name):\n    std = Student(name)\n    # 把std放到全局变量global_dict中：\n    global_dict[threading.current_thread()] = std\n    do_task_1()\n    do_task_2()\n\ndef do_task_1():\n    # 不传入std，而是根据当前线程查找：\n    std = global_dict[threading.current_thread()]\n    ...\n\ndef do_task_2():\n    # 任何函数都可以查找出当前线程的std变量：\n    std = global_dict[threading.current_thread()]\n```\n如果用一个全局变量`dict`来存放所有的`Student`对象，然后以`thread`自身作为`key`获得线程对应的`student`,这样就消除了`std`对象在每层函数中传递问题，但是还是不够简单。\n\n`ThreadLocal`就是来自动帮你做这些事情的，不用查找`dict`。\n```\nimport threading\n\n# 创建全局ThreadLocal对象:\nlocal_school = threading.local()\n\ndef process_student():\n    print 'Hello, %s (in %s)' % (local_school.student, threading.current_thread().name)\n\ndef process_thread(name):\n    # 绑定ThreadLocal的student:\n    local_school.student = name\n    process_student()\n\nt1 = threading.Thread(target= process_thread, args=('Alice',), name='Thread-A')\nt2 = threading.Thread(target= process_thread, args=('Bob',), name='Thread-B')\nt1.start()\nt2.start()\nt1.join()\nt2.join()\n```\n全局变量`local_school`是一个`ThreadLocal`对象，每个`Thread`对它都可以读写`student`属性，但互不影响。你可以把`local_school`看成全局变量，但每个属性如`local_school.student`都是线程的局部变量，可以任意读写而不互相干扰，也不用管理锁的问题，`ThreadLocal`内部会进行处理。\n\n可以理解为全局变量`local_school`是一个`dict`，不但可以用`local_school.student`，还可以绑定其他变量，如`local_school.teacher`等等。\n\n`ThreadLocal`最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。\n\n### 进程 vs. 线程\n\n现在我们来讨论一下这两种方式的优缺点。\n\n首先，要实现多任务，通常我们会设计`Master-Worker`模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。\n\n自然，主的就是Master，其他进程/线程就是Worker\n\n多进程最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程（当然主进程挂了所有子进程都挂了，但是Master进程只负责分配任务，挂掉的概率低）。著名的Apache最早就是采用多进程模式。\n\n多进程的缺点就是创建进程的代价大，在Unix/Linu系统下，用`fork`调用还行，在Windows下创建进程就开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都是问题。\n\n多线程模式通常比多进程要快一些，但是也快不到哪里去，而且，多线程模式致命的缺点就是任何一个线程挂掉都直接可能造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出现了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作体统会强制结束整个进程。\n\n在Windows下，多线程的效率要比多进程高，所以微软的IIS服务器默认采用多线程模式，为了缓解这个问题，IIS和Apache现在又有多线程+多进程的混合模式，真是把问题越搞越复杂。\n\n### 线程切换\n\n无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？\n\n任务之间切换是有代价的。比如你从语文切换到数学，要收拾桌子上的语文书（这叫保存现场），然后打开数学课本（这叫准备新环境），才能开始做数学作业。操作系统在切换进程/线程也是需要时间的，它需要先保存当前执行的现场环境(CPU寄存器状态、内存页等)然后，把新任务的执行环境准备好(恢复上次的寄存器状态，切换内存页等)，才能开始执行。这个切换虽然快，但也需要时间，操作系统在任务多的时候可能主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口没反应，系统处于假死状态。\n\n所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果笑来急剧下降，所有任务都做不好。\n\n### 计算密集型 vs IO密集型\n\n是否采用多任务的第二个考虑是任务的类型。我们可以吧任务分为计算密集型和IO密集型。\n\n计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要高效利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。\n\n计算密集型任务主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务，多余计算密集型任务最好用C语言编写。\n\n第二种任务类型就是IO密集型，涉及到网络、磁盘IO任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成(因为IO的速度远远低于CPU和内存的速度)。对于IO密集型任务，任务越多，CPU效率越高，但也有个限度。常见的大部分任务都是IO密集型任务，比如Web应用。\n\nIO密集型任务执行期间，99%的时间都花在了IO上，花在CPU的时间爱你很少，对于IO密集型任务，最适合的语言就是开发效率最高(代码量最少)的语言，脚本语言是首选，C最差。\n\n### 异步IO\n考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程汇总大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。\n\n现代操作系统多IO操作已经做了巨大的改进，最大的特点就是支持异步IO，如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效的支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常有效。用异步IO编程模型来实现多任务是一个主要的趋势。\n\n对应到python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。\n\n协程我们后续会提到。\n\n### 分布式进程\n\n在process和thread中，应当优先选process，因为process更稳定，而且，process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。\n\nPython的`multiprocessing`模块不但支持多进程，其中`managers`子模块还支持把多进程分布到多台机器上。一个服务进程可以作为跳度者，将任务分布到其他多个进程中，依靠网络通信。由于`managers`模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。\n\n举个例子：如果我们已经有一个通过`Queue`通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望吧发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？\n\n原有的`Queue`可以继续使用，但是，通过`managers`模块把`Queue`通过网络暴Queue露出去，就可以让其他机器的进程访问`Queue`了。\n\n我们先看服务进程，服务进程负责启动`Queue`，把`Queue`注册到网络上，然后往`Queue`里面写任务：\n```\n'分布式进程 -- 服务器端'\n\nimport random, multiprocessing\nfrom multiprocessing.managers import BaseManager\nfrom multiprocessing import freeze_support\n\n\n# 从BaseManager继承的QueueManager:\nclass QueueManager(BaseManager):\n    pass\n\n\n# 发送任务的队列:\ntask_queue = multiprocessing.Queue()\n# 接收结果的队列:\nresult_queue = multiprocessing.Queue()\n\n# 为解决__main__.<lambda> not found问题\ndef get_task_queue():\n    return task_queue\n\n# 为解决__main__.<lambda> not found问题\ndef get_result_queue():\n    return result_queue\n\n\n# 把两个Queue都注册到网络上, callable参数关联了Queue对象:\nQueueManager.register('get_task_queue', callable=get_task_queue)\nQueueManager.register('get_result_queue', callable=get_result_queue)\n# 绑定端口5000, 设置验证码'abc':\nmanager = QueueManager(address=('127.0.0.1', 5000), authkey='abc')\n\n\ndef communicate():\n    # 获得通过网络访问的Queue对象:\n    task = manager.get_task_queue()\n    result = manager.get_result_queue()\n\n    # 放几个任务进去:\n    for i in range(10):\n        n = random.randint(0, 10000)\n        print('Put task %d...' % n)\n        task.put(n)\n\n    # 从result队列读取结果:\n    print('Try get results...')\n    for i in range(10):\n        r = result.get(timeout=10)\n        print('Result: %s' % r)\n\n    # 关闭:\n    manager.shutdown()\n\n\nif __name__ == '__main__':\n    freeze_support()\n    # 启动Queue:\n    manager.start()\n    communicate()\n\n```\n请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到`Queue`不可以直接对原始的`task_queue`进行操作，那样就绕过了`QueueManager`的封装，必须通过`manager.get_task_queue()`获得的`Queue`接口添加。\n```\nimport time, sys, Queue\nfrom multiprocessing.managers import BaseManager\n\n# 创建类似的QueueManager:\nclass QueueManager(BaseManager):\n    pass\n\n# 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:\nQueueManager.register('get_task_queue')\nQueueManager.register('get_result_queue')\n\n# 连接到服务器，也就是运行taskmanager.py的机器:\nserver_addr = '127.0.0.1'\nprint('Connect to server %s...' % server_addr)\n# 端口和验证码注意保持与taskmanager.py设置的完全一致:\nm = QueueManager(address=(server_addr, 5000), authkey='abc')\n# 从网络连接:\nm.connect()\n# 获取Queue的对象:\ntask = m.get_task_queue()\nresult = m.get_result_queue()\n# 从task队列取任务,并把结果写入result队列:\nfor i in range(10):\n    try:\n        n = task.get(timeout=1)\n        print('run task %d * %d...' % (n, n))\n        r = '%d * %d = %d' % (n, n, n*n)\n        time.sleep(1)\n        result.put(r)\n    except Queue.Empty:\n        print('task queue is empty.')\n# 处理结束:\nprint('worker exit.')\n```\n任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。\n\n先执行服务器端，再执行worker端，可以实现master端和worker端的分布式计算了。\n\n另外，发现`worker.py`根本没有创建`Queue`，所以，`Queue`对象存储在`manager.py`进程中。\n\n而`queue`之所以可以通过网络访问，是通过`queueManager`实现的。由于`queueManager`管理的不知一个`Queue`，所以，要给每个Queue的网络调用接口起个名字，比如`get_task_queue`。\n\n而`authkey`为了保证两台机器之间正常通信，不被其他机器干扰，做验证码用。\n\n注意`Queue`的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","slug":"python/初探python(10)进程与线程","published":1,"updated":"2019-03-22T14:44:36.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn2p00bk4l3nngqleax4","content":"<p>的确，线程和进程的知识有点繁，耐下性子先过一遍吧。</p>\n<h2 id=\"什么是多进程和多线程\"><a href=\"#什么是多进程和多线程\" class=\"headerlink\" title=\"什么是多进程和多线程\"></a>什么是多进程和多线程</h2><p>对于操作系统来说，一个任务就是一个进程（Process）。<br>多进程的操作系统轮流让各个进程交替执行，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。<br><a id=\"more\"></a><br>真正的并行执行多进程只能在多核CPU上实现，但是，由于进程数量远远多于CPU的核心数量，所以，操作系统也会自动把很多进程轮流调度到每个核心上执行。</p>\n<p>在一个进程内部有些还不是干一件事，像Word可以有多件事同时干，就需要运行多个子任务，我们把子任务称之为“线程”（Thread）。</p>\n<p>由于每个进程至少要干一件事，所以至少有一个线程。操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p>\n<p>那python要同时执行执行多个任务的话，多任务的实现有3种方式：</p>\n<p>多进程模式；<br>多线程模式；<br>多进程+多线程模式。</p>\n<p>多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。</p>\n<h2 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h2><h3 id=\"fork\"><a href=\"#fork\" class=\"headerlink\" title=\"fork\"></a>fork</h3><p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>\n<p>子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import <span class=\"built_in\">os</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">'Process (%s) start...'</span> % <span class=\"built_in\">os</span>.getpid()</span><br><span class=\"line\">pid = <span class=\"built_in\">os</span>.fork()</span><br><span class=\"line\"><span class=\"keyword\">if</span> pid==<span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'I am child process (%s) and my parent is %s.'</span> % (<span class=\"built_in\">os</span>.getpid(), <span class=\"built_in\">os</span>.getppid())</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'I (%s) just created a child process (%s).'</span> % (<span class=\"built_in\">os</span>.getpid(), pid)</span><br></pre></td></tr></table></figure></p>\n<p>有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p>\n<h3 id=\"multiprocessing\"><a href=\"#multiprocessing\" class=\"headerlink\" title=\"multiprocessing\"></a>multiprocessing</h3><p>但我用的是Windows系统，由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。<code>multiprocessing</code>模块就是跨平台版本的多进程模块。<br><figure class=\"highlight moonscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"built_in\">os</span></span><br><span class=\"line\"></span><br><span class=\"line\">def run_proc(name):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Run child process %s (%s)...'</span> % (name, <span class=\"built_in\">os</span>.getpid())</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Run parent process %s...'</span> % <span class=\"built_in\">os</span>.getpid()</span><br><span class=\"line\">    p = Process(target=run_proc, args=(<span class=\"string\">'test'</span>,))</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'child process will start ...'</span></span><br><span class=\"line\">    p.start()</span><br><span class=\"line\">    p.join()</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Process end.'</span></span><br></pre></td></tr></table></figure></p>\n<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。</p>\n<p>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>\n<p>###　Pool<br>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from multiprocessing import Pool</span><br><span class=\"line\">import <span class=\"built_in\">os</span>, <span class=\"built_in\">time</span>, <span class=\"built_in\">random</span></span><br><span class=\"line\"></span><br><span class=\"line\">def long_time_task(name):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Run task %s (%s)...'</span> % (name, <span class=\"built_in\">os</span>.getpid())</span><br><span class=\"line\">    start = <span class=\"built_in\">time</span>.<span class=\"built_in\">time</span>()</span><br><span class=\"line\">    <span class=\"built_in\">time</span>.sleep(<span class=\"built_in\">random</span>.<span class=\"built_in\">random</span>() * <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">end</span> = <span class=\"built_in\">time</span>.<span class=\"built_in\">time</span>()</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Task %s runs %0.2f seconds.'</span> % (name, (<span class=\"keyword\">end</span> - start))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Parent process %s.'</span> % <span class=\"built_in\">os</span>.getpid()</span><br><span class=\"line\">    p = Pool()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\">        p.apply_async(long_time_task, args=(i,))</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Waiting for all subprocesses done...'</span></span><br><span class=\"line\">    p.<span class=\"built_in\">close</span>()</span><br><span class=\"line\">    p.join()</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'All subprocesses done.'</span></span><br></pre></td></tr></table></figure></p>\n<p>由于Pool的默认大小是CPU的核数。task一次性执行4个，其他的要等之前的执行完才能执行，如果改成:<br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">p</span> = Pool(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h3><p>Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p>\n<p>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">from</span> multiprocessing import Process,Queue</span><br><span class=\"line\">import os,<span class=\"built_in\">time</span>,<span class=\"built_in\">random</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 写数据进程执行的代码:</span></span><br><span class=\"line\">def <span class=\"built_in\">write</span>(q):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">value</span> <span class=\"keyword\">in</span> [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>]:</span><br><span class=\"line\">        print <span class=\"string\">'Put %s to queue...'</span> %<span class=\"built_in\">value</span></span><br><span class=\"line\">        q.<span class=\"built_in\">put</span>(<span class=\"built_in\">value</span>)</span><br><span class=\"line\">        <span class=\"built_in\">time</span>.sleep(<span class=\"built_in\">random</span>.<span class=\"built_in\">random</span>())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读数据进程执行的代码:</span></span><br><span class=\"line\">def <span class=\"built_in\">read</span>(q):</span><br><span class=\"line\">    <span class=\"keyword\">while</span> True:</span><br><span class=\"line\">        <span class=\"built_in\">value</span> = q.<span class=\"built_in\">get</span>(True)</span><br><span class=\"line\">        print <span class=\"string\">'Get %s from queue.'</span> % <span class=\"built_in\">value</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ ==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class=\"line\">    q = Queue()</span><br><span class=\"line\">    pw = Process(target=<span class=\"built_in\">write</span>, args=(q,))</span><br><span class=\"line\">    pr = Process(target=<span class=\"built_in\">read</span>, args=(q,))</span><br><span class=\"line\">    <span class=\"comment\"># 启动子进程pw，写入:</span></span><br><span class=\"line\">    pw.<span class=\"built_in\">start</span>()</span><br><span class=\"line\">    <span class=\"comment\"># 启动子进程pw，读出:</span></span><br><span class=\"line\">    pr.<span class=\"built_in\">start</span>()</span><br><span class=\"line\">    pw.join()</span><br><span class=\"line\">    <span class=\"comment\"># pr进程无限循环，强制终止</span></span><br><span class=\"line\">    pr.terminate()</span><br></pre></td></tr></table></figure>\n<p>##　多线程<br>由于线程是操作系统直接支持的执行单元，因此，python高级语言通常都内置多线程的支持，并且Python的线程是真正的Posix Thread（可移植操作系统接口 线程），而不是模拟出来的线程。</p>\n<p>Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p>\n<p>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：<br><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"built_in\">time</span>, threading</span><br><span class=\"line\"></span><br><span class=\"line\">def <span class=\"keyword\">loop</span>():</span><br><span class=\"line\">    print <span class=\"string\">'thread %s is running ... '</span> % threading.current_thread().<span class=\"keyword\">name</span></span><br><span class=\"line\">    n = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt;<span class=\"number\">5</span>:</span><br><span class=\"line\">        n += <span class=\"number\">1</span></span><br><span class=\"line\">        print <span class=\"string\">'thread %s =&gt; %s'</span> % (threading.current_thread().<span class=\"keyword\">name</span>,n)</span><br><span class=\"line\">        <span class=\"built_in\">time</span>.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">    print <span class=\"string\">'thread %s ended'</span> % threading.current_thread().<span class=\"keyword\">name</span></span><br><span class=\"line\"></span><br><span class=\"line\">print <span class=\"string\">'thread %s is running ...'</span> % threading.current_thread().<span class=\"keyword\">name</span></span><br><span class=\"line\">t = threading.Thread(target=<span class=\"keyword\">loop</span>, <span class=\"keyword\">name</span>=<span class=\"string\">'LoopThread'</span>)</span><br><span class=\"line\">t.start()</span><br><span class=\"line\">t.join()</span><br><span class=\"line\">print <span class=\"string\">'thread %s ended'</span> % threading.current_thread().<span class=\"keyword\">name</span></span><br></pre></td></tr></table></figure></p>\n<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1</code>，<code>Thread-2</code>……</p>\n<h3 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h3><p>多线程和多进程最大的不同在于:</p>\n<ul>\n<li>多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响;</li>\n<li>多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改。</li>\n</ul>\n<p>因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p>\n<p>所以，我们必须确保一个线程在修改变量的时候，别的线程一定不能改。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time, threading</span><br><span class=\"line\"></span><br><span class=\"line\">balance = <span class=\"number\">0</span></span><br><span class=\"line\">lock = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">change_it</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> balance</span><br><span class=\"line\">    balance = balance - n</span><br><span class=\"line\">    balance = balance + n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_thread</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1000</span>):</span><br><span class=\"line\">        lock.acquire()</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            change_it(i)</span><br><span class=\"line\">        <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">            lock.release()</span><br><span class=\"line\"></span><br><span class=\"line\">thread1 = threading.Thread(target=run_thread, args=(<span class=\"number\">5</span>,))</span><br><span class=\"line\">thread2 = threading.Thread(target=run_thread, args=(<span class=\"number\">8</span>,))</span><br><span class=\"line\"></span><br><span class=\"line\">thread1.start()</span><br><span class=\"line\">thread2.start()</span><br><span class=\"line\">thread1.join()</span><br><span class=\"line\">thread2.join()</span><br><span class=\"line\"><span class=\"keyword\">print</span> balance</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"多核CPU\"><a href=\"#多核CPU\" class=\"headerlink\" title=\"多核CPU\"></a>多核CPU</h3><p>如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。</p>\n<p>如果写一个死循环的话，会出现什么情况呢？</p>\n<p>打开Mac OS X的Activity Monitor，或者Windows的Task Manager，都可以监控某个进程的CPU使用率。</p>\n<p>我们可以监控到一个死循环线程会100%占用一个CPU。</p>\n<p>启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有160%，但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p>\n<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>\n<p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p>\n<p>所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p>\n<p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>\n<h2 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h2><p>正如上面所说，在多线程环境下，对于全局变量的修改必须加锁，因此，一个线程使用局部变量只有线程自己看得到，不会影响其他线程。</p>\n<p>但局部变量也有问题。就是在传递的时候非常麻烦。尽管是局部变量，但是每个函数都要用它，因此必须传进去。用全局变量又会影响其他进程，不能共享。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global_dict = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">std_thread</span><span class=\"params\">(name)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    std = Student(name)</span><br><span class=\"line\">    <span class=\"comment\"># 把std放到全局变量global_dict中：</span></span><br><span class=\"line\">    global_dict[threading.current_thread()] = std</span><br><span class=\"line\">    do_task_1()</span><br><span class=\"line\">    do_task_2()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_task_1</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"comment\"># 不传入std，而是根据当前线程查找：</span></span><br><span class=\"line\">    std = global_dict[threading.current_thread()]</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_task_2</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"comment\"># 任何函数都可以查找出当前线程的std变量：</span></span><br><span class=\"line\">    std = global_dict[threading.current_thread()]</span><br></pre></td></tr></table></figure></p>\n<p>如果用一个全局变量<code>dict</code>来存放所有的<code>Student</code>对象，然后以<code>thread</code>自身作为<code>key</code>获得线程对应的<code>student</code>,这样就消除了<code>std</code>对象在每层函数中传递问题，但是还是不够简单。</p>\n<p><code>ThreadLocal</code>就是来自动帮你做这些事情的，不用查找<code>dict</code>。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建全局ThreadLocal对象:</span></span><br><span class=\"line\">local_school = threading.local()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_student</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Hello, %s (in %s)'</span> % (local_school.student, threading.current_thread().name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_thread</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 绑定ThreadLocal的student:</span></span><br><span class=\"line\">    local_school.student = name</span><br><span class=\"line\">    process_student()</span><br><span class=\"line\"></span><br><span class=\"line\">t1 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Alice'</span>,), name=<span class=\"string\">'Thread-A'</span>)</span><br><span class=\"line\">t2 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Bob'</span>,), name=<span class=\"string\">'Thread-B'</span>)</span><br><span class=\"line\">t1.start()</span><br><span class=\"line\">t2.start()</span><br><span class=\"line\">t1.join()</span><br><span class=\"line\">t2.join()</span><br></pre></td></tr></table></figure></p>\n<p>全局变量<code>local_school</code>是一个<code>ThreadLocal</code>对象，每个<code>Thread</code>对它都可以读写<code>student</code>属性，但互不影响。你可以把<code>local_school</code>看成全局变量，但每个属性如<code>local_school.student</code>都是线程的局部变量，可以任意读写而不互相干扰，也不用管理锁的问题，<code>ThreadLocal</code>内部会进行处理。</p>\n<p>可以理解为全局变量<code>local_school</code>是一个<code>dict</code>，不但可以用<code>local_school.student</code>，还可以绑定其他变量，如<code>local_school.teacher</code>等等。</p>\n<p><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>\n<h3 id=\"进程-vs-线程\"><a href=\"#进程-vs-线程\" class=\"headerlink\" title=\"进程 vs. 线程\"></a>进程 vs. 线程</h3><p>现在我们来讨论一下这两种方式的优缺点。</p>\n<p>首先，要实现多任务，通常我们会设计<code>Master-Worker</code>模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p>\n<p>自然，主的就是Master，其他进程/线程就是Worker</p>\n<p>多进程最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程（当然主进程挂了所有子进程都挂了，但是Master进程只负责分配任务，挂掉的概率低）。著名的Apache最早就是采用多进程模式。</p>\n<p>多进程的缺点就是创建进程的代价大，在Unix/Linu系统下，用<code>fork</code>调用还行，在Windows下创建进程就开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都是问题。</p>\n<p>多线程模式通常比多进程要快一些，但是也快不到哪里去，而且，多线程模式致命的缺点就是任何一个线程挂掉都直接可能造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出现了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作体统会强制结束整个进程。</p>\n<p>在Windows下，多线程的效率要比多进程高，所以微软的IIS服务器默认采用多线程模式，为了缓解这个问题，IIS和Apache现在又有多线程+多进程的混合模式，真是把问题越搞越复杂。</p>\n<h3 id=\"线程切换\"><a href=\"#线程切换\" class=\"headerlink\" title=\"线程切换\"></a>线程切换</h3><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？</p>\n<p>任务之间切换是有代价的。比如你从语文切换到数学，要收拾桌子上的语文书（这叫保存现场），然后打开数学课本（这叫准备新环境），才能开始做数学作业。操作系统在切换进程/线程也是需要时间的，它需要先保存当前执行的现场环境(CPU寄存器状态、内存页等)然后，把新任务的执行环境准备好(恢复上次的寄存器状态，切换内存页等)，才能开始执行。这个切换虽然快，但也需要时间，操作系统在任务多的时候可能主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口没反应，系统处于假死状态。</p>\n<p>所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果笑来急剧下降，所有任务都做不好。</p>\n<h3 id=\"计算密集型-vs-IO密集型\"><a href=\"#计算密集型-vs-IO密集型\" class=\"headerlink\" title=\"计算密集型 vs IO密集型\"></a>计算密集型 vs IO密集型</h3><p>是否采用多任务的第二个考虑是任务的类型。我们可以吧任务分为计算密集型和IO密集型。</p>\n<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要高效利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>\n<p>计算密集型任务主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务，多余计算密集型任务最好用C语言编写。</p>\n<p>第二种任务类型就是IO密集型，涉及到网络、磁盘IO任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成(因为IO的速度远远低于CPU和内存的速度)。对于IO密集型任务，任务越多，CPU效率越高，但也有个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>\n<p>IO密集型任务执行期间，99%的时间都花在了IO上，花在CPU的时间爱你很少，对于IO密集型任务，最适合的语言就是开发效率最高(代码量最少)的语言，脚本语言是首选，C最差。</p>\n<h3 id=\"异步IO\"><a href=\"#异步IO\" class=\"headerlink\" title=\"异步IO\"></a>异步IO</h3><p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程汇总大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</p>\n<p>现代操作系统多IO操作已经做了巨大的改进，最大的特点就是支持异步IO，如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效的支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常有效。用异步IO编程模型来实现多任务是一个主要的趋势。</p>\n<p>对应到python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。</p>\n<p>协程我们后续会提到。</p>\n<h3 id=\"分布式进程\"><a href=\"#分布式进程\" class=\"headerlink\" title=\"分布式进程\"></a>分布式进程</h3><p>在process和thread中，应当优先选process，因为process更稳定，而且，process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p>\n<p>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。一个服务进程可以作为跳度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>\n<p>举个例子：如果我们已经有一个通过<code>Queue</code>通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望吧发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p>\n<p>原有的<code>Queue</code>可以继续使用，但是，通过<code>managers</code>模块把<code>Queue</code>通过网络暴Queue露出去，就可以让其他机器的进程访问<code>Queue</code>了。</p>\n<p>我们先看服务进程，服务进程负责启动<code>Queue</code>，把<code>Queue</code>注册到网络上，然后往<code>Queue</code>里面写任务：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'分布式进程 -- 服务器端'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> random, multiprocessing</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing.managers <span class=\"keyword\">import</span> BaseManager</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> freeze_support</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从BaseManager继承的QueueManager:</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueManager</span><span class=\"params\">(BaseManager)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 发送任务的队列:</span></span><br><span class=\"line\">task_queue = multiprocessing.Queue()</span><br><span class=\"line\"><span class=\"comment\"># 接收结果的队列:</span></span><br><span class=\"line\">result_queue = multiprocessing.Queue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为解决__main__.&lt;lambda&gt; not found问题</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_task_queue</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> task_queue</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为解决__main__.&lt;lambda&gt; not found问题</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_result_queue</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result_queue</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span></span><br><span class=\"line\">QueueManager.register(<span class=\"string\">'get_task_queue'</span>, callable=get_task_queue)</span><br><span class=\"line\">QueueManager.register(<span class=\"string\">'get_result_queue'</span>, callable=get_result_queue)</span><br><span class=\"line\"><span class=\"comment\"># 绑定端口5000, 设置验证码'abc':</span></span><br><span class=\"line\">manager = QueueManager(address=(<span class=\"string\">'127.0.0.1'</span>, <span class=\"number\">5000</span>), authkey=<span class=\"string\">'abc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">communicate</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 获得通过网络访问的Queue对象:</span></span><br><span class=\"line\">    task = manager.get_task_queue()</span><br><span class=\"line\">    result = manager.get_result_queue()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 放几个任务进去:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">        n = random.randint(<span class=\"number\">0</span>, <span class=\"number\">10000</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'Put task %d...'</span> % n)</span><br><span class=\"line\">        task.put(n)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 从result队列读取结果:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Try get results...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">        r = result.get(timeout=<span class=\"number\">10</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'Result: %s'</span> % r)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 关闭:</span></span><br><span class=\"line\">    manager.shutdown()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    freeze_support()</span><br><span class=\"line\">    <span class=\"comment\"># 启动Queue:</span></span><br><span class=\"line\">    manager.start()</span><br><span class=\"line\">    communicate()</span><br></pre></td></tr></table></figure></p>\n<p>请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到<code>Queue</code>不可以直接对原始的<code>task_queue</code>进行操作，那样就绕过了<code>QueueManager</code>的封装，必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time, sys, Queue</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing.managers <span class=\"keyword\">import</span> BaseManager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建类似的QueueManager:</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueManager</span><span class=\"params\">(BaseManager)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span></span><br><span class=\"line\">QueueManager.register(<span class=\"string\">'get_task_queue'</span>)</span><br><span class=\"line\">QueueManager.register(<span class=\"string\">'get_result_queue'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 连接到服务器，也就是运行taskmanager.py的机器:</span></span><br><span class=\"line\">server_addr = <span class=\"string\">'127.0.0.1'</span></span><br><span class=\"line\">print(<span class=\"string\">'Connect to server %s...'</span> % server_addr)</span><br><span class=\"line\"><span class=\"comment\"># 端口和验证码注意保持与taskmanager.py设置的完全一致:</span></span><br><span class=\"line\">m = QueueManager(address=(server_addr, <span class=\"number\">5000</span>), authkey=<span class=\"string\">'abc'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 从网络连接:</span></span><br><span class=\"line\">m.connect()</span><br><span class=\"line\"><span class=\"comment\"># 获取Queue的对象:</span></span><br><span class=\"line\">task = m.get_task_queue()</span><br><span class=\"line\">result = m.get_result_queue()</span><br><span class=\"line\"><span class=\"comment\"># 从task队列取任务,并把结果写入result队列:</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        n = task.get(timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'run task %d * %d...'</span> % (n, n))</span><br><span class=\"line\">        r = <span class=\"string\">'%d * %d = %d'</span> % (n, n, n*n)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        result.put(r)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Queue.Empty:</span><br><span class=\"line\">        print(<span class=\"string\">'task queue is empty.'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 处理结束:</span></span><br><span class=\"line\">print(<span class=\"string\">'worker exit.'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p>\n<p>先执行服务器端，再执行worker端，可以实现master端和worker端的分布式计算了。</p>\n<p>另外，发现<code>worker.py</code>根本没有创建<code>Queue</code>，所以，<code>Queue</code>对象存储在<code>manager.py</code>进程中。</p>\n<p>而<code>queue</code>之所以可以通过网络访问，是通过<code>queueManager</code>实现的。由于<code>queueManager</code>管理的不知一个<code>Queue</code>，所以，要给每个Queue的网络调用接口起个名字，比如<code>get_task_queue</code>。</p>\n<p>而<code>authkey</code>为了保证两台机器之间正常通信，不被其他机器干扰，做验证码用。</p>\n<p>注意<code>Queue</code>的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>的确，线程和进程的知识有点繁，耐下性子先过一遍吧。</p>\n<h2 id=\"什么是多进程和多线程\"><a href=\"#什么是多进程和多线程\" class=\"headerlink\" title=\"什么是多进程和多线程\"></a>什么是多进程和多线程</h2><p>对于操作系统来说，一个任务就是一个进程（Process）。<br>多进程的操作系统轮流让各个进程交替执行，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。<br></p>","more":"<br>真正的并行执行多进程只能在多核CPU上实现，但是，由于进程数量远远多于CPU的核心数量，所以，操作系统也会自动把很多进程轮流调度到每个核心上执行。<p></p>\n<p>在一个进程内部有些还不是干一件事，像Word可以有多件事同时干，就需要运行多个子任务，我们把子任务称之为“线程”（Thread）。</p>\n<p>由于每个进程至少要干一件事，所以至少有一个线程。操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p>\n<p>那python要同时执行执行多个任务的话，多任务的实现有3种方式：</p>\n<p>多进程模式；<br>多线程模式；<br>多进程+多线程模式。</p>\n<p>多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。</p>\n<h2 id=\"多进程\"><a href=\"#多进程\" class=\"headerlink\" title=\"多进程\"></a>多进程</h2><h3 id=\"fork\"><a href=\"#fork\" class=\"headerlink\" title=\"fork\"></a>fork</h3><p>Unix/Linux操作系统提供了一个fork()系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是fork()调用一次，返回两次，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后，分别在父进程和子进程内返回。</p>\n<p>子进程永远返回0，而父进程返回子进程的ID。这样做的理由是，一个父进程可以fork出很多子进程，所以，父进程要记下每个子进程的ID，而子进程只需要调用getppid()就可以拿到父进程的ID。<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import <span class=\"built_in\">os</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"string\">'Process (%s) start...'</span> % <span class=\"built_in\">os</span>.getpid()</span><br><span class=\"line\">pid = <span class=\"built_in\">os</span>.fork()</span><br><span class=\"line\"><span class=\"keyword\">if</span> pid==<span class=\"number\">0</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'I am child process (%s) and my parent is %s.'</span> % (<span class=\"built_in\">os</span>.getpid(), <span class=\"built_in\">os</span>.getppid())</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'I (%s) just created a child process (%s).'</span> % (<span class=\"built_in\">os</span>.getpid(), pid)</span><br></pre></td></tr></table></figure></p>\n<p>有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p>\n<h3 id=\"multiprocessing\"><a href=\"#multiprocessing\" class=\"headerlink\" title=\"multiprocessing\"></a>multiprocessing</h3><p>但我用的是Windows系统，由于Python是跨平台的，自然也应该提供一个跨平台的多进程支持。<code>multiprocessing</code>模块就是跨平台版本的多进程模块。<br><figure class=\"highlight moonscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> Process</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"built_in\">os</span></span><br><span class=\"line\"></span><br><span class=\"line\">def run_proc(name):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Run child process %s (%s)...'</span> % (name, <span class=\"built_in\">os</span>.getpid())</span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Run parent process %s...'</span> % <span class=\"built_in\">os</span>.getpid()</span><br><span class=\"line\">    p = Process(target=run_proc, args=(<span class=\"string\">'test'</span>,))</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'child process will start ...'</span></span><br><span class=\"line\">    p.start()</span><br><span class=\"line\">    p.join()</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Process end.'</span></span><br></pre></td></tr></table></figure></p>\n<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个Process实例，用start()方法启动，这样创建进程比fork()还要简单。</p>\n<p>join()方法可以等待子进程结束后再继续往下运行，通常用于进程间的同步。</p>\n<p>###　Pool<br>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：<br><figure class=\"highlight lua\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from multiprocessing import Pool</span><br><span class=\"line\">import <span class=\"built_in\">os</span>, <span class=\"built_in\">time</span>, <span class=\"built_in\">random</span></span><br><span class=\"line\"></span><br><span class=\"line\">def long_time_task(name):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Run task %s (%s)...'</span> % (name, <span class=\"built_in\">os</span>.getpid())</span><br><span class=\"line\">    start = <span class=\"built_in\">time</span>.<span class=\"built_in\">time</span>()</span><br><span class=\"line\">    <span class=\"built_in\">time</span>.sleep(<span class=\"built_in\">random</span>.<span class=\"built_in\">random</span>() * <span class=\"number\">3</span>)</span><br><span class=\"line\">    <span class=\"keyword\">end</span> = <span class=\"built_in\">time</span>.<span class=\"built_in\">time</span>()</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Task %s runs %0.2f seconds.'</span> % (name, (<span class=\"keyword\">end</span> - start))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Parent process %s.'</span> % <span class=\"built_in\">os</span>.getpid()</span><br><span class=\"line\">    p = Pool()</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">5</span>):</span><br><span class=\"line\">        p.apply_async(long_time_task, args=(i,))</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'Waiting for all subprocesses done...'</span></span><br><span class=\"line\">    p.<span class=\"built_in\">close</span>()</span><br><span class=\"line\">    p.join()</span><br><span class=\"line\">    <span class=\"built_in\">print</span> <span class=\"string\">'All subprocesses done.'</span></span><br></pre></td></tr></table></figure></p>\n<p>由于Pool的默认大小是CPU的核数。task一次性执行4个，其他的要等之前的执行完才能执行，如果改成:<br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">p</span> = Pool(<span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"进程间通信\"><a href=\"#进程间通信\" class=\"headerlink\" title=\"进程间通信\"></a>进程间通信</h3><p>Python的<code>multiprocessing</code>模块包装了底层的机制，提供了<code>Queue</code>、<code>Pipes</code>等多种方式来交换数据。</p>\n<p>我们以Queue为例，在父进程中创建两个子进程，一个往Queue里写数据，一个从Queue里读数据：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">from</span> multiprocessing import Process,Queue</span><br><span class=\"line\">import os,<span class=\"built_in\">time</span>,<span class=\"built_in\">random</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 写数据进程执行的代码:</span></span><br><span class=\"line\">def <span class=\"built_in\">write</span>(q):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"built_in\">value</span> <span class=\"keyword\">in</span> [<span class=\"string\">'A'</span>,<span class=\"string\">'B'</span>,<span class=\"string\">'C'</span>]:</span><br><span class=\"line\">        print <span class=\"string\">'Put %s to queue...'</span> %<span class=\"built_in\">value</span></span><br><span class=\"line\">        q.<span class=\"built_in\">put</span>(<span class=\"built_in\">value</span>)</span><br><span class=\"line\">        <span class=\"built_in\">time</span>.sleep(<span class=\"built_in\">random</span>.<span class=\"built_in\">random</span>())</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 读数据进程执行的代码:</span></span><br><span class=\"line\">def <span class=\"built_in\">read</span>(q):</span><br><span class=\"line\">    <span class=\"keyword\">while</span> True:</span><br><span class=\"line\">        <span class=\"built_in\">value</span> = q.<span class=\"built_in\">get</span>(True)</span><br><span class=\"line\">        print <span class=\"string\">'Get %s from queue.'</span> % <span class=\"built_in\">value</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ ==<span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    <span class=\"comment\"># 父进程创建Queue，并传给各个子进程：</span></span><br><span class=\"line\">    q = Queue()</span><br><span class=\"line\">    pw = Process(target=<span class=\"built_in\">write</span>, args=(q,))</span><br><span class=\"line\">    pr = Process(target=<span class=\"built_in\">read</span>, args=(q,))</span><br><span class=\"line\">    <span class=\"comment\"># 启动子进程pw，写入:</span></span><br><span class=\"line\">    pw.<span class=\"built_in\">start</span>()</span><br><span class=\"line\">    <span class=\"comment\"># 启动子进程pw，读出:</span></span><br><span class=\"line\">    pr.<span class=\"built_in\">start</span>()</span><br><span class=\"line\">    pw.join()</span><br><span class=\"line\">    <span class=\"comment\"># pr进程无限循环，强制终止</span></span><br><span class=\"line\">    pr.terminate()</span><br></pre></td></tr></table></figure>\n<p>##　多线程<br>由于线程是操作系统直接支持的执行单元，因此，python高级语言通常都内置多线程的支持，并且Python的线程是真正的Posix Thread（可移植操作系统接口 线程），而不是模拟出来的线程。</p>\n<p>Python的标准库提供了两个模块：thread和threading，thread是低级模块，threading是高级模块，对thread进行了封装。绝大多数情况下，我们只需要使用threading这个高级模块。</p>\n<p>启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行：<br><figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"built_in\">time</span>, threading</span><br><span class=\"line\"></span><br><span class=\"line\">def <span class=\"keyword\">loop</span>():</span><br><span class=\"line\">    print <span class=\"string\">'thread %s is running ... '</span> % threading.current_thread().<span class=\"keyword\">name</span></span><br><span class=\"line\">    n = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> n &lt;<span class=\"number\">5</span>:</span><br><span class=\"line\">        n += <span class=\"number\">1</span></span><br><span class=\"line\">        print <span class=\"string\">'thread %s =&gt; %s'</span> % (threading.current_thread().<span class=\"keyword\">name</span>,n)</span><br><span class=\"line\">        <span class=\"built_in\">time</span>.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">    print <span class=\"string\">'thread %s ended'</span> % threading.current_thread().<span class=\"keyword\">name</span></span><br><span class=\"line\"></span><br><span class=\"line\">print <span class=\"string\">'thread %s is running ...'</span> % threading.current_thread().<span class=\"keyword\">name</span></span><br><span class=\"line\">t = threading.Thread(target=<span class=\"keyword\">loop</span>, <span class=\"keyword\">name</span>=<span class=\"string\">'LoopThread'</span>)</span><br><span class=\"line\">t.start()</span><br><span class=\"line\">t.join()</span><br><span class=\"line\">print <span class=\"string\">'thread %s ended'</span> % threading.current_thread().<span class=\"keyword\">name</span></span><br></pre></td></tr></table></figure></p>\n<p>由于任何进程默认就会启动一个线程，我们把该线程称为主线程，主线程又可以启动新的线程，Python的threading模块有个<code>current_thread()</code>函数，它永远返回当前线程的实例。主线程实例的名字叫<code>MainThread</code>，子线程的名字在创建时指定，我们用<code>LoopThread</code>命名子线程。名字仅仅在打印时用来显示，完全没有其他意义，如果不起名字Python就自动给线程命名为<code>Thread-1</code>，<code>Thread-2</code>……</p>\n<h3 id=\"Lock\"><a href=\"#Lock\" class=\"headerlink\" title=\"Lock\"></a>Lock</h3><p>多线程和多进程最大的不同在于:</p>\n<ul>\n<li>多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响;</li>\n<li>多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改。</li>\n</ul>\n<p>因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。</p>\n<p>所以，我们必须确保一个线程在修改变量的时候，别的线程一定不能改。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time, threading</span><br><span class=\"line\"></span><br><span class=\"line\">balance = <span class=\"number\">0</span></span><br><span class=\"line\">lock = threading.Lock()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">change_it</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">global</span> balance</span><br><span class=\"line\">    balance = balance - n</span><br><span class=\"line\">    balance = balance + n</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">run_thread</span><span class=\"params\">(n)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1000</span>):</span><br><span class=\"line\">        lock.acquire()</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            change_it(i)</span><br><span class=\"line\">        <span class=\"keyword\">finally</span>:</span><br><span class=\"line\">            lock.release()</span><br><span class=\"line\"></span><br><span class=\"line\">thread1 = threading.Thread(target=run_thread, args=(<span class=\"number\">5</span>,))</span><br><span class=\"line\">thread2 = threading.Thread(target=run_thread, args=(<span class=\"number\">8</span>,))</span><br><span class=\"line\"></span><br><span class=\"line\">thread1.start()</span><br><span class=\"line\">thread2.start()</span><br><span class=\"line\">thread1.join()</span><br><span class=\"line\">thread2.join()</span><br><span class=\"line\"><span class=\"keyword\">print</span> balance</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"多核CPU\"><a href=\"#多核CPU\" class=\"headerlink\" title=\"多核CPU\"></a>多核CPU</h3><p>如果你不幸拥有一个多核CPU，你肯定在想，多核应该可以同时执行多个线程。</p>\n<p>如果写一个死循环的话，会出现什么情况呢？</p>\n<p>打开Mac OS X的Activity Monitor，或者Windows的Task Manager，都可以监控某个进程的CPU使用率。</p>\n<p>我们可以监控到一个死循环线程会100%占用一个CPU。</p>\n<p>启动与CPU核心数量相同的N个线程，在4核CPU上可以监控到CPU占用率仅有160%，但是用C、C++或Java来改写相同的死循环，直接可以把全部核心跑满，4核就跑到400%，8核就跑到800%，为什么Python不行呢？</p>\n<p>因为Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global Interpreter Lock，任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</p>\n<p>GIL是Python解释器设计的历史遗留问题，通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器。</p>\n<p>所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。</p>\n<p>不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。</p>\n<h2 id=\"ThreadLocal\"><a href=\"#ThreadLocal\" class=\"headerlink\" title=\"ThreadLocal\"></a>ThreadLocal</h2><p>正如上面所说，在多线程环境下，对于全局变量的修改必须加锁，因此，一个线程使用局部变量只有线程自己看得到，不会影响其他线程。</p>\n<p>但局部变量也有问题。就是在传递的时候非常麻烦。尽管是局部变量，但是每个函数都要用它，因此必须传进去。用全局变量又会影响其他进程，不能共享。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global_dict = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">std_thread</span><span class=\"params\">(name)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    std = Student(name)</span><br><span class=\"line\">    <span class=\"comment\"># 把std放到全局变量global_dict中：</span></span><br><span class=\"line\">    global_dict[threading.current_thread()] = std</span><br><span class=\"line\">    do_task_1()</span><br><span class=\"line\">    do_task_2()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_task_1</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"comment\"># 不传入std，而是根据当前线程查找：</span></span><br><span class=\"line\">    std = global_dict[threading.current_thread()]</span><br><span class=\"line\">    ...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">do_task_2</span><span class=\"params\">()</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"comment\"># 任何函数都可以查找出当前线程的std变量：</span></span><br><span class=\"line\">    std = global_dict[threading.current_thread()]</span><br></pre></td></tr></table></figure></p>\n<p>如果用一个全局变量<code>dict</code>来存放所有的<code>Student</code>对象，然后以<code>thread</code>自身作为<code>key</code>获得线程对应的<code>student</code>,这样就消除了<code>std</code>对象在每层函数中传递问题，但是还是不够简单。</p>\n<p><code>ThreadLocal</code>就是来自动帮你做这些事情的，不用查找<code>dict</code>。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> threading</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建全局ThreadLocal对象:</span></span><br><span class=\"line\">local_school = threading.local()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_student</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">print</span> <span class=\"string\">'Hello, %s (in %s)'</span> % (local_school.student, threading.current_thread().name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">process_thread</span><span class=\"params\">(name)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 绑定ThreadLocal的student:</span></span><br><span class=\"line\">    local_school.student = name</span><br><span class=\"line\">    process_student()</span><br><span class=\"line\"></span><br><span class=\"line\">t1 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Alice'</span>,), name=<span class=\"string\">'Thread-A'</span>)</span><br><span class=\"line\">t2 = threading.Thread(target= process_thread, args=(<span class=\"string\">'Bob'</span>,), name=<span class=\"string\">'Thread-B'</span>)</span><br><span class=\"line\">t1.start()</span><br><span class=\"line\">t2.start()</span><br><span class=\"line\">t1.join()</span><br><span class=\"line\">t2.join()</span><br></pre></td></tr></table></figure></p>\n<p>全局变量<code>local_school</code>是一个<code>ThreadLocal</code>对象，每个<code>Thread</code>对它都可以读写<code>student</code>属性，但互不影响。你可以把<code>local_school</code>看成全局变量，但每个属性如<code>local_school.student</code>都是线程的局部变量，可以任意读写而不互相干扰，也不用管理锁的问题，<code>ThreadLocal</code>内部会进行处理。</p>\n<p>可以理解为全局变量<code>local_school</code>是一个<code>dict</code>，不但可以用<code>local_school.student</code>，还可以绑定其他变量，如<code>local_school.teacher</code>等等。</p>\n<p><code>ThreadLocal</code>最常用的地方就是为每个线程绑定一个数据库连接，HTTP请求，用户身份信息等，这样一个线程的所有调用到的处理函数都可以非常方便地访问这些资源。</p>\n<h3 id=\"进程-vs-线程\"><a href=\"#进程-vs-线程\" class=\"headerlink\" title=\"进程 vs. 线程\"></a>进程 vs. 线程</h3><p>现在我们来讨论一下这两种方式的优缺点。</p>\n<p>首先，要实现多任务，通常我们会设计<code>Master-Worker</code>模式，Master负责分配任务，Worker负责执行任务，因此，多任务环境下，通常是一个Master，多个Worker。</p>\n<p>自然，主的就是Master，其他进程/线程就是Worker</p>\n<p>多进程最大的优点就是稳定性高，因为一个子进程崩溃了，不会影响主进程和其他子进程（当然主进程挂了所有子进程都挂了，但是Master进程只负责分配任务，挂掉的概率低）。著名的Apache最早就是采用多进程模式。</p>\n<p>多进程的缺点就是创建进程的代价大，在Unix/Linu系统下，用<code>fork</code>调用还行，在Windows下创建进程就开销巨大。另外，操作系统能同时运行的进程数也是有限的，在内存和CPU的限制下，如果有几千个进程同时运行，操作系统连调度都是问题。</p>\n<p>多线程模式通常比多进程要快一些，但是也快不到哪里去，而且，多线程模式致命的缺点就是任何一个线程挂掉都直接可能造成整个进程崩溃，因为所有线程共享进程的内存。在Windows上，如果一个线程执行的代码出现了问题，你经常可以看到这样的提示：“该程序执行了非法操作，即将关闭”，其实往往是某个线程出了问题，但是操作体统会强制结束整个进程。</p>\n<p>在Windows下，多线程的效率要比多进程高，所以微软的IIS服务器默认采用多线程模式，为了缓解这个问题，IIS和Apache现在又有多线程+多进程的混合模式，真是把问题越搞越复杂。</p>\n<h3 id=\"线程切换\"><a href=\"#线程切换\" class=\"headerlink\" title=\"线程切换\"></a>线程切换</h3><p>无论是多进程还是多线程，只要数量一多，效率肯定上不去，为什么呢？</p>\n<p>任务之间切换是有代价的。比如你从语文切换到数学，要收拾桌子上的语文书（这叫保存现场），然后打开数学课本（这叫准备新环境），才能开始做数学作业。操作系统在切换进程/线程也是需要时间的，它需要先保存当前执行的现场环境(CPU寄存器状态、内存页等)然后，把新任务的执行环境准备好(恢复上次的寄存器状态，切换内存页等)，才能开始执行。这个切换虽然快，但也需要时间，操作系统在任务多的时候可能主要忙着切换任务，根本没有多少时间去执行任务了，这种情况最常见的就是硬盘狂响，点窗口没反应，系统处于假死状态。</p>\n<p>所以，多任务一旦多到一个限度，就会消耗掉系统所有的资源，结果笑来急剧下降，所有任务都做不好。</p>\n<h3 id=\"计算密集型-vs-IO密集型\"><a href=\"#计算密集型-vs-IO密集型\" class=\"headerlink\" title=\"计算密集型 vs IO密集型\"></a>计算密集型 vs IO密集型</h3><p>是否采用多任务的第二个考虑是任务的类型。我们可以吧任务分为计算密集型和IO密集型。</p>\n<p>计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要高效利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。</p>\n<p>计算密集型任务主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务，多余计算密集型任务最好用C语言编写。</p>\n<p>第二种任务类型就是IO密集型，涉及到网络、磁盘IO任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成(因为IO的速度远远低于CPU和内存的速度)。对于IO密集型任务，任务越多，CPU效率越高，但也有个限度。常见的大部分任务都是IO密集型任务，比如Web应用。</p>\n<p>IO密集型任务执行期间，99%的时间都花在了IO上，花在CPU的时间爱你很少，对于IO密集型任务，最适合的语言就是开发效率最高(代码量最少)的语言，脚本语言是首选，C最差。</p>\n<h3 id=\"异步IO\"><a href=\"#异步IO\" class=\"headerlink\" title=\"异步IO\"></a>异步IO</h3><p>考虑到CPU和IO之间巨大的速度差异，一个任务在执行的过程汇总大部分时间都在等待IO操作，单进程单线程模型会导致别的任务无法并行执行，因此，我们才需要多进程模型或者多线程模型来支持多任务并发执行。</p>\n<p>现代操作系统多IO操作已经做了巨大的改进，最大的特点就是支持异步IO，如果充分利用操作系统提供的异步IO支持，就可以用单进程单线程模型来执行多任务，这种全新的模型称为事件驱动模型，Nginx就是支持异步IO的Web服务器，它在单核CPU上采用单进程模型就可以高效的支持多任务。在多核CPU上，可以运行多个进程（数量与CPU核心数相同），充分利用多核CPU。由于系统总的进程数量十分有限，因此操作系统调度非常有效。用异步IO编程模型来实现多任务是一个主要的趋势。</p>\n<p>对应到python语言，单进程的异步编程模型称为协程，有了协程的支持，就可以基于事件驱动编写高效的多任务程序。</p>\n<p>协程我们后续会提到。</p>\n<h3 id=\"分布式进程\"><a href=\"#分布式进程\" class=\"headerlink\" title=\"分布式进程\"></a>分布式进程</h3><p>在process和thread中，应当优先选process，因为process更稳定，而且，process可以分布到多台机器上，而Thread最多只能分布到同一台机器的多个CPU上。</p>\n<p>Python的<code>multiprocessing</code>模块不但支持多进程，其中<code>managers</code>子模块还支持把多进程分布到多台机器上。一个服务进程可以作为跳度者，将任务分布到其他多个进程中，依靠网络通信。由于<code>managers</code>模块封装很好，不必了解网络通信的细节，就可以很容易地编写分布式多进程程序。</p>\n<p>举个例子：如果我们已经有一个通过<code>Queue</code>通信的多进程程序在同一台机器上运行，现在，由于处理任务的进程任务繁重，希望吧发送任务的进程和处理任务的进程分布到两台机器上。怎么用分布式进程实现？</p>\n<p>原有的<code>Queue</code>可以继续使用，但是，通过<code>managers</code>模块把<code>Queue</code>通过网络暴Queue露出去，就可以让其他机器的进程访问<code>Queue</code>了。</p>\n<p>我们先看服务进程，服务进程负责启动<code>Queue</code>，把<code>Queue</code>注册到网络上，然后往<code>Queue</code>里面写任务：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">'分布式进程 -- 服务器端'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> random, multiprocessing</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing.managers <span class=\"keyword\">import</span> BaseManager</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing <span class=\"keyword\">import</span> freeze_support</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 从BaseManager继承的QueueManager:</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueManager</span><span class=\"params\">(BaseManager)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 发送任务的队列:</span></span><br><span class=\"line\">task_queue = multiprocessing.Queue()</span><br><span class=\"line\"><span class=\"comment\"># 接收结果的队列:</span></span><br><span class=\"line\">result_queue = multiprocessing.Queue()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为解决__main__.&lt;lambda&gt; not found问题</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_task_queue</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> task_queue</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 为解决__main__.&lt;lambda&gt; not found问题</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_result_queue</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result_queue</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 把两个Queue都注册到网络上, callable参数关联了Queue对象:</span></span><br><span class=\"line\">QueueManager.register(<span class=\"string\">'get_task_queue'</span>, callable=get_task_queue)</span><br><span class=\"line\">QueueManager.register(<span class=\"string\">'get_result_queue'</span>, callable=get_result_queue)</span><br><span class=\"line\"><span class=\"comment\"># 绑定端口5000, 设置验证码'abc':</span></span><br><span class=\"line\">manager = QueueManager(address=(<span class=\"string\">'127.0.0.1'</span>, <span class=\"number\">5000</span>), authkey=<span class=\"string\">'abc'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">communicate</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 获得通过网络访问的Queue对象:</span></span><br><span class=\"line\">    task = manager.get_task_queue()</span><br><span class=\"line\">    result = manager.get_result_queue()</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 放几个任务进去:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">        n = random.randint(<span class=\"number\">0</span>, <span class=\"number\">10000</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'Put task %d...'</span> % n)</span><br><span class=\"line\">        task.put(n)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 从result队列读取结果:</span></span><br><span class=\"line\">    print(<span class=\"string\">'Try get results...'</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">        r = result.get(timeout=<span class=\"number\">10</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'Result: %s'</span> % r)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 关闭:</span></span><br><span class=\"line\">    manager.shutdown()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    freeze_support()</span><br><span class=\"line\">    <span class=\"comment\"># 启动Queue:</span></span><br><span class=\"line\">    manager.start()</span><br><span class=\"line\">    communicate()</span><br></pre></td></tr></table></figure></p>\n<p>请注意，当我们在一台机器上写多进程程序时，创建的Queue可以直接拿来用，但是，在分布式多进程环境下，添加任务到<code>Queue</code>不可以直接对原始的<code>task_queue</code>进行操作，那样就绕过了<code>QueueManager</code>的封装，必须通过<code>manager.get_task_queue()</code>获得的<code>Queue</code>接口添加。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time, sys, Queue</span><br><span class=\"line\"><span class=\"keyword\">from</span> multiprocessing.managers <span class=\"keyword\">import</span> BaseManager</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建类似的QueueManager:</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueManager</span><span class=\"params\">(BaseManager)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 由于这个QueueManager只从网络上获取Queue，所以注册时只提供名字:</span></span><br><span class=\"line\">QueueManager.register(<span class=\"string\">'get_task_queue'</span>)</span><br><span class=\"line\">QueueManager.register(<span class=\"string\">'get_result_queue'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 连接到服务器，也就是运行taskmanager.py的机器:</span></span><br><span class=\"line\">server_addr = <span class=\"string\">'127.0.0.1'</span></span><br><span class=\"line\">print(<span class=\"string\">'Connect to server %s...'</span> % server_addr)</span><br><span class=\"line\"><span class=\"comment\"># 端口和验证码注意保持与taskmanager.py设置的完全一致:</span></span><br><span class=\"line\">m = QueueManager(address=(server_addr, <span class=\"number\">5000</span>), authkey=<span class=\"string\">'abc'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 从网络连接:</span></span><br><span class=\"line\">m.connect()</span><br><span class=\"line\"><span class=\"comment\"># 获取Queue的对象:</span></span><br><span class=\"line\">task = m.get_task_queue()</span><br><span class=\"line\">result = m.get_result_queue()</span><br><span class=\"line\"><span class=\"comment\"># 从task队列取任务,并把结果写入result队列:</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:</span><br><span class=\"line\">        n = task.get(timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">        print(<span class=\"string\">'run task %d * %d...'</span> % (n, n))</span><br><span class=\"line\">        r = <span class=\"string\">'%d * %d = %d'</span> % (n, n, n*n)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">        result.put(r)</span><br><span class=\"line\">    <span class=\"keyword\">except</span> Queue.Empty:</span><br><span class=\"line\">        print(<span class=\"string\">'task queue is empty.'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 处理结束:</span></span><br><span class=\"line\">print(<span class=\"string\">'worker exit.'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>任务进程要通过网络连接到服务进程，所以要指定服务进程的IP。</p>\n<p>先执行服务器端，再执行worker端，可以实现master端和worker端的分布式计算了。</p>\n<p>另外，发现<code>worker.py</code>根本没有创建<code>Queue</code>，所以，<code>Queue</code>对象存储在<code>manager.py</code>进程中。</p>\n<p>而<code>queue</code>之所以可以通过网络访问，是通过<code>queueManager</code>实现的。由于<code>queueManager</code>管理的不知一个<code>Queue</code>，所以，要给每个Queue的网络调用接口起个名字，比如<code>get_task_queue</code>。</p>\n<p>而<code>authkey</code>为了保证两台机器之间正常通信，不被其他机器干扰，做验证码用。</p>\n<p>注意<code>Queue</code>的作用是用来传递任务和接收结果，每个任务的描述数据量要尽量小。比如发送一个处理日志文件的任务，就不要发送几百兆的日志文件本身，而是发送日志文件存放的完整路径，由Worker进程再去共享的磁盘上读取文件。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"初探python(11)常用的内建模块","date":"2016-11-06T13:26:30.000Z","_content":"Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。下面来介绍一下。\n## collections\n\ncollections是Python内建的一个集合模块，提供许多有用的集合类。\n<!-- more -->\n### namedtuple\n\n在之前的学习中我们知道tuple可以表示不变集合，例如，一个点的二维坐标就可以表示成`p = (1, 2)`,但是光光看到这个`(1,2)`，很难看出是用来表示一个坐标的。\n定义一个class又小题大做。\n\n这时，我们需要用到`namedtuple`：\n```\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(1, 2)\np.x\n# 1\np.y\n# 2\n```\n`namedtuple`是一个函数，用来创建一个自定义的`tuple`对象，并且规定了`tuple`元素的个数，并可以用属性而不是索引来引用`tuple`的某个元素。\n\n这样一来，我们用`namedtuple`可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。\n\n输入`help(namedtuple)`你会发现，\n```\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)\n\n```\n在帮助文档中，也提供了tuple转字典的方法，以及一些替换的方法。\n### deque\n\n之前在学习的时候已经碰到了这个函数，看了下官方解释：\n\n```\ndeque([iterable[, maxlen]])\nBuild an ordered collection with optimized access from its endpoints.\n```\n建立一个从两个端点进行优化的有序集合。\n\n简而言之，是一个可以设置最大长度的队列或堆，优点是`deque`除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素；此外，还可以用来取最近的几条数据，后来的数据会顶开早些的数据。\n\n### defaultdict\n\n与`dict`相比，不同之处在于如果key不存在时，返回一个默认值。\n注意：默认值是调用函数返回的，而函数在创建`defaultdict`对象时传入。\n```\ndd = defaultdict(lambda: 'N/A')\n\n```\n除了在`Key`不存在时返回默认值，`defaultdict`的其他行为跟`dict`是完全一样的。\n\n### OrderedDict\n\n正如名字所言，有序字典。他的有序指的是Key会按照插入的顺序排列，不是Key本身排序。\n\n### Counter\n\nCounter是一个简单的计数器，例如，统计字符出现的个数：\n```\nfrom collections import Counter\nc = Counter()\nfor ch in 'programming':\n...     c[ch] = c[ch] + 1\n...\nc\n#Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})\n\n```\nCounter实际上也是dict的一个子类。\n\n## base64\nBase64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。\n\n### 原理\n\n首先，准备一个包含64个字符的数组：\n```\n['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']\n```\n然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit,也就是2^6,64个字符相对应。\n\n这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。\n\nBase64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。\n\n如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。\n\n```\nimport base64\nbase64.b64encode('binary\\x00string')\n# 对于在URL，有一种\"url safe\"的base64编码，\n# 把字符+和/分别变成-和_，防止搞混\nbase64.urlsafe_b64decode('abcd--__')\n```\n由于`=`字符也可能出现在Base64编码中，但`=`用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把`=`去掉,但在解码的时候，我们需要把`=`加上。\n```\ndef b64decode_self(str):\n    return base64.b64decode(str+'='*(4-len(str)%4))\n```\n\n## struct\n用来解决str和其他二进制数据类型的转换。\n\n`struct`的`pack`函数把任意数据类型变成字符串。\n```\nimport struct\nstruct.pack('>I', 10240099)\n# '\\x00\\x9c@c'\n```\npack的第一个参数是处理指令，'>I'的意思是：\n\n`>`表示字节顺序是big-endian，大端字节序也就是网络序，高字节存于内存低地址；低字节存于内存高地址。I表示4字节无符号整数。\n\n`unpack`把`str`变成相应的数据类型：\n```\n struct.unpack('>IH', '\\xf0\\xf0\\xf0\\xf0\\x80\\x80')\n(4042322160, 32896)\n```\n具体处理指令可用`help`来查看。\n\n下面我们用`struct`分析一下bmp格式。\n首先找一个`bmp`文件，没有的话用“画图”画一个。\n读入前30个字节来分析。\n\nBMP格式采用小端方式存储数据，文件头的结构按顺序如下：\n\n两个字节：'BM'表示`Windows`位图，'BA'表示OS/2位图；\n一个4字节整数：表示位图大小；\n一个4字节整数：保留位，始终为0；\n一个4字节整数：实际图像的偏移量；\n一个4字节整数：Header的字节数；\n一个4字节整数：图像宽度；\n一个4字节整数：图像高度；\n一个2字节整数：始终为1；\n一个2字节整数：颜色数。\n\n所以，组合起来用unpack读取：\n```\nstruct.unpack('<ccIIIIIIHH', s)\n('B', 'M', 691256, 0, 54, 40, 640, 360, 1, 24)\n```\n结果显示，'B'、'M'说明是Windows位图，位图大小为640x360，颜色数为24。\n\n\n### 练习\n\n请编写一个bmpinfo.py，可以检查任意文件是否是位图文件，如果是，打印出图片大小和颜色数。\n```\nimport struct\n\n\ndef isbmp(s):\n    f = open(s, 'rb').read(30)\n    b = struct.unpack('<ccIIIIIIHH', f)\n    if b[0] == 'B' and b[1] == 'M':\n        print \"size = %s * %s\" % (b[6], b[7])\n        print \"color = %s \" % (b[-1])\n    else:\n        print \"it's not bmp!\"\nif __name__ == '__main__':\n    isbmp('1.bmp')\n    isbmp(\"1.jpg\")\n```\n\n## hashlib\n\n摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。\n\nPython的hashlib提供了常见的摘要算法，如MD5，SHA1等等。\n\n什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。\n\nMD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。\n```\nimport hashlib\n\nmd5 = hashlib.md5()\nmd5.update('how to use md5 in python hashlib?')\nprint md5.hexdigest()\n```\n而SHA1也是其中一种算法，和调用MD5完全类似:\n```\nimport hashlib\n\nsha1 = hashlib.sha1()\nsha1.update('how to use sha1 in ')\nsha1.update('python hashlib?')\nprint sha1.hexdigest()\n```\n比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法越慢，而且摘要长度更长。\n\n有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能。因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞。\n### 应用\n这种用法常用于数据保密。如明文保存账户数据容易被黑客盗取，用户登录时，通过用户输入的口令来计算摘要，如果和存储的摘要一致，就可以认为是登录正确。\n\n存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。\n\n采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。\n\n考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：\n```\n'e10adc3949ba59abbe56e057f20f883e': '123456'\n'21218cca77804d2ba1922c33e0151105': '888888'\n'5f4dcc3b5aa765d61d8327deb882cf99': 'password'\n```\n这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。\n\n对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？\n\n### 加盐\n由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：\n\n```\ndef calc_md5(password):\n    return get_md5(password + 'the-Salt')\n```\n经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。\n\n但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？\n\n如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。\n\n\n### 练习\n1.设计一个验证用户登录小程序，根据用户输入的口令保存账号密码，亦可做登录检查。\n\n解：\n```\nimport hashlib\ndef md5(str):\n    md = hashlib.md5()\n    md.update(str)\n    md_5 = md.hexdigest()\n    return md_5\ndict_client = {}\nwhile 1:\n    ty = raw_input(\"欢迎使用用户登录系统...存储用户数据请按1，登录请按2，退出请按3\\n\")\n    if ty =='1':\n\n        name_str = raw_input(\"请输出用户名字：\\n\")\n        keywords_str = raw_input(\"请输入密码：\\n\")\n        dict_client[name_str]=md5(keywords_str)\n        print 'MD5密码加密已完成...'\n        print dict_client\n    if ty ==\"2\":\n        name_str = raw_input(\"请输出用户名字：\\n\")\n        keywords_str = raw_input(\"请输入密码：\\n\")\n        if dict_client[name_str]==md5(keywords_str):\n            print \"welcome %s\" %name_str\n        else :\n            print \"your keywords are wrong ! \"\n    if ty ==\"3\":\n        print 'BYE...'\n        break\n```\n2.根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5.\n```\ndb = {}\n\ndef register(username, password):\n    db[username] = get_md5(password + username + 'the-Salt')\n\n```\n然后，根据修改后的MD5算法实现用户登录的验证：\n```\ndef login(username, password):\n    pass\n```\n解法：\n```\nimport hashlib\n\n\ndef md5(str):\n    md = hashlib.md5()\n    md.update(str)\n    md_5 = md.hexdigest()\n    return md_5\n\n\ndef register(username, password):\n    dict_client[username] = md5(password + username + 'the-Salt')\n\n\ndef login(username, password):\n    if dict_client[username] == md5(password + username + 'the-Salt'):\n        print \"welcome %s\" % username\n    else:\n        print \"your keywords are wrong ! \"\n\n\ndict_client = {}\nwhile 1:\n    ty = raw_input(\"欢迎使用用户登录系统...存储用户数据请按1，登录请按2，退出请按3\\n\")\n    if ty == '1':\n        name_str = raw_input(\"请输出用户名字：\\n\")\n        keywords_str = raw_input(\"请输入密码：\\n\")\n        register(name_str, keywords_str)\n        print 'MD5密码加密已完成...'\n        print dict_client\n    if ty == \"2\":\n        name_str = raw_input(\"请输出用户名字：\\n\")\n        keywords_str = raw_input(\"请输入密码：\\n\")\n        login(name_str,keywords_str)\n    if ty == \"3\":\n        print 'BYE...'\n        break\n```\n## itertools\n\n`itertools`提供了非常有用的用于操作迭代对象的函数。\n\n### count\n```\nnatuals = itertools.count(1,2)\nfor n in natuals:\n    print n\n```\n\n返回一个从第一个参数1开始的连续值，可以设置第二个参数`step`步长。\n\n### cycle()\n```\ncs = itertools.cycle(\"ABCD\")\n```\nReturn elements from the iterable until it is exhausted.\n当然。电脑不会精疲力竭，将传入的序列无限重复下去。\n### repeat()\n```\nns = itertools.repeat('A', 10)\n```\nrepeat(object [,times]) -> create an iterator which returns the object\nfor the specified number of times.  If not specified, returns the object\nendlessly.\n\n负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数,不提供，同样无穷重复。\n\n### takewhile()\n无限序列虽然可以无限迭代下去，但是通常我们会通过`takewhile()`等函数根据条件判断来截取一个有限序列。\n\n```\nimport itertools\n\nns = itertools.count(1)\n\nn = itertools.takewhile(lambda x: x <= 10, ns)\nfor i in n:\n    print i\n```\n\n`itertools`提供的几个迭代器操作函数更加有用：\n\n### chain()\n```\nfor c in itertools.chain('ABC', 'XYZ'):\n    print c\n```\n加强版的`cycle`，可以将一组迭代对象串联起来，形成一个更大的迭代器。\n\n### groupby()\n把迭代器中相邻的重复元素挑出来放在一起。\n\n实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key,第二个参数用来筛选规则例如可以忽略大小写。\n```\nfor key, group in itertools.groupby('AAABBBbCCAAAaaa',lambda a:a.upper()):\n    print key, list(group) \n```\n\n### imap()\n`imap()`和`map()`的区别在于，`imap()`可以作用于无穷序列，并且，如果两个序列的长度不一致，以短的那个为准。\n长与短序列对应相乘。\n```\nfor x in itertools.imap(lambda x, y: x * y, [10, 20, 30], itertools.count(1)):\n    print x\nfor n in itertools.imap(lambda x:x*x,[1,2,3]):\n    print n\n\n```\n注意，`imap()`返回一个迭代对象，而`map()`返回一个list，当你调用map事，已经计算完毕。而当你调用imap时，并没有进行任何计算。必须用for循环对其进行迭代，才会在每次循环过程中计算出下一个元素。\n\n换种说法，`imap()`是`map()`的惰性实现。\n\n同理，ifilter()就是filter()的惰性实现。\n还有islice()，也是slice()的惰性实现。\n\n## XML\n\nXML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。\n\n### DOM vs SAX\n\n操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。\n\n正常情况下，优先考虑SAX，因为DOM实在太占内存。\n\n在Python中使用SAX解析XML非常简洁，通常我们关心的事件是`start_element`，`end_element`和`char_data`，准备好这3个函数，然后就可以解析xml了。\n\n举个例子，当SAX解析器读到一个节点时：\n```\n<a href=\"/\">python</a>\n```\n会产生3个事件：\n1.start_element事件，在读取<a href=\"/\">时；\n2.char_data事件，在读取python时；\n3.end_element事件，在读取</a>时。\n\n```\nfrom xml.parsers.expat import ParserCreate\n\nclass DefaultSaxHandler(object):\n    def start_element(self, name, attrs):\n        print('sax:start_element: %s, attrs: %s' % (name, str(attrs)))\n\n    def end_element(self, name):\n        print('sax:end_element: %s' % name)\n\n    def char_data(self, text):\n        print('sax:char_data: %s' % text)\n\nxml = r'''<?xml version=\"1.0\"?>\n<ol>\n    <li><a href=\"/python\">Python</a></li>\n    <li><a href=\"/ruby\">Ruby</a></li>\n</ol>\n'''\nhandler = DefaultSaxHandler()\nparser = ParserCreate()\nparser.returns_unicode = True\nparser.StartElementHandler = handler.start_element\nparser.EndElementHandler = handler.end_element\nparser.CharacterDataHandler = handler.char_data\nparser.Parse(xml)\n```\n而生成XML可以使用`append()`和`join()`拼接字符串的方式。\n\n如果生成复杂的XML呢？建议你不要用XML，改成JSON。\n\n## HTMLParser\n一个便于解析HTML的模块。\n\n如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。\n\n假设第一步已经完成了，第二步应该如何解析HTML呢？\n\nHTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。\n```\nfrom HTMLParser import HTMLParser\nfrom htmlentitydefs import name2codepoint\n\nclass MyHTMLParser(HTMLParser):\n\n    def handle_starttag(self, tag, attrs):\n        print('<%s>' % tag)\n\n    def handle_endtag(self, tag):\n        print('</%s>' % tag)\n\n    def handle_startendtag(self, tag, attrs):\n        print('<%s/>' % tag)\n\n    def handle_data(self, data):\n        print('data')\n\n    def handle_comment(self, data):\n        print('<!-- -->')\n\n    def handle_entityref(self, name):\n        print('&%s;' % name)\n\n    def handle_charref(self, name):\n        print('&#%s;' % name)\n\nparser = MyHTMLParser()\nparser.feed('<html><head></head><body><p>Some <a href=\\\"#\\\">html</a> tutorial...<br>END</p></body></html>')\n```\n\n`feed()`方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。\n\n特殊字符有两种，一种是英文表示的`&nbsp;`（占位符），一种是数字表示的`&#1234;`，这两种字符都可以通过Parser解析出来。\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)和官方文档的一个学习内容的总结。以便于自己后的学习和整理。","source":"_posts/python/初探python(11)常用的内建模块.md","raw":"---\ntitle: 初探python(11)常用的内建模块\ndate: 2016-11-06 21:26:30\ntags: \n- python\n- python教程\ncategories: 总结\n---\nPython之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。下面来介绍一下。\n## collections\n\ncollections是Python内建的一个集合模块，提供许多有用的集合类。\n<!-- more -->\n### namedtuple\n\n在之前的学习中我们知道tuple可以表示不变集合，例如，一个点的二维坐标就可以表示成`p = (1, 2)`,但是光光看到这个`(1,2)`，很难看出是用来表示一个坐标的。\n定义一个class又小题大做。\n\n这时，我们需要用到`namedtuple`：\n```\nfrom collections import namedtuple\nPoint = namedtuple('Point', ['x', 'y'])\np = Point(1, 2)\np.x\n# 1\np.y\n# 2\n```\n`namedtuple`是一个函数，用来创建一个自定义的`tuple`对象，并且规定了`tuple`元素的个数，并可以用属性而不是索引来引用`tuple`的某个元素。\n\n这样一来，我们用`namedtuple`可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。\n\n输入`help(namedtuple)`你会发现，\n```\n>>> d = p._asdict()                 # convert to a dictionary\n>>> d['x']\n11\n>>> Point(**d)                      # convert from a dictionary\nPoint(x=11, y=22)\n>>> p._replace(x=100)               # _replace() is like str.replace() but targets named fields\nPoint(x=100, y=22)\n\n```\n在帮助文档中，也提供了tuple转字典的方法，以及一些替换的方法。\n### deque\n\n之前在学习的时候已经碰到了这个函数，看了下官方解释：\n\n```\ndeque([iterable[, maxlen]])\nBuild an ordered collection with optimized access from its endpoints.\n```\n建立一个从两个端点进行优化的有序集合。\n\n简而言之，是一个可以设置最大长度的队列或堆，优点是`deque`除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素；此外，还可以用来取最近的几条数据，后来的数据会顶开早些的数据。\n\n### defaultdict\n\n与`dict`相比，不同之处在于如果key不存在时，返回一个默认值。\n注意：默认值是调用函数返回的，而函数在创建`defaultdict`对象时传入。\n```\ndd = defaultdict(lambda: 'N/A')\n\n```\n除了在`Key`不存在时返回默认值，`defaultdict`的其他行为跟`dict`是完全一样的。\n\n### OrderedDict\n\n正如名字所言，有序字典。他的有序指的是Key会按照插入的顺序排列，不是Key本身排序。\n\n### Counter\n\nCounter是一个简单的计数器，例如，统计字符出现的个数：\n```\nfrom collections import Counter\nc = Counter()\nfor ch in 'programming':\n...     c[ch] = c[ch] + 1\n...\nc\n#Counter({'g': 2, 'm': 2, 'r': 2, 'a': 1, 'i': 1, 'o': 1, 'n': 1, 'p': 1})\n\n```\nCounter实际上也是dict的一个子类。\n\n## base64\nBase64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。\n\n### 原理\n\n首先，准备一个包含64个字符的数组：\n```\n['A', 'B', 'C', ... 'a', 'b', 'c', ... '0', '1', ... '+', '/']\n```\n然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit,也就是2^6,64个字符相对应。\n\n这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。\n\nBase64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。\n\n如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。\n\n```\nimport base64\nbase64.b64encode('binary\\x00string')\n# 对于在URL，有一种\"url safe\"的base64编码，\n# 把字符+和/分别变成-和_，防止搞混\nbase64.urlsafe_b64decode('abcd--__')\n```\n由于`=`字符也可能出现在Base64编码中，但`=`用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把`=`去掉,但在解码的时候，我们需要把`=`加上。\n```\ndef b64decode_self(str):\n    return base64.b64decode(str+'='*(4-len(str)%4))\n```\n\n## struct\n用来解决str和其他二进制数据类型的转换。\n\n`struct`的`pack`函数把任意数据类型变成字符串。\n```\nimport struct\nstruct.pack('>I', 10240099)\n# '\\x00\\x9c@c'\n```\npack的第一个参数是处理指令，'>I'的意思是：\n\n`>`表示字节顺序是big-endian，大端字节序也就是网络序，高字节存于内存低地址；低字节存于内存高地址。I表示4字节无符号整数。\n\n`unpack`把`str`变成相应的数据类型：\n```\n struct.unpack('>IH', '\\xf0\\xf0\\xf0\\xf0\\x80\\x80')\n(4042322160, 32896)\n```\n具体处理指令可用`help`来查看。\n\n下面我们用`struct`分析一下bmp格式。\n首先找一个`bmp`文件，没有的话用“画图”画一个。\n读入前30个字节来分析。\n\nBMP格式采用小端方式存储数据，文件头的结构按顺序如下：\n\n两个字节：'BM'表示`Windows`位图，'BA'表示OS/2位图；\n一个4字节整数：表示位图大小；\n一个4字节整数：保留位，始终为0；\n一个4字节整数：实际图像的偏移量；\n一个4字节整数：Header的字节数；\n一个4字节整数：图像宽度；\n一个4字节整数：图像高度；\n一个2字节整数：始终为1；\n一个2字节整数：颜色数。\n\n所以，组合起来用unpack读取：\n```\nstruct.unpack('<ccIIIIIIHH', s)\n('B', 'M', 691256, 0, 54, 40, 640, 360, 1, 24)\n```\n结果显示，'B'、'M'说明是Windows位图，位图大小为640x360，颜色数为24。\n\n\n### 练习\n\n请编写一个bmpinfo.py，可以检查任意文件是否是位图文件，如果是，打印出图片大小和颜色数。\n```\nimport struct\n\n\ndef isbmp(s):\n    f = open(s, 'rb').read(30)\n    b = struct.unpack('<ccIIIIIIHH', f)\n    if b[0] == 'B' and b[1] == 'M':\n        print \"size = %s * %s\" % (b[6], b[7])\n        print \"color = %s \" % (b[-1])\n    else:\n        print \"it's not bmp!\"\nif __name__ == '__main__':\n    isbmp('1.bmp')\n    isbmp(\"1.jpg\")\n```\n\n## hashlib\n\n摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。\n\nPython的hashlib提供了常见的摘要算法，如MD5，SHA1等等。\n\n什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。\n\nMD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。\n```\nimport hashlib\n\nmd5 = hashlib.md5()\nmd5.update('how to use md5 in python hashlib?')\nprint md5.hexdigest()\n```\n而SHA1也是其中一种算法，和调用MD5完全类似:\n```\nimport hashlib\n\nsha1 = hashlib.sha1()\nsha1.update('how to use sha1 in ')\nsha1.update('python hashlib?')\nprint sha1.hexdigest()\n```\n比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法越慢，而且摘要长度更长。\n\n有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能。因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞。\n### 应用\n这种用法常用于数据保密。如明文保存账户数据容易被黑客盗取，用户登录时，通过用户输入的口令来计算摘要，如果和存储的摘要一致，就可以认为是登录正确。\n\n存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。\n\n采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。\n\n考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：\n```\n'e10adc3949ba59abbe56e057f20f883e': '123456'\n'21218cca77804d2ba1922c33e0151105': '888888'\n'5f4dcc3b5aa765d61d8327deb882cf99': 'password'\n```\n这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。\n\n对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？\n\n### 加盐\n由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：\n\n```\ndef calc_md5(password):\n    return get_md5(password + 'the-Salt')\n```\n经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。\n\n但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？\n\n如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。\n\n\n### 练习\n1.设计一个验证用户登录小程序，根据用户输入的口令保存账号密码，亦可做登录检查。\n\n解：\n```\nimport hashlib\ndef md5(str):\n    md = hashlib.md5()\n    md.update(str)\n    md_5 = md.hexdigest()\n    return md_5\ndict_client = {}\nwhile 1:\n    ty = raw_input(\"欢迎使用用户登录系统...存储用户数据请按1，登录请按2，退出请按3\\n\")\n    if ty =='1':\n\n        name_str = raw_input(\"请输出用户名字：\\n\")\n        keywords_str = raw_input(\"请输入密码：\\n\")\n        dict_client[name_str]=md5(keywords_str)\n        print 'MD5密码加密已完成...'\n        print dict_client\n    if ty ==\"2\":\n        name_str = raw_input(\"请输出用户名字：\\n\")\n        keywords_str = raw_input(\"请输入密码：\\n\")\n        if dict_client[name_str]==md5(keywords_str):\n            print \"welcome %s\" %name_str\n        else :\n            print \"your keywords are wrong ! \"\n    if ty ==\"3\":\n        print 'BYE...'\n        break\n```\n2.根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5.\n```\ndb = {}\n\ndef register(username, password):\n    db[username] = get_md5(password + username + 'the-Salt')\n\n```\n然后，根据修改后的MD5算法实现用户登录的验证：\n```\ndef login(username, password):\n    pass\n```\n解法：\n```\nimport hashlib\n\n\ndef md5(str):\n    md = hashlib.md5()\n    md.update(str)\n    md_5 = md.hexdigest()\n    return md_5\n\n\ndef register(username, password):\n    dict_client[username] = md5(password + username + 'the-Salt')\n\n\ndef login(username, password):\n    if dict_client[username] == md5(password + username + 'the-Salt'):\n        print \"welcome %s\" % username\n    else:\n        print \"your keywords are wrong ! \"\n\n\ndict_client = {}\nwhile 1:\n    ty = raw_input(\"欢迎使用用户登录系统...存储用户数据请按1，登录请按2，退出请按3\\n\")\n    if ty == '1':\n        name_str = raw_input(\"请输出用户名字：\\n\")\n        keywords_str = raw_input(\"请输入密码：\\n\")\n        register(name_str, keywords_str)\n        print 'MD5密码加密已完成...'\n        print dict_client\n    if ty == \"2\":\n        name_str = raw_input(\"请输出用户名字：\\n\")\n        keywords_str = raw_input(\"请输入密码：\\n\")\n        login(name_str,keywords_str)\n    if ty == \"3\":\n        print 'BYE...'\n        break\n```\n## itertools\n\n`itertools`提供了非常有用的用于操作迭代对象的函数。\n\n### count\n```\nnatuals = itertools.count(1,2)\nfor n in natuals:\n    print n\n```\n\n返回一个从第一个参数1开始的连续值，可以设置第二个参数`step`步长。\n\n### cycle()\n```\ncs = itertools.cycle(\"ABCD\")\n```\nReturn elements from the iterable until it is exhausted.\n当然。电脑不会精疲力竭，将传入的序列无限重复下去。\n### repeat()\n```\nns = itertools.repeat('A', 10)\n```\nrepeat(object [,times]) -> create an iterator which returns the object\nfor the specified number of times.  If not specified, returns the object\nendlessly.\n\n负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数,不提供，同样无穷重复。\n\n### takewhile()\n无限序列虽然可以无限迭代下去，但是通常我们会通过`takewhile()`等函数根据条件判断来截取一个有限序列。\n\n```\nimport itertools\n\nns = itertools.count(1)\n\nn = itertools.takewhile(lambda x: x <= 10, ns)\nfor i in n:\n    print i\n```\n\n`itertools`提供的几个迭代器操作函数更加有用：\n\n### chain()\n```\nfor c in itertools.chain('ABC', 'XYZ'):\n    print c\n```\n加强版的`cycle`，可以将一组迭代对象串联起来，形成一个更大的迭代器。\n\n### groupby()\n把迭代器中相邻的重复元素挑出来放在一起。\n\n实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key,第二个参数用来筛选规则例如可以忽略大小写。\n```\nfor key, group in itertools.groupby('AAABBBbCCAAAaaa',lambda a:a.upper()):\n    print key, list(group) \n```\n\n### imap()\n`imap()`和`map()`的区别在于，`imap()`可以作用于无穷序列，并且，如果两个序列的长度不一致，以短的那个为准。\n长与短序列对应相乘。\n```\nfor x in itertools.imap(lambda x, y: x * y, [10, 20, 30], itertools.count(1)):\n    print x\nfor n in itertools.imap(lambda x:x*x,[1,2,3]):\n    print n\n\n```\n注意，`imap()`返回一个迭代对象，而`map()`返回一个list，当你调用map事，已经计算完毕。而当你调用imap时，并没有进行任何计算。必须用for循环对其进行迭代，才会在每次循环过程中计算出下一个元素。\n\n换种说法，`imap()`是`map()`的惰性实现。\n\n同理，ifilter()就是filter()的惰性实现。\n还有islice()，也是slice()的惰性实现。\n\n## XML\n\nXML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。\n\n### DOM vs SAX\n\n操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。\n\n正常情况下，优先考虑SAX，因为DOM实在太占内存。\n\n在Python中使用SAX解析XML非常简洁，通常我们关心的事件是`start_element`，`end_element`和`char_data`，准备好这3个函数，然后就可以解析xml了。\n\n举个例子，当SAX解析器读到一个节点时：\n```\n<a href=\"/\">python</a>\n```\n会产生3个事件：\n1.start_element事件，在读取<a href=\"/\">时；\n2.char_data事件，在读取python时；\n3.end_element事件，在读取</a>时。\n\n```\nfrom xml.parsers.expat import ParserCreate\n\nclass DefaultSaxHandler(object):\n    def start_element(self, name, attrs):\n        print('sax:start_element: %s, attrs: %s' % (name, str(attrs)))\n\n    def end_element(self, name):\n        print('sax:end_element: %s' % name)\n\n    def char_data(self, text):\n        print('sax:char_data: %s' % text)\n\nxml = r'''<?xml version=\"1.0\"?>\n<ol>\n    <li><a href=\"/python\">Python</a></li>\n    <li><a href=\"/ruby\">Ruby</a></li>\n</ol>\n'''\nhandler = DefaultSaxHandler()\nparser = ParserCreate()\nparser.returns_unicode = True\nparser.StartElementHandler = handler.start_element\nparser.EndElementHandler = handler.end_element\nparser.CharacterDataHandler = handler.char_data\nparser.Parse(xml)\n```\n而生成XML可以使用`append()`和`join()`拼接字符串的方式。\n\n如果生成复杂的XML呢？建议你不要用XML，改成JSON。\n\n## HTMLParser\n一个便于解析HTML的模块。\n\n如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。\n\n假设第一步已经完成了，第二步应该如何解析HTML呢？\n\nHTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。\n```\nfrom HTMLParser import HTMLParser\nfrom htmlentitydefs import name2codepoint\n\nclass MyHTMLParser(HTMLParser):\n\n    def handle_starttag(self, tag, attrs):\n        print('<%s>' % tag)\n\n    def handle_endtag(self, tag):\n        print('</%s>' % tag)\n\n    def handle_startendtag(self, tag, attrs):\n        print('<%s/>' % tag)\n\n    def handle_data(self, data):\n        print('data')\n\n    def handle_comment(self, data):\n        print('<!-- -->')\n\n    def handle_entityref(self, name):\n        print('&%s;' % name)\n\n    def handle_charref(self, name):\n        print('&#%s;' % name)\n\nparser = MyHTMLParser()\nparser.feed('<html><head></head><body><p>Some <a href=\\\"#\\\">html</a> tutorial...<br>END</p></body></html>')\n```\n\n`feed()`方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。\n\n特殊字符有两种，一种是英文表示的`&nbsp;`（占位符），一种是数字表示的`&#1234;`，这两种字符都可以通过Parser解析出来。\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)和官方文档的一个学习内容的总结。以便于自己后的学习和整理。","slug":"python/初探python(11)常用的内建模块","published":1,"updated":"2019-03-22T14:44:36.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn2q00bm4l3nszs3rj54","content":"<p>Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。下面来介绍一下。</p>\n<h2 id=\"collections\"><a href=\"#collections\" class=\"headerlink\" title=\"collections\"></a>collections</h2><p>collections是Python内建的一个集合模块，提供许多有用的集合类。<br><a id=\"more\"></a></p>\n<h3 id=\"namedtuple\"><a href=\"#namedtuple\" class=\"headerlink\" title=\"namedtuple\"></a>namedtuple</h3><p>在之前的学习中我们知道tuple可以表示不变集合，例如，一个点的二维坐标就可以表示成<code>p = (1, 2)</code>,但是光光看到这个<code>(1,2)</code>，很难看出是用来表示一个坐标的。<br>定义一个class又小题大做。</p>\n<p>这时，我们需要用到<code>namedtuple</code>：<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> namedtuple</span><br><span class=\"line\">Point = namedtuple(<span class=\"string\">'Point'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>])</span><br><span class=\"line\">p = Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">p.x</span><br><span class=\"line\"># <span class=\"number\">1</span></span><br><span class=\"line\">p.y</span><br><span class=\"line\"># <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p><code>namedtuple</code>是一个函数，用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p>\n<p>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p>\n<p>输入<code>help(namedtuple)</code>你会发现，<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; d = p._asdict()                 <span class=\"comment\"># convert to a dictionary</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; d[<span class=\"string\">'x'</span>]</span><br><span class=\"line\"><span class=\"number\">11</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Point(**d)                      <span class=\"comment\"># convert from a dictionary</span></span><br><span class=\"line\">Point(x=<span class=\"number\">11</span>, y=<span class=\"number\">22</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; p._replace(x=<span class=\"number\">100</span>)               <span class=\"comment\"># _replace() is like str.replace() but targets named fields</span></span><br><span class=\"line\">Point(x=<span class=\"number\">100</span>, y=<span class=\"number\">22</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在帮助文档中，也提供了tuple转字典的方法，以及一些替换的方法。</p>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>之前在学习的时候已经碰到了这个函数，看了下官方解释：</p>\n<figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deque([iterable[, maxlen]])</span><br><span class=\"line\"><span class=\"keyword\">Build</span> an ordered <span class=\"keyword\">collection</span> <span class=\"keyword\">with</span> optimized access <span class=\"keyword\">from</span> its endpoints.</span><br></pre></td></tr></table></figure>\n<p>建立一个从两个端点进行优化的有序集合。</p>\n<p>简而言之，是一个可以设置最大长度的队列或堆，优点是<code>deque</code>除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素；此外，还可以用来取最近的几条数据，后来的数据会顶开早些的数据。</p>\n<h3 id=\"defaultdict\"><a href=\"#defaultdict\" class=\"headerlink\" title=\"defaultdict\"></a>defaultdict</h3><p>与<code>dict</code>相比，不同之处在于如果key不存在时，返回一个默认值。<br>注意：默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。<br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">dd</span> = defaultdict(lambda: <span class=\"string\">'N/A'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>\n<h3 id=\"OrderedDict\"><a href=\"#OrderedDict\" class=\"headerlink\" title=\"OrderedDict\"></a>OrderedDict</h3><p>正如名字所言，有序字典。他的有序指的是Key会按照插入的顺序排列，不是Key本身排序。</p>\n<h3 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h3><p>Counter是一个简单的计数器，例如，统计字符出现的个数：<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">c = Counter()</span><br><span class=\"line\">for ch <span class=\"keyword\">in</span> <span class=\"string\">'programming'</span>:</span><br><span class=\"line\">...     c[ch] = c[ch] + <span class=\"number\">1</span></span><br><span class=\"line\">...</span><br><span class=\"line\">c</span><br><span class=\"line\">#Counter(&#123;<span class=\"string\">'g'</span>: <span class=\"number\">2</span>, <span class=\"string\">'m'</span>: <span class=\"number\">2</span>, <span class=\"string\">'r'</span>: <span class=\"number\">2</span>, <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'i'</span>: <span class=\"number\">1</span>, <span class=\"string\">'o'</span>: <span class=\"number\">1</span>, <span class=\"string\">'n'</span>: <span class=\"number\">1</span>, <span class=\"string\">'p'</span>: <span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>Counter实际上也是dict的一个子类。</p>\n<h2 id=\"base64\"><a href=\"#base64\" class=\"headerlink\" title=\"base64\"></a>base64</h2><p>Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>首先，准备一个包含64个字符的数组：<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">'A</span>', <span class=\"symbol\">'B</span>', <span class=\"symbol\">'C</span>', ... <span class=\"symbol\">'a</span>', <span class=\"symbol\">'b</span>', <span class=\"symbol\">'c</span>', ... <span class=\"symbol\">'0</span>', <span class=\"symbol\">'1</span>', ... <span class=\"symbol\">'+</span>', <span class=\"symbol\">'/</span>']</span><br></pre></td></tr></table></figure></p>\n<p>然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit,也就是2^6,64个字符相对应。</p>\n<p>这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。</p>\n<p>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p>\n<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import <span class=\"built_in\">base64</span></span><br><span class=\"line\"><span class=\"built_in\">base64</span>.b64encode('binary\\x00string')</span><br><span class=\"line\"># 对于在URL，有一种<span class=\"string\">\"url safe\"</span>的<span class=\"built_in\">base64</span>编码，</span><br><span class=\"line\"># 把字符+和/分别变成-和<span class=\"symbol\">_</span>，防止搞混</span><br><span class=\"line\"><span class=\"built_in\">base64</span>.urlsafe_b64decode('abcd--<span class=\"symbol\">__</span>')</span><br></pre></td></tr></table></figure>\n<p>由于<code>=</code>字符也可能出现在Base64编码中，但<code>=</code>用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把<code>=</code>去掉,但在解码的时候，我们需要把<code>=</code>加上。<br><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def b64decode_self(<span class=\"keyword\">str</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> base64.b64decode(<span class=\"keyword\">str</span>+<span class=\"string\">'='</span>*(<span class=\"number\">4</span>-len(<span class=\"keyword\">str</span>)%<span class=\"number\">4</span>))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"struct\"><a href=\"#struct\" class=\"headerlink\" title=\"struct\"></a>struct</h2><p>用来解决str和其他二进制数据类型的转换。</p>\n<p><code>struct</code>的<code>pack</code>函数把任意数据类型变成字符串。<br><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span>.<span class=\"title\">pack</span>('&gt;<span class=\"title\">I</span>', 10240099)</span></span><br><span class=\"line\"><span class=\"comment\"># '\\x00\\x9c@c'</span></span><br></pre></td></tr></table></figure></p>\n<p>pack的第一个参数是处理指令，’&gt;I’的意思是：</p>\n<p><code>&gt;</code>表示字节顺序是big-endian，大端字节序也就是网络序，高字节存于内存低地址；低字节存于内存高地址。I表示4字节无符号整数。</p>\n<p><code>unpack</code>把<code>str</code>变成相应的数据类型：<br><figure class=\"highlight taggerscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> struct.unpack('&gt;IH', '<span class=\"symbol\">\\x</span>f0<span class=\"symbol\">\\x</span>f0<span class=\"symbol\">\\x</span>f0<span class=\"symbol\">\\x</span>f0<span class=\"symbol\">\\x</span>80<span class=\"symbol\">\\x</span>80')</span><br><span class=\"line\">(4042322160, 32896)</span><br></pre></td></tr></table></figure></p>\n<p>具体处理指令可用<code>help</code>来查看。</p>\n<p>下面我们用<code>struct</code>分析一下bmp格式。<br>首先找一个<code>bmp</code>文件，没有的话用“画图”画一个。<br>读入前30个字节来分析。</p>\n<p>BMP格式采用小端方式存储数据，文件头的结构按顺序如下：</p>\n<p>两个字节：’BM’表示<code>Windows</code>位图，’BA’表示OS/2位图；<br>一个4字节整数：表示位图大小；<br>一个4字节整数：保留位，始终为0；<br>一个4字节整数：实际图像的偏移量；<br>一个4字节整数：Header的字节数；<br>一个4字节整数：图像宽度；<br>一个4字节整数：图像高度；<br>一个2字节整数：始终为1；<br>一个2字节整数：颜色数。</p>\n<p>所以，组合起来用unpack读取：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct.unpack('&lt;ccIIIIIIHH', s)</span><br><span class=\"line\">('B', 'M', <span class=\"number\">691256</span>, <span class=\"number\">0</span>, <span class=\"number\">54</span>, <span class=\"number\">40</span>, <span class=\"number\">640</span>, <span class=\"number\">360</span>, <span class=\"number\">1</span>, <span class=\"number\">24</span>)</span><br></pre></td></tr></table></figure></p>\n<p>结果显示，’B’、’M’说明是Windows位图，位图大小为640x360，颜色数为24。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>请编写一个bmpinfo.py，可以检查任意文件是否是位图文件，如果是，打印出图片大小和颜色数。<br><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import struct</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def isbmp(<span class=\"keyword\">s</span>):</span><br><span class=\"line\">    f = <span class=\"keyword\">open</span>(<span class=\"keyword\">s</span>, <span class=\"string\">'rb'</span>).read(<span class=\"number\">30</span>)</span><br><span class=\"line\">    b = struct.unpack(<span class=\"string\">'&lt;ccIIIIIIHH'</span>, f)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> b[<span class=\"number\">0</span>] == <span class=\"string\">'B'</span> <span class=\"keyword\">and</span> b[<span class=\"number\">1</span>] == <span class=\"string\">'M'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"size = %s * %s\"</span> % (b[<span class=\"number\">6</span>], b[<span class=\"number\">7</span>])</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"color = %s \"</span> % (b[-<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"it's not bmp!\"</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name_<span class=\"number\">_</span> == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    isbmp(<span class=\"string\">'1.bmp'</span>)</span><br><span class=\"line\">    isbmp(<span class=\"string\">\"1.jpg\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"hashlib\"><a href=\"#hashlib\" class=\"headerlink\" title=\"hashlib\"></a>hashlib</h2><p>摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。</p>\n<p>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</p>\n<p>什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p>\n<p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import hashlib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">md5</span> = hashlib.<span class=\"built_in\">md5</span>()</span><br><span class=\"line\"><span class=\"built_in\">md5</span>.<span class=\"keyword\">update</span>('how to use <span class=\"built_in\">md5</span> in python hashlib?')</span><br><span class=\"line\">print <span class=\"built_in\">md5</span>.hexdigest()</span><br></pre></td></tr></table></figure></p>\n<p>而SHA1也是其中一种算法，和调用MD5完全类似:<br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import hashlib</span><br><span class=\"line\"></span><br><span class=\"line\">sha1 = hashlib.sha1()</span><br><span class=\"line\">sha1.<span class=\"keyword\">update</span>('how to <span class=\"keyword\">use</span> sha1 <span class=\"keyword\">in</span> ')</span><br><span class=\"line\">sha1.<span class=\"keyword\">update</span>('python hashlib?')</span><br><span class=\"line\"><span class=\"keyword\">print</span> sha1.hexdigest()</span><br></pre></td></tr></table></figure></p>\n<p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法越慢，而且摘要长度更长。</p>\n<p>有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能。因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>这种用法常用于数据保密。如明文保存账户数据容易被黑客盗取，用户登录时，通过用户输入的口令来计算摘要，如果和存储的摘要一致，就可以认为是登录正确。</p>\n<p>存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。</p>\n<p>采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。</p>\n<p>考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：<br><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'e10adc<span class=\"number\">3949</span>ba59abbe56e057f20f883e': '<span class=\"number\">123456</span>'</span><br><span class=\"line\">'<span class=\"number\">2121</span>8cca<span class=\"number\">7780</span>4d2ba<span class=\"number\">1922</span>c33e<span class=\"number\">015110</span>5': '<span class=\"number\">888888</span>'</span><br><span class=\"line\">'5f4dcc3b5aa765d61d<span class=\"number\">8327</span>deb882cf99': 'password'</span><br></pre></td></tr></table></figure></p>\n<p>这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。</p>\n<p>对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？</p>\n<h3 id=\"加盐\"><a href=\"#加盐\" class=\"headerlink\" title=\"加盐\"></a>加盐</h3><p>由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc_md5</span><span class=\"params\">(password)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> get_md5(password + <span class=\"string\">'the-Salt'</span>)</span><br></pre></td></tr></table></figure>\n<p>经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。</p>\n<p>但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？</p>\n<p>如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。</p>\n<h3 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>1.设计一个验证用户登录小程序，根据用户输入的口令保存账号密码，亦可做登录检查。</p>\n<p>解：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">md5</span><span class=\"params\">(str)</span>:</span></span><br><span class=\"line\">    md = hashlib.md5()</span><br><span class=\"line\">    md.update(str)</span><br><span class=\"line\">    md_5 = md.hexdigest()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> md_5</span><br><span class=\"line\">dict_client = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    ty = raw_input(<span class=\"string\">\"欢迎使用用户登录系统...存储用户数据请按1，登录请按2，退出请按3\\n\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty ==<span class=\"string\">'1'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">        name_str = raw_input(<span class=\"string\">\"请输出用户名字：\\n\"</span>)</span><br><span class=\"line\">        keywords_str = raw_input(<span class=\"string\">\"请输入密码：\\n\"</span>)</span><br><span class=\"line\">        dict_client[name_str]=md5(keywords_str)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'MD5密码加密已完成...'</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> dict_client</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty ==<span class=\"string\">\"2\"</span>:</span><br><span class=\"line\">        name_str = raw_input(<span class=\"string\">\"请输出用户名字：\\n\"</span>)</span><br><span class=\"line\">        keywords_str = raw_input(<span class=\"string\">\"请输入密码：\\n\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dict_client[name_str]==md5(keywords_str):</span><br><span class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"welcome %s\"</span> %name_str</span><br><span class=\"line\">        <span class=\"keyword\">else</span> :</span><br><span class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"your keywords are wrong ! \"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty ==<span class=\"string\">\"3\"</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'BYE...'</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure></p>\n<p>2.根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5.<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">register</span><span class=\"params\">(username, password)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    db[username] = get_md5(password + username + <span class=\"string\">'the-Salt'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>然后，根据修改后的MD5算法实现用户登录的验证：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">login</span><span class=\"params\">(username, password)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>解法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">md5</span><span class=\"params\">(str)</span>:</span></span><br><span class=\"line\">    md = hashlib.md5()</span><br><span class=\"line\">    md.update(str)</span><br><span class=\"line\">    md_5 = md.hexdigest()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> md_5</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">register</span><span class=\"params\">(username, password)</span>:</span></span><br><span class=\"line\">    dict_client[username] = md5(password + username + <span class=\"string\">'the-Salt'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">login</span><span class=\"params\">(username, password)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> dict_client[username] == md5(password + username + <span class=\"string\">'the-Salt'</span>):</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"welcome %s\"</span> % username</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"your keywords are wrong ! \"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">dict_client = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    ty = raw_input(<span class=\"string\">\"欢迎使用用户登录系统...存储用户数据请按1，登录请按2，退出请按3\\n\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty == <span class=\"string\">'1'</span>:</span><br><span class=\"line\">        name_str = raw_input(<span class=\"string\">\"请输出用户名字：\\n\"</span>)</span><br><span class=\"line\">        keywords_str = raw_input(<span class=\"string\">\"请输入密码：\\n\"</span>)</span><br><span class=\"line\">        register(name_str, keywords_str)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'MD5密码加密已完成...'</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> dict_client</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty == <span class=\"string\">\"2\"</span>:</span><br><span class=\"line\">        name_str = raw_input(<span class=\"string\">\"请输出用户名字：\\n\"</span>)</span><br><span class=\"line\">        keywords_str = raw_input(<span class=\"string\">\"请输入密码：\\n\"</span>)</span><br><span class=\"line\">        login(name_str,keywords_str)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty == <span class=\"string\">\"3\"</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'BYE...'</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"itertools\"><a href=\"#itertools\" class=\"headerlink\" title=\"itertools\"></a>itertools</h2><p><code>itertools</code>提供了非常有用的用于操作迭代对象的函数。</p>\n<h3 id=\"count\"><a href=\"#count\" class=\"headerlink\" title=\"count\"></a>count</h3><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">natuals = itertools.count(1,2)</span><br><span class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> natuals:</span><br><span class=\"line\">    <span class=\"builtin-name\">print</span> n</span><br></pre></td></tr></table></figure>\n<p>返回一个从第一个参数1开始的连续值，可以设置第二个参数<code>step</code>步长。</p>\n<h3 id=\"cycle\"><a href=\"#cycle\" class=\"headerlink\" title=\"cycle()\"></a>cycle()</h3><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">cs</span> = itertools.cycle(<span class=\"string\">\"ABCD\"</span>)</span><br></pre></td></tr></table></figure>\n<p>Return elements from the iterable until it is exhausted.<br>当然。电脑不会精疲力竭，将传入的序列无限重复下去。</p>\n<h3 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat()\"></a>repeat()</h3><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">ns</span> = itertools.repeat(<span class=\"string\">'A'</span>, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>repeat(object [,times]) -&gt; create an iterator which returns the object<br>for the specified number of times.  If not specified, returns the object<br>endlessly.</p>\n<p>负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数,不提供，同样无穷重复。</p>\n<h3 id=\"takewhile\"><a href=\"#takewhile\" class=\"headerlink\" title=\"takewhile()\"></a>takewhile()</h3><p>无限序列虽然可以无限迭代下去，但是通常我们会通过<code>takewhile()</code>等函数根据条件判断来截取一个有限序列。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itertools</span><br><span class=\"line\"></span><br><span class=\"line\">ns = itertools.<span class=\"built_in\">count</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">n = itertools.takewhile(lambda x: x &lt;= <span class=\"number\">10</span>, ns)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> n:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> i</span><br></pre></td></tr></table></figure>\n<p><code>itertools</code>提供的几个迭代器操作函数更加有用：</p>\n<h3 id=\"chain\"><a href=\"#chain\" class=\"headerlink\" title=\"chain()\"></a>chain()</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> itertools.chain(<span class=\"string\">'ABC'</span>, <span class=\"string\">'XYZ'</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> c</span><br></pre></td></tr></table></figure>\n<p>加强版的<code>cycle</code>，可以将一组迭代对象串联起来，形成一个更大的迭代器。</p>\n<h3 id=\"groupby\"><a href=\"#groupby\" class=\"headerlink\" title=\"groupby()\"></a>groupby()</h3><p>把迭代器中相邻的重复元素挑出来放在一起。</p>\n<p>实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key,第二个参数用来筛选规则例如可以忽略大小写。<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">key</span>, <span class=\"keyword\">group</span> <span class=\"keyword\">in</span> itertools.groupby(<span class=\"comment\">'AAABBBbCCAAAaaa',lambda a:a.upper()):</span></span><br><span class=\"line\">    print <span class=\"keyword\">key</span>, list(<span class=\"keyword\">group</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"imap\"><a href=\"#imap\" class=\"headerlink\" title=\"imap()\"></a>imap()</h3><p><code>imap()</code>和<code>map()</code>的区别在于，<code>imap()</code>可以作用于无穷序列，并且，如果两个序列的长度不一致，以短的那个为准。<br>长与短序列对应相乘。<br><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> itertools.imap(<span class=\"built_in\">lambda</span> x, y: x * y, [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>], itertools.count(<span class=\"number\">1</span>)):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> x</span><br><span class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> itertools.imap(<span class=\"built_in\">lambda</span> x:x*x,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> n</span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>imap()</code>返回一个迭代对象，而<code>map()</code>返回一个list，当你调用map事，已经计算完毕。而当你调用imap时，并没有进行任何计算。必须用for循环对其进行迭代，才会在每次循环过程中计算出下一个元素。</p>\n<p>换种说法，<code>imap()</code>是<code>map()</code>的惰性实现。</p>\n<p>同理，ifilter()就是filter()的惰性实现。<br>还有islice()，也是slice()的惰性实现。</p>\n<h2 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h2><p>XML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。</p>\n<h3 id=\"DOM-vs-SAX\"><a href=\"#DOM-vs-SAX\" class=\"headerlink\" title=\"DOM vs SAX\"></a>DOM vs SAX</h3><p>操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p>\n<p>正常情况下，优先考虑SAX，因为DOM实在太占内存。</p>\n<p>在Python中使用SAX解析XML非常简洁，通常我们关心的事件是<code>start_element</code>，<code>end_element</code>和<code>char_data</code>，准备好这3个函数，然后就可以解析xml了。</p>\n<p>举个例子，当SAX解析器读到一个节点时：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/\"</span>&gt;</span>python<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>会产生3个事件：<br>1.start_element事件，在读取<a href=\"/\">时；<br>2.char_data事件，在读取python时；<br>3.end_element事件，在读取</a>时。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> xml.parsers.expat <span class=\"keyword\">import</span> ParserCreate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultSaxHandler</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start_element</span><span class=\"params\">(self, name, attrs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'sax:start_element: %s, attrs: %s'</span> % (name, str(attrs)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">end_element</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'sax:end_element: %s'</span> % name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">char_data</span><span class=\"params\">(self, text)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'sax:char_data: %s'</span> % text)</span><br><span class=\"line\"></span><br><span class=\"line\">xml = <span class=\"string\">r'''&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;ol&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;li&gt;&lt;a href=\"/python\"&gt;Python&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;li&gt;&lt;a href=\"/ruby\"&gt;Ruby&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/ol&gt;</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\">handler = DefaultSaxHandler()</span><br><span class=\"line\">parser = ParserCreate()</span><br><span class=\"line\">parser.returns_unicode = <span class=\"keyword\">True</span></span><br><span class=\"line\">parser.StartElementHandler = handler.start_element</span><br><span class=\"line\">parser.EndElementHandler = handler.end_element</span><br><span class=\"line\">parser.CharacterDataHandler = handler.char_data</span><br><span class=\"line\">parser.Parse(xml)</span><br></pre></td></tr></table></figure>\n<p>而生成XML可以使用<code>append()</code>和<code>join()</code>拼接字符串的方式。</p>\n<p>如果生成复杂的XML呢？建议你不要用XML，改成JSON。</p>\n<h2 id=\"HTMLParser\"><a href=\"#HTMLParser\" class=\"headerlink\" title=\"HTMLParser\"></a>HTMLParser</h2><p>一个便于解析HTML的模块。</p>\n<p>如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。</p>\n<p>假设第一步已经完成了，第二步应该如何解析HTML呢？</p>\n<p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> HTMLParser <span class=\"keyword\">import</span> HTMLParser</span><br><span class=\"line\"><span class=\"keyword\">from</span> htmlentitydefs <span class=\"keyword\">import</span> name2codepoint</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHTMLParser</span><span class=\"params\">(HTMLParser)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_starttag</span><span class=\"params\">(self, tag, attrs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&lt;%s&gt;'</span> % tag)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_endtag</span><span class=\"params\">(self, tag)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&lt;/%s&gt;'</span> % tag)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_startendtag</span><span class=\"params\">(self, tag, attrs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&lt;%s/&gt;'</span> % tag)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_data</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'data'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_comment</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&lt;!-- --&gt;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_entityref</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&amp;%s;'</span> % name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_charref</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&amp;#%s;'</span> % name)</span><br><span class=\"line\"></span><br><span class=\"line\">parser = MyHTMLParser()</span><br><span class=\"line\">parser.feed(<span class=\"string\">'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Some &lt;a href=\\\"#\\\"&gt;html&lt;/a&gt; tutorial...&lt;br&gt;END&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span>)</span><br></pre></td></tr></table></figure></p>\n<p><code>feed()</code>方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。</p>\n<p>特殊字符有两种，一种是英文表示的<code>&amp;nbsp;</code>（占位符），一种是数字表示的<code>&amp;#1234;</code>，这两种字符都可以通过Parser解析出来。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>和官方文档的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>Python之所以自称“batteries included”，就是因为内置了许多非常有用的模块，无需额外安装和配置，即可直接使用。下面来介绍一下。</p>\n<h2 id=\"collections\"><a href=\"#collections\" class=\"headerlink\" title=\"collections\"></a>collections</h2><p>collections是Python内建的一个集合模块，提供许多有用的集合类。<br></p>","more":"<p></p>\n<h3 id=\"namedtuple\"><a href=\"#namedtuple\" class=\"headerlink\" title=\"namedtuple\"></a>namedtuple</h3><p>在之前的学习中我们知道tuple可以表示不变集合，例如，一个点的二维坐标就可以表示成<code>p = (1, 2)</code>,但是光光看到这个<code>(1,2)</code>，很难看出是用来表示一个坐标的。<br>定义一个class又小题大做。</p>\n<p>这时，我们需要用到<code>namedtuple</code>：<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> namedtuple</span><br><span class=\"line\">Point = namedtuple(<span class=\"string\">'Point'</span>, [<span class=\"string\">'x'</span>, <span class=\"string\">'y'</span>])</span><br><span class=\"line\">p = Point(<span class=\"number\">1</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">p.x</span><br><span class=\"line\"># <span class=\"number\">1</span></span><br><span class=\"line\">p.y</span><br><span class=\"line\"># <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p><code>namedtuple</code>是一个函数，用来创建一个自定义的<code>tuple</code>对象，并且规定了<code>tuple</code>元素的个数，并可以用属性而不是索引来引用<code>tuple</code>的某个元素。</p>\n<p>这样一来，我们用<code>namedtuple</code>可以很方便地定义一种数据类型，它具备tuple的不变性，又可以根据属性来引用，使用十分方便。</p>\n<p>输入<code>help(namedtuple)</code>你会发现，<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; d = p._asdict()                 <span class=\"comment\"># convert to a dictionary</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; d[<span class=\"string\">'x'</span>]</span><br><span class=\"line\"><span class=\"number\">11</span></span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; Point(**d)                      <span class=\"comment\"># convert from a dictionary</span></span><br><span class=\"line\">Point(x=<span class=\"number\">11</span>, y=<span class=\"number\">22</span>)</span><br><span class=\"line\"><span class=\"meta\">&gt;&gt;</span>&gt; p._replace(x=<span class=\"number\">100</span>)               <span class=\"comment\"># _replace() is like str.replace() but targets named fields</span></span><br><span class=\"line\">Point(x=<span class=\"number\">100</span>, y=<span class=\"number\">22</span>)</span><br></pre></td></tr></table></figure></p>\n<p>在帮助文档中，也提供了tuple转字典的方法，以及一些替换的方法。</p>\n<h3 id=\"deque\"><a href=\"#deque\" class=\"headerlink\" title=\"deque\"></a>deque</h3><p>之前在学习的时候已经碰到了这个函数，看了下官方解释：</p>\n<figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deque([iterable[, maxlen]])</span><br><span class=\"line\"><span class=\"keyword\">Build</span> an ordered <span class=\"keyword\">collection</span> <span class=\"keyword\">with</span> optimized access <span class=\"keyword\">from</span> its endpoints.</span><br></pre></td></tr></table></figure>\n<p>建立一个从两个端点进行优化的有序集合。</p>\n<p>简而言之，是一个可以设置最大长度的队列或堆，优点是<code>deque</code>除了实现list的append()和pop()外，还支持appendleft()和popleft()，这样就可以非常高效地往头部添加或删除元素；此外，还可以用来取最近的几条数据，后来的数据会顶开早些的数据。</p>\n<h3 id=\"defaultdict\"><a href=\"#defaultdict\" class=\"headerlink\" title=\"defaultdict\"></a>defaultdict</h3><p>与<code>dict</code>相比，不同之处在于如果key不存在时，返回一个默认值。<br>注意：默认值是调用函数返回的，而函数在创建<code>defaultdict</code>对象时传入。<br><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">dd</span> = defaultdict(lambda: <span class=\"string\">'N/A'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>除了在<code>Key</code>不存在时返回默认值，<code>defaultdict</code>的其他行为跟<code>dict</code>是完全一样的。</p>\n<h3 id=\"OrderedDict\"><a href=\"#OrderedDict\" class=\"headerlink\" title=\"OrderedDict\"></a>OrderedDict</h3><p>正如名字所言，有序字典。他的有序指的是Key会按照插入的顺序排列，不是Key本身排序。</p>\n<h3 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h3><p>Counter是一个简单的计数器，例如，统计字符出现的个数：<br><figure class=\"highlight clean\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> collections <span class=\"keyword\">import</span> Counter</span><br><span class=\"line\">c = Counter()</span><br><span class=\"line\">for ch <span class=\"keyword\">in</span> <span class=\"string\">'programming'</span>:</span><br><span class=\"line\">...     c[ch] = c[ch] + <span class=\"number\">1</span></span><br><span class=\"line\">...</span><br><span class=\"line\">c</span><br><span class=\"line\">#Counter(&#123;<span class=\"string\">'g'</span>: <span class=\"number\">2</span>, <span class=\"string\">'m'</span>: <span class=\"number\">2</span>, <span class=\"string\">'r'</span>: <span class=\"number\">2</span>, <span class=\"string\">'a'</span>: <span class=\"number\">1</span>, <span class=\"string\">'i'</span>: <span class=\"number\">1</span>, <span class=\"string\">'o'</span>: <span class=\"number\">1</span>, <span class=\"string\">'n'</span>: <span class=\"number\">1</span>, <span class=\"string\">'p'</span>: <span class=\"number\">1</span>&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>Counter实际上也是dict的一个子类。</p>\n<h2 id=\"base64\"><a href=\"#base64\" class=\"headerlink\" title=\"base64\"></a>base64</h2><p>Base64是一种任意二进制到文本字符串的编码方法，常用于在URL、Cookie、网页中传输少量二进制数据。</p>\n<h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><p>首先，准备一个包含64个字符的数组：<br><figure class=\"highlight scheme\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[<span class=\"symbol\">'A</span>', <span class=\"symbol\">'B</span>', <span class=\"symbol\">'C</span>', ... <span class=\"symbol\">'a</span>', <span class=\"symbol\">'b</span>', <span class=\"symbol\">'c</span>', ... <span class=\"symbol\">'0</span>', <span class=\"symbol\">'1</span>', ... <span class=\"symbol\">'+</span>', <span class=\"symbol\">'/</span>']</span><br></pre></td></tr></table></figure></p>\n<p>然后，对二进制数据进行处理，每3个字节一组，一共是3x8=24bit，划为4组，每组正好6个bit,也就是2^6,64个字符相对应。</p>\n<p>这样我们得到4个数字作为索引，然后查表，获得相应的4个字符，就是编码后的字符串。</p>\n<p>Base64编码会把3字节的二进制数据编码为4字节的文本数据，长度增加33%，好处是编码后的文本数据可以在邮件正文、网页等直接显示。</p>\n<p>如果要编码的二进制数据不是3的倍数，最后会剩下1个或2个字节怎么办？Base64用\\x00字节在末尾补足后，再在编码的末尾加上1个或2个=号，表示补了多少字节，解码的时候，会自动去掉。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import <span class=\"built_in\">base64</span></span><br><span class=\"line\"><span class=\"built_in\">base64</span>.b64encode('binary\\x00string')</span><br><span class=\"line\"># 对于在URL，有一种<span class=\"string\">\"url safe\"</span>的<span class=\"built_in\">base64</span>编码，</span><br><span class=\"line\"># 把字符+和/分别变成-和<span class=\"symbol\">_</span>，防止搞混</span><br><span class=\"line\"><span class=\"built_in\">base64</span>.urlsafe_b64decode('abcd--<span class=\"symbol\">__</span>')</span><br></pre></td></tr></table></figure>\n<p>由于<code>=</code>字符也可能出现在Base64编码中，但<code>=</code>用在URL、Cookie里面会造成歧义，所以，很多Base64编码后会把<code>=</code>去掉,但在解码的时候，我们需要把<code>=</code>加上。<br><figure class=\"highlight axapta\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def b64decode_self(<span class=\"keyword\">str</span>):</span><br><span class=\"line\">    <span class=\"keyword\">return</span> base64.b64decode(<span class=\"keyword\">str</span>+<span class=\"string\">'='</span>*(<span class=\"number\">4</span>-len(<span class=\"keyword\">str</span>)%<span class=\"number\">4</span>))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"struct\"><a href=\"#struct\" class=\"headerlink\" title=\"struct\"></a>struct</h2><p>用来解决str和其他二进制数据类型的转换。</p>\n<p><code>struct</code>的<code>pack</code>函数把任意数据类型变成字符串。<br><figure class=\"highlight crystal\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span>.<span class=\"title\">pack</span>('&gt;<span class=\"title\">I</span>', 10240099)</span></span><br><span class=\"line\"><span class=\"comment\"># '\\x00\\x9c@c'</span></span><br></pre></td></tr></table></figure></p>\n<p>pack的第一个参数是处理指令，’&gt;I’的意思是：</p>\n<p><code>&gt;</code>表示字节顺序是big-endian，大端字节序也就是网络序，高字节存于内存低地址；低字节存于内存高地址。I表示4字节无符号整数。</p>\n<p><code>unpack</code>把<code>str</code>变成相应的数据类型：<br><figure class=\"highlight taggerscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> struct.unpack('&gt;IH', '<span class=\"symbol\">\\x</span>f0<span class=\"symbol\">\\x</span>f0<span class=\"symbol\">\\x</span>f0<span class=\"symbol\">\\x</span>f0<span class=\"symbol\">\\x</span>80<span class=\"symbol\">\\x</span>80')</span><br><span class=\"line\">(4042322160, 32896)</span><br></pre></td></tr></table></figure></p>\n<p>具体处理指令可用<code>help</code>来查看。</p>\n<p>下面我们用<code>struct</code>分析一下bmp格式。<br>首先找一个<code>bmp</code>文件，没有的话用“画图”画一个。<br>读入前30个字节来分析。</p>\n<p>BMP格式采用小端方式存储数据，文件头的结构按顺序如下：</p>\n<p>两个字节：’BM’表示<code>Windows</code>位图，’BA’表示OS/2位图；<br>一个4字节整数：表示位图大小；<br>一个4字节整数：保留位，始终为0；<br>一个4字节整数：实际图像的偏移量；<br>一个4字节整数：Header的字节数；<br>一个4字节整数：图像宽度；<br>一个4字节整数：图像高度；<br>一个2字节整数：始终为1；<br>一个2字节整数：颜色数。</p>\n<p>所以，组合起来用unpack读取：<br><figure class=\"highlight lsl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct.unpack('&lt;ccIIIIIIHH', s)</span><br><span class=\"line\">('B', 'M', <span class=\"number\">691256</span>, <span class=\"number\">0</span>, <span class=\"number\">54</span>, <span class=\"number\">40</span>, <span class=\"number\">640</span>, <span class=\"number\">360</span>, <span class=\"number\">1</span>, <span class=\"number\">24</span>)</span><br></pre></td></tr></table></figure></p>\n<p>结果显示，’B’、’M’说明是Windows位图，位图大小为640x360，颜色数为24。</p>\n<h3 id=\"练习\"><a href=\"#练习\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>请编写一个bmpinfo.py，可以检查任意文件是否是位图文件，如果是，打印出图片大小和颜色数。<br><figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import struct</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">def isbmp(<span class=\"keyword\">s</span>):</span><br><span class=\"line\">    f = <span class=\"keyword\">open</span>(<span class=\"keyword\">s</span>, <span class=\"string\">'rb'</span>).read(<span class=\"number\">30</span>)</span><br><span class=\"line\">    b = struct.unpack(<span class=\"string\">'&lt;ccIIIIIIHH'</span>, f)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> b[<span class=\"number\">0</span>] == <span class=\"string\">'B'</span> <span class=\"keyword\">and</span> b[<span class=\"number\">1</span>] == <span class=\"string\">'M'</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"size = %s * %s\"</span> % (b[<span class=\"number\">6</span>], b[<span class=\"number\">7</span>])</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"color = %s \"</span> % (b[-<span class=\"number\">1</span>])</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"it's not bmp!\"</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name_<span class=\"number\">_</span> == <span class=\"string\">'__main__'</span>:</span><br><span class=\"line\">    isbmp(<span class=\"string\">'1.bmp'</span>)</span><br><span class=\"line\">    isbmp(<span class=\"string\">\"1.jpg\"</span>)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"hashlib\"><a href=\"#hashlib\" class=\"headerlink\" title=\"hashlib\"></a>hashlib</h2><p>摘要算法在很多地方都有广泛的应用。要注意摘要算法不是加密算法，不能用于加密（因为无法通过摘要反推明文），只能用于防篡改，但是它的单向计算特性决定了可以在不存储明文口令的情况下验证用户口令。</p>\n<p>Python的hashlib提供了常见的摘要算法，如MD5，SHA1等等。</p>\n<p>什么是摘要算法呢？摘要算法又称哈希算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p>\n<p>MD5是最常见的摘要算法，速度很快，生成结果是固定的128 bit字节，通常用一个32位的16进制字符串表示。<br><figure class=\"highlight q\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import hashlib</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">md5</span> = hashlib.<span class=\"built_in\">md5</span>()</span><br><span class=\"line\"><span class=\"built_in\">md5</span>.<span class=\"keyword\">update</span>('how to use <span class=\"built_in\">md5</span> in python hashlib?')</span><br><span class=\"line\">print <span class=\"built_in\">md5</span>.hexdigest()</span><br></pre></td></tr></table></figure></p>\n<p>而SHA1也是其中一种算法，和调用MD5完全类似:<br><figure class=\"highlight stata\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import hashlib</span><br><span class=\"line\"></span><br><span class=\"line\">sha1 = hashlib.sha1()</span><br><span class=\"line\">sha1.<span class=\"keyword\">update</span>('how to <span class=\"keyword\">use</span> sha1 <span class=\"keyword\">in</span> ')</span><br><span class=\"line\">sha1.<span class=\"keyword\">update</span>('python hashlib?')</span><br><span class=\"line\"><span class=\"keyword\">print</span> sha1.hexdigest()</span><br></pre></td></tr></table></figure></p>\n<p>比SHA1更安全的算法是SHA256和SHA512，不过越安全的算法越慢，而且摘要长度更长。</p>\n<p>有没有可能两个不同的数据通过某个摘要算法得到了相同的摘要？完全有可能。因为任何摘要算法都是把无限多的数据集合映射到一个有限的集合中。这种情况称为碰撞。</p>\n<h3 id=\"应用\"><a href=\"#应用\" class=\"headerlink\" title=\"应用\"></a>应用</h3><p>这种用法常用于数据保密。如明文保存账户数据容易被黑客盗取，用户登录时，通过用户输入的口令来计算摘要，如果和存储的摘要一致，就可以认为是登录正确。</p>\n<p>存储MD5的好处是即使运维人员能访问数据库，也无法获知用户的明文口令。</p>\n<p>采用MD5存储口令是否就一定安全呢？也不一定。假设你是一个黑客，已经拿到了存储MD5口令的数据库，如何通过MD5反推用户的明文口令呢？暴力破解费事费力，真正的黑客不会这么干。</p>\n<p>考虑这么个情况，很多用户喜欢用123456，888888，password这些简单的口令，于是，黑客可以事先计算出这些常用口令的MD5值，得到一个反推表：<br><figure class=\"highlight 1c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">'e10adc<span class=\"number\">3949</span>ba59abbe56e057f20f883e': '<span class=\"number\">123456</span>'</span><br><span class=\"line\">'<span class=\"number\">2121</span>8cca<span class=\"number\">7780</span>4d2ba<span class=\"number\">1922</span>c33e<span class=\"number\">015110</span>5': '<span class=\"number\">888888</span>'</span><br><span class=\"line\">'5f4dcc3b5aa765d61d<span class=\"number\">8327</span>deb882cf99': 'password'</span><br></pre></td></tr></table></figure></p>\n<p>这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。</p>\n<p>对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？</p>\n<h3 id=\"加盐\"><a href=\"#加盐\" class=\"headerlink\" title=\"加盐\"></a>加盐</h3><p>由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">calc_md5</span><span class=\"params\">(password)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> get_md5(password + <span class=\"string\">'the-Salt'</span>)</span><br></pre></td></tr></table></figure>\n<p>经过Salt处理的MD5口令，只要Salt不被黑客知道，即使用户输入简单口令，也很难通过MD5反推明文口令。</p>\n<p>但是如果有两个用户都使用了相同的简单口令比如123456，在数据库中，将存储两条相同的MD5值，这说明这两个用户的口令是一样的。有没有办法让使用相同口令的用户存储不同的MD5呢？</p>\n<p>如果假定用户无法修改登录名，就可以通过把登录名作为Salt的一部分来计算MD5，从而实现相同口令的用户也存储不同的MD5。</p>\n<h3 id=\"练习-1\"><a href=\"#练习-1\" class=\"headerlink\" title=\"练习\"></a>练习</h3><p>1.设计一个验证用户登录小程序，根据用户输入的口令保存账号密码，亦可做登录检查。</p>\n<p>解：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">md5</span><span class=\"params\">(str)</span>:</span></span><br><span class=\"line\">    md = hashlib.md5()</span><br><span class=\"line\">    md.update(str)</span><br><span class=\"line\">    md_5 = md.hexdigest()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> md_5</span><br><span class=\"line\">dict_client = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    ty = raw_input(<span class=\"string\">\"欢迎使用用户登录系统...存储用户数据请按1，登录请按2，退出请按3\\n\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty ==<span class=\"string\">'1'</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">        name_str = raw_input(<span class=\"string\">\"请输出用户名字：\\n\"</span>)</span><br><span class=\"line\">        keywords_str = raw_input(<span class=\"string\">\"请输入密码：\\n\"</span>)</span><br><span class=\"line\">        dict_client[name_str]=md5(keywords_str)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'MD5密码加密已完成...'</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> dict_client</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty ==<span class=\"string\">\"2\"</span>:</span><br><span class=\"line\">        name_str = raw_input(<span class=\"string\">\"请输出用户名字：\\n\"</span>)</span><br><span class=\"line\">        keywords_str = raw_input(<span class=\"string\">\"请输入密码：\\n\"</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> dict_client[name_str]==md5(keywords_str):</span><br><span class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"welcome %s\"</span> %name_str</span><br><span class=\"line\">        <span class=\"keyword\">else</span> :</span><br><span class=\"line\">            <span class=\"keyword\">print</span> <span class=\"string\">\"your keywords are wrong ! \"</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty ==<span class=\"string\">\"3\"</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'BYE...'</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure></p>\n<p>2.根据用户输入的登录名和口令模拟用户注册，计算更安全的MD5.<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">db = &#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">register</span><span class=\"params\">(username, password)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">    db[username] = get_md5(password + username + <span class=\"string\">'the-Salt'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>然后，根据修改后的MD5算法实现用户登录的验证：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">login</span><span class=\"params\">(username, password)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure></p>\n<p>解法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">md5</span><span class=\"params\">(str)</span>:</span></span><br><span class=\"line\">    md = hashlib.md5()</span><br><span class=\"line\">    md.update(str)</span><br><span class=\"line\">    md_5 = md.hexdigest()</span><br><span class=\"line\">    <span class=\"keyword\">return</span> md_5</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">register</span><span class=\"params\">(username, password)</span>:</span></span><br><span class=\"line\">    dict_client[username] = md5(password + username + <span class=\"string\">'the-Salt'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">login</span><span class=\"params\">(username, password)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> dict_client[username] == md5(password + username + <span class=\"string\">'the-Salt'</span>):</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"welcome %s\"</span> % username</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"your keywords are wrong ! \"</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">dict_client = &#123;&#125;</span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    ty = raw_input(<span class=\"string\">\"欢迎使用用户登录系统...存储用户数据请按1，登录请按2，退出请按3\\n\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty == <span class=\"string\">'1'</span>:</span><br><span class=\"line\">        name_str = raw_input(<span class=\"string\">\"请输出用户名字：\\n\"</span>)</span><br><span class=\"line\">        keywords_str = raw_input(<span class=\"string\">\"请输入密码：\\n\"</span>)</span><br><span class=\"line\">        register(name_str, keywords_str)</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'MD5密码加密已完成...'</span></span><br><span class=\"line\">        <span class=\"keyword\">print</span> dict_client</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty == <span class=\"string\">\"2\"</span>:</span><br><span class=\"line\">        name_str = raw_input(<span class=\"string\">\"请输出用户名字：\\n\"</span>)</span><br><span class=\"line\">        keywords_str = raw_input(<span class=\"string\">\"请输入密码：\\n\"</span>)</span><br><span class=\"line\">        login(name_str,keywords_str)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ty == <span class=\"string\">\"3\"</span>:</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">'BYE...'</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"itertools\"><a href=\"#itertools\" class=\"headerlink\" title=\"itertools\"></a>itertools</h2><p><code>itertools</code>提供了非常有用的用于操作迭代对象的函数。</p>\n<h3 id=\"count\"><a href=\"#count\" class=\"headerlink\" title=\"count\"></a>count</h3><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">natuals = itertools.count(1,2)</span><br><span class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> natuals:</span><br><span class=\"line\">    <span class=\"builtin-name\">print</span> n</span><br></pre></td></tr></table></figure>\n<p>返回一个从第一个参数1开始的连续值，可以设置第二个参数<code>step</code>步长。</p>\n<h3 id=\"cycle\"><a href=\"#cycle\" class=\"headerlink\" title=\"cycle()\"></a>cycle()</h3><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">cs</span> = itertools.cycle(<span class=\"string\">\"ABCD\"</span>)</span><br></pre></td></tr></table></figure>\n<p>Return elements from the iterable until it is exhausted.<br>当然。电脑不会精疲力竭，将传入的序列无限重复下去。</p>\n<h3 id=\"repeat\"><a href=\"#repeat\" class=\"headerlink\" title=\"repeat()\"></a>repeat()</h3><figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">ns</span> = itertools.repeat(<span class=\"string\">'A'</span>, <span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<p>repeat(object [,times]) -&gt; create an iterator which returns the object<br>for the specified number of times.  If not specified, returns the object<br>endlessly.</p>\n<p>负责把一个元素无限重复下去，不过如果提供第二个参数就可以限定重复次数,不提供，同样无穷重复。</p>\n<h3 id=\"takewhile\"><a href=\"#takewhile\" class=\"headerlink\" title=\"takewhile()\"></a>takewhile()</h3><p>无限序列虽然可以无限迭代下去，但是通常我们会通过<code>takewhile()</code>等函数根据条件判断来截取一个有限序列。</p>\n<figure class=\"highlight swift\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> itertools</span><br><span class=\"line\"></span><br><span class=\"line\">ns = itertools.<span class=\"built_in\">count</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">n = itertools.takewhile(lambda x: x &lt;= <span class=\"number\">10</span>, ns)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> n:</span><br><span class=\"line\">    <span class=\"built_in\">print</span> i</span><br></pre></td></tr></table></figure>\n<p><code>itertools</code>提供的几个迭代器操作函数更加有用：</p>\n<h3 id=\"chain\"><a href=\"#chain\" class=\"headerlink\" title=\"chain()\"></a>chain()</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> c <span class=\"keyword\">in</span> itertools.chain(<span class=\"string\">'ABC'</span>, <span class=\"string\">'XYZ'</span>):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> c</span><br></pre></td></tr></table></figure>\n<p>加强版的<code>cycle</code>，可以将一组迭代对象串联起来，形成一个更大的迭代器。</p>\n<h3 id=\"groupby\"><a href=\"#groupby\" class=\"headerlink\" title=\"groupby()\"></a>groupby()</h3><p>把迭代器中相邻的重复元素挑出来放在一起。</p>\n<p>实际上挑选规则是通过函数完成的，只要作用于函数的两个元素返回的值相等，这两个元素就被认为是在一组的，而函数返回值作为组的key,第二个参数用来筛选规则例如可以忽略大小写。<br><figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> <span class=\"keyword\">key</span>, <span class=\"keyword\">group</span> <span class=\"keyword\">in</span> itertools.groupby(<span class=\"comment\">'AAABBBbCCAAAaaa',lambda a:a.upper()):</span></span><br><span class=\"line\">    print <span class=\"keyword\">key</span>, list(<span class=\"keyword\">group</span>)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"imap\"><a href=\"#imap\" class=\"headerlink\" title=\"imap()\"></a>imap()</h3><p><code>imap()</code>和<code>map()</code>的区别在于，<code>imap()</code>可以作用于无穷序列，并且，如果两个序列的长度不一致，以短的那个为准。<br>长与短序列对应相乘。<br><figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> itertools.imap(<span class=\"built_in\">lambda</span> x, y: x * y, [<span class=\"number\">10</span>, <span class=\"number\">20</span>, <span class=\"number\">30</span>], itertools.count(<span class=\"number\">1</span>)):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> x</span><br><span class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> itertools.imap(<span class=\"built_in\">lambda</span> x:x*x,[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]):</span><br><span class=\"line\">    <span class=\"built_in\">print</span> n</span><br></pre></td></tr></table></figure></p>\n<p>注意，<code>imap()</code>返回一个迭代对象，而<code>map()</code>返回一个list，当你调用map事，已经计算完毕。而当你调用imap时，并没有进行任何计算。必须用for循环对其进行迭代，才会在每次循环过程中计算出下一个元素。</p>\n<p>换种说法，<code>imap()</code>是<code>map()</code>的惰性实现。</p>\n<p>同理，ifilter()就是filter()的惰性实现。<br>还有islice()，也是slice()的惰性实现。</p>\n<h2 id=\"XML\"><a href=\"#XML\" class=\"headerlink\" title=\"XML\"></a>XML</h2><p>XML虽然比JSON复杂，在Web中应用也不如以前多了，不过仍有很多地方在用，所以，有必要了解如何操作XML。</p>\n<h3 id=\"DOM-vs-SAX\"><a href=\"#DOM-vs-SAX\" class=\"headerlink\" title=\"DOM vs SAX\"></a>DOM vs SAX</h3><p>操作XML有两种方法：DOM和SAX。DOM会把整个XML读入内存，解析为树，因此占用内存大，解析慢，优点是可以任意遍历树的节点。SAX是流模式，边读边解析，占用内存小，解析快，缺点是我们需要自己处理事件。</p>\n<p>正常情况下，优先考虑SAX，因为DOM实在太占内存。</p>\n<p>在Python中使用SAX解析XML非常简洁，通常我们关心的事件是<code>start_element</code>，<code>end_element</code>和<code>char_data</code>，准备好这3个函数，然后就可以解析xml了。</p>\n<p>举个例子，当SAX解析器读到一个节点时：<br><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">a</span> <span class=\"attr\">href</span>=<span class=\"string\">\"/\"</span>&gt;</span>python<span class=\"tag\">&lt;/<span class=\"name\">a</span>&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>会产生3个事件：<br>1.start_element事件，在读取<a href=\"/\">时；<br>2.char_data事件，在读取python时；<br>3.end_element事件，在读取</a>时。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> xml.parsers.expat <span class=\"keyword\">import</span> ParserCreate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DefaultSaxHandler</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">start_element</span><span class=\"params\">(self, name, attrs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'sax:start_element: %s, attrs: %s'</span> % (name, str(attrs)))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">end_element</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'sax:end_element: %s'</span> % name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">char_data</span><span class=\"params\">(self, text)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'sax:char_data: %s'</span> % text)</span><br><span class=\"line\"></span><br><span class=\"line\">xml = <span class=\"string\">r'''&lt;?xml version=\"1.0\"?&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;ol&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;li&gt;&lt;a href=\"/python\"&gt;Python&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">    &lt;li&gt;&lt;a href=\"/ruby\"&gt;Ruby&lt;/a&gt;&lt;/li&gt;</span></span><br><span class=\"line\"><span class=\"string\">&lt;/ol&gt;</span></span><br><span class=\"line\"><span class=\"string\">'''</span></span><br><span class=\"line\">handler = DefaultSaxHandler()</span><br><span class=\"line\">parser = ParserCreate()</span><br><span class=\"line\">parser.returns_unicode = <span class=\"keyword\">True</span></span><br><span class=\"line\">parser.StartElementHandler = handler.start_element</span><br><span class=\"line\">parser.EndElementHandler = handler.end_element</span><br><span class=\"line\">parser.CharacterDataHandler = handler.char_data</span><br><span class=\"line\">parser.Parse(xml)</span><br></pre></td></tr></table></figure>\n<p>而生成XML可以使用<code>append()</code>和<code>join()</code>拼接字符串的方式。</p>\n<p>如果生成复杂的XML呢？建议你不要用XML，改成JSON。</p>\n<h2 id=\"HTMLParser\"><a href=\"#HTMLParser\" class=\"headerlink\" title=\"HTMLParser\"></a>HTMLParser</h2><p>一个便于解析HTML的模块。</p>\n<p>如果我们要编写一个搜索引擎，第一步是用爬虫把目标网站的页面抓下来，第二步就是解析该HTML页面，看看里面的内容到底是新闻、图片还是视频。</p>\n<p>假设第一步已经完成了，第二步应该如何解析HTML呢？</p>\n<p>HTML本质上是XML的子集，但是HTML的语法没有XML那么严格，所以不能用标准的DOM或SAX来解析HTML。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> HTMLParser <span class=\"keyword\">import</span> HTMLParser</span><br><span class=\"line\"><span class=\"keyword\">from</span> htmlentitydefs <span class=\"keyword\">import</span> name2codepoint</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyHTMLParser</span><span class=\"params\">(HTMLParser)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_starttag</span><span class=\"params\">(self, tag, attrs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&lt;%s&gt;'</span> % tag)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_endtag</span><span class=\"params\">(self, tag)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&lt;/%s&gt;'</span> % tag)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_startendtag</span><span class=\"params\">(self, tag, attrs)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&lt;%s/&gt;'</span> % tag)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_data</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'data'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_comment</span><span class=\"params\">(self, data)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&lt;!-- --&gt;'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_entityref</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&amp;%s;'</span> % name)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">handle_charref</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">        print(<span class=\"string\">'&amp;#%s;'</span> % name)</span><br><span class=\"line\"></span><br><span class=\"line\">parser = MyHTMLParser()</span><br><span class=\"line\">parser.feed(<span class=\"string\">'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Some &lt;a href=\\\"#\\\"&gt;html&lt;/a&gt; tutorial...&lt;br&gt;END&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span>)</span><br></pre></td></tr></table></figure></p>\n<p><code>feed()</code>方法可以多次调用，也就是不一定一次把整个HTML字符串都塞进去，可以一部分一部分塞进去。</p>\n<p>特殊字符有两种，一种是英文表示的<code>&amp;nbsp;</code>（占位符），一种是数字表示的<code>&amp;#1234;</code>，这两种字符都可以通过Parser解析出来。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>和官方文档的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"初探python(7)面向对象高级编程","date":"2016-10-10T13:26:30.000Z","_content":"\n数据封装、继承和多态只是面向对象程序设计中最基础的3个概念。在Python中，面向对象还有很多高级特性，允许我们写出非常强大的功能。我们接下来会讨论多重继承、定制类、元类等高级概念。\n\n<!-- more -->\n## 引言\n\n正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。\n```\n# 绑定属性\ns = Student()\ns.name = 'Michael'\n\n# 绑定方法\nfrom types import MethodType\ns.set_age = MethodType(set_age, s, Student) # 给实例绑定一个方法\n\nStudent.set_score = MethodType(set_score, None, Student) # 给class绑定一个方法\n\n```\n动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。\n\n## 使用`__slots__`\n\n`__slots__`用以限制class的属性，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class能添加的属性。\n```\n class Student(object):\n    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称\n```\n使用`__slots__`要注意，`__slots__`定义的属性仅对当前类起作用，对继承的子类是不起作用的。\n\n如果要使得在子类中起作用，那要在子类中也定义`__slots__`，这样，子类允许定义的属性就是自身的`__slots__`加上父类的`__slots__`。\n```\nclass Student(object):\n    __slots__ = ('age', 'name')\nclass new(Student):\n    __slots__ = ('grade')\n\ns = new()\ns.name = 'a'\ns.grade = 97\nprint s.grade\n```\n\n## 使用`@property`\n\n在绑定属性的时候，如果我们把属性直接暴露出去，其值容易被随意更改。\nPython内置的`@property`装饰器就是负责把一个方法变成属性调用的。\n\n好处有二：\n1.能检查参数\n2.方便调用，可以用类似属性的方式来访问\n\n```\nclass Student(object):\n    @property\n    def score(self):\n        return self._score\n\n    @score.setter\n    def score(self,value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if 0<= value <= 100:\n            self._score = value\n        else:\n            raise ValueError(\"取值范围为0到100！\")\n    @score.deleter\n    def score(self):\n        del self._score\n        print \"score is already delete\"\n\ns = Student()\ns.score = 99\nprint s.score\ndel s.score\n\ns = Student()\ns.score = 99\nprint s.score\n# 99\n# score is already delete\n```\n\n我们在对实例属性操作的时候，就知道`@property`很可能不是直接暴露的，而是通过`getter`、`setter` 和`deleter`方法来实现的。\n\n把一个`getter`方法变成属性，只需要加上`@property`就可以了，此时，`@property`本身又创建了另一个装饰器`@score.setter`，负责把一个`setter`方法变成属性赋值。\n\n当然，你也有可能看到一些遗留的代码：\n```\nclass Student(object):\n    def get_score(self):\n        return self._score\n    def set_score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if value < 0 or value > 100:\n            raise ValueError('score must between 0 ~ 100!')\n        self._score = value\n    score = property(get_score, set_score)\n\n\n\ns = Student()\ns.score = 99\nprint s.score\n```\n\n通过增加一句`score = property(get_score, set_score)`，它允许score属性设置并获取值本身而不破坏原有代码。\n\n\n## 多重继承\n\n通过多重继承，一个子类就可以同时获得多个父类的所有功能。\n\n### Mixin\n\n如果不是单一继承，要实现多个继承，如让`Ostrich`除了继承自`Bird`外，再同时继承`Runnable`。这种设计通常称之为Mixin。\n\nMixin的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个Mixin的功能，而不是设计多层次的复杂的继承关系。\n\n这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。\n\n注：Java没有此类设计。\n\n## 定制类\nPython的class中还有许多`__slots__`，`__len__()`这样有特殊用途的函数，可以帮助我们定制类。\n\n### `__str__`和`__repr__`\n\n用来定制打印实例的内容。\n```\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\nprint Student('Michael')\n# <__main__.Student object at 0x109afb190>\n\n# 在类中定义加一条\ndef __str__(self):\n        return 'Student object (name: %s)' % self.name\n\nprint Student('Michael')\n# Student object (name: Michael)\n```\n另外，发现直接这样写还是会结果不同\n```\n s = Student('Michael')\n s\n# <__main__.Student object at 0x109afb310>\n```\n因为直接显示变量调用的不是`__str__()`，而是`__repr__()`，两者的区别是`__str__()`返回用户看到的字符串，而`__repr__()`返回程序开发者看到的字符串，也就是说，`__repr__()`是为调试服务的。\n\n因此，在定义里再加一条，省时省力的写法：\n```\n__repr__ = __str__\n```\n\n### `__iter__`\n用于`for···in`循环，返回一个迭代对象。然后，Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。\n```\nclass Fib(object):\n    def __init__(self):\n        self.a, self.b = 0, 1  # 初始化两个计数器a，b\n\n    def __iter__(self):\n        return self  # 实例本身就是迭代对象，故返回自己\n\n    def next(self):\n        self.a, self.b = self.b, self.a + self.b  # 计算下一个值\n        if self.a > 100000:  # 退出循环的条件\n            raise StopIteration()\n        return self.a  # 返回下一个值\nfor n in Fib():\n    print n\n```\n\n### `__getitem__`\n如上所说，Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，取不了其中的元素。\n```\nclass Fib(object):\n    def __getitem__(self, n):\n        a, b = 1, 1\n        for x in range(n):\n            a, b = b, a + b\n        return a\n```\n这样，通过调用`print Fib()[2016]`就可以访问第2016项了（第0项就是原来数）。\n\n如果要实现如同`list`的切片操作，需判断传入值是slice还是int：\n```\nclass Fib(object):\n    def __getitem__(self, n):\n        if isinstance(n, int):\n            a, b = 1, 1\n            for x in range(n):\n                a, b = b, a + b\n            return a\n        if isinstance(n, slice):\n            start = n.start\n            stop = n.stop\n            a, b = 1, 1\n            L = []\n            for x in range(stop):\n                if x >= start:\n                    L.append(a)\n                a, b = b, a + b\n            return L\n```\n但是上述例子中没有对step参数作处理，也没有对负数作处理，所以，要正确实现一个`__getitem__()`还是有很多工作要做的。\n\n此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以作key的object，例如str。\n\n与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。\n\n总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”（“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。），不需要强制继承某个接口。\n\n\n### `__getattr__`\n\n正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。这个方法的优点就是动态返回一个属性。\n\n当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性。\n```\nclass Student(object):\n\n    def __init__(self):\n        self.name = 'Michael'\n\n    def __getattr__(self, attr):\n        if attr=='score':\n            return 99\ns.score\n# 99\n```\n这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。\n\n作用之一就是动态调用API，利用完全动态的`__getattr__`，我们可以写出一个链式调用：\n```\nclass Chain(object):\n\n    def __init__(self, path=''):\n        self._path = path\n\n    def __getattr__(self, path):\n        return Chain('%s/%s' % (self._path, path))\n\n    def __str__(self):\n        return self._path\nprint Chain().status.user.timeline.list\n# '/status/user/timeline/list'\n#调用Github的URL时，需要把:user替换为实际用户名。\n\n```\n这样就能很方便的调用API了。\n\n### `__call__`\n\n`__call__`能够直接就可以对实例进行调用。\n\n```\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self):\n        print('My name is %s.' % self.name)\ns = Student('Michael')\ns()\n# My name is Michael.\n```\n\n对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。\n\n那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有__call()__的类实例：\n```\ncallable(Student())\n# True\n```\n\n## 使用元类\n\n### type()\n\ntype()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello。\n\n还可以创建一个新的类型。\n要创建一个class对象，type()函数依次传入3个参数：\n1.class的名称；\n2.继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；\n3.class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。\n\n```\ndef fn(self, name='world'): # 先定义函数\n    print('Hello, %s.' % name)\n\n Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class\n```\n通过`type()`数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用`type()`函数创建出class。\n\n###　metaclass\n\n`metaclass`直译为“元类”，用来控制类的创建行为。\n创建类的流程应该是：先定义metaclass，就可以创建类，最后创建实例。\n\n用到比较少，但是是Python面向对象里最难理解，也是最难使用的魔术代码。\n\n定义metaclass时，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass。\n\n```\nclass MylistMetaclass(type):\n    def __new__(cls, name, bases, attrs):\n        attrs['add'] = lambda self, value: self.append(value)\n        attrs['dele'] = lambda self, value: self.remove(value)\n        return type.__new__(cls, name, bases, attrs)\n\n\nclass Mylist(list):\n    __metaclass__ = MylistMetaclass\n\na = Mylist()\n\na.add(\"a\")\n\nprint a\na.dele(\"a\")\nprint a\n\n```\n当我们写下`__metaclass__ = ListMetaclass`语句时，魔术就生效了，它指示Python解释器在创建MyList时，要通过`ListMetaclass.__new__()`来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。\n\n`__new__()`方法接收到的参数依次是：\n\n1.当前准备创建的类的对象；\n\n2.类的名字；\n\n3.类继承的父类集合；\n\n4.类的方法集合。\n\n那么，动态修改的意义在哪？一般的写直接添加'add'放法即可。\n\n但是，总会遇到需要通过`metaclass`修改类定义的。ORM就是一个典型的例子。\n\nORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。\n\n要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。\n\n让我们来尝试编写一个ORM框架。\n\n编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码：\n```\nclass User(Model):\n    # 定义类的属性到列的映射：\n    id = IntegerField('id')\n    name = StringField('username')\n    email = StringField('email')\n    password = StringField('password')\n\n# 创建一个实例：\nu = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')\n# 保存到数据库：\nu.save()\n```\n首先来定义Field类，它负责保存数据库表的字段名和字段类型：\n```\nclass Field(object):\n    def __init__(self, name, column_type):\n        self.name = name\n        self.column_type = column_type\n\n    def __str__(self):\n        return '<%s:%s>' % (self.__class__.__name__, self.name)\n```\n\n然后，在此基础上进一步定义各类Field：\n```\nclass StringField(Field):\n    def __init__(self,name):\n        super(StringField, self).__init__(name, 'varchar(100)')\n\n\nclass IntField(Field):\n    def __init__(self,name):\n        super(IntField,self).__init__(name, 'bigint')\n```\n\n接下来开始写`metaclass`：\n```\nclass ModelMetaclass(type):\n    def __new__(cls, name, bases, attrs):\n        if name == 'Model':\n            return type.__new__(cls, name, bases, attrs)\n        print('Found model: %s' % name)\n        mappings = dict()\n        for k, v in attrs.iteritems():\n            if isinstance(v, Field):\n                print \"Found mapping:%s ==> %s\"%(k, v)\n                mappings[k] = v\n        for k in mappings.iterkeys():\n            attrs.pop(k)\n        attrs['__mappings__'] = mappings # 保存属性和列的映射关系\n        attrs['__table__'] = name # 假设表名和类名一致\n        return type.__new__(cls, name, bases, attrs)\n\n```\n`metaclass`一共做了三件事情：\n\n1.排除对`Model`的修改；\n\n2.在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个__mappings__的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误；\n\n3.把表名保存到__table__中，这里简化为表名默认为类名。\n\n再接下来，创建基类Model：\n```\nclass Model(dict):\n    __metaclass__ = ModelMetaclass\n\n    def __init__(self, **kw):\n        super(Model, self).__init__(**kw)\n\n    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError:\n            raise AttributeError(r\"'Model' object has no attribute '%s'\" % key)\n\n    def __setattr__(self, key, value):\n        self[key] = value\n\n    def save(self):\n        fields = []\n        params = []\n        args = []\n        for k, v in self.__mappings__.iteritems():\n            fields.append(v.name)\n            params.append('?')\n            args.append(getattr(self, k, None))\n        sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params))\n        print('SQL: %s' % sql)\n        print('ARGS: %s' % str(args))\n        print('table name:%s'%self.__table__)\n```\n\n当用户定义一个`class User(Model)`时，Python解释器首先在当前类User的定义中查找`__metaclass__`，如果没有找到，就继续在父类Model中查找`__metaclass__`，找到了，就使用`Model`中定义的`__metaclass__`的`ModelMetaclass`来创建`User`类，也就是说，`metaclass`可以隐式地继承到子类，但却在子类处没有显示。\n\n\n在接下来实例化User：\n```\nu = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')\nu.save()\n\n#Found model: User\n#Found mapping:email ==> <StringField:email>\n#Found mapping:password ==> <StringField:password>\n#Found mapping:id ==> <IntField:uid>\n#Found mapping:name ==> <StringField:username>\n#SQL: insert into User (password,email,username,uid) values (?,?,?,?)\n#ARGS: ['my-pwd', 'test@orm.org', 'Michael', 12345]\n#table name:User\n```\n\n在我们编写的ORM中，ModelMetaclass会删除掉User类的所有类属性，目的就是避免造成混淆。\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","source":"_posts/python/初探python(7)面向对象高级编程.md","raw":"---\ntitle: 初探python(7)面向对象高级编程\ndate: 2016-10-10 21:26:30\ntags: \n- python\n- python教程\ncategories: 总结\n---\n\n数据封装、继承和多态只是面向对象程序设计中最基础的3个概念。在Python中，面向对象还有很多高级特性，允许我们写出非常强大的功能。我们接下来会讨论多重继承、定制类、元类等高级概念。\n\n<!-- more -->\n## 引言\n\n正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。\n```\n# 绑定属性\ns = Student()\ns.name = 'Michael'\n\n# 绑定方法\nfrom types import MethodType\ns.set_age = MethodType(set_age, s, Student) # 给实例绑定一个方法\n\nStudent.set_score = MethodType(set_score, None, Student) # 给class绑定一个方法\n\n```\n动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。\n\n## 使用`__slots__`\n\n`__slots__`用以限制class的属性，Python允许在定义class的时候，定义一个特殊的`__slots__`变量，来限制该class能添加的属性。\n```\n class Student(object):\n    __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称\n```\n使用`__slots__`要注意，`__slots__`定义的属性仅对当前类起作用，对继承的子类是不起作用的。\n\n如果要使得在子类中起作用，那要在子类中也定义`__slots__`，这样，子类允许定义的属性就是自身的`__slots__`加上父类的`__slots__`。\n```\nclass Student(object):\n    __slots__ = ('age', 'name')\nclass new(Student):\n    __slots__ = ('grade')\n\ns = new()\ns.name = 'a'\ns.grade = 97\nprint s.grade\n```\n\n## 使用`@property`\n\n在绑定属性的时候，如果我们把属性直接暴露出去，其值容易被随意更改。\nPython内置的`@property`装饰器就是负责把一个方法变成属性调用的。\n\n好处有二：\n1.能检查参数\n2.方便调用，可以用类似属性的方式来访问\n\n```\nclass Student(object):\n    @property\n    def score(self):\n        return self._score\n\n    @score.setter\n    def score(self,value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if 0<= value <= 100:\n            self._score = value\n        else:\n            raise ValueError(\"取值范围为0到100！\")\n    @score.deleter\n    def score(self):\n        del self._score\n        print \"score is already delete\"\n\ns = Student()\ns.score = 99\nprint s.score\ndel s.score\n\ns = Student()\ns.score = 99\nprint s.score\n# 99\n# score is already delete\n```\n\n我们在对实例属性操作的时候，就知道`@property`很可能不是直接暴露的，而是通过`getter`、`setter` 和`deleter`方法来实现的。\n\n把一个`getter`方法变成属性，只需要加上`@property`就可以了，此时，`@property`本身又创建了另一个装饰器`@score.setter`，负责把一个`setter`方法变成属性赋值。\n\n当然，你也有可能看到一些遗留的代码：\n```\nclass Student(object):\n    def get_score(self):\n        return self._score\n    def set_score(self, value):\n        if not isinstance(value, int):\n            raise ValueError('score must be an integer!')\n        if value < 0 or value > 100:\n            raise ValueError('score must between 0 ~ 100!')\n        self._score = value\n    score = property(get_score, set_score)\n\n\n\ns = Student()\ns.score = 99\nprint s.score\n```\n\n通过增加一句`score = property(get_score, set_score)`，它允许score属性设置并获取值本身而不破坏原有代码。\n\n\n## 多重继承\n\n通过多重继承，一个子类就可以同时获得多个父类的所有功能。\n\n### Mixin\n\n如果不是单一继承，要实现多个继承，如让`Ostrich`除了继承自`Bird`外，再同时继承`Runnable`。这种设计通常称之为Mixin。\n\nMixin的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个Mixin的功能，而不是设计多层次的复杂的继承关系。\n\n这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。\n\n注：Java没有此类设计。\n\n## 定制类\nPython的class中还有许多`__slots__`，`__len__()`这样有特殊用途的函数，可以帮助我们定制类。\n\n### `__str__`和`__repr__`\n\n用来定制打印实例的内容。\n```\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\nprint Student('Michael')\n# <__main__.Student object at 0x109afb190>\n\n# 在类中定义加一条\ndef __str__(self):\n        return 'Student object (name: %s)' % self.name\n\nprint Student('Michael')\n# Student object (name: Michael)\n```\n另外，发现直接这样写还是会结果不同\n```\n s = Student('Michael')\n s\n# <__main__.Student object at 0x109afb310>\n```\n因为直接显示变量调用的不是`__str__()`，而是`__repr__()`，两者的区别是`__str__()`返回用户看到的字符串，而`__repr__()`返回程序开发者看到的字符串，也就是说，`__repr__()`是为调试服务的。\n\n因此，在定义里再加一条，省时省力的写法：\n```\n__repr__ = __str__\n```\n\n### `__iter__`\n用于`for···in`循环，返回一个迭代对象。然后，Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。\n```\nclass Fib(object):\n    def __init__(self):\n        self.a, self.b = 0, 1  # 初始化两个计数器a，b\n\n    def __iter__(self):\n        return self  # 实例本身就是迭代对象，故返回自己\n\n    def next(self):\n        self.a, self.b = self.b, self.a + self.b  # 计算下一个值\n        if self.a > 100000:  # 退出循环的条件\n            raise StopIteration()\n        return self.a  # 返回下一个值\nfor n in Fib():\n    print n\n```\n\n### `__getitem__`\n如上所说，Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，取不了其中的元素。\n```\nclass Fib(object):\n    def __getitem__(self, n):\n        a, b = 1, 1\n        for x in range(n):\n            a, b = b, a + b\n        return a\n```\n这样，通过调用`print Fib()[2016]`就可以访问第2016项了（第0项就是原来数）。\n\n如果要实现如同`list`的切片操作，需判断传入值是slice还是int：\n```\nclass Fib(object):\n    def __getitem__(self, n):\n        if isinstance(n, int):\n            a, b = 1, 1\n            for x in range(n):\n                a, b = b, a + b\n            return a\n        if isinstance(n, slice):\n            start = n.start\n            stop = n.stop\n            a, b = 1, 1\n            L = []\n            for x in range(stop):\n                if x >= start:\n                    L.append(a)\n                a, b = b, a + b\n            return L\n```\n但是上述例子中没有对step参数作处理，也没有对负数作处理，所以，要正确实现一个`__getitem__()`还是有很多工作要做的。\n\n此外，如果把对象看成dict，__getitem__()的参数也可能是一个可以作key的object，例如str。\n\n与之对应的是__setitem__()方法，把对象视作list或dict来对集合赋值。最后，还有一个__delitem__()方法，用于删除某个元素。\n\n总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”（“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。），不需要强制继承某个接口。\n\n\n### `__getattr__`\n\n正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。这个方法的优点就是动态返回一个属性。\n\n当调用不存在的属性时，比如score，Python解释器会试图调用__getattr__(self, 'score')来尝试获得属性。\n```\nclass Student(object):\n\n    def __init__(self):\n        self.name = 'Michael'\n\n    def __getattr__(self, attr):\n        if attr=='score':\n            return 99\ns.score\n# 99\n```\n这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。\n\n作用之一就是动态调用API，利用完全动态的`__getattr__`，我们可以写出一个链式调用：\n```\nclass Chain(object):\n\n    def __init__(self, path=''):\n        self._path = path\n\n    def __getattr__(self, path):\n        return Chain('%s/%s' % (self._path, path))\n\n    def __str__(self):\n        return self._path\nprint Chain().status.user.timeline.list\n# '/status/user/timeline/list'\n#调用Github的URL时，需要把:user替换为实际用户名。\n\n```\n这样就能很方便的调用API了。\n\n### `__call__`\n\n`__call__`能够直接就可以对实例进行调用。\n\n```\nclass Student(object):\n    def __init__(self, name):\n        self.name = name\n\n    def __call__(self):\n        print('My name is %s.' % self.name)\ns = Student('Michael')\ns()\n# My name is Michael.\n```\n\n对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。\n\n那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有__call()__的类实例：\n```\ncallable(Student())\n# True\n```\n\n## 使用元类\n\n### type()\n\ntype()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello。\n\n还可以创建一个新的类型。\n要创建一个class对象，type()函数依次传入3个参数：\n1.class的名称；\n2.继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；\n3.class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。\n\n```\ndef fn(self, name='world'): # 先定义函数\n    print('Hello, %s.' % name)\n\n Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello class\n```\n通过`type()`数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用`type()`函数创建出class。\n\n###　metaclass\n\n`metaclass`直译为“元类”，用来控制类的创建行为。\n创建类的流程应该是：先定义metaclass，就可以创建类，最后创建实例。\n\n用到比较少，但是是Python面向对象里最难理解，也是最难使用的魔术代码。\n\n定义metaclass时，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass。\n\n```\nclass MylistMetaclass(type):\n    def __new__(cls, name, bases, attrs):\n        attrs['add'] = lambda self, value: self.append(value)\n        attrs['dele'] = lambda self, value: self.remove(value)\n        return type.__new__(cls, name, bases, attrs)\n\n\nclass Mylist(list):\n    __metaclass__ = MylistMetaclass\n\na = Mylist()\n\na.add(\"a\")\n\nprint a\na.dele(\"a\")\nprint a\n\n```\n当我们写下`__metaclass__ = ListMetaclass`语句时，魔术就生效了，它指示Python解释器在创建MyList时，要通过`ListMetaclass.__new__()`来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。\n\n`__new__()`方法接收到的参数依次是：\n\n1.当前准备创建的类的对象；\n\n2.类的名字；\n\n3.类继承的父类集合；\n\n4.类的方法集合。\n\n那么，动态修改的意义在哪？一般的写直接添加'add'放法即可。\n\n但是，总会遇到需要通过`metaclass`修改类定义的。ORM就是一个典型的例子。\n\nORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。\n\n要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。\n\n让我们来尝试编写一个ORM框架。\n\n编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码：\n```\nclass User(Model):\n    # 定义类的属性到列的映射：\n    id = IntegerField('id')\n    name = StringField('username')\n    email = StringField('email')\n    password = StringField('password')\n\n# 创建一个实例：\nu = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')\n# 保存到数据库：\nu.save()\n```\n首先来定义Field类，它负责保存数据库表的字段名和字段类型：\n```\nclass Field(object):\n    def __init__(self, name, column_type):\n        self.name = name\n        self.column_type = column_type\n\n    def __str__(self):\n        return '<%s:%s>' % (self.__class__.__name__, self.name)\n```\n\n然后，在此基础上进一步定义各类Field：\n```\nclass StringField(Field):\n    def __init__(self,name):\n        super(StringField, self).__init__(name, 'varchar(100)')\n\n\nclass IntField(Field):\n    def __init__(self,name):\n        super(IntField,self).__init__(name, 'bigint')\n```\n\n接下来开始写`metaclass`：\n```\nclass ModelMetaclass(type):\n    def __new__(cls, name, bases, attrs):\n        if name == 'Model':\n            return type.__new__(cls, name, bases, attrs)\n        print('Found model: %s' % name)\n        mappings = dict()\n        for k, v in attrs.iteritems():\n            if isinstance(v, Field):\n                print \"Found mapping:%s ==> %s\"%(k, v)\n                mappings[k] = v\n        for k in mappings.iterkeys():\n            attrs.pop(k)\n        attrs['__mappings__'] = mappings # 保存属性和列的映射关系\n        attrs['__table__'] = name # 假设表名和类名一致\n        return type.__new__(cls, name, bases, attrs)\n\n```\n`metaclass`一共做了三件事情：\n\n1.排除对`Model`的修改；\n\n2.在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个__mappings__的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误；\n\n3.把表名保存到__table__中，这里简化为表名默认为类名。\n\n再接下来，创建基类Model：\n```\nclass Model(dict):\n    __metaclass__ = ModelMetaclass\n\n    def __init__(self, **kw):\n        super(Model, self).__init__(**kw)\n\n    def __getattr__(self, key):\n        try:\n            return self[key]\n        except KeyError:\n            raise AttributeError(r\"'Model' object has no attribute '%s'\" % key)\n\n    def __setattr__(self, key, value):\n        self[key] = value\n\n    def save(self):\n        fields = []\n        params = []\n        args = []\n        for k, v in self.__mappings__.iteritems():\n            fields.append(v.name)\n            params.append('?')\n            args.append(getattr(self, k, None))\n        sql = 'insert into %s (%s) values (%s)' % (self.__table__, ','.join(fields), ','.join(params))\n        print('SQL: %s' % sql)\n        print('ARGS: %s' % str(args))\n        print('table name:%s'%self.__table__)\n```\n\n当用户定义一个`class User(Model)`时，Python解释器首先在当前类User的定义中查找`__metaclass__`，如果没有找到，就继续在父类Model中查找`__metaclass__`，找到了，就使用`Model`中定义的`__metaclass__`的`ModelMetaclass`来创建`User`类，也就是说，`metaclass`可以隐式地继承到子类，但却在子类处没有显示。\n\n\n在接下来实例化User：\n```\nu = User(id=12345, name='Michael', email='test@orm.org', password='my-pwd')\nu.save()\n\n#Found model: User\n#Found mapping:email ==> <StringField:email>\n#Found mapping:password ==> <StringField:password>\n#Found mapping:id ==> <IntField:uid>\n#Found mapping:name ==> <StringField:username>\n#SQL: insert into User (password,email,username,uid) values (?,?,?,?)\n#ARGS: ['my-pwd', 'test@orm.org', 'Michael', 12345]\n#table name:User\n```\n\n在我们编写的ORM中，ModelMetaclass会删除掉User类的所有类属性，目的就是避免造成混淆。\n\n>此python学习路径来源于[廖雪峰的Python教程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000)的一个学习内容的总结。以便于自己后的学习和整理。","slug":"python/初探python(7)面向对象高级编程","published":1,"updated":"2019-03-22T14:44:36.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn2s00bp4l3n1ksp8lgm","content":"<p>数据封装、继承和多态只是面向对象程序设计中最基础的3个概念。在Python中，面向对象还有很多高级特性，允许我们写出非常强大的功能。我们接下来会讨论多重继承、定制类、元类等高级概念。</p>\n<a id=\"more\"></a>\n<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。<br><figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 绑定属性</span></span><br><span class=\"line\"><span class=\"attr\">s</span> = Student()</span><br><span class=\"line\">s.<span class=\"attr\">name</span> = 'Michael'</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 绑定方法</span></span><br><span class=\"line\">from types <span class=\"built_in\">import</span> MethodType</span><br><span class=\"line\">s.<span class=\"attr\">set_age</span> = MethodType(set_age, s, Student) <span class=\"comment\"># 给实例绑定一个方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">Student.<span class=\"attr\">set_score</span> = MethodType(set_score, None, Student) <span class=\"comment\"># 给class绑定一个方法</span></span><br></pre></td></tr></table></figure></p>\n<p>动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</p>\n<h2 id=\"使用-slots\"><a href=\"#使用-slots\" class=\"headerlink\" title=\"使用__slots__\"></a>使用<code>__slots__</code></h2><p><code>__slots__</code>用以限制class的属性，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class能添加的属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">   __slots__ = (<span class=\"string\">'name'</span>, <span class=\"string\">'age'</span>) <span class=\"comment\"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure></p>\n<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类起作用，对继承的子类是不起作用的。</p>\n<p>如果要使得在子类中起作用，那要在子类中也定义<code>__slots__</code>，这样，子类允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    __slots__ = (<span class=\"string\">'age'</span>, <span class=\"string\">'name'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">new</span><span class=\"params\">(Student)</span>:</span></span><br><span class=\"line\">    __slots__ = (<span class=\"string\">'grade'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s = new()</span><br><span class=\"line\">s.name = <span class=\"string\">'a'</span></span><br><span class=\"line\">s.grade = <span class=\"number\">97</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> s.grade</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用-property\"><a href=\"#使用-property\" class=\"headerlink\" title=\"使用@property\"></a>使用<code>@property</code></h2><p>在绑定属性的时候，如果我们把属性直接暴露出去，其值容易被随意更改。<br>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的。</p>\n<p>好处有二：<br>1.能检查参数<br>2.方便调用，可以用类似属性的方式来访问</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._score</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @score.setter</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self,value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value, int):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must be an integer!'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;= value &lt;= <span class=\"number\">100</span>:</span><br><span class=\"line\">            self._score = value</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">\"取值范围为0到100！\"</span>)</span><br><span class=\"line\"><span class=\"meta\">    @score.deleter</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">del</span> self._score</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"score is already delete\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">s = Student()</span><br><span class=\"line\">s.score = <span class=\"number\">99</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> s.score</span><br><span class=\"line\"><span class=\"keyword\">del</span> s.score</span><br><span class=\"line\"></span><br><span class=\"line\">s = Student()</span><br><span class=\"line\">s.score = <span class=\"number\">99</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> s.score</span><br><span class=\"line\"><span class=\"comment\"># 99</span></span><br><span class=\"line\"><span class=\"comment\"># score is already delete</span></span><br></pre></td></tr></table></figure>\n<p>我们在对实例属性操作的时候，就知道<code>@property</code>很可能不是直接暴露的，而是通过<code>getter</code>、<code>setter</code> 和<code>deleter</code>方法来实现的。</p>\n<p>把一个<code>getter</code>方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<a href=\"mailto:`@score.setter\" target=\"_blank\" rel=\"noopener\">`@score.setter</a><code>，负责把一个</code>setter`方法变成属性赋值。</p>\n<p>当然，你也有可能看到一些遗留的代码：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_score</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>._score</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_score</span><span class=\"params\">(<span class=\"keyword\">self</span>, value)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value, int)<span class=\"symbol\">:</span></span><br><span class=\"line\">            raise ValueError(<span class=\"string\">'score must be an integer!'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> value &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> value &gt; <span class=\"number\">100</span><span class=\"symbol\">:</span></span><br><span class=\"line\">            raise ValueError(<span class=\"string\">'score must between 0 ~ 100!'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>._score = value</span><br><span class=\"line\">    score = property(get_score, set_score)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">s = Student()</span><br><span class=\"line\">s.score = <span class=\"number\">99</span></span><br><span class=\"line\">print s.score</span><br></pre></td></tr></table></figure></p>\n<p>通过增加一句<code>score = property(get_score, set_score)</code>，它允许score属性设置并获取值本身而不破坏原有代码。</p>\n<h2 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h2><p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>\n<h3 id=\"Mixin\"><a href=\"#Mixin\" class=\"headerlink\" title=\"Mixin\"></a>Mixin</h3><p>如果不是单一继承，要实现多个继承，如让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为Mixin。</p>\n<p>Mixin的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个Mixin的功能，而不是设计多层次的复杂的继承关系。</p>\n<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>\n<p>注：Java没有此类设计。</p>\n<h2 id=\"定制类\"><a href=\"#定制类\" class=\"headerlink\" title=\"定制类\"></a>定制类</h2><p>Python的class中还有许多<code>__slots__</code>，<code>__len__()</code>这样有特殊用途的函数，可以帮助我们定制类。</p>\n<h3 id=\"str-和-repr\"><a href=\"#str-和-repr\" class=\"headerlink\" title=\"__str__和__repr__\"></a><code>__str__</code>和<code>__repr__</code></h3><p>用来定制打印实例的内容。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, name)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\"></span><br><span class=\"line\">print Student(<span class=\"string\">'Michael'</span>)</span><br><span class=\"line\"><span class=\"comment\"># &lt;__main__.Student object at 0x109afb190&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在类中定义加一条</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Student object (name: %s)'</span> % <span class=\"keyword\">self</span>.name</span><br><span class=\"line\"></span><br><span class=\"line\">print Student(<span class=\"string\">'Michael'</span>)</span><br><span class=\"line\"><span class=\"comment\"># Student object (name: Michael)</span></span><br></pre></td></tr></table></figure></p>\n<p>另外，发现直接这样写还是会结果不同<br><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"attribute\">s</span> = Student(<span class=\"string\">'Michael'</span>)</span><br><span class=\"line\"> s</span><br><span class=\"line\"><span class=\"comment\"># &lt;__main__.Student object at 0x109afb310&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>\n<p>因此，在定义里再加一条，省时省力的写法：<br><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"strong\">__repr__</span> = <span class=\"strong\">__str__</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"iter\"><a href=\"#iter\" class=\"headerlink\" title=\"__iter__\"></a><code>__iter__</code></h3><p>用于<code>for···in</code>循环，返回一个迭代对象。然后，Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.a, <span class=\"keyword\">self</span>.b = <span class=\"number\">0</span>, <span class=\"number\">1</span>  <span class=\"comment\"># 初始化两个计数器a，b</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__iter__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>  <span class=\"comment\"># 实例本身就是迭代对象，故返回自己</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">next</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.a, <span class=\"keyword\">self</span>.b = <span class=\"keyword\">self</span>.b, <span class=\"keyword\">self</span>.a + <span class=\"keyword\">self</span>.b  <span class=\"comment\"># 计算下一个值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.a &gt; <span class=\"number\">100000</span>:  <span class=\"comment\"># 退出循环的条件</span></span><br><span class=\"line\">            raise StopIteration()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.a  <span class=\"comment\"># 返回下一个值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> Fib()<span class=\"symbol\">:</span></span><br><span class=\"line\">    print n</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"getitem\"><a href=\"#getitem\" class=\"headerlink\" title=\"__getitem__\"></a><code>__getitem__</code></h3><p>如上所说，Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，取不了其中的元素。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getitem__</span><span class=\"params\">(<span class=\"keyword\">self</span>, n)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(n)<span class=\"symbol\">:</span></span><br><span class=\"line\">            a, b = b, a + b</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a</span><br></pre></td></tr></table></figure></p>\n<p>这样，通过调用<code>print Fib()[2016]</code>就可以访问第2016项了（第0项就是原来数）。</p>\n<p>如果要实现如同<code>list</code>的切片操作，需判断传入值是slice还是int：<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Fib(object):</span><br><span class=\"line\">    def __getitem__(self, n):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, int):</span><br><span class=\"line\">            <span class=\"keyword\">a</span>, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">a</span>, b = b, <span class=\"keyword\">a</span> + b</span><br><span class=\"line\">            <span class=\"literal\">return</span> <span class=\"keyword\">a</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, slice):</span><br><span class=\"line\">            <span class=\"built_in\">start</span> = n.<span class=\"built_in\">start</span></span><br><span class=\"line\">            <span class=\"built_in\">stop</span> = n.<span class=\"built_in\">stop</span></span><br><span class=\"line\">            <span class=\"keyword\">a</span>, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">            L = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"built_in\">stop</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> x &gt;= <span class=\"built_in\">start</span>:</span><br><span class=\"line\">                    L.append(<span class=\"keyword\">a</span>)</span><br><span class=\"line\">                <span class=\"keyword\">a</span>, b = b, <span class=\"keyword\">a</span> + b</span><br><span class=\"line\">            <span class=\"literal\">return</span> L</span><br></pre></td></tr></table></figure></p>\n<p>但是上述例子中没有对step参数作处理，也没有对负数作处理，所以，要正确实现一个<code>__getitem__()</code>还是有很多工作要做的。</p>\n<p>此外，如果把对象看成dict，<strong>getitem</strong>()的参数也可能是一个可以作key的object，例如str。</p>\n<p>与之对应的是<strong>setitem</strong>()方法，把对象视作list或dict来对集合赋值。最后，还有一个<strong>delitem</strong>()方法，用于删除某个元素。</p>\n<p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”（“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。），不需要强制继承某个接口。</p>\n<h3 id=\"getattr\"><a href=\"#getattr\" class=\"headerlink\" title=\"__getattr__\"></a><code>__getattr__</code></h3><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。这个方法的优点就是动态返回一个属性。</p>\n<p>当调用不存在的属性时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = <span class=\"string\">'Michael'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(<span class=\"keyword\">self</span>, attr)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> attr==<span class=\"string\">'score'</span><span class=\"symbol\">:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">99</span></span><br><span class=\"line\">s.score</span><br><span class=\"line\"><span class=\"comment\"># 99</span></span><br></pre></td></tr></table></figure></p>\n<p>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。</p>\n<p>作用之一就是动态调用API，利用完全动态的<code>__getattr__</code>，我们可以写出一个链式调用：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chain</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, path=<span class=\"string\">''</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>._path = path</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(<span class=\"keyword\">self</span>, path)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Chain(<span class=\"string\">'%s/%s'</span> % (<span class=\"keyword\">self</span>._path, path))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>._path</span><br><span class=\"line\">print Chain().status.user.timeline.list</span><br><span class=\"line\"><span class=\"comment\"># '/status/user/timeline/list'</span></span><br><span class=\"line\"><span class=\"comment\">#调用Github的URL时，需要把:user替换为实际用户名。</span></span><br></pre></td></tr></table></figure></p>\n<p>这样就能很方便的调用API了。</p>\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"__call__\"></a><code>__call__</code></h3><p><code>__call__</code>能够直接就可以对实例进行调用。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, name)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        print(<span class=\"string\">'My name is %s.'</span> % <span class=\"keyword\">self</span>.name)</span><br><span class=\"line\">s = Student(<span class=\"string\">'Michael'</span>)</span><br><span class=\"line\">s()</span><br><span class=\"line\"><span class=\"comment\"># My name is Michael.</span></span><br></pre></td></tr></table></figure>\n<p>对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>\n<p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有<strong>call()</strong>的类实例：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callable(<span class=\"name\">Student</span>())</span><br><span class=\"line\"># True</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用元类\"><a href=\"#使用元类\" class=\"headerlink\" title=\"使用元类\"></a>使用元类</h2><h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type()\"></a>type()</h3><p>type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello。</p>\n<p>还可以创建一个新的类型。<br>要创建一个class对象，type()函数依次传入3个参数：<br>1.class的名称；<br>2.继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；<br>3.class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fn</span></span>(<span class=\"keyword\">self</span>, name=<span class=\"string\">'world'</span>): <span class=\"comment\"># 先定义函数</span></span><br><span class=\"line\">    print(<span class=\"string\">'Hello, %s.'</span> % name)</span><br><span class=\"line\"></span><br><span class=\"line\"> Hello = type(<span class=\"string\">'Hello'</span>, (object,), dict(hello=<span class=\"keyword\">fn</span>)) <span class=\"comment\"># 创建Hello class</span></span><br></pre></td></tr></table></figure>\n<p>通过<code>type()</code>数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p>\n<p>###　metaclass</p>\n<p><code>metaclass</code>直译为“元类”，用来控制类的创建行为。<br>创建类的流程应该是：先定义metaclass，就可以创建类，最后创建实例。</p>\n<p>用到比较少，但是是Python面向对象里最难理解，也是最难使用的魔术代码。</p>\n<p>定义metaclass时，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MylistMetaclass</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, name, bases, attrs)</span>:</span></span><br><span class=\"line\">        attrs[<span class=\"string\">'add'</span>] = <span class=\"keyword\">lambda</span> self, value: self.append(value)</span><br><span class=\"line\">        attrs[<span class=\"string\">'dele'</span>] = <span class=\"keyword\">lambda</span> self, value: self.remove(value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mylist</span><span class=\"params\">(list)</span>:</span></span><br><span class=\"line\">    __metaclass__ = MylistMetaclass</span><br><span class=\"line\"></span><br><span class=\"line\">a = Mylist()</span><br><span class=\"line\"></span><br><span class=\"line\">a.add(<span class=\"string\">\"a\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> a</span><br><span class=\"line\">a.dele(<span class=\"string\">\"a\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> a</span><br></pre></td></tr></table></figure>\n<p>当我们写下<code>__metaclass__ = ListMetaclass</code>语句时，魔术就生效了，它指示Python解释器在创建MyList时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>\n<p><code>__new__()</code>方法接收到的参数依次是：</p>\n<p>1.当前准备创建的类的对象；</p>\n<p>2.类的名字；</p>\n<p>3.类继承的父类集合；</p>\n<p>4.类的方法集合。</p>\n<p>那么，动态修改的意义在哪？一般的写直接添加’add’放法即可。</p>\n<p>但是，总会遇到需要通过<code>metaclass</code>修改类定义的。ORM就是一个典型的例子。</p>\n<p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</p>\n<p>要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p>\n<p>让我们来尝试编写一个ORM框架。</p>\n<p>编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span><span class=\"params\">(Model)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 定义类的属性到列的映射：</span></span><br><span class=\"line\">    id = IntegerField(<span class=\"string\">'id'</span>)</span><br><span class=\"line\">    name = StringField(<span class=\"string\">'username'</span>)</span><br><span class=\"line\">    email = StringField(<span class=\"string\">'email'</span>)</span><br><span class=\"line\">    password = StringField(<span class=\"string\">'password'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个实例：</span></span><br><span class=\"line\">u = User(id=<span class=\"number\">12345</span>, name=<span class=\"string\">'Michael'</span>, email=<span class=\"string\">'test@orm.org'</span>, password=<span class=\"string\">'my-pwd'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 保存到数据库：</span></span><br><span class=\"line\">u.save()</span><br></pre></td></tr></table></figure></p>\n<p>首先来定义Field类，它负责保存数据库表的字段名和字段类型：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Field</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, name, column_type)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.column_type = column_type</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;%s:%s&gt;'</span> % (<span class=\"keyword\">self</span>.__class_<span class=\"number\">_</span>.__name_<span class=\"number\">_</span>, <span class=\"keyword\">self</span>.name)</span><br></pre></td></tr></table></figure></p>\n<p>然后，在此基础上进一步定义各类Field：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringField</span>(<span class=\"title\">Field</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>,name)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">super</span>(StringField, <span class=\"keyword\">self</span>).__init_<span class=\"number\">_</span>(name, <span class=\"string\">'varchar(100)'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntField</span>(<span class=\"title\">Field</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>,name)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">super</span>(IntField,<span class=\"keyword\">self</span>).__init_<span class=\"number\">_</span>(name, <span class=\"string\">'bigint'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>接下来开始写<code>metaclass</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ModelMetaclass</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, name, bases, attrs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> name == <span class=\"string\">'Model'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class=\"line\">        print(<span class=\"string\">'Found model: %s'</span> % name)</span><br><span class=\"line\">        mappings = dict()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> attrs.iteritems():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> isinstance(v, Field):</span><br><span class=\"line\">                <span class=\"keyword\">print</span> <span class=\"string\">\"Found mapping:%s ==&gt; %s\"</span>%(k, v)</span><br><span class=\"line\">                mappings[k] = v</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> mappings.iterkeys():</span><br><span class=\"line\">            attrs.pop(k)</span><br><span class=\"line\">        attrs[<span class=\"string\">'__mappings__'</span>] = mappings <span class=\"comment\"># 保存属性和列的映射关系</span></span><br><span class=\"line\">        attrs[<span class=\"string\">'__table__'</span>] = name <span class=\"comment\"># 假设表名和类名一致</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(cls, name, bases, attrs)</span><br></pre></td></tr></table></figure></p>\n<p><code>metaclass</code>一共做了三件事情：</p>\n<p>1.排除对<code>Model</code>的修改；</p>\n<p>2.在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个<strong>mappings</strong>的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误；</p>\n<p>3.把表名保存到<strong>table</strong>中，这里简化为表名默认为类名。</p>\n<p>再接下来，创建基类Model：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Model</span><span class=\"params\">(dict)</span>:</span></span><br><span class=\"line\">    __metaclass__ = ModelMetaclass</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, **kw)</span>:</span></span><br><span class=\"line\">        super(Model, self).__init__(**kw)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self[key]</span><br><span class=\"line\">        <span class=\"keyword\">except</span> KeyError:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError(<span class=\"string\">r\"'Model' object has no attribute '%s'\"</span> % key)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__setattr__</span><span class=\"params\">(self, key, value)</span>:</span></span><br><span class=\"line\">        self[key] = value</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        fields = []</span><br><span class=\"line\">        params = []</span><br><span class=\"line\">        args = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> self.__mappings__.iteritems():</span><br><span class=\"line\">            fields.append(v.name)</span><br><span class=\"line\">            params.append(<span class=\"string\">'?'</span>)</span><br><span class=\"line\">            args.append(getattr(self, k, <span class=\"keyword\">None</span>))</span><br><span class=\"line\">        sql = <span class=\"string\">'insert into %s (%s) values (%s)'</span> % (self.__table__, <span class=\"string\">','</span>.join(fields), <span class=\"string\">','</span>.join(params))</span><br><span class=\"line\">        print(<span class=\"string\">'SQL: %s'</span> % sql)</span><br><span class=\"line\">        print(<span class=\"string\">'ARGS: %s'</span> % str(args))</span><br><span class=\"line\">        print(<span class=\"string\">'table name:%s'</span>%self.__table__)</span><br></pre></td></tr></table></figure></p>\n<p>当用户定义一个<code>class User(Model)</code>时，Python解释器首先在当前类User的定义中查找<code>__metaclass__</code>，如果没有找到，就继续在父类Model中查找<code>__metaclass__</code>，找到了，就使用<code>Model</code>中定义的<code>__metaclass__</code>的<code>ModelMetaclass</code>来创建<code>User</code>类，也就是说，<code>metaclass</code>可以隐式地继承到子类，但却在子类处没有显示。</p>\n<p>在接下来实例化User：<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u = User(<span class=\"attribute\">id</span>=12345, <span class=\"attribute\">name</span>=<span class=\"string\">'Michael'</span>, <span class=\"attribute\">email</span>=<span class=\"string\">'test@orm.org'</span>, <span class=\"attribute\">password</span>=<span class=\"string\">'my-pwd'</span>)</span><br><span class=\"line\">u.save()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Found model: User</span></span><br><span class=\"line\"><span class=\"comment\">#Found mapping:email ==&gt; &lt;StringField:email&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#Found mapping:password ==&gt; &lt;StringField:password&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#Found mapping:id ==&gt; &lt;IntField:uid&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#Found mapping:name ==&gt; &lt;StringField:username&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#SQL: insert into User (password,email,username,uid) values (?,?,?,?)</span></span><br><span class=\"line\"><span class=\"comment\">#ARGS: ['my-pwd', 'test@orm.org', 'Michael', 12345]</span></span><br><span class=\"line\"><span class=\"comment\">#table name:User</span></span><br></pre></td></tr></table></figure></p>\n<p>在我们编写的ORM中，ModelMetaclass会删除掉User类的所有类属性，目的就是避免造成混淆。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>数据封装、继承和多态只是面向对象程序设计中最基础的3个概念。在Python中，面向对象还有很多高级特性，允许我们写出非常强大的功能。我们接下来会讨论多重继承、定制类、元类等高级概念。</p>","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>正常情况下，当我们定义了一个class，创建了一个class的实例后，我们可以给该实例绑定任何属性和方法，这就是动态语言的灵活性。<br><figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 绑定属性</span></span><br><span class=\"line\"><span class=\"attr\">s</span> = Student()</span><br><span class=\"line\">s.<span class=\"attr\">name</span> = 'Michael'</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 绑定方法</span></span><br><span class=\"line\">from types <span class=\"built_in\">import</span> MethodType</span><br><span class=\"line\">s.<span class=\"attr\">set_age</span> = MethodType(set_age, s, Student) <span class=\"comment\"># 给实例绑定一个方法</span></span><br><span class=\"line\"></span><br><span class=\"line\">Student.<span class=\"attr\">set_score</span> = MethodType(set_score, None, Student) <span class=\"comment\"># 给class绑定一个方法</span></span><br></pre></td></tr></table></figure></p>\n<p>动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</p>\n<h2 id=\"使用-slots\"><a href=\"#使用-slots\" class=\"headerlink\" title=\"使用__slots__\"></a>使用<code>__slots__</code></h2><p><code>__slots__</code>用以限制class的属性，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class能添加的属性。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">   __slots__ = (<span class=\"string\">'name'</span>, <span class=\"string\">'age'</span>) <span class=\"comment\"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure></p>\n<p>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类起作用，对继承的子类是不起作用的。</p>\n<p>如果要使得在子类中起作用，那要在子类中也定义<code>__slots__</code>，这样，子类允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code>。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\">    __slots__ = (<span class=\"string\">'age'</span>, <span class=\"string\">'name'</span>)</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">new</span><span class=\"params\">(Student)</span>:</span></span><br><span class=\"line\">    __slots__ = (<span class=\"string\">'grade'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s = new()</span><br><span class=\"line\">s.name = <span class=\"string\">'a'</span></span><br><span class=\"line\">s.grade = <span class=\"number\">97</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> s.grade</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用-property\"><a href=\"#使用-property\" class=\"headerlink\" title=\"使用@property\"></a>使用<code>@property</code></h2><p>在绑定属性的时候，如果我们把属性直接暴露出去，其值容易被随意更改。<br>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用的。</p>\n<p>好处有二：<br>1.能检查参数<br>2.方便调用，可以用类似属性的方式来访问</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span><span class=\"params\">(object)</span>:</span></span><br><span class=\"line\"><span class=\"meta\">    @property</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> self._score</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @score.setter</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self,value)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value, int):</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">'score must be an integer!'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"number\">0</span>&lt;= value &lt;= <span class=\"number\">100</span>:</span><br><span class=\"line\">            self._score = value</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> ValueError(<span class=\"string\">\"取值范围为0到100！\"</span>)</span><br><span class=\"line\"><span class=\"meta\">    @score.deleter</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">score</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">del</span> self._score</span><br><span class=\"line\">        <span class=\"keyword\">print</span> <span class=\"string\">\"score is already delete\"</span></span><br><span class=\"line\"></span><br><span class=\"line\">s = Student()</span><br><span class=\"line\">s.score = <span class=\"number\">99</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> s.score</span><br><span class=\"line\"><span class=\"keyword\">del</span> s.score</span><br><span class=\"line\"></span><br><span class=\"line\">s = Student()</span><br><span class=\"line\">s.score = <span class=\"number\">99</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> s.score</span><br><span class=\"line\"><span class=\"comment\"># 99</span></span><br><span class=\"line\"><span class=\"comment\"># score is already delete</span></span><br></pre></td></tr></table></figure>\n<p>我们在对实例属性操作的时候，就知道<code>@property</code>很可能不是直接暴露的，而是通过<code>getter</code>、<code>setter</code> 和<code>deleter</code>方法来实现的。</p>\n<p>把一个<code>getter</code>方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<a href=\"mailto:`@score.setter\" target=\"_blank\" rel=\"noopener\">`@score.setter</a><code>，负责把一个</code>setter`方法变成属性赋值。</p>\n<p>当然，你也有可能看到一些遗留的代码：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_score</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>._score</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_score</span><span class=\"params\">(<span class=\"keyword\">self</span>, value)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> isinstance(value, int)<span class=\"symbol\">:</span></span><br><span class=\"line\">            raise ValueError(<span class=\"string\">'score must be an integer!'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> value &lt; <span class=\"number\">0</span> <span class=\"keyword\">or</span> value &gt; <span class=\"number\">100</span><span class=\"symbol\">:</span></span><br><span class=\"line\">            raise ValueError(<span class=\"string\">'score must between 0 ~ 100!'</span>)</span><br><span class=\"line\">        <span class=\"keyword\">self</span>._score = value</span><br><span class=\"line\">    score = property(get_score, set_score)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">s = Student()</span><br><span class=\"line\">s.score = <span class=\"number\">99</span></span><br><span class=\"line\">print s.score</span><br></pre></td></tr></table></figure></p>\n<p>通过增加一句<code>score = property(get_score, set_score)</code>，它允许score属性设置并获取值本身而不破坏原有代码。</p>\n<h2 id=\"多重继承\"><a href=\"#多重继承\" class=\"headerlink\" title=\"多重继承\"></a>多重继承</h2><p>通过多重继承，一个子类就可以同时获得多个父类的所有功能。</p>\n<h3 id=\"Mixin\"><a href=\"#Mixin\" class=\"headerlink\" title=\"Mixin\"></a>Mixin</h3><p>如果不是单一继承，要实现多个继承，如让<code>Ostrich</code>除了继承自<code>Bird</code>外，再同时继承<code>Runnable</code>。这种设计通常称之为Mixin。</p>\n<p>Mixin的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个Mixin的功能，而不是设计多层次的复杂的继承关系。</p>\n<p>这样一来，我们不需要复杂而庞大的继承链，只要选择组合不同的类的功能，就可以快速构造出所需的子类。</p>\n<p>注：Java没有此类设计。</p>\n<h2 id=\"定制类\"><a href=\"#定制类\" class=\"headerlink\" title=\"定制类\"></a>定制类</h2><p>Python的class中还有许多<code>__slots__</code>，<code>__len__()</code>这样有特殊用途的函数，可以帮助我们定制类。</p>\n<h3 id=\"str-和-repr\"><a href=\"#str-和-repr\" class=\"headerlink\" title=\"__str__和__repr__\"></a><code>__str__</code>和<code>__repr__</code></h3><p>用来定制打印实例的内容。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, name)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\"></span><br><span class=\"line\">print Student(<span class=\"string\">'Michael'</span>)</span><br><span class=\"line\"><span class=\"comment\"># &lt;__main__.Student object at 0x109afb190&gt;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在类中定义加一条</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'Student object (name: %s)'</span> % <span class=\"keyword\">self</span>.name</span><br><span class=\"line\"></span><br><span class=\"line\">print Student(<span class=\"string\">'Michael'</span>)</span><br><span class=\"line\"><span class=\"comment\"># Student object (name: Michael)</span></span><br></pre></td></tr></table></figure></p>\n<p>另外，发现直接这样写还是会结果不同<br><figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"attribute\">s</span> = Student(<span class=\"string\">'Michael'</span>)</span><br><span class=\"line\"> s</span><br><span class=\"line\"><span class=\"comment\"># &lt;__main__.Student object at 0x109afb310&gt;</span></span><br></pre></td></tr></table></figure></p>\n<p>因为直接显示变量调用的不是<code>__str__()</code>，而是<code>__repr__()</code>，两者的区别是<code>__str__()</code>返回用户看到的字符串，而<code>__repr__()</code>返回程序开发者看到的字符串，也就是说，<code>__repr__()</code>是为调试服务的。</p>\n<p>因此，在定义里再加一条，省时省力的写法：<br><figure class=\"highlight markdown\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"strong\">__repr__</span> = <span class=\"strong\">__str__</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"iter\"><a href=\"#iter\" class=\"headerlink\" title=\"__iter__\"></a><code>__iter__</code></h3><p>用于<code>for···in</code>循环，返回一个迭代对象。然后，Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.a, <span class=\"keyword\">self</span>.b = <span class=\"number\">0</span>, <span class=\"number\">1</span>  <span class=\"comment\"># 初始化两个计数器a，b</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__iter__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>  <span class=\"comment\"># 实例本身就是迭代对象，故返回自己</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">next</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.a, <span class=\"keyword\">self</span>.b = <span class=\"keyword\">self</span>.b, <span class=\"keyword\">self</span>.a + <span class=\"keyword\">self</span>.b  <span class=\"comment\"># 计算下一个值</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"keyword\">self</span>.a &gt; <span class=\"number\">100000</span>:  <span class=\"comment\"># 退出循环的条件</span></span><br><span class=\"line\">            raise StopIteration()</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>.a  <span class=\"comment\"># 返回下一个值</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> n <span class=\"keyword\">in</span> Fib()<span class=\"symbol\">:</span></span><br><span class=\"line\">    print n</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"getitem\"><a href=\"#getitem\" class=\"headerlink\" title=\"__getitem__\"></a><code>__getitem__</code></h3><p>如上所说，Fib实例虽然能作用于for循环，看起来和list有点像，但是，把它当成list来使用还是不行，取不了其中的元素。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Fib</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getitem__</span><span class=\"params\">(<span class=\"keyword\">self</span>, n)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        a, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(n)<span class=\"symbol\">:</span></span><br><span class=\"line\">            a, b = b, a + b</span><br><span class=\"line\">        <span class=\"keyword\">return</span> a</span><br></pre></td></tr></table></figure></p>\n<p>这样，通过调用<code>print Fib()[2016]</code>就可以访问第2016项了（第0项就是原来数）。</p>\n<p>如果要实现如同<code>list</code>的切片操作，需判断传入值是slice还是int：<br><figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Fib(object):</span><br><span class=\"line\">    def __getitem__(self, n):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, int):</span><br><span class=\"line\">            <span class=\"keyword\">a</span>, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">                <span class=\"keyword\">a</span>, b = b, <span class=\"keyword\">a</span> + b</span><br><span class=\"line\">            <span class=\"literal\">return</span> <span class=\"keyword\">a</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> isinstance(n, slice):</span><br><span class=\"line\">            <span class=\"built_in\">start</span> = n.<span class=\"built_in\">start</span></span><br><span class=\"line\">            <span class=\"built_in\">stop</span> = n.<span class=\"built_in\">stop</span></span><br><span class=\"line\">            <span class=\"keyword\">a</span>, b = <span class=\"number\">1</span>, <span class=\"number\">1</span></span><br><span class=\"line\">            L = []</span><br><span class=\"line\">            <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"built_in\">stop</span>):</span><br><span class=\"line\">                <span class=\"keyword\">if</span> x &gt;= <span class=\"built_in\">start</span>:</span><br><span class=\"line\">                    L.append(<span class=\"keyword\">a</span>)</span><br><span class=\"line\">                <span class=\"keyword\">a</span>, b = b, <span class=\"keyword\">a</span> + b</span><br><span class=\"line\">            <span class=\"literal\">return</span> L</span><br></pre></td></tr></table></figure></p>\n<p>但是上述例子中没有对step参数作处理，也没有对负数作处理，所以，要正确实现一个<code>__getitem__()</code>还是有很多工作要做的。</p>\n<p>此外，如果把对象看成dict，<strong>getitem</strong>()的参数也可能是一个可以作key的object，例如str。</p>\n<p>与之对应的是<strong>setitem</strong>()方法，把对象视作list或dict来对集合赋值。最后，还有一个<strong>delitem</strong>()方法，用于删除某个元素。</p>\n<p>总之，通过上面的方法，我们自己定义的类表现得和Python自带的list、tuple、dict没什么区别，这完全归功于动态语言的“鸭子类型”（“鸭子类型”的语言是这么推断的：一只鸟走起来像鸭子、游起泳来像鸭子、叫起来也像鸭子，那它就可以被当做鸭子。也就是说，它不关注对象的类型，而是关注对象具有的行为(方法)。），不需要强制继承某个接口。</p>\n<h3 id=\"getattr\"><a href=\"#getattr\" class=\"headerlink\" title=\"__getattr__\"></a><code>__getattr__</code></h3><p>正常情况下，当我们调用类的方法或属性时，如果不存在，就会报错。这个方法的优点就是动态返回一个属性。</p>\n<p>当调用不存在的属性时，比如score，Python解释器会试图调用<strong>getattr</strong>(self, ‘score’)来尝试获得属性。<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = <span class=\"string\">'Michael'</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(<span class=\"keyword\">self</span>, attr)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> attr==<span class=\"string\">'score'</span><span class=\"symbol\">:</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">99</span></span><br><span class=\"line\">s.score</span><br><span class=\"line\"><span class=\"comment\"># 99</span></span><br></pre></td></tr></table></figure></p>\n<p>这种完全动态调用的特性有什么实际作用呢？作用就是，可以针对完全动态的情况作调用。</p>\n<p>作用之一就是动态调用API，利用完全动态的<code>__getattr__</code>，我们可以写出一个链式调用：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Chain</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, path=<span class=\"string\">''</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>._path = path</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(<span class=\"keyword\">self</span>, path)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> Chain(<span class=\"string\">'%s/%s'</span> % (<span class=\"keyword\">self</span>._path, path))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">self</span>._path</span><br><span class=\"line\">print Chain().status.user.timeline.list</span><br><span class=\"line\"><span class=\"comment\"># '/status/user/timeline/list'</span></span><br><span class=\"line\"><span class=\"comment\">#调用Github的URL时，需要把:user替换为实际用户名。</span></span><br></pre></td></tr></table></figure></p>\n<p>这样就能很方便的调用API了。</p>\n<h3 id=\"call\"><a href=\"#call\" class=\"headerlink\" title=\"__call__\"></a><code>__call__</code></h3><p><code>__call__</code>能够直接就可以对实例进行调用。</p>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, name)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__call__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        print(<span class=\"string\">'My name is %s.'</span> % <span class=\"keyword\">self</span>.name)</span><br><span class=\"line\">s = Student(<span class=\"string\">'Michael'</span>)</span><br><span class=\"line\">s()</span><br><span class=\"line\"><span class=\"comment\"># My name is Michael.</span></span><br></pre></td></tr></table></figure>\n<p>对实例进行直接调用就好比对一个函数进行调用一样，所以你完全可以把对象看成函数，把函数看成对象，因为这两者之间本来就没啥根本的区别。</p>\n<p>那么，怎么判断一个变量是对象还是函数呢？其实，更多的时候，我们需要判断一个对象是否能被调用，能被调用的对象就是一个Callable对象，比如函数和我们上面定义的带有<strong>call()</strong>的类实例：<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">callable(<span class=\"name\">Student</span>())</span><br><span class=\"line\"># True</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"使用元类\"><a href=\"#使用元类\" class=\"headerlink\" title=\"使用元类\"></a>使用元类</h2><h3 id=\"type\"><a href=\"#type\" class=\"headerlink\" title=\"type()\"></a>type()</h3><p>type()函数可以查看一个类型或变量的类型，Hello是一个class，它的类型就是type，而h是一个实例，它的类型就是class Hello。</p>\n<p>还可以创建一个新的类型。<br>要创建一个class对象，type()函数依次传入3个参数：<br>1.class的名称；<br>2.继承的父类集合，注意Python支持多重继承，如果只有一个父类，别忘了tuple的单元素写法；<br>3.class的方法名称与函数绑定，这里我们把函数fn绑定到方法名hello上。</p>\n<figure class=\"highlight elixir\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">fn</span></span>(<span class=\"keyword\">self</span>, name=<span class=\"string\">'world'</span>): <span class=\"comment\"># 先定义函数</span></span><br><span class=\"line\">    print(<span class=\"string\">'Hello, %s.'</span> % name)</span><br><span class=\"line\"></span><br><span class=\"line\"> Hello = type(<span class=\"string\">'Hello'</span>, (object,), dict(hello=<span class=\"keyword\">fn</span>)) <span class=\"comment\"># 创建Hello class</span></span><br></pre></td></tr></table></figure>\n<p>通过<code>type()</code>数创建的类和直接写class是完全一样的，因为Python解释器遇到class定义时，仅仅是扫描一下class定义的语法，然后调用<code>type()</code>函数创建出class。</p>\n<p>###　metaclass</p>\n<p><code>metaclass</code>直译为“元类”，用来控制类的创建行为。<br>创建类的流程应该是：先定义metaclass，就可以创建类，最后创建实例。</p>\n<p>用到比较少，但是是Python面向对象里最难理解，也是最难使用的魔术代码。</p>\n<p>定义metaclass时，metaclass的类名总是以Metaclass结尾，以便清楚地表示这是一个metaclass。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MylistMetaclass</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, name, bases, attrs)</span>:</span></span><br><span class=\"line\">        attrs[<span class=\"string\">'add'</span>] = <span class=\"keyword\">lambda</span> self, value: self.append(value)</span><br><span class=\"line\">        attrs[<span class=\"string\">'dele'</span>] = <span class=\"keyword\">lambda</span> self, value: self.remove(value)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mylist</span><span class=\"params\">(list)</span>:</span></span><br><span class=\"line\">    __metaclass__ = MylistMetaclass</span><br><span class=\"line\"></span><br><span class=\"line\">a = Mylist()</span><br><span class=\"line\"></span><br><span class=\"line\">a.add(<span class=\"string\">\"a\"</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">print</span> a</span><br><span class=\"line\">a.dele(<span class=\"string\">\"a\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">print</span> a</span><br></pre></td></tr></table></figure>\n<p>当我们写下<code>__metaclass__ = ListMetaclass</code>语句时，魔术就生效了，它指示Python解释器在创建MyList时，要通过<code>ListMetaclass.__new__()</code>来创建，在此，我们可以修改类的定义，比如，加上新的方法，然后，返回修改后的定义。</p>\n<p><code>__new__()</code>方法接收到的参数依次是：</p>\n<p>1.当前准备创建的类的对象；</p>\n<p>2.类的名字；</p>\n<p>3.类继承的父类集合；</p>\n<p>4.类的方法集合。</p>\n<p>那么，动态修改的意义在哪？一般的写直接添加’add’放法即可。</p>\n<p>但是，总会遇到需要通过<code>metaclass</code>修改类定义的。ORM就是一个典型的例子。</p>\n<p>ORM全称“Object Relational Mapping”，即对象-关系映射，就是把关系数据库的一行映射为一个对象，也就是一个类对应一个表，这样，写代码更简单，不用直接操作SQL语句。</p>\n<p>要编写一个ORM框架，所有的类都只能动态定义，因为只有使用者才能根据表的结构定义出对应的类来。</p>\n<p>让我们来尝试编写一个ORM框架。</p>\n<p>编写底层模块的第一步，就是先把调用接口写出来。比如，使用者如果使用这个ORM框架，想定义一个User类来操作对应的数据库表User，我们期待他写出这样的代码：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span><span class=\"params\">(Model)</span>:</span></span><br><span class=\"line\">    <span class=\"comment\"># 定义类的属性到列的映射：</span></span><br><span class=\"line\">    id = IntegerField(<span class=\"string\">'id'</span>)</span><br><span class=\"line\">    name = StringField(<span class=\"string\">'username'</span>)</span><br><span class=\"line\">    email = StringField(<span class=\"string\">'email'</span>)</span><br><span class=\"line\">    password = StringField(<span class=\"string\">'password'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个实例：</span></span><br><span class=\"line\">u = User(id=<span class=\"number\">12345</span>, name=<span class=\"string\">'Michael'</span>, email=<span class=\"string\">'test@orm.org'</span>, password=<span class=\"string\">'my-pwd'</span>)</span><br><span class=\"line\"><span class=\"comment\"># 保存到数据库：</span></span><br><span class=\"line\">u.save()</span><br></pre></td></tr></table></figure></p>\n<p>首先来定义Field类，它负责保存数据库表的字段名和字段类型：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Field</span>(<span class=\"title\">object</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>, name, column_type)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">self</span>.name = name</span><br><span class=\"line\">        <span class=\"keyword\">self</span>.column_type = column_type</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__str__</span><span class=\"params\">(<span class=\"keyword\">self</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'&lt;%s:%s&gt;'</span> % (<span class=\"keyword\">self</span>.__class_<span class=\"number\">_</span>.__name_<span class=\"number\">_</span>, <span class=\"keyword\">self</span>.name)</span><br></pre></td></tr></table></figure></p>\n<p>然后，在此基础上进一步定义各类Field：<br><figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">StringField</span>(<span class=\"title\">Field</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>,name)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">super</span>(StringField, <span class=\"keyword\">self</span>).__init_<span class=\"number\">_</span>(name, <span class=\"string\">'varchar(100)'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IntField</span>(<span class=\"title\">Field</span>):</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(<span class=\"keyword\">self</span>,name)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">        <span class=\"keyword\">super</span>(IntField,<span class=\"keyword\">self</span>).__init_<span class=\"number\">_</span>(name, <span class=\"string\">'bigint'</span>)</span><br></pre></td></tr></table></figure></p>\n<p>接下来开始写<code>metaclass</code>：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ModelMetaclass</span><span class=\"params\">(type)</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__new__</span><span class=\"params\">(cls, name, bases, attrs)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> name == <span class=\"string\">'Model'</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> type.__new__(cls, name, bases, attrs)</span><br><span class=\"line\">        print(<span class=\"string\">'Found model: %s'</span> % name)</span><br><span class=\"line\">        mappings = dict()</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> attrs.iteritems():</span><br><span class=\"line\">            <span class=\"keyword\">if</span> isinstance(v, Field):</span><br><span class=\"line\">                <span class=\"keyword\">print</span> <span class=\"string\">\"Found mapping:%s ==&gt; %s\"</span>%(k, v)</span><br><span class=\"line\">                mappings[k] = v</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k <span class=\"keyword\">in</span> mappings.iterkeys():</span><br><span class=\"line\">            attrs.pop(k)</span><br><span class=\"line\">        attrs[<span class=\"string\">'__mappings__'</span>] = mappings <span class=\"comment\"># 保存属性和列的映射关系</span></span><br><span class=\"line\">        attrs[<span class=\"string\">'__table__'</span>] = name <span class=\"comment\"># 假设表名和类名一致</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> type.__new__(cls, name, bases, attrs)</span><br></pre></td></tr></table></figure></p>\n<p><code>metaclass</code>一共做了三件事情：</p>\n<p>1.排除对<code>Model</code>的修改；</p>\n<p>2.在当前类（比如User）中查找定义的类的所有属性，如果找到一个Field属性，就把它保存到一个<strong>mappings</strong>的dict中，同时从类属性中删除该Field属性，否则，容易造成运行时错误；</p>\n<p>3.把表名保存到<strong>table</strong>中，这里简化为表名默认为类名。</p>\n<p>再接下来，创建基类Model：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Model</span><span class=\"params\">(dict)</span>:</span></span><br><span class=\"line\">    __metaclass__ = ModelMetaclass</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, **kw)</span>:</span></span><br><span class=\"line\">        super(Model, self).__init__(**kw)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__getattr__</span><span class=\"params\">(self, key)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> self[key]</span><br><span class=\"line\">        <span class=\"keyword\">except</span> KeyError:</span><br><span class=\"line\">            <span class=\"keyword\">raise</span> AttributeError(<span class=\"string\">r\"'Model' object has no attribute '%s'\"</span> % key)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__setattr__</span><span class=\"params\">(self, key, value)</span>:</span></span><br><span class=\"line\">        self[key] = value</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">save</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        fields = []</span><br><span class=\"line\">        params = []</span><br><span class=\"line\">        args = []</span><br><span class=\"line\">        <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> self.__mappings__.iteritems():</span><br><span class=\"line\">            fields.append(v.name)</span><br><span class=\"line\">            params.append(<span class=\"string\">'?'</span>)</span><br><span class=\"line\">            args.append(getattr(self, k, <span class=\"keyword\">None</span>))</span><br><span class=\"line\">        sql = <span class=\"string\">'insert into %s (%s) values (%s)'</span> % (self.__table__, <span class=\"string\">','</span>.join(fields), <span class=\"string\">','</span>.join(params))</span><br><span class=\"line\">        print(<span class=\"string\">'SQL: %s'</span> % sql)</span><br><span class=\"line\">        print(<span class=\"string\">'ARGS: %s'</span> % str(args))</span><br><span class=\"line\">        print(<span class=\"string\">'table name:%s'</span>%self.__table__)</span><br></pre></td></tr></table></figure></p>\n<p>当用户定义一个<code>class User(Model)</code>时，Python解释器首先在当前类User的定义中查找<code>__metaclass__</code>，如果没有找到，就继续在父类Model中查找<code>__metaclass__</code>，找到了，就使用<code>Model</code>中定义的<code>__metaclass__</code>的<code>ModelMetaclass</code>来创建<code>User</code>类，也就是说，<code>metaclass</code>可以隐式地继承到子类，但却在子类处没有显示。</p>\n<p>在接下来实例化User：<br><figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">u = User(<span class=\"attribute\">id</span>=12345, <span class=\"attribute\">name</span>=<span class=\"string\">'Michael'</span>, <span class=\"attribute\">email</span>=<span class=\"string\">'test@orm.org'</span>, <span class=\"attribute\">password</span>=<span class=\"string\">'my-pwd'</span>)</span><br><span class=\"line\">u.save()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#Found model: User</span></span><br><span class=\"line\"><span class=\"comment\">#Found mapping:email ==&gt; &lt;StringField:email&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#Found mapping:password ==&gt; &lt;StringField:password&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#Found mapping:id ==&gt; &lt;IntField:uid&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#Found mapping:name ==&gt; &lt;StringField:username&gt;</span></span><br><span class=\"line\"><span class=\"comment\">#SQL: insert into User (password,email,username,uid) values (?,?,?,?)</span></span><br><span class=\"line\"><span class=\"comment\">#ARGS: ['my-pwd', 'test@orm.org', 'Michael', 12345]</span></span><br><span class=\"line\"><span class=\"comment\">#table name:User</span></span><br></pre></td></tr></table></figure></p>\n<p>在我们编写的ORM中，ModelMetaclass会删除掉User类的所有类属性，目的就是避免造成混淆。</p>\n<blockquote>\n<p>此python学习路径来源于<a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000\" target=\"_blank\" rel=\"noopener\">廖雪峰的Python教程</a>的一个学习内容的总结。以便于自己后的学习和整理。</p>\n</blockquote>"},{"title":"数据库杂记","date":"2016-10-26T13:22:50.000Z","_content":"\n最近面试面到数据结构的题有点爆炸。基本都忘光了，记录一下基础的东西吧。\n\n<!--more-->\n## SQL语言的基本概念\n数据(Data)是数据库中存储的基本对象。\n\n数据库(DataBase，简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。\n\n\n数据库管理系统(DBMS，Database Management System)\n位于用户与操作系统之间的一层数据管理软件。\n是基础软件，是一个大型复杂的软件系统。\n\n数据库系统(DBS，DataBase System)在计算机系统中引入数据库后的系统构成，包括硬件、软件、数据和人员。\n\n### SQL语言的主要特点\n1.SQL语言是一种非过程语言，即用户只要提出“干什么”即可，不必管具体操作过程，也不必了解数据的存取路径，只要指明所需的数据即可。\n\n2.SQL语言是一种面向集合的语言，每个命令的操作对象是一个或多个关系，结果也是一个关系。\n\n3.SQL语言既是自含式语言，又是嵌入式语言。可独立使用交互命令，适用于终端用户、应用程序员和DBA；也可嵌入在高级语言中使用，供应用程序员开发应用程序。\n\nSQL语言具有:\n数据定义（DEFINITION）(CREATE,DROP,ALTER)，\n数据查询（QUERY）(SELECT)，\n数据操纵（MANIPULATION）(INSERT,UPDATE,DELETE)，\n数据控制（CONTROL）(GRANT,REVOKE)。\n\n基本表（BASE TABLE）：是独立存在的表，不是由其它的表导出的表。一个关系对应一个基本表，一个或多个基本表对应一个存储文件。\n\n视图（VIEW）：\n是一个虚拟的表，是从一个或几个基本表导出的表。它本身不独立存在于数据库中，数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。\n当基本表中的数据发生变化时，从视图中查询出来的数据也随之改变。\n\n在用户看来，视图是通过不同路径去看一个实际表，就象一个窗口一样，我们通过窗户去看外面的高楼，可以看到高楼的不同部分，而透过视图可以看到数据库中自己感兴趣的内容。\n\n索引（INDEX）：是一种和表格或视图有关的结构，可以加快从表格或视图中获得数据行。表格索引可以是群集的，也可以是非群集的。群集指数据在物理上是基于索引关键字的顺序存放的。\n\n关键字：是众多列中一列或组，它唯一识别一行（主关键字），定义两个表格之间的关系（外关键字），或者用于构建一个索引\n\n存储过程：是一种Transact-SQL语句，它们被编译成一个执行计划。该过程用于性能优化和控制访问。\n\n约束：定义了有关列中允许的值的规则，是加强数据完整性的标准机制。\n\n触发器：存储过程的一个特殊类，用于当对一个表格或视图发出update、insert 或delete语句时，能自动执行。\n\n\n### 三级模式结构\nSQL语言支持数据库的三级模式结构，如图所示。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。\n\n![三级模式结构](http://p1.bqimg.com/567571/405330844246062d.png)\n\n## 基本表的操作\n\n### 创建基本表\n创建一个数据表时主要包括以下几个组成部分：\n\n（1）字段名（列名）：字段名可长达128个字符。字段名可包含中文、英文字母、下划线、#号、货币符号（￥）及AT符号(@)。同一表中不许有重名列；\n\n（2）字段数据类型；\n\n（3）字段的长度、精度和小数位数；\n\n（4）NULL值与DEFAULT值：DEFAULT值表示某一字段的默认值，当没有输入数据时，则使用此默认的值。\n\n\n在SQL语言中，使用语句CREATE TABLE创建数据表，其基本语法格式为：\n\n```\nCREATE TABLE [ database_name . [ schema_name ] . | schema_name . ] <表名>\n  (     <列定义>[{，<列定义>|<表约束>}][,\n        [CONSTRAINT 主键约束] PRIMARY KY （属性名）][,\n        [CONSTRAINT 检查约束] CHECK（逻辑表达式）][,\n        [CONSTRAINT 外键约束] REFRENCES 参照表（参照属性）[,…n]]\n  )\n  [ON {文件组|默认文件组}]\n```\n### 定义完整性约束\n在SQL SERVER中可以定义五种类型的完整性约束。\n#### NULL/NOT NULL\n是否允许该字段的值为NULL。表示“不知道”、“不确定”或“没有数据”的意思。\n如主键列就不允许出现空值，否则就失去了唯一标识一条记录的作用\n#### UNIQUE约束\n用于指明基本表在某一列或多个列的组合上的取值必须唯一。\n\n定义了UNIQUE约束的那些列称为唯一键，系统自动为唯一键建立唯一索引，从而保证了唯一键的唯一性。\n#### PRIMARY KEY约束\nPRIMARY KEY约束用于定义基本表的主键，起唯一标识作用，其值不能为NULL，也不能重复，以此来保证实体的完整性。\nPRIMARY KEY与UNIQUE的区别：\n1.在一个基本表中只能定义一个PRIMARY KEY约束，但可定义多个UNIQUE约束；\n2.对于指定为PRIMARY KEY的一个列或多个列的组合，其中任何一个列都不能出现空值，而对于UNIQUE所约束的唯一键，则允许为空。\n#### FOREIGN KEY约束\nFOREIGN KEY约束指定某一个列或一组列作为外部键，其中，包含外部键的表称为从表，包含外部键所引用的主键或唯一键的表称主表。\n#### CHECK约束\nCHECK约束用来检查字段值所允许的范围，如，一个字段只能输入整数，而且限定在0-100的整数，以此来保证域的完整性。\n\n\n\n### 修改基本表\n由于应用环境和应用需求的变化，经常需要修改基本表的结构，比如，增加新列和完整性约束、修改原有的列定义和完整性约束等。\n#### ADD方式\n用于增加新列和完整性约束。\n\n定义方式同`CREATE TABLE`语句中的定义方式相同，其语法格式为：\n```\n//ALTER TABLE <表名> ADD <列定义> | <完整性约束定义>\nALTER TABLE Student ADD   RegisterDate DATETIME,\n```\n#### ALTER方式\n\n用于修改某些列，其语法格式为：\n```\n//ALTER TABLE<表名> ALTER COLUMN <列名><数据类型>[NULL|NOT NULL]\nALTER TABLE Student ALTER COLUMN Sage SMALEINT NULL\n```\n要求：\n1.不能改变列名；\n2.不能将含有空值的列的定义修改为NOT NULL约束；\n3.若列中已有数据，则不能减少该列的宽度，也不能改变其数据类型；\n4.只能修改NULL|NOT NULL约束，其它类型的约束在修改之前必须先删除，然后再重新添加修改过的约束定义。\n\n#### DROP方式\n删除完整性约束定义，其语法格式为：\n```\n//ALTER TABLE<表名> DROP CONSTRAINT <约束名>\nALTER TABLE Student DROP  UNIQUE(SNAME)\n```\n\n### 删除基本表\n```\nDROP TABLE <表名>\n```\n## 数据库表的基本操作\nSQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。\n\n### 插入数据记录\n有两种方式，一种是向具体记录插入常量数据；另一种是把子查询的结果输入到另一个表中去。前者智能插入一条数据，后者一次可以插入多条。\n#### 插入一行新记录\n```\n//INSERT INTO <表名>[(<列名1>[,<列名2>…])] VALUES(<值>)\n\nINSERT INTO  S VALUES  ('s7','小刚','男',21,'计算机')\n\n```\n注意：\n\n必须用逗号将各个数据分开，字符型数据要用单引号括起来。\n\nINTO子句中没有指定列名，则新插入的记录必须在每个属性列上均有值，且VALUES子句中值的排列顺序要和表中各属性列的排列顺序一致。\n#### 插入一行部分数据\n在SC表中插入一条选课记录（’S7’,’C1’）。\n```\nINSERT INTO SC (SNO,CNO)\n         VALUES ('s7',‘c1')\n```\n注意：\n\n将VALUES子句中的值按照INTO子句中指定列名的顺序插入到表中。\n\n对于INTO子句中没有出现的列，则新插入的记录在这些列上将取空值，如上例的SCORE即赋空值。\n但在表定义时有NOT NULL约束的属性列不能取空值。      \n#### 插入多行记录\n1.\n```\nINSERT INTO `userTable` (`user_id`, `user_name`) VALUES\n(1, 'dsf'),\n(2, 'fgy'),\n(3, 'faad');\n```\n这样只需执行一次SQL查询，即可插入多行记录，大大提高了效率，使用php编程的时候，可以使用字符串连接的方式连接sql语句即可:\n```\n$a = 1;\nwhile (5 == $a)\n{\n    if (1 == $a)\n        $sql = \"INSERT INTO tbl_name (col1,col2) VALUES ($a,$b)\";\n    else\n        $sql .= \",($a,$b)\";\n\n    $a++;\n    $b++;\n}\nmysql_query($sql);\n```\n\n用于表间的拷贝，将一个表中的数据抽取数行插入另一表中，可以通过子查询来实现。\n```\n///INSERT INTO <表名> [(<列名1>[,<列名2>…])] 子查询\nINSERT INTO MySalesReason\n    SELECT SalesReasonID, Name, ModifiedDate\n    FROM AdventureWorks2008R2.Sales.SalesReason\n    WHERE ReasonType = N'Marketing';\n```\n### 修改数据记录\n```\n//UPDATE <表名> SET <列名>=<表达式> [,<列名>=<表达式>]…[WHERE <条件>]\n//修改一行\n\nUPDATE T \n    SET DEPT='信息' \n  WHERE TN='刘伟'\n\n//用子查询选择要修改的行\nUPDATE T \n\tSET COMN=COMN+100\n WHERE TNO IN \n\t (SELECT T.TNO \n\t\tFROM T,TC\n\t   WHERE T.TNO=TC.TNO\n\t\t\tAND TC.CNO='C5')\n//用子查询提供要修改的值\n\nUPDATE T\n\tSET SAL =\n\t\t(SELECT 1.2*AVG(SAL) \n\t\tFROM T)\n```\n### 删除数据记录\n```\n//DELETE FROM <表名> [WHERE <条件>]\n//删除一行\nDELETE \n    FROM T \n WHERE TN=’刘伟’\n//删除多行\nDELETE \n    FROM TC\n//利用子查询选择要删除的行\nDELETE\n    FROM TC \n WHERE TNO=  \n     (SELECT TNO\n          FROM T\n       WHERE TN=’ 刘伟’)\n```\n\n\n## 索引\n索引的作用：\n1. 加快查询速度；\n2. 保证行的唯一性。\n### 索引的分类\n按照索引记录的存放位置分类：\n\n聚集索引：按照索引的字段排列记录，并且依照排好的顺序将记录存储在表中。\n\n非聚集索引：按照索引的字段排列记录，但是排列的结果并不会存储在表中，而是另外存储。\n\n### 唯一索引\n唯一索引表示表中每一个索引值只对应唯一的数据记录，\n这与表的PRIMARY KEY的特性类似，因此唯一性索引常用于PRIMARY KEY的字段上，以区别每一笔记录。\n\n当表中有被设置为UNIQUE的字段时，SQL SERVER会自动建立一个非聚集的唯一性索引。\n\n而当表中有PRIMARY KEY的字段时，SQL SERVER会在PRIMARY KEY字段建立一个非聚集索引。\n\n### 建立索引\n```\n//CREATE [UNIQUE] [CLUSTERED|NONCLUSTERED] INDEX <索引名> ON <表名>  (<列名> [次序] [{,<列名>}] [次序]…)\n//在agent表中建立一个索引aidx，保证每一行都有唯一的aid值。\ncreate unique index aidx on agents(aid);\n```\n次序用来指定索引值的排列顺序，可为ASC（升序）或DESC（降序），缺省值为ASC。\n```\nUSE STUDENT\nCREATE UNIQUE INDEX SCI ON SC(SNO,CNO)\n```\n执行此命令后，为SC表建立一个索引名为SCI的唯一索引\n此索引为SNO和CNO两列的复合索引，即对SC表中的行先按SNO的递增顺序索引，对于相同的SNO，又按CNO的递增顺序索引。\n### 删除索引\n建立索引是为了提高查询速度，但随着索引的增多，数据更新时，系统会花费许多时间来维护索引。这时，应删除不必要的索引。\n```\n//DROP INDEX 数据表名.索引名\n//删除表SC的索引SCI。\t\t\nDROP INDEX SC.SCI\n```\n### 查看索引\n#### 查看索引信息\n报告有关表或视图上索引的信息，当前数据库中表或视图的名称的数据类型为nvarchar(776)。\n```\n//sp_helpindex [ @objname = ] '表或视图的名称'\nUse  eduDB\nGO\nEXEC sp_helpindex ‘s’\n```\n#### 查看索引的空间信息\n显示行数、保留的磁盘空间以及当前数据库中的表所使用的磁盘空间，或显示由整个数据库保留和使用的磁盘空间\n\n```\n//sp_spaceused ['表的名称']\nUSE eduDB\ngo\nEXEC sp_spaceused ‘s’\n```\n#### 查看索引属性\n显示表中指定索引的属性信息。可以是下列值中的一个。\n\n```\n//INDEXPROPERTY (表的标识号，索引的名称, 属性)\nUSE eduDB\ngo\nSELECT INDEXPROPERTY(OBJECT_ID(' sc '), ' IX_CID',  'IsPadIndex') \n```\n## 视图\n视图是虚表，其数据不存储，其记录来自基本表，只在数据库中存储其定义。\n视图在概念上与基本表等同，用户可以在视图上再定义视图，可以对视图进行查询、删除、更新等操作。\n### 定义视图\n定义视图使用语句CREATE VIEW,格式为：\n```\nCREATE VIEW [架构名].<视图名>[(<视图列表>)]\n[WITH  ENCRYPTION]\nAS <子查询>\n[WITH CHECK OPTION]\n```\n以下两种情况下，视图列名不可省略：\n1.视图由多个表连接得到，在不同的表中存在同名列，则需指定列名；\n2.当视图的列名为表达式或库函数的计算结果时，而不是单纯的属性名时，则需指明列名。\n\n在子查询中不允许使用ORDER BY 子句和DISTINCT短语，如果需要排序，则可在视图定义后，对视图查询时再进行排序。\n\n视图创建后，只在数据字典中存放视图的定义，而其中的子查询SELECT语句并不执行。\n只有当用户对视图进行操作时，才按照视图的定义将数据从基本表中取出。\n\n ### 删除视图\n```\nDROP VIEW <视图名>\n```\n视图删除后，只会删除该视图在数据字典中的定义，而与该视图有关的基本表中的数据不会受任何影响，由此视图导出的其他视图的定义不会删除，但已无任何意义。用户应该把这些视图删除。\n\n### 查询视图\n视图定义后，对视图的查询操作如同对基本表的查询操作一样。更新操作也一致。\n\n### 使用视图的优点\n1. **利于数据保密**，对不同的用户定义不同的视图，使用户只能看到与自己有关的数据。\n例如,对教师表创建了计算机系视图，本系教师只能使用此视图，而无法访问其他系教师的数据。\n2. **简化查询操作**，为复杂的查询建立一个视图，用户不必键入复杂的查询语句，只需针对此视图做简单的查询即可。如例3.75。\n3. **保证数据的逻辑独立性。**对于视图的操作，比如查询，只依赖于视图的定义。当构成视图的基本表要修改时，只需修改视图定义中的子查询部分。而基于视图的查询不用改变。这就是第一章介绍过的外模式与模式之间的独立性，即数据的逻辑独立性。 \n\n\n\n\n\n## 事务\n数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。\n\n1.原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n2.一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。\n\n3.隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。\n\n4.持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n\ndrop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始。delete删除表中数据，可以加where字句。\n\n\n## ER图\n\n在ER图中有如下四个成分：\n矩形框：表示实体，在框中记入实体名。\n菱形框：表示联系，在框中记入联系名。\n椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。\n连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)\n\n## 冗余字段\n冗余字段，是设计数据的时候常用的一种手段。优点是，可以在很大程度上避免数据库的关联查询，不使用join提升查询速度。缺点是，数据一致性维护成本高，需要维护冗余字段的一致性。\n\n## 存储过程与触发器的区别\n\n触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。\n\n两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。","source":"_posts/python/数据库杂谈.md","raw":"---\ntitle: 数据库杂记\ndate: 2016-10-26 21:22:50\ntags: \n- 数据库\ncategories: 总结\n---\n\n最近面试面到数据结构的题有点爆炸。基本都忘光了，记录一下基础的东西吧。\n\n<!--more-->\n## SQL语言的基本概念\n数据(Data)是数据库中存储的基本对象。\n\n数据库(DataBase，简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。\n\n\n数据库管理系统(DBMS，Database Management System)\n位于用户与操作系统之间的一层数据管理软件。\n是基础软件，是一个大型复杂的软件系统。\n\n数据库系统(DBS，DataBase System)在计算机系统中引入数据库后的系统构成，包括硬件、软件、数据和人员。\n\n### SQL语言的主要特点\n1.SQL语言是一种非过程语言，即用户只要提出“干什么”即可，不必管具体操作过程，也不必了解数据的存取路径，只要指明所需的数据即可。\n\n2.SQL语言是一种面向集合的语言，每个命令的操作对象是一个或多个关系，结果也是一个关系。\n\n3.SQL语言既是自含式语言，又是嵌入式语言。可独立使用交互命令，适用于终端用户、应用程序员和DBA；也可嵌入在高级语言中使用，供应用程序员开发应用程序。\n\nSQL语言具有:\n数据定义（DEFINITION）(CREATE,DROP,ALTER)，\n数据查询（QUERY）(SELECT)，\n数据操纵（MANIPULATION）(INSERT,UPDATE,DELETE)，\n数据控制（CONTROL）(GRANT,REVOKE)。\n\n基本表（BASE TABLE）：是独立存在的表，不是由其它的表导出的表。一个关系对应一个基本表，一个或多个基本表对应一个存储文件。\n\n视图（VIEW）：\n是一个虚拟的表，是从一个或几个基本表导出的表。它本身不独立存在于数据库中，数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。\n当基本表中的数据发生变化时，从视图中查询出来的数据也随之改变。\n\n在用户看来，视图是通过不同路径去看一个实际表，就象一个窗口一样，我们通过窗户去看外面的高楼，可以看到高楼的不同部分，而透过视图可以看到数据库中自己感兴趣的内容。\n\n索引（INDEX）：是一种和表格或视图有关的结构，可以加快从表格或视图中获得数据行。表格索引可以是群集的，也可以是非群集的。群集指数据在物理上是基于索引关键字的顺序存放的。\n\n关键字：是众多列中一列或组，它唯一识别一行（主关键字），定义两个表格之间的关系（外关键字），或者用于构建一个索引\n\n存储过程：是一种Transact-SQL语句，它们被编译成一个执行计划。该过程用于性能优化和控制访问。\n\n约束：定义了有关列中允许的值的规则，是加强数据完整性的标准机制。\n\n触发器：存储过程的一个特殊类，用于当对一个表格或视图发出update、insert 或delete语句时，能自动执行。\n\n\n### 三级模式结构\nSQL语言支持数据库的三级模式结构，如图所示。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。\n\n![三级模式结构](http://p1.bqimg.com/567571/405330844246062d.png)\n\n## 基本表的操作\n\n### 创建基本表\n创建一个数据表时主要包括以下几个组成部分：\n\n（1）字段名（列名）：字段名可长达128个字符。字段名可包含中文、英文字母、下划线、#号、货币符号（￥）及AT符号(@)。同一表中不许有重名列；\n\n（2）字段数据类型；\n\n（3）字段的长度、精度和小数位数；\n\n（4）NULL值与DEFAULT值：DEFAULT值表示某一字段的默认值，当没有输入数据时，则使用此默认的值。\n\n\n在SQL语言中，使用语句CREATE TABLE创建数据表，其基本语法格式为：\n\n```\nCREATE TABLE [ database_name . [ schema_name ] . | schema_name . ] <表名>\n  (     <列定义>[{，<列定义>|<表约束>}][,\n        [CONSTRAINT 主键约束] PRIMARY KY （属性名）][,\n        [CONSTRAINT 检查约束] CHECK（逻辑表达式）][,\n        [CONSTRAINT 外键约束] REFRENCES 参照表（参照属性）[,…n]]\n  )\n  [ON {文件组|默认文件组}]\n```\n### 定义完整性约束\n在SQL SERVER中可以定义五种类型的完整性约束。\n#### NULL/NOT NULL\n是否允许该字段的值为NULL。表示“不知道”、“不确定”或“没有数据”的意思。\n如主键列就不允许出现空值，否则就失去了唯一标识一条记录的作用\n#### UNIQUE约束\n用于指明基本表在某一列或多个列的组合上的取值必须唯一。\n\n定义了UNIQUE约束的那些列称为唯一键，系统自动为唯一键建立唯一索引，从而保证了唯一键的唯一性。\n#### PRIMARY KEY约束\nPRIMARY KEY约束用于定义基本表的主键，起唯一标识作用，其值不能为NULL，也不能重复，以此来保证实体的完整性。\nPRIMARY KEY与UNIQUE的区别：\n1.在一个基本表中只能定义一个PRIMARY KEY约束，但可定义多个UNIQUE约束；\n2.对于指定为PRIMARY KEY的一个列或多个列的组合，其中任何一个列都不能出现空值，而对于UNIQUE所约束的唯一键，则允许为空。\n#### FOREIGN KEY约束\nFOREIGN KEY约束指定某一个列或一组列作为外部键，其中，包含外部键的表称为从表，包含外部键所引用的主键或唯一键的表称主表。\n#### CHECK约束\nCHECK约束用来检查字段值所允许的范围，如，一个字段只能输入整数，而且限定在0-100的整数，以此来保证域的完整性。\n\n\n\n### 修改基本表\n由于应用环境和应用需求的变化，经常需要修改基本表的结构，比如，增加新列和完整性约束、修改原有的列定义和完整性约束等。\n#### ADD方式\n用于增加新列和完整性约束。\n\n定义方式同`CREATE TABLE`语句中的定义方式相同，其语法格式为：\n```\n//ALTER TABLE <表名> ADD <列定义> | <完整性约束定义>\nALTER TABLE Student ADD   RegisterDate DATETIME,\n```\n#### ALTER方式\n\n用于修改某些列，其语法格式为：\n```\n//ALTER TABLE<表名> ALTER COLUMN <列名><数据类型>[NULL|NOT NULL]\nALTER TABLE Student ALTER COLUMN Sage SMALEINT NULL\n```\n要求：\n1.不能改变列名；\n2.不能将含有空值的列的定义修改为NOT NULL约束；\n3.若列中已有数据，则不能减少该列的宽度，也不能改变其数据类型；\n4.只能修改NULL|NOT NULL约束，其它类型的约束在修改之前必须先删除，然后再重新添加修改过的约束定义。\n\n#### DROP方式\n删除完整性约束定义，其语法格式为：\n```\n//ALTER TABLE<表名> DROP CONSTRAINT <约束名>\nALTER TABLE Student DROP  UNIQUE(SNAME)\n```\n\n### 删除基本表\n```\nDROP TABLE <表名>\n```\n## 数据库表的基本操作\nSQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。\n\n### 插入数据记录\n有两种方式，一种是向具体记录插入常量数据；另一种是把子查询的结果输入到另一个表中去。前者智能插入一条数据，后者一次可以插入多条。\n#### 插入一行新记录\n```\n//INSERT INTO <表名>[(<列名1>[,<列名2>…])] VALUES(<值>)\n\nINSERT INTO  S VALUES  ('s7','小刚','男',21,'计算机')\n\n```\n注意：\n\n必须用逗号将各个数据分开，字符型数据要用单引号括起来。\n\nINTO子句中没有指定列名，则新插入的记录必须在每个属性列上均有值，且VALUES子句中值的排列顺序要和表中各属性列的排列顺序一致。\n#### 插入一行部分数据\n在SC表中插入一条选课记录（’S7’,’C1’）。\n```\nINSERT INTO SC (SNO,CNO)\n         VALUES ('s7',‘c1')\n```\n注意：\n\n将VALUES子句中的值按照INTO子句中指定列名的顺序插入到表中。\n\n对于INTO子句中没有出现的列，则新插入的记录在这些列上将取空值，如上例的SCORE即赋空值。\n但在表定义时有NOT NULL约束的属性列不能取空值。      \n#### 插入多行记录\n1.\n```\nINSERT INTO `userTable` (`user_id`, `user_name`) VALUES\n(1, 'dsf'),\n(2, 'fgy'),\n(3, 'faad');\n```\n这样只需执行一次SQL查询，即可插入多行记录，大大提高了效率，使用php编程的时候，可以使用字符串连接的方式连接sql语句即可:\n```\n$a = 1;\nwhile (5 == $a)\n{\n    if (1 == $a)\n        $sql = \"INSERT INTO tbl_name (col1,col2) VALUES ($a,$b)\";\n    else\n        $sql .= \",($a,$b)\";\n\n    $a++;\n    $b++;\n}\nmysql_query($sql);\n```\n\n用于表间的拷贝，将一个表中的数据抽取数行插入另一表中，可以通过子查询来实现。\n```\n///INSERT INTO <表名> [(<列名1>[,<列名2>…])] 子查询\nINSERT INTO MySalesReason\n    SELECT SalesReasonID, Name, ModifiedDate\n    FROM AdventureWorks2008R2.Sales.SalesReason\n    WHERE ReasonType = N'Marketing';\n```\n### 修改数据记录\n```\n//UPDATE <表名> SET <列名>=<表达式> [,<列名>=<表达式>]…[WHERE <条件>]\n//修改一行\n\nUPDATE T \n    SET DEPT='信息' \n  WHERE TN='刘伟'\n\n//用子查询选择要修改的行\nUPDATE T \n\tSET COMN=COMN+100\n WHERE TNO IN \n\t (SELECT T.TNO \n\t\tFROM T,TC\n\t   WHERE T.TNO=TC.TNO\n\t\t\tAND TC.CNO='C5')\n//用子查询提供要修改的值\n\nUPDATE T\n\tSET SAL =\n\t\t(SELECT 1.2*AVG(SAL) \n\t\tFROM T)\n```\n### 删除数据记录\n```\n//DELETE FROM <表名> [WHERE <条件>]\n//删除一行\nDELETE \n    FROM T \n WHERE TN=’刘伟’\n//删除多行\nDELETE \n    FROM TC\n//利用子查询选择要删除的行\nDELETE\n    FROM TC \n WHERE TNO=  \n     (SELECT TNO\n          FROM T\n       WHERE TN=’ 刘伟’)\n```\n\n\n## 索引\n索引的作用：\n1. 加快查询速度；\n2. 保证行的唯一性。\n### 索引的分类\n按照索引记录的存放位置分类：\n\n聚集索引：按照索引的字段排列记录，并且依照排好的顺序将记录存储在表中。\n\n非聚集索引：按照索引的字段排列记录，但是排列的结果并不会存储在表中，而是另外存储。\n\n### 唯一索引\n唯一索引表示表中每一个索引值只对应唯一的数据记录，\n这与表的PRIMARY KEY的特性类似，因此唯一性索引常用于PRIMARY KEY的字段上，以区别每一笔记录。\n\n当表中有被设置为UNIQUE的字段时，SQL SERVER会自动建立一个非聚集的唯一性索引。\n\n而当表中有PRIMARY KEY的字段时，SQL SERVER会在PRIMARY KEY字段建立一个非聚集索引。\n\n### 建立索引\n```\n//CREATE [UNIQUE] [CLUSTERED|NONCLUSTERED] INDEX <索引名> ON <表名>  (<列名> [次序] [{,<列名>}] [次序]…)\n//在agent表中建立一个索引aidx，保证每一行都有唯一的aid值。\ncreate unique index aidx on agents(aid);\n```\n次序用来指定索引值的排列顺序，可为ASC（升序）或DESC（降序），缺省值为ASC。\n```\nUSE STUDENT\nCREATE UNIQUE INDEX SCI ON SC(SNO,CNO)\n```\n执行此命令后，为SC表建立一个索引名为SCI的唯一索引\n此索引为SNO和CNO两列的复合索引，即对SC表中的行先按SNO的递增顺序索引，对于相同的SNO，又按CNO的递增顺序索引。\n### 删除索引\n建立索引是为了提高查询速度，但随着索引的增多，数据更新时，系统会花费许多时间来维护索引。这时，应删除不必要的索引。\n```\n//DROP INDEX 数据表名.索引名\n//删除表SC的索引SCI。\t\t\nDROP INDEX SC.SCI\n```\n### 查看索引\n#### 查看索引信息\n报告有关表或视图上索引的信息，当前数据库中表或视图的名称的数据类型为nvarchar(776)。\n```\n//sp_helpindex [ @objname = ] '表或视图的名称'\nUse  eduDB\nGO\nEXEC sp_helpindex ‘s’\n```\n#### 查看索引的空间信息\n显示行数、保留的磁盘空间以及当前数据库中的表所使用的磁盘空间，或显示由整个数据库保留和使用的磁盘空间\n\n```\n//sp_spaceused ['表的名称']\nUSE eduDB\ngo\nEXEC sp_spaceused ‘s’\n```\n#### 查看索引属性\n显示表中指定索引的属性信息。可以是下列值中的一个。\n\n```\n//INDEXPROPERTY (表的标识号，索引的名称, 属性)\nUSE eduDB\ngo\nSELECT INDEXPROPERTY(OBJECT_ID(' sc '), ' IX_CID',  'IsPadIndex') \n```\n## 视图\n视图是虚表，其数据不存储，其记录来自基本表，只在数据库中存储其定义。\n视图在概念上与基本表等同，用户可以在视图上再定义视图，可以对视图进行查询、删除、更新等操作。\n### 定义视图\n定义视图使用语句CREATE VIEW,格式为：\n```\nCREATE VIEW [架构名].<视图名>[(<视图列表>)]\n[WITH  ENCRYPTION]\nAS <子查询>\n[WITH CHECK OPTION]\n```\n以下两种情况下，视图列名不可省略：\n1.视图由多个表连接得到，在不同的表中存在同名列，则需指定列名；\n2.当视图的列名为表达式或库函数的计算结果时，而不是单纯的属性名时，则需指明列名。\n\n在子查询中不允许使用ORDER BY 子句和DISTINCT短语，如果需要排序，则可在视图定义后，对视图查询时再进行排序。\n\n视图创建后，只在数据字典中存放视图的定义，而其中的子查询SELECT语句并不执行。\n只有当用户对视图进行操作时，才按照视图的定义将数据从基本表中取出。\n\n ### 删除视图\n```\nDROP VIEW <视图名>\n```\n视图删除后，只会删除该视图在数据字典中的定义，而与该视图有关的基本表中的数据不会受任何影响，由此视图导出的其他视图的定义不会删除，但已无任何意义。用户应该把这些视图删除。\n\n### 查询视图\n视图定义后，对视图的查询操作如同对基本表的查询操作一样。更新操作也一致。\n\n### 使用视图的优点\n1. **利于数据保密**，对不同的用户定义不同的视图，使用户只能看到与自己有关的数据。\n例如,对教师表创建了计算机系视图，本系教师只能使用此视图，而无法访问其他系教师的数据。\n2. **简化查询操作**，为复杂的查询建立一个视图，用户不必键入复杂的查询语句，只需针对此视图做简单的查询即可。如例3.75。\n3. **保证数据的逻辑独立性。**对于视图的操作，比如查询，只依赖于视图的定义。当构成视图的基本表要修改时，只需修改视图定义中的子查询部分。而基于视图的查询不用改变。这就是第一章介绍过的外模式与模式之间的独立性，即数据的逻辑独立性。 \n\n\n\n\n\n## 事务\n数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。\n\n1.原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。\n\n2.一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。\n\n3.隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。\n\n4.持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。\n\ndrop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始。delete删除表中数据，可以加where字句。\n\n\n## ER图\n\n在ER图中有如下四个成分：\n矩形框：表示实体，在框中记入实体名。\n菱形框：表示联系，在框中记入联系名。\n椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。\n连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)\n\n## 冗余字段\n冗余字段，是设计数据的时候常用的一种手段。优点是，可以在很大程度上避免数据库的关联查询，不使用join提升查询速度。缺点是，数据一致性维护成本高，需要维护冗余字段的一致性。\n\n## 存储过程与触发器的区别\n\n触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。\n\n两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。","slug":"python/数据库杂谈","published":1,"updated":"2019-03-22T14:44:36.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn2t00bs4l3n6qbt65wf","content":"<p>最近面试面到数据结构的题有点爆炸。基本都忘光了，记录一下基础的东西吧。</p>\n<a id=\"more\"></a>\n<h2 id=\"SQL语言的基本概念\"><a href=\"#SQL语言的基本概念\" class=\"headerlink\" title=\"SQL语言的基本概念\"></a>SQL语言的基本概念</h2><p>数据(Data)是数据库中存储的基本对象。</p>\n<p>数据库(DataBase，简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p>\n<p>数据库管理系统(DBMS，Database Management System)<br>位于用户与操作系统之间的一层数据管理软件。<br>是基础软件，是一个大型复杂的软件系统。</p>\n<p>数据库系统(DBS，DataBase System)在计算机系统中引入数据库后的系统构成，包括硬件、软件、数据和人员。</p>\n<h3 id=\"SQL语言的主要特点\"><a href=\"#SQL语言的主要特点\" class=\"headerlink\" title=\"SQL语言的主要特点\"></a>SQL语言的主要特点</h3><p>1.SQL语言是一种非过程语言，即用户只要提出“干什么”即可，不必管具体操作过程，也不必了解数据的存取路径，只要指明所需的数据即可。</p>\n<p>2.SQL语言是一种面向集合的语言，每个命令的操作对象是一个或多个关系，结果也是一个关系。</p>\n<p>3.SQL语言既是自含式语言，又是嵌入式语言。可独立使用交互命令，适用于终端用户、应用程序员和DBA；也可嵌入在高级语言中使用，供应用程序员开发应用程序。</p>\n<p>SQL语言具有:<br>数据定义（DEFINITION）(CREATE,DROP,ALTER)，<br>数据查询（QUERY）(SELECT)，<br>数据操纵（MANIPULATION）(INSERT,UPDATE,DELETE)，<br>数据控制（CONTROL）(GRANT,REVOKE)。</p>\n<p>基本表（BASE TABLE）：是独立存在的表，不是由其它的表导出的表。一个关系对应一个基本表，一个或多个基本表对应一个存储文件。</p>\n<p>视图（VIEW）：<br>是一个虚拟的表，是从一个或几个基本表导出的表。它本身不独立存在于数据库中，数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。<br>当基本表中的数据发生变化时，从视图中查询出来的数据也随之改变。</p>\n<p>在用户看来，视图是通过不同路径去看一个实际表，就象一个窗口一样，我们通过窗户去看外面的高楼，可以看到高楼的不同部分，而透过视图可以看到数据库中自己感兴趣的内容。</p>\n<p>索引（INDEX）：是一种和表格或视图有关的结构，可以加快从表格或视图中获得数据行。表格索引可以是群集的，也可以是非群集的。群集指数据在物理上是基于索引关键字的顺序存放的。</p>\n<p>关键字：是众多列中一列或组，它唯一识别一行（主关键字），定义两个表格之间的关系（外关键字），或者用于构建一个索引</p>\n<p>存储过程：是一种Transact-SQL语句，它们被编译成一个执行计划。该过程用于性能优化和控制访问。</p>\n<p>约束：定义了有关列中允许的值的规则，是加强数据完整性的标准机制。</p>\n<p>触发器：存储过程的一个特殊类，用于当对一个表格或视图发出update、insert 或delete语句时，能自动执行。</p>\n<h3 id=\"三级模式结构\"><a href=\"#三级模式结构\" class=\"headerlink\" title=\"三级模式结构\"></a>三级模式结构</h3><p>SQL语言支持数据库的三级模式结构，如图所示。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。</p>\n<p><img src=\"http://p1.bqimg.com/567571/405330844246062d.png\" alt=\"三级模式结构\"></p>\n<h2 id=\"基本表的操作\"><a href=\"#基本表的操作\" class=\"headerlink\" title=\"基本表的操作\"></a>基本表的操作</h2><h3 id=\"创建基本表\"><a href=\"#创建基本表\" class=\"headerlink\" title=\"创建基本表\"></a>创建基本表</h3><p>创建一个数据表时主要包括以下几个组成部分：</p>\n<p>（1）字段名（列名）：字段名可长达128个字符。字段名可包含中文、英文字母、下划线、#号、货币符号（￥）及AT符号(@)。同一表中不许有重名列；</p>\n<p>（2）字段数据类型；</p>\n<p>（3）字段的长度、精度和小数位数；</p>\n<p>（4）NULL值与DEFAULT值：DEFAULT值表示某一字段的默认值，当没有输入数据时，则使用此默认的值。</p>\n<p>在SQL语言中，使用语句CREATE TABLE创建数据表，其基本语法格式为：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"comment\">[ database_name . <span class=\"comment\">[ schema_name ]</span> . | schema_name . ]</span> &lt;表名&gt;</span><br><span class=\"line\">  (     &lt;列定义&gt;<span class=\"comment\">[&#123;，&lt;列定义&gt;|&lt;表约束&gt;&#125;]</span><span class=\"comment\">[,</span></span><br><span class=\"line\"><span class=\"comment\">        <span class=\"comment\">[CONSTRAINT 主键约束]</span> PRIMARY KY （属性名）]</span><span class=\"comment\">[,</span></span><br><span class=\"line\"><span class=\"comment\">        <span class=\"comment\">[CONSTRAINT 检查约束]</span> CHECK（逻辑表达式）]</span><span class=\"comment\">[,</span></span><br><span class=\"line\"><span class=\"comment\">        <span class=\"comment\">[CONSTRAINT 外键约束]</span> REFRENCES 参照表（参照属性）<span class=\"comment\">[,…n]</span>]</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">[ON &#123;文件组|默认文件组&#125;]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"定义完整性约束\"><a href=\"#定义完整性约束\" class=\"headerlink\" title=\"定义完整性约束\"></a>定义完整性约束</h3><p>在SQL SERVER中可以定义五种类型的完整性约束。</p>\n<h4 id=\"NULL-NOT-NULL\"><a href=\"#NULL-NOT-NULL\" class=\"headerlink\" title=\"NULL/NOT NULL\"></a>NULL/NOT NULL</h4><p>是否允许该字段的值为NULL。表示“不知道”、“不确定”或“没有数据”的意思。<br>如主键列就不允许出现空值，否则就失去了唯一标识一条记录的作用</p>\n<h4 id=\"UNIQUE约束\"><a href=\"#UNIQUE约束\" class=\"headerlink\" title=\"UNIQUE约束\"></a>UNIQUE约束</h4><p>用于指明基本表在某一列或多个列的组合上的取值必须唯一。</p>\n<p>定义了UNIQUE约束的那些列称为唯一键，系统自动为唯一键建立唯一索引，从而保证了唯一键的唯一性。</p>\n<h4 id=\"PRIMARY-KEY约束\"><a href=\"#PRIMARY-KEY约束\" class=\"headerlink\" title=\"PRIMARY KEY约束\"></a>PRIMARY KEY约束</h4><p>PRIMARY KEY约束用于定义基本表的主键，起唯一标识作用，其值不能为NULL，也不能重复，以此来保证实体的完整性。<br>PRIMARY KEY与UNIQUE的区别：<br>1.在一个基本表中只能定义一个PRIMARY KEY约束，但可定义多个UNIQUE约束；<br>2.对于指定为PRIMARY KEY的一个列或多个列的组合，其中任何一个列都不能出现空值，而对于UNIQUE所约束的唯一键，则允许为空。</p>\n<h4 id=\"FOREIGN-KEY约束\"><a href=\"#FOREIGN-KEY约束\" class=\"headerlink\" title=\"FOREIGN KEY约束\"></a>FOREIGN KEY约束</h4><p>FOREIGN KEY约束指定某一个列或一组列作为外部键，其中，包含外部键的表称为从表，包含外部键所引用的主键或唯一键的表称主表。</p>\n<h4 id=\"CHECK约束\"><a href=\"#CHECK约束\" class=\"headerlink\" title=\"CHECK约束\"></a>CHECK约束</h4><p>CHECK约束用来检查字段值所允许的范围，如，一个字段只能输入整数，而且限定在0-100的整数，以此来保证域的完整性。</p>\n<h3 id=\"修改基本表\"><a href=\"#修改基本表\" class=\"headerlink\" title=\"修改基本表\"></a>修改基本表</h3><p>由于应用环境和应用需求的变化，经常需要修改基本表的结构，比如，增加新列和完整性约束、修改原有的列定义和完整性约束等。</p>\n<h4 id=\"ADD方式\"><a href=\"#ADD方式\" class=\"headerlink\" title=\"ADD方式\"></a>ADD方式</h4><p>用于增加新列和完整性约束。</p>\n<p>定义方式同<code>CREATE TABLE</code>语句中的定义方式相同，其语法格式为：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> &lt;表名&gt; <span class=\"keyword\">ADD</span> &lt;列定义&gt; | &lt;完整性约束定义&gt;</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Student <span class=\"keyword\">ADD</span>   RegisterDate DATETIME,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ALTER方式\"><a href=\"#ALTER方式\" class=\"headerlink\" title=\"ALTER方式\"></a>ALTER方式</h4><p>用于修改某些列，其语法格式为：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span>&lt;表名&gt; <span class=\"keyword\">ALTER</span> <span class=\"keyword\">COLUMN</span> &lt;列名&gt;&lt;数据类型&gt;[<span class=\"literal\">NULL</span>|<span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>]</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Student <span class=\"keyword\">ALTER</span> <span class=\"keyword\">COLUMN</span> Sage SMALEINT <span class=\"literal\">NULL</span></span><br></pre></td></tr></table></figure></p>\n<p>要求：<br>1.不能改变列名；<br>2.不能将含有空值的列的定义修改为NOT NULL约束；<br>3.若列中已有数据，则不能减少该列的宽度，也不能改变其数据类型；<br>4.只能修改NULL|NOT NULL约束，其它类型的约束在修改之前必须先删除，然后再重新添加修改过的约束定义。</p>\n<h4 id=\"DROP方式\"><a href=\"#DROP方式\" class=\"headerlink\" title=\"DROP方式\"></a>DROP方式</h4><p>删除完整性约束定义，其语法格式为：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span>&lt;表名&gt; <span class=\"keyword\">DROP</span> <span class=\"keyword\">CONSTRAINT</span> &lt;约束名&gt;</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Student <span class=\"keyword\">DROP</span>  <span class=\"keyword\">UNIQUE</span>(SNAME)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"删除基本表\"><a href=\"#删除基本表\" class=\"headerlink\" title=\"删除基本表\"></a>删除基本表</h3><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP <span class=\"keyword\">TABLE</span> &lt;表名&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据库表的基本操作\"><a href=\"#数据库表的基本操作\" class=\"headerlink\" title=\"数据库表的基本操作\"></a>数据库表的基本操作</h2><p>SQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。</p>\n<h3 id=\"插入数据记录\"><a href=\"#插入数据记录\" class=\"headerlink\" title=\"插入数据记录\"></a>插入数据记录</h3><p>有两种方式，一种是向具体记录插入常量数据；另一种是把子查询的结果输入到另一个表中去。前者智能插入一条数据，后者一次可以插入多条。</p>\n<h4 id=\"插入一行新记录\"><a href=\"#插入一行新记录\" class=\"headerlink\" title=\"插入一行新记录\"></a>插入一行新记录</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> &lt;表名&gt;[(&lt;列名<span class=\"number\">1</span>&gt;[,&lt;列名<span class=\"number\">2</span>&gt;…])] <span class=\"keyword\">VALUES</span>(&lt;值&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span>  S <span class=\"keyword\">VALUES</span>  (<span class=\"string\">'s7'</span>,<span class=\"string\">'小刚'</span>,<span class=\"string\">'男'</span>,<span class=\"number\">21</span>,<span class=\"string\">'计算机'</span>)</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<p>必须用逗号将各个数据分开，字符型数据要用单引号括起来。</p>\n<p>INTO子句中没有指定列名，则新插入的记录必须在每个属性列上均有值，且VALUES子句中值的排列顺序要和表中各属性列的排列顺序一致。</p>\n<h4 id=\"插入一行部分数据\"><a href=\"#插入一行部分数据\" class=\"headerlink\" title=\"插入一行部分数据\"></a>插入一行部分数据</h4><p>在SC表中插入一条选课记录（’S7’,’C1’）。<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT INTO SC (<span class=\"name\">SNO</span>,CNO)</span><br><span class=\"line\">         VALUES ('s7',‘c1')</span><br></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<p>将VALUES子句中的值按照INTO子句中指定列名的顺序插入到表中。</p>\n<p>对于INTO子句中没有出现的列，则新插入的记录在这些列上将取空值，如上例的SCORE即赋空值。<br>但在表定义时有NOT NULL约束的属性列不能取空值。      </p>\n<h4 id=\"插入多行记录\"><a href=\"#插入多行记录\" class=\"headerlink\" title=\"插入多行记录\"></a>插入多行记录</h4><p>1.<br><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"symbol\">`userTable`</span> (<span class=\"symbol\">`user_id`</span>, <span class=\"symbol\">`user_name`</span>) <span class=\"keyword\">VALUES</span></span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"string\">'dsf'</span>),</span><br><span class=\"line\">(<span class=\"number\">2</span>, <span class=\"string\">'fgy'</span>),</span><br><span class=\"line\">(<span class=\"number\">3</span>, <span class=\"string\">'faad'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这样只需执行一次SQL查询，即可插入多行记录，大大提高了效率，使用php编程的时候，可以使用字符串连接的方式连接sql语句即可:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$a</span> = 1;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (5 == <span class=\"variable\">$a</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (1 == <span class=\"variable\">$a</span>)</span><br><span class=\"line\">        <span class=\"variable\">$sql</span> = <span class=\"string\">\"INSERT INTO tbl_name (col1,col2) VALUES (<span class=\"variable\">$a</span>,<span class=\"variable\">$b</span>)\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"variable\">$sql</span> .= <span class=\"string\">\",(<span class=\"variable\">$a</span>,<span class=\"variable\">$b</span>)\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">$a</span>++;</span><br><span class=\"line\">    <span class=\"variable\">$b</span>++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mysql_query(<span class=\"variable\">$sql</span>);</span><br></pre></td></tr></table></figure></p>\n<p>用于表间的拷贝，将一个表中的数据抽取数行插入另一表中，可以通过子查询来实现。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">///<span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> &lt;表名&gt; [(&lt;列名<span class=\"number\">1</span>&gt;[,&lt;列名<span class=\"number\">2</span>&gt;…])] 子查询</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> MySalesReason</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> SalesReasonID, <span class=\"keyword\">Name</span>, ModifiedDate</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> AdventureWorks2008R2.Sales.SalesReason</span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span> ReasonType = N<span class=\"string\">'Marketing'</span>;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修改数据记录\"><a href=\"#修改数据记录\" class=\"headerlink\" title=\"修改数据记录\"></a>修改数据记录</h3><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//UPDATE &lt;表名&gt; SET &lt;列名&gt;=&lt;表达式&gt; [,&lt;列名&gt;=&lt;表达式&gt;]…[WHERE &lt;条件&gt;]</span></span><br><span class=\"line\"><span class=\"comment\">//修改一行</span></span><br><span class=\"line\"></span><br><span class=\"line\">UPDATE T </span><br><span class=\"line\">    <span class=\"keyword\">SET</span> DEPT=<span class=\"string\">'信息'</span> </span><br><span class=\"line\">  WHERE <span class=\"comment\">TN=</span><span class=\"comment\">'刘伟'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用子查询选择要修改的行</span></span><br><span class=\"line\">UPDATE <span class=\"comment\">T</span> </span><br><span class=\"line\">\t<span class=\"keyword\">SET</span> <span class=\"comment\">COMN=COMN+100</span></span><br><span class=\"line\"> WHERE <span class=\"comment\">TNO IN</span> </span><br><span class=\"line\">\t (SELECT <span class=\"comment\">T.TNO</span> </span><br><span class=\"line\">\t\tFROM <span class=\"comment\">T,TC</span></span><br><span class=\"line\">\t   WHERE <span class=\"comment\">T.TNO=TC.TNO</span></span><br><span class=\"line\">\t\t\tAND <span class=\"comment\">TC.CNO=</span><span class=\"comment\">'C5'</span><span class=\"comment\">)</span></span><br><span class=\"line\"><span class=\"comment\">//用子查询提供要修改的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">UPDATE <span class=\"comment\">T</span></span><br><span class=\"line\">\t<span class=\"keyword\">SET</span> <span class=\"comment\">SAL =</span></span><br><span class=\"line\">\t\t(SELECT <span class=\"comment\">1.2*AVG(SAL)</span> </span><br><span class=\"line\">\t\tFROM <span class=\"comment\">T)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"删除数据记录\"><a href=\"#删除数据记录\" class=\"headerlink\" title=\"删除数据记录\"></a>删除数据记录</h3><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> &lt;表名&gt; [<span class=\"keyword\">WHERE</span> &lt;条件&gt;]</span><br><span class=\"line\">//删除一行</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> </span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> T </span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> TN=’刘伟’</span><br><span class=\"line\">//删除多行</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> </span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">//利用子查询选择要删除的行</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span></span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> TC </span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> TNO=  </span><br><span class=\"line\">     (<span class=\"keyword\">SELECT</span> TNO</span><br><span class=\"line\">          <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\">       <span class=\"keyword\">WHERE</span> TN=’ 刘伟’)</span><br></pre></td></tr></table></figure>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引的作用：</p>\n<ol>\n<li>加快查询速度；</li>\n<li>保证行的唯一性。<h3 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h3>按照索引记录的存放位置分类：</li>\n</ol>\n<p>聚集索引：按照索引的字段排列记录，并且依照排好的顺序将记录存储在表中。</p>\n<p>非聚集索引：按照索引的字段排列记录，但是排列的结果并不会存储在表中，而是另外存储。</p>\n<h3 id=\"唯一索引\"><a href=\"#唯一索引\" class=\"headerlink\" title=\"唯一索引\"></a>唯一索引</h3><p>唯一索引表示表中每一个索引值只对应唯一的数据记录，<br>这与表的PRIMARY KEY的特性类似，因此唯一性索引常用于PRIMARY KEY的字段上，以区别每一笔记录。</p>\n<p>当表中有被设置为UNIQUE的字段时，SQL SERVER会自动建立一个非聚集的唯一性索引。</p>\n<p>而当表中有PRIMARY KEY的字段时，SQL SERVER会在PRIMARY KEY字段建立一个非聚集索引。</p>\n<h3 id=\"建立索引\"><a href=\"#建立索引\" class=\"headerlink\" title=\"建立索引\"></a>建立索引</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">CREATE</span> [<span class=\"keyword\">UNIQUE</span>] [CLUSTERED|NONCLUSTERED] <span class=\"keyword\">INDEX</span> &lt;索引名&gt; <span class=\"keyword\">ON</span> &lt;表名&gt;  (&lt;列名&gt; [次序] [&#123;,&lt;列名&gt;&#125;] [次序]…)</span><br><span class=\"line\">//在<span class=\"keyword\">agent</span>表中建立一个索引aidx，保证每一行都有唯一的aid值。</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">unique</span> <span class=\"keyword\">index</span> aidx <span class=\"keyword\">on</span> agents(aid);</span><br></pre></td></tr></table></figure>\n<p>次序用来指定索引值的排列顺序，可为ASC（升序）或DESC（降序），缺省值为ASC。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">USE</span> STUDENT</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">INDEX</span> SCI <span class=\"keyword\">ON</span> SC(SNO,CNO)</span><br></pre></td></tr></table></figure></p>\n<p>执行此命令后，为SC表建立一个索引名为SCI的唯一索引<br>此索引为SNO和CNO两列的复合索引，即对SC表中的行先按SNO的递增顺序索引，对于相同的SNO，又按CNO的递增顺序索引。</p>\n<h3 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h3><p>建立索引是为了提高查询速度，但随着索引的增多，数据更新时，系统会花费许多时间来维护索引。这时，应删除不必要的索引。<br><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">DROP</span> <span class=\"keyword\">INDEX</span> 数据表名.索引名</span><br><span class=\"line\">//删除表SC的索引SCI。\t\t</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">INDEX</span> SC.SCI</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查看索引\"><a href=\"#查看索引\" class=\"headerlink\" title=\"查看索引\"></a>查看索引</h3><h4 id=\"查看索引信息\"><a href=\"#查看索引信息\" class=\"headerlink\" title=\"查看索引信息\"></a>查看索引信息</h4><p>报告有关表或视图上索引的信息，当前数据库中表或视图的名称的数据类型为nvarchar(776)。<br><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sp_helpindex [ @objname = ] '表或视图的名称'</span></span><br><span class=\"line\"><span class=\"keyword\">Use</span>  eduDB</span><br><span class=\"line\">GO</span><br><span class=\"line\"><span class=\"built_in\">EXEC</span> sp_helpindex ‘s’</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"查看索引的空间信息\"><a href=\"#查看索引的空间信息\" class=\"headerlink\" title=\"查看索引的空间信息\"></a>查看索引的空间信息</h4><p>显示行数、保留的磁盘空间以及当前数据库中的表所使用的磁盘空间，或显示由整个数据库保留和使用的磁盘空间</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sp_spaceused ['表的名称']</span></span><br><span class=\"line\"><span class=\"keyword\">USE</span> eduDB</span><br><span class=\"line\">go</span><br><span class=\"line\"><span class=\"built_in\">EXEC</span> sp_spaceused ‘s’</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看索引属性\"><a href=\"#查看索引属性\" class=\"headerlink\" title=\"查看索引属性\"></a>查看索引属性</h4><p>显示表中指定索引的属性信息。可以是下列值中的一个。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//INDEXPROPERTY (表的标识号，索引的名称, 属性)</span><br><span class=\"line\"><span class=\"keyword\">USE</span> eduDB</span><br><span class=\"line\"><span class=\"keyword\">go</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> INDEXPROPERTY(OBJECT_ID(<span class=\"string\">' sc '</span>), <span class=\"string\">' IX_CID'</span>,  <span class=\"string\">'IsPadIndex'</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>视图是虚表，其数据不存储，其记录来自基本表，只在数据库中存储其定义。<br>视图在概念上与基本表等同，用户可以在视图上再定义视图，可以对视图进行查询、删除、更新等操作。</p>\n<h3 id=\"定义视图\"><a href=\"#定义视图\" class=\"headerlink\" title=\"定义视图\"></a>定义视图</h3><p>定义视图使用语句CREATE VIEW,格式为：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> [架构名].&lt;视图名&gt;[(&lt;视图列表&gt;)]</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span>  ENCRYPTION]</span><br><span class=\"line\"><span class=\"keyword\">AS</span> &lt;子查询&gt;</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> <span class=\"keyword\">CHECK</span> <span class=\"keyword\">OPTION</span>]</span><br></pre></td></tr></table></figure></p>\n<p>以下两种情况下，视图列名不可省略：<br>1.视图由多个表连接得到，在不同的表中存在同名列，则需指定列名；<br>2.当视图的列名为表达式或库函数的计算结果时，而不是单纯的属性名时，则需指明列名。</p>\n<p>在子查询中不允许使用ORDER BY 子句和DISTINCT短语，如果需要排序，则可在视图定义后，对视图查询时再进行排序。</p>\n<p>视图创建后，只在数据字典中存放视图的定义，而其中的子查询SELECT语句并不执行。<br>只有当用户对视图进行操作时，才按照视图的定义将数据从基本表中取出。</p>\n<h3 id=\"删除视图\"><a href=\"#删除视图\" class=\"headerlink\" title=\"删除视图\"></a>删除视图</h3><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">DROP</span> <span class=\"built_in\">VIEW</span> &lt;视图名&gt;</span><br></pre></td></tr></table></figure>\n<p>视图删除后，只会删除该视图在数据字典中的定义，而与该视图有关的基本表中的数据不会受任何影响，由此视图导出的其他视图的定义不会删除，但已无任何意义。用户应该把这些视图删除。</p>\n<h3 id=\"查询视图\"><a href=\"#查询视图\" class=\"headerlink\" title=\"查询视图\"></a>查询视图</h3><p>视图定义后，对视图的查询操作如同对基本表的查询操作一样。更新操作也一致。</p>\n<h3 id=\"使用视图的优点\"><a href=\"#使用视图的优点\" class=\"headerlink\" title=\"使用视图的优点\"></a>使用视图的优点</h3><ol>\n<li><strong>利于数据保密</strong>，对不同的用户定义不同的视图，使用户只能看到与自己有关的数据。<br>例如,对教师表创建了计算机系视图，本系教师只能使用此视图，而无法访问其他系教师的数据。</li>\n<li><strong>简化查询操作</strong>，为复杂的查询建立一个视图，用户不必键入复杂的查询语句，只需针对此视图做简单的查询即可。如例3.75。</li>\n<li><strong>保证数据的逻辑独立性。</strong>对于视图的操作，比如查询，只依赖于视图的定义。当构成视图的基本表要修改时，只需修改视图定义中的子查询部分。而基于视图的查询不用改变。这就是第一章介绍过的外模式与模式之间的独立性，即数据的逻辑独立性。 </li>\n</ol>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。</p>\n<p>1.原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>\n<p>2.一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>\n<p>3.隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。</p>\n<p>4.持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>\n<p>drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始。delete删除表中数据，可以加where字句。</p>\n<h2 id=\"ER图\"><a href=\"#ER图\" class=\"headerlink\" title=\"ER图\"></a>ER图</h2><p>在ER图中有如下四个成分：<br>矩形框：表示实体，在框中记入实体名。<br>菱形框：表示联系，在框中记入联系名。<br>椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。<br>连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)</p>\n<h2 id=\"冗余字段\"><a href=\"#冗余字段\" class=\"headerlink\" title=\"冗余字段\"></a>冗余字段</h2><p>冗余字段，是设计数据的时候常用的一种手段。优点是，可以在很大程度上避免数据库的关联查询，不使用join提升查询速度。缺点是，数据一致性维护成本高，需要维护冗余字段的一致性。</p>\n<h2 id=\"存储过程与触发器的区别\"><a href=\"#存储过程与触发器的区别\" class=\"headerlink\" title=\"存储过程与触发器的区别\"></a>存储过程与触发器的区别</h2><p>触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。</p>\n<p>两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。</p>\n","site":{"data":{}},"excerpt":"<p>最近面试面到数据结构的题有点爆炸。基本都忘光了，记录一下基础的东西吧。</p>","more":"<h2 id=\"SQL语言的基本概念\"><a href=\"#SQL语言的基本概念\" class=\"headerlink\" title=\"SQL语言的基本概念\"></a>SQL语言的基本概念</h2><p>数据(Data)是数据库中存储的基本对象。</p>\n<p>数据库(DataBase，简称DB)是长期储存在计算机内、有组织的、可共享的大量数据的集合。</p>\n<p>数据库管理系统(DBMS，Database Management System)<br>位于用户与操作系统之间的一层数据管理软件。<br>是基础软件，是一个大型复杂的软件系统。</p>\n<p>数据库系统(DBS，DataBase System)在计算机系统中引入数据库后的系统构成，包括硬件、软件、数据和人员。</p>\n<h3 id=\"SQL语言的主要特点\"><a href=\"#SQL语言的主要特点\" class=\"headerlink\" title=\"SQL语言的主要特点\"></a>SQL语言的主要特点</h3><p>1.SQL语言是一种非过程语言，即用户只要提出“干什么”即可，不必管具体操作过程，也不必了解数据的存取路径，只要指明所需的数据即可。</p>\n<p>2.SQL语言是一种面向集合的语言，每个命令的操作对象是一个或多个关系，结果也是一个关系。</p>\n<p>3.SQL语言既是自含式语言，又是嵌入式语言。可独立使用交互命令，适用于终端用户、应用程序员和DBA；也可嵌入在高级语言中使用，供应用程序员开发应用程序。</p>\n<p>SQL语言具有:<br>数据定义（DEFINITION）(CREATE,DROP,ALTER)，<br>数据查询（QUERY）(SELECT)，<br>数据操纵（MANIPULATION）(INSERT,UPDATE,DELETE)，<br>数据控制（CONTROL）(GRANT,REVOKE)。</p>\n<p>基本表（BASE TABLE）：是独立存在的表，不是由其它的表导出的表。一个关系对应一个基本表，一个或多个基本表对应一个存储文件。</p>\n<p>视图（VIEW）：<br>是一个虚拟的表，是从一个或几个基本表导出的表。它本身不独立存在于数据库中，数据库中只存放视图的定义而不存放视图对应的数据，这些数据仍存放在导出视图的基本表中。<br>当基本表中的数据发生变化时，从视图中查询出来的数据也随之改变。</p>\n<p>在用户看来，视图是通过不同路径去看一个实际表，就象一个窗口一样，我们通过窗户去看外面的高楼，可以看到高楼的不同部分，而透过视图可以看到数据库中自己感兴趣的内容。</p>\n<p>索引（INDEX）：是一种和表格或视图有关的结构，可以加快从表格或视图中获得数据行。表格索引可以是群集的，也可以是非群集的。群集指数据在物理上是基于索引关键字的顺序存放的。</p>\n<p>关键字：是众多列中一列或组，它唯一识别一行（主关键字），定义两个表格之间的关系（外关键字），或者用于构建一个索引</p>\n<p>存储过程：是一种Transact-SQL语句，它们被编译成一个执行计划。该过程用于性能优化和控制访问。</p>\n<p>约束：定义了有关列中允许的值的规则，是加强数据完整性的标准机制。</p>\n<p>触发器：存储过程的一个特殊类，用于当对一个表格或视图发出update、insert 或delete语句时，能自动执行。</p>\n<h3 id=\"三级模式结构\"><a href=\"#三级模式结构\" class=\"headerlink\" title=\"三级模式结构\"></a>三级模式结构</h3><p>SQL语言支持数据库的三级模式结构，如图所示。其中外模式对应于视图和部分基本表，模式对应于基本表，内模式对应于存储文件。</p>\n<p><img src=\"http://p1.bqimg.com/567571/405330844246062d.png\" alt=\"三级模式结构\"></p>\n<h2 id=\"基本表的操作\"><a href=\"#基本表的操作\" class=\"headerlink\" title=\"基本表的操作\"></a>基本表的操作</h2><h3 id=\"创建基本表\"><a href=\"#创建基本表\" class=\"headerlink\" title=\"创建基本表\"></a>创建基本表</h3><p>创建一个数据表时主要包括以下几个组成部分：</p>\n<p>（1）字段名（列名）：字段名可长达128个字符。字段名可包含中文、英文字母、下划线、#号、货币符号（￥）及AT符号(@)。同一表中不许有重名列；</p>\n<p>（2）字段数据类型；</p>\n<p>（3）字段的长度、精度和小数位数；</p>\n<p>（4）NULL值与DEFAULT值：DEFAULT值表示某一字段的默认值，当没有输入数据时，则使用此默认的值。</p>\n<p>在SQL语言中，使用语句CREATE TABLE创建数据表，其基本语法格式为：</p>\n<figure class=\"highlight inform7\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CREATE TABLE <span class=\"comment\">[ database_name . <span class=\"comment\">[ schema_name ]</span> . | schema_name . ]</span> &lt;表名&gt;</span><br><span class=\"line\">  (     &lt;列定义&gt;<span class=\"comment\">[&#123;，&lt;列定义&gt;|&lt;表约束&gt;&#125;]</span><span class=\"comment\">[,</span></span><br><span class=\"line\"><span class=\"comment\">        <span class=\"comment\">[CONSTRAINT 主键约束]</span> PRIMARY KY （属性名）]</span><span class=\"comment\">[,</span></span><br><span class=\"line\"><span class=\"comment\">        <span class=\"comment\">[CONSTRAINT 检查约束]</span> CHECK（逻辑表达式）]</span><span class=\"comment\">[,</span></span><br><span class=\"line\"><span class=\"comment\">        <span class=\"comment\">[CONSTRAINT 外键约束]</span> REFRENCES 参照表（参照属性）<span class=\"comment\">[,…n]</span>]</span></span><br><span class=\"line\">  )</span><br><span class=\"line\">  <span class=\"comment\">[ON &#123;文件组|默认文件组&#125;]</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"定义完整性约束\"><a href=\"#定义完整性约束\" class=\"headerlink\" title=\"定义完整性约束\"></a>定义完整性约束</h3><p>在SQL SERVER中可以定义五种类型的完整性约束。</p>\n<h4 id=\"NULL-NOT-NULL\"><a href=\"#NULL-NOT-NULL\" class=\"headerlink\" title=\"NULL/NOT NULL\"></a>NULL/NOT NULL</h4><p>是否允许该字段的值为NULL。表示“不知道”、“不确定”或“没有数据”的意思。<br>如主键列就不允许出现空值，否则就失去了唯一标识一条记录的作用</p>\n<h4 id=\"UNIQUE约束\"><a href=\"#UNIQUE约束\" class=\"headerlink\" title=\"UNIQUE约束\"></a>UNIQUE约束</h4><p>用于指明基本表在某一列或多个列的组合上的取值必须唯一。</p>\n<p>定义了UNIQUE约束的那些列称为唯一键，系统自动为唯一键建立唯一索引，从而保证了唯一键的唯一性。</p>\n<h4 id=\"PRIMARY-KEY约束\"><a href=\"#PRIMARY-KEY约束\" class=\"headerlink\" title=\"PRIMARY KEY约束\"></a>PRIMARY KEY约束</h4><p>PRIMARY KEY约束用于定义基本表的主键，起唯一标识作用，其值不能为NULL，也不能重复，以此来保证实体的完整性。<br>PRIMARY KEY与UNIQUE的区别：<br>1.在一个基本表中只能定义一个PRIMARY KEY约束，但可定义多个UNIQUE约束；<br>2.对于指定为PRIMARY KEY的一个列或多个列的组合，其中任何一个列都不能出现空值，而对于UNIQUE所约束的唯一键，则允许为空。</p>\n<h4 id=\"FOREIGN-KEY约束\"><a href=\"#FOREIGN-KEY约束\" class=\"headerlink\" title=\"FOREIGN KEY约束\"></a>FOREIGN KEY约束</h4><p>FOREIGN KEY约束指定某一个列或一组列作为外部键，其中，包含外部键的表称为从表，包含外部键所引用的主键或唯一键的表称主表。</p>\n<h4 id=\"CHECK约束\"><a href=\"#CHECK约束\" class=\"headerlink\" title=\"CHECK约束\"></a>CHECK约束</h4><p>CHECK约束用来检查字段值所允许的范围，如，一个字段只能输入整数，而且限定在0-100的整数，以此来保证域的完整性。</p>\n<h3 id=\"修改基本表\"><a href=\"#修改基本表\" class=\"headerlink\" title=\"修改基本表\"></a>修改基本表</h3><p>由于应用环境和应用需求的变化，经常需要修改基本表的结构，比如，增加新列和完整性约束、修改原有的列定义和完整性约束等。</p>\n<h4 id=\"ADD方式\"><a href=\"#ADD方式\" class=\"headerlink\" title=\"ADD方式\"></a>ADD方式</h4><p>用于增加新列和完整性约束。</p>\n<p>定义方式同<code>CREATE TABLE</code>语句中的定义方式相同，其语法格式为：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> &lt;表名&gt; <span class=\"keyword\">ADD</span> &lt;列定义&gt; | &lt;完整性约束定义&gt;</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Student <span class=\"keyword\">ADD</span>   RegisterDate DATETIME,</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"ALTER方式\"><a href=\"#ALTER方式\" class=\"headerlink\" title=\"ALTER方式\"></a>ALTER方式</h4><p>用于修改某些列，其语法格式为：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span>&lt;表名&gt; <span class=\"keyword\">ALTER</span> <span class=\"keyword\">COLUMN</span> &lt;列名&gt;&lt;数据类型&gt;[<span class=\"literal\">NULL</span>|<span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>]</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Student <span class=\"keyword\">ALTER</span> <span class=\"keyword\">COLUMN</span> Sage SMALEINT <span class=\"literal\">NULL</span></span><br></pre></td></tr></table></figure></p>\n<p>要求：<br>1.不能改变列名；<br>2.不能将含有空值的列的定义修改为NOT NULL约束；<br>3.若列中已有数据，则不能减少该列的宽度，也不能改变其数据类型；<br>4.只能修改NULL|NOT NULL约束，其它类型的约束在修改之前必须先删除，然后再重新添加修改过的约束定义。</p>\n<h4 id=\"DROP方式\"><a href=\"#DROP方式\" class=\"headerlink\" title=\"DROP方式\"></a>DROP方式</h4><p>删除完整性约束定义，其语法格式为：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span>&lt;表名&gt; <span class=\"keyword\">DROP</span> <span class=\"keyword\">CONSTRAINT</span> &lt;约束名&gt;</span><br><span class=\"line\"><span class=\"keyword\">ALTER</span> <span class=\"keyword\">TABLE</span> Student <span class=\"keyword\">DROP</span>  <span class=\"keyword\">UNIQUE</span>(SNAME)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"删除基本表\"><a href=\"#删除基本表\" class=\"headerlink\" title=\"删除基本表\"></a>删除基本表</h3><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DROP <span class=\"keyword\">TABLE</span> &lt;表名&gt;</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据库表的基本操作\"><a href=\"#数据库表的基本操作\" class=\"headerlink\" title=\"数据库表的基本操作\"></a>数据库表的基本操作</h2><p>SQL语言的数据更新语句DML主要包括插入数据、修改数据和删除数据三种语句。</p>\n<h3 id=\"插入数据记录\"><a href=\"#插入数据记录\" class=\"headerlink\" title=\"插入数据记录\"></a>插入数据记录</h3><p>有两种方式，一种是向具体记录插入常量数据；另一种是把子查询的结果输入到另一个表中去。前者智能插入一条数据，后者一次可以插入多条。</p>\n<h4 id=\"插入一行新记录\"><a href=\"#插入一行新记录\" class=\"headerlink\" title=\"插入一行新记录\"></a>插入一行新记录</h4><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> &lt;表名&gt;[(&lt;列名<span class=\"number\">1</span>&gt;[,&lt;列名<span class=\"number\">2</span>&gt;…])] <span class=\"keyword\">VALUES</span>(&lt;值&gt;)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span>  S <span class=\"keyword\">VALUES</span>  (<span class=\"string\">'s7'</span>,<span class=\"string\">'小刚'</span>,<span class=\"string\">'男'</span>,<span class=\"number\">21</span>,<span class=\"string\">'计算机'</span>)</span><br></pre></td></tr></table></figure>\n<p>注意：</p>\n<p>必须用逗号将各个数据分开，字符型数据要用单引号括起来。</p>\n<p>INTO子句中没有指定列名，则新插入的记录必须在每个属性列上均有值，且VALUES子句中值的排列顺序要和表中各属性列的排列顺序一致。</p>\n<h4 id=\"插入一行部分数据\"><a href=\"#插入一行部分数据\" class=\"headerlink\" title=\"插入一行部分数据\"></a>插入一行部分数据</h4><p>在SC表中插入一条选课记录（’S7’,’C1’）。<br><figure class=\"highlight lisp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">INSERT INTO SC (<span class=\"name\">SNO</span>,CNO)</span><br><span class=\"line\">         VALUES ('s7',‘c1')</span><br></pre></td></tr></table></figure></p>\n<p>注意：</p>\n<p>将VALUES子句中的值按照INTO子句中指定列名的顺序插入到表中。</p>\n<p>对于INTO子句中没有出现的列，则新插入的记录在这些列上将取空值，如上例的SCORE即赋空值。<br>但在表定义时有NOT NULL约束的属性列不能取空值。      </p>\n<h4 id=\"插入多行记录\"><a href=\"#插入多行记录\" class=\"headerlink\" title=\"插入多行记录\"></a>插入多行记录</h4><p>1.<br><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"symbol\">`userTable`</span> (<span class=\"symbol\">`user_id`</span>, <span class=\"symbol\">`user_name`</span>) <span class=\"keyword\">VALUES</span></span><br><span class=\"line\">(<span class=\"number\">1</span>, <span class=\"string\">'dsf'</span>),</span><br><span class=\"line\">(<span class=\"number\">2</span>, <span class=\"string\">'fgy'</span>),</span><br><span class=\"line\">(<span class=\"number\">3</span>, <span class=\"string\">'faad'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>这样只需执行一次SQL查询，即可插入多行记录，大大提高了效率，使用php编程的时候，可以使用字符串连接的方式连接sql语句即可:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"variable\">$a</span> = 1;</span><br><span class=\"line\"><span class=\"keyword\">while</span> (5 == <span class=\"variable\">$a</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (1 == <span class=\"variable\">$a</span>)</span><br><span class=\"line\">        <span class=\"variable\">$sql</span> = <span class=\"string\">\"INSERT INTO tbl_name (col1,col2) VALUES (<span class=\"variable\">$a</span>,<span class=\"variable\">$b</span>)\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"variable\">$sql</span> .= <span class=\"string\">\",(<span class=\"variable\">$a</span>,<span class=\"variable\">$b</span>)\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"variable\">$a</span>++;</span><br><span class=\"line\">    <span class=\"variable\">$b</span>++;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">mysql_query(<span class=\"variable\">$sql</span>);</span><br></pre></td></tr></table></figure></p>\n<p>用于表间的拷贝，将一个表中的数据抽取数行插入另一表中，可以通过子查询来实现。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">///<span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> &lt;表名&gt; [(&lt;列名<span class=\"number\">1</span>&gt;[,&lt;列名<span class=\"number\">2</span>&gt;…])] 子查询</span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> MySalesReason</span><br><span class=\"line\">    <span class=\"keyword\">SELECT</span> SalesReasonID, <span class=\"keyword\">Name</span>, ModifiedDate</span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> AdventureWorks2008R2.Sales.SalesReason</span><br><span class=\"line\">    <span class=\"keyword\">WHERE</span> ReasonType = N<span class=\"string\">'Marketing'</span>;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"修改数据记录\"><a href=\"#修改数据记录\" class=\"headerlink\" title=\"修改数据记录\"></a>修改数据记录</h3><figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//UPDATE &lt;表名&gt; SET &lt;列名&gt;=&lt;表达式&gt; [,&lt;列名&gt;=&lt;表达式&gt;]…[WHERE &lt;条件&gt;]</span></span><br><span class=\"line\"><span class=\"comment\">//修改一行</span></span><br><span class=\"line\"></span><br><span class=\"line\">UPDATE T </span><br><span class=\"line\">    <span class=\"keyword\">SET</span> DEPT=<span class=\"string\">'信息'</span> </span><br><span class=\"line\">  WHERE <span class=\"comment\">TN=</span><span class=\"comment\">'刘伟'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//用子查询选择要修改的行</span></span><br><span class=\"line\">UPDATE <span class=\"comment\">T</span> </span><br><span class=\"line\">\t<span class=\"keyword\">SET</span> <span class=\"comment\">COMN=COMN+100</span></span><br><span class=\"line\"> WHERE <span class=\"comment\">TNO IN</span> </span><br><span class=\"line\">\t (SELECT <span class=\"comment\">T.TNO</span> </span><br><span class=\"line\">\t\tFROM <span class=\"comment\">T,TC</span></span><br><span class=\"line\">\t   WHERE <span class=\"comment\">T.TNO=TC.TNO</span></span><br><span class=\"line\">\t\t\tAND <span class=\"comment\">TC.CNO=</span><span class=\"comment\">'C5'</span><span class=\"comment\">)</span></span><br><span class=\"line\"><span class=\"comment\">//用子查询提供要修改的值</span></span><br><span class=\"line\"></span><br><span class=\"line\">UPDATE <span class=\"comment\">T</span></span><br><span class=\"line\">\t<span class=\"keyword\">SET</span> <span class=\"comment\">SAL =</span></span><br><span class=\"line\">\t\t(SELECT <span class=\"comment\">1.2*AVG(SAL)</span> </span><br><span class=\"line\">\t\tFROM <span class=\"comment\">T)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"删除数据记录\"><a href=\"#删除数据记录\" class=\"headerlink\" title=\"删除数据记录\"></a>删除数据记录</h3><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">DELETE</span> <span class=\"keyword\">FROM</span> &lt;表名&gt; [<span class=\"keyword\">WHERE</span> &lt;条件&gt;]</span><br><span class=\"line\">//删除一行</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> </span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> T </span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> TN=’刘伟’</span><br><span class=\"line\">//删除多行</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span> </span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> TC</span><br><span class=\"line\">//利用子查询选择要删除的行</span><br><span class=\"line\"><span class=\"keyword\">DELETE</span></span><br><span class=\"line\">    <span class=\"keyword\">FROM</span> TC </span><br><span class=\"line\"> <span class=\"keyword\">WHERE</span> TNO=  </span><br><span class=\"line\">     (<span class=\"keyword\">SELECT</span> TNO</span><br><span class=\"line\">          <span class=\"keyword\">FROM</span> T</span><br><span class=\"line\">       <span class=\"keyword\">WHERE</span> TN=’ 刘伟’)</span><br></pre></td></tr></table></figure>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><p>索引的作用：</p>\n<ol>\n<li>加快查询速度；</li>\n<li>保证行的唯一性。<h3 id=\"索引的分类\"><a href=\"#索引的分类\" class=\"headerlink\" title=\"索引的分类\"></a>索引的分类</h3>按照索引记录的存放位置分类：</li>\n</ol>\n<p>聚集索引：按照索引的字段排列记录，并且依照排好的顺序将记录存储在表中。</p>\n<p>非聚集索引：按照索引的字段排列记录，但是排列的结果并不会存储在表中，而是另外存储。</p>\n<h3 id=\"唯一索引\"><a href=\"#唯一索引\" class=\"headerlink\" title=\"唯一索引\"></a>唯一索引</h3><p>唯一索引表示表中每一个索引值只对应唯一的数据记录，<br>这与表的PRIMARY KEY的特性类似，因此唯一性索引常用于PRIMARY KEY的字段上，以区别每一笔记录。</p>\n<p>当表中有被设置为UNIQUE的字段时，SQL SERVER会自动建立一个非聚集的唯一性索引。</p>\n<p>而当表中有PRIMARY KEY的字段时，SQL SERVER会在PRIMARY KEY字段建立一个非聚集索引。</p>\n<h3 id=\"建立索引\"><a href=\"#建立索引\" class=\"headerlink\" title=\"建立索引\"></a>建立索引</h3><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">CREATE</span> [<span class=\"keyword\">UNIQUE</span>] [CLUSTERED|NONCLUSTERED] <span class=\"keyword\">INDEX</span> &lt;索引名&gt; <span class=\"keyword\">ON</span> &lt;表名&gt;  (&lt;列名&gt; [次序] [&#123;,&lt;列名&gt;&#125;] [次序]…)</span><br><span class=\"line\">//在<span class=\"keyword\">agent</span>表中建立一个索引aidx，保证每一行都有唯一的aid值。</span><br><span class=\"line\"><span class=\"keyword\">create</span> <span class=\"keyword\">unique</span> <span class=\"keyword\">index</span> aidx <span class=\"keyword\">on</span> agents(aid);</span><br></pre></td></tr></table></figure>\n<p>次序用来指定索引值的排列顺序，可为ASC（升序）或DESC（降序），缺省值为ASC。<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">USE</span> STUDENT</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">UNIQUE</span> <span class=\"keyword\">INDEX</span> SCI <span class=\"keyword\">ON</span> SC(SNO,CNO)</span><br></pre></td></tr></table></figure></p>\n<p>执行此命令后，为SC表建立一个索引名为SCI的唯一索引<br>此索引为SNO和CNO两列的复合索引，即对SC表中的行先按SNO的递增顺序索引，对于相同的SNO，又按CNO的递增顺序索引。</p>\n<h3 id=\"删除索引\"><a href=\"#删除索引\" class=\"headerlink\" title=\"删除索引\"></a>删除索引</h3><p>建立索引是为了提高查询速度，但随着索引的增多，数据更新时，系统会花费许多时间来维护索引。这时，应删除不必要的索引。<br><figure class=\"highlight n1ql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//<span class=\"keyword\">DROP</span> <span class=\"keyword\">INDEX</span> 数据表名.索引名</span><br><span class=\"line\">//删除表SC的索引SCI。\t\t</span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">INDEX</span> SC.SCI</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"查看索引\"><a href=\"#查看索引\" class=\"headerlink\" title=\"查看索引\"></a>查看索引</h3><h4 id=\"查看索引信息\"><a href=\"#查看索引信息\" class=\"headerlink\" title=\"查看索引信息\"></a>查看索引信息</h4><p>报告有关表或视图上索引的信息，当前数据库中表或视图的名称的数据类型为nvarchar(776)。<br><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sp_helpindex [ @objname = ] '表或视图的名称'</span></span><br><span class=\"line\"><span class=\"keyword\">Use</span>  eduDB</span><br><span class=\"line\">GO</span><br><span class=\"line\"><span class=\"built_in\">EXEC</span> sp_helpindex ‘s’</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"查看索引的空间信息\"><a href=\"#查看索引的空间信息\" class=\"headerlink\" title=\"查看索引的空间信息\"></a>查看索引的空间信息</h4><p>显示行数、保留的磁盘空间以及当前数据库中的表所使用的磁盘空间，或显示由整个数据库保留和使用的磁盘空间</p>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//sp_spaceused ['表的名称']</span></span><br><span class=\"line\"><span class=\"keyword\">USE</span> eduDB</span><br><span class=\"line\">go</span><br><span class=\"line\"><span class=\"built_in\">EXEC</span> sp_spaceused ‘s’</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看索引属性\"><a href=\"#查看索引属性\" class=\"headerlink\" title=\"查看索引属性\"></a>查看索引属性</h4><p>显示表中指定索引的属性信息。可以是下列值中的一个。</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//INDEXPROPERTY (表的标识号，索引的名称, 属性)</span><br><span class=\"line\"><span class=\"keyword\">USE</span> eduDB</span><br><span class=\"line\"><span class=\"keyword\">go</span></span><br><span class=\"line\"><span class=\"keyword\">SELECT</span> INDEXPROPERTY(OBJECT_ID(<span class=\"string\">' sc '</span>), <span class=\"string\">' IX_CID'</span>,  <span class=\"string\">'IsPadIndex'</span>)</span><br></pre></td></tr></table></figure>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><p>视图是虚表，其数据不存储，其记录来自基本表，只在数据库中存储其定义。<br>视图在概念上与基本表等同，用户可以在视图上再定义视图，可以对视图进行查询、删除、更新等操作。</p>\n<h3 id=\"定义视图\"><a href=\"#定义视图\" class=\"headerlink\" title=\"定义视图\"></a>定义视图</h3><p>定义视图使用语句CREATE VIEW,格式为：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">VIEW</span> [架构名].&lt;视图名&gt;[(&lt;视图列表&gt;)]</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span>  ENCRYPTION]</span><br><span class=\"line\"><span class=\"keyword\">AS</span> &lt;子查询&gt;</span><br><span class=\"line\">[<span class=\"keyword\">WITH</span> <span class=\"keyword\">CHECK</span> <span class=\"keyword\">OPTION</span>]</span><br></pre></td></tr></table></figure></p>\n<p>以下两种情况下，视图列名不可省略：<br>1.视图由多个表连接得到，在不同的表中存在同名列，则需指定列名；<br>2.当视图的列名为表达式或库函数的计算结果时，而不是单纯的属性名时，则需指明列名。</p>\n<p>在子查询中不允许使用ORDER BY 子句和DISTINCT短语，如果需要排序，则可在视图定义后，对视图查询时再进行排序。</p>\n<p>视图创建后，只在数据字典中存放视图的定义，而其中的子查询SELECT语句并不执行。<br>只有当用户对视图进行操作时，才按照视图的定义将数据从基本表中取出。</p>\n<h3 id=\"删除视图\"><a href=\"#删除视图\" class=\"headerlink\" title=\"删除视图\"></a>删除视图</h3><figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">DROP</span> <span class=\"built_in\">VIEW</span> &lt;视图名&gt;</span><br></pre></td></tr></table></figure>\n<p>视图删除后，只会删除该视图在数据字典中的定义，而与该视图有关的基本表中的数据不会受任何影响，由此视图导出的其他视图的定义不会删除，但已无任何意义。用户应该把这些视图删除。</p>\n<h3 id=\"查询视图\"><a href=\"#查询视图\" class=\"headerlink\" title=\"查询视图\"></a>查询视图</h3><p>视图定义后，对视图的查询操作如同对基本表的查询操作一样。更新操作也一致。</p>\n<h3 id=\"使用视图的优点\"><a href=\"#使用视图的优点\" class=\"headerlink\" title=\"使用视图的优点\"></a>使用视图的优点</h3><ol>\n<li><strong>利于数据保密</strong>，对不同的用户定义不同的视图，使用户只能看到与自己有关的数据。<br>例如,对教师表创建了计算机系视图，本系教师只能使用此视图，而无法访问其他系教师的数据。</li>\n<li><strong>简化查询操作</strong>，为复杂的查询建立一个视图，用户不必键入复杂的查询语句，只需针对此视图做简单的查询即可。如例3.75。</li>\n<li><strong>保证数据的逻辑独立性。</strong>对于视图的操作，比如查询，只依赖于视图的定义。当构成视图的基本表要修改时，只需修改视图定义中的子查询部分。而基于视图的查询不用改变。这就是第一章介绍过的外模式与模式之间的独立性，即数据的逻辑独立性。 </li>\n</ol>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p>数据库事务transanction正确执行的四个基本要素。ACID,原子性(Atomicity)、一致性(Correspondence)、隔离性(Isolation)、持久性(Durability)。</p>\n<p>1.原子性:整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p>\n<p>2.一致性:在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。</p>\n<p>3.隔离性:隔离状态执行事务，使它们好像是系统在给定时间内执行的唯一操作。如果有两个事务，运行在相同的时间内，执行 相同的功能，事务的隔离性将确保每一事务在系统中认为只有该事务在使用系统。这种属性有时称为串行化，为了防止事务操作间的混淆，必须串行化或序列化请 求，使得在同一时间仅有一个请求用于同一数据。</p>\n<p>4.持久性:在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。</p>\n<p>drop直接删掉表 truncate删除表中数据，再插入时自增长id又从1开始。delete删除表中数据，可以加where字句。</p>\n<h2 id=\"ER图\"><a href=\"#ER图\" class=\"headerlink\" title=\"ER图\"></a>ER图</h2><p>在ER图中有如下四个成分：<br>矩形框：表示实体，在框中记入实体名。<br>菱形框：表示联系，在框中记入联系名。<br>椭圆形框：表示实体或联系的属性，将属性名记入框中。对于主属性名，则在其名称下划一下划线。<br>连线：实体与属性之间；实体与联系之间；联系与属性之间用直线相连，并在直线上标注联系的类型。（对于一对一联系，要在两个实体连线方向各写1； 对于一对多联系，要在一的一方写1，多的一方写N；对于多对多关系，则要在两个实体连线方向各写N,M。)</p>\n<h2 id=\"冗余字段\"><a href=\"#冗余字段\" class=\"headerlink\" title=\"冗余字段\"></a>冗余字段</h2><p>冗余字段，是设计数据的时候常用的一种手段。优点是，可以在很大程度上避免数据库的关联查询，不使用join提升查询速度。缺点是，数据一致性维护成本高，需要维护冗余字段的一致性。</p>\n<h2 id=\"存储过程与触发器的区别\"><a href=\"#存储过程与触发器的区别\" class=\"headerlink\" title=\"存储过程与触发器的区别\"></a>存储过程与触发器的区别</h2><p>触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。</p>\n<p>两者唯一的区别是触发器不能用EXECUTE语句调用，而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。</p>"},{"title":"JavaScript学习(3)错误处理机制","date":"2016-08-31T14:14:50.000Z","_content":"\n## Error对象\n\nJavaScript解析或执行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript原生提供一个Error构造函数，所有抛出的错误都是这个构造函数的实例。\n<!-- more -->\n```\nvar err = new Error('出错了');\nerr.message // \"出错了\"\n```\n上面代码中，我们调用Error构造函数，生成一个err实例。\n\nError构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。\n\nError对象的实例必须有message属性，表示出错时的提示信息，其他属性则没有提及。大多数JavaScript引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。\n\n利用name和message这两个属性，可以对发生什么错误有一个大概的了解。\n\n```\nif (error.name){\n  console.log(error.name + \": \" + error.message);\n}\n```\n\nstack属性用来查看错误发生时的堆栈。\n\n## JavaScript的原生错误类型\nError对象是最一般的错误类型，在它的基础上，JavaScript还定义了其他6种错误，也就是说，存在Error的6个派生对象。\n\n### （1）SyntaxError\n\nSyntaxError是解析代码时发生的语法错误。\n\n```\n// 变量名错误\nvar 1a;\n\n// 缺少括号\nconsole.log 'hello');\n```\n###（2）ReferenceError\n\nReferenceError是引用一个不存在的变量时发生的错误。\n\nReferenceError: unknownVariable is not defined\n\n另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。\n\n\n###（3）RangeError\n\nRangeError是当一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。\n\n###（4）TypeError\n\nTypeError是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。\n\n###（5）URIError\n\nURIError是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。\n\n###（6）EvalError\n\neval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再在ES5中出现了，只是为了保证与以前代码兼容，才继续保留。\n\n以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，人为生成错误对象的实例。\n\n上面的实例可以看到，错误对象的构造函数接受一个参数，代表错误提示信息（message）。\n\n##　自定义错误\n除了JavaScript内建的7种错误对象，还可以定义自己的错误对象。\n```\nfunction UserError(message) {\n   this.message = message || \"默认信息\";\n   this.name = \"UserError\";\n}\n\nUserError.prototype = new Error();\nUserError.prototype.constructor = UserError;\n```\n然后，就可以生成这种自定义的错误了。\n```\nnew UserError(\"这是自定义的错误！\");\n```\n##　throw语句\n\nthrow语句的作用是1.中断程序执行2.抛出一个意外或错误。它接受一个表达式作为参数，可以抛出各种值，包括字符串，数值，布尔值，对象等。\n\n如果只是简单的错误，返回一条出错信息就可以了，但是如果遇到复杂的情况，就需要在出错以后进一步处理。这时最好的做法是使用throw语句自定义抛出一个Error对象。\n\n```\nfunction UserError(message) {\n  this.message = message || \"默认信息\";\n  this.name = \"UserError\";\n}\n\nUserError.prototype.toString = function (){\n  return this.name + ': \"' + this.message + '\"';\n}\n\nthrow new UserError(\"出错了！\");\n```\n##　try…catch结构\n\n为了对错误进行处理，需要使用try...catch结构。\n\ntry代码块一抛出错误（上例用的是throw语句），JavaScript引擎就立即把代码的执行，转到catch代码块。可以看作，错误可以被catch代码块捕获。catch接受一个参数，表示try代码块抛出的值。\n\ncatch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。可循环嵌套try...catch\n\n为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。\n```\ntry {\n  foo.bar();\n} catch (e) {\n  if (e instanceof EvalError) {\n    console.log(e.name + \": \" + e.message);\n  } else if (e instanceof RangeError) {\n    console.log(e.name + \": \" + e.message);\n  }\n  // ...\n}\n```\ntry...catch结构是JavaScript语言受到Java语言影响的一个明显的例子。这种结构多多少少是对结构化编程原则一种破坏，处理不当就会变成类似goto语句的效果，应该谨慎使用。\n\n## finally 代码块\n\ntry...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。\n\n```\nfunction idle(x) {\n  try {\n    console.log(x);\n    return 'result';\n  } finally {\n    console.log(\"FINALLY\");\n  }\n}\n\nidle('hello')\n// hello\n// FINALLY\n// \"result\"\n```\n即使有return语句在前，finally代码块依然会得到执行，且在其执行完毕后，才会显示return语句的值。\n\n也就是说return先执行后返回，finally后执行先返回。\n\n```\nvar count = 0;\nfunction countUp() {\n  try {\n    return count;\n  } finally {\n    count++;\n  }\n}\n\ncountUp()\n// 0\ncount\n// 1\n```\n上面代码很好的说明了上述情况。\n\n下面是一道经典例题：\n```\nfunction f() {\n  try {\n    console.log(0);\n    throw \"bug\";\n  } catch(e) {\n    console.log(1);\n    return true; // 这句原本会延迟到finally代码块结束再执行\n    console.log(2); // 不会运行\n  } finally {\n    console.log(3);\n    return false; // 这句会覆盖掉前面那句return\n    console.log(4); // 不会运行\n  }\n\n  console.log(5); // 不会运行\n}\n\nvar result = f();\n// 0\n// 1\n// 3\n\nresult\n// false\n```\n从catch转入finally的标志，不仅有return语句，还有throw语句。\n\n```\nfunction f() {\n  try {\n    throw '出错了！';\n  } catch(e) {\n    console.log('捕捉到内部错误');\n    throw e; // 这句原本会等到finally结束再执行\n  } finally {\n    return false; // 直接返回\n  }\n}\n\ntry {\n  f();\n} catch(e) {\n  // 此处不会执行\n  console.log('caught outer \"bogus\"');\n}\n\n//  捕捉到内部错误\n```\n上面代码中，进入catch代码块之后，一遇到throw语句，就会去执行finally代码块，其中有return false语句，因此就直接返回了，不再会回去执行catch代码块剩下的部分了。\n\n----\n学习参考：\n[JavaScript 标准参考教程 阮一峰](http://javascript.ruanyifeng.com/)","source":"_posts/前端相关学习/js/JavaScript学习(3).md","raw":"---\ntitle: JavaScript学习(3)错误处理机制\ndate: 2016-08-31 22:14:50\ntags: \n- JavaScript\ncategories: 总结\n---\n\n## Error对象\n\nJavaScript解析或执行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript原生提供一个Error构造函数，所有抛出的错误都是这个构造函数的实例。\n<!-- more -->\n```\nvar err = new Error('出错了');\nerr.message // \"出错了\"\n```\n上面代码中，我们调用Error构造函数，生成一个err实例。\n\nError构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。\n\nError对象的实例必须有message属性，表示出错时的提示信息，其他属性则没有提及。大多数JavaScript引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。\n\n利用name和message这两个属性，可以对发生什么错误有一个大概的了解。\n\n```\nif (error.name){\n  console.log(error.name + \": \" + error.message);\n}\n```\n\nstack属性用来查看错误发生时的堆栈。\n\n## JavaScript的原生错误类型\nError对象是最一般的错误类型，在它的基础上，JavaScript还定义了其他6种错误，也就是说，存在Error的6个派生对象。\n\n### （1）SyntaxError\n\nSyntaxError是解析代码时发生的语法错误。\n\n```\n// 变量名错误\nvar 1a;\n\n// 缺少括号\nconsole.log 'hello');\n```\n###（2）ReferenceError\n\nReferenceError是引用一个不存在的变量时发生的错误。\n\nReferenceError: unknownVariable is not defined\n\n另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。\n\n\n###（3）RangeError\n\nRangeError是当一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。\n\n###（4）TypeError\n\nTypeError是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。\n\n###（5）URIError\n\nURIError是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。\n\n###（6）EvalError\n\neval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再在ES5中出现了，只是为了保证与以前代码兼容，才继续保留。\n\n以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，人为生成错误对象的实例。\n\n上面的实例可以看到，错误对象的构造函数接受一个参数，代表错误提示信息（message）。\n\n##　自定义错误\n除了JavaScript内建的7种错误对象，还可以定义自己的错误对象。\n```\nfunction UserError(message) {\n   this.message = message || \"默认信息\";\n   this.name = \"UserError\";\n}\n\nUserError.prototype = new Error();\nUserError.prototype.constructor = UserError;\n```\n然后，就可以生成这种自定义的错误了。\n```\nnew UserError(\"这是自定义的错误！\");\n```\n##　throw语句\n\nthrow语句的作用是1.中断程序执行2.抛出一个意外或错误。它接受一个表达式作为参数，可以抛出各种值，包括字符串，数值，布尔值，对象等。\n\n如果只是简单的错误，返回一条出错信息就可以了，但是如果遇到复杂的情况，就需要在出错以后进一步处理。这时最好的做法是使用throw语句自定义抛出一个Error对象。\n\n```\nfunction UserError(message) {\n  this.message = message || \"默认信息\";\n  this.name = \"UserError\";\n}\n\nUserError.prototype.toString = function (){\n  return this.name + ': \"' + this.message + '\"';\n}\n\nthrow new UserError(\"出错了！\");\n```\n##　try…catch结构\n\n为了对错误进行处理，需要使用try...catch结构。\n\ntry代码块一抛出错误（上例用的是throw语句），JavaScript引擎就立即把代码的执行，转到catch代码块。可以看作，错误可以被catch代码块捕获。catch接受一个参数，表示try代码块抛出的值。\n\ncatch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。可循环嵌套try...catch\n\n为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。\n```\ntry {\n  foo.bar();\n} catch (e) {\n  if (e instanceof EvalError) {\n    console.log(e.name + \": \" + e.message);\n  } else if (e instanceof RangeError) {\n    console.log(e.name + \": \" + e.message);\n  }\n  // ...\n}\n```\ntry...catch结构是JavaScript语言受到Java语言影响的一个明显的例子。这种结构多多少少是对结构化编程原则一种破坏，处理不当就会变成类似goto语句的效果，应该谨慎使用。\n\n## finally 代码块\n\ntry...catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。\n\n```\nfunction idle(x) {\n  try {\n    console.log(x);\n    return 'result';\n  } finally {\n    console.log(\"FINALLY\");\n  }\n}\n\nidle('hello')\n// hello\n// FINALLY\n// \"result\"\n```\n即使有return语句在前，finally代码块依然会得到执行，且在其执行完毕后，才会显示return语句的值。\n\n也就是说return先执行后返回，finally后执行先返回。\n\n```\nvar count = 0;\nfunction countUp() {\n  try {\n    return count;\n  } finally {\n    count++;\n  }\n}\n\ncountUp()\n// 0\ncount\n// 1\n```\n上面代码很好的说明了上述情况。\n\n下面是一道经典例题：\n```\nfunction f() {\n  try {\n    console.log(0);\n    throw \"bug\";\n  } catch(e) {\n    console.log(1);\n    return true; // 这句原本会延迟到finally代码块结束再执行\n    console.log(2); // 不会运行\n  } finally {\n    console.log(3);\n    return false; // 这句会覆盖掉前面那句return\n    console.log(4); // 不会运行\n  }\n\n  console.log(5); // 不会运行\n}\n\nvar result = f();\n// 0\n// 1\n// 3\n\nresult\n// false\n```\n从catch转入finally的标志，不仅有return语句，还有throw语句。\n\n```\nfunction f() {\n  try {\n    throw '出错了！';\n  } catch(e) {\n    console.log('捕捉到内部错误');\n    throw e; // 这句原本会等到finally结束再执行\n  } finally {\n    return false; // 直接返回\n  }\n}\n\ntry {\n  f();\n} catch(e) {\n  // 此处不会执行\n  console.log('caught outer \"bogus\"');\n}\n\n//  捕捉到内部错误\n```\n上面代码中，进入catch代码块之后，一遇到throw语句，就会去执行finally代码块，其中有return false语句，因此就直接返回了，不再会回去执行catch代码块剩下的部分了。\n\n----\n学习参考：\n[JavaScript 标准参考教程 阮一峰](http://javascript.ruanyifeng.com/)","slug":"前端相关学习/js/JavaScript学习(3)","published":1,"updated":"2019-03-22T14:44:36.736Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn2u00bv4l3ny8u8rtc3","content":"<h2 id=\"Error对象\"><a href=\"#Error对象\" class=\"headerlink\" title=\"Error对象\"></a>Error对象</h2><p>JavaScript解析或执行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript原生提供一个Error构造函数，所有抛出的错误都是这个构造函数的实例。<br><a id=\"more\"></a><br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> err = <span class=\"keyword\">new</span> <span class=\"type\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">err.message <span class=\"comment\">// \"出错了\"</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，我们调用Error构造函数，生成一个err实例。</p>\n<p>Error构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。</p>\n<p>Error对象的实例必须有message属性，表示出错时的提示信息，其他属性则没有提及。大多数JavaScript引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p>\n<p>利用name和message这两个属性，可以对发生什么错误有一个大概的了解。</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">error</span>.<span class=\"built_in\">name</span>)&#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(<span class=\"keyword\">error</span>.<span class=\"built_in\">name</span> + <span class=\"string\">\": \"</span> + <span class=\"keyword\">error</span>.message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>stack属性用来查看错误发生时的堆栈。</p>\n<h2 id=\"JavaScript的原生错误类型\"><a href=\"#JavaScript的原生错误类型\" class=\"headerlink\" title=\"JavaScript的原生错误类型\"></a>JavaScript的原生错误类型</h2><p>Error对象是最一般的错误类型，在它的基础上，JavaScript还定义了其他6种错误，也就是说，存在Error的6个派生对象。</p>\n<h3 id=\"（1）SyntaxError\"><a href=\"#（1）SyntaxError\" class=\"headerlink\" title=\"（1）SyntaxError\"></a>（1）SyntaxError</h3><p>SyntaxError是解析代码时发生的语法错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 变量名错误</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"number\">1</span>a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缺少括号</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log <span class=\"string\">'hello'</span>);</span><br></pre></td></tr></table></figure>\n<p>###（2）ReferenceError</p>\n<p>ReferenceError是引用一个不存在的变量时发生的错误。</p>\n<p>ReferenceError: unknownVariable is not defined</p>\n<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。</p>\n<p>###（3）RangeError</p>\n<p>RangeError是当一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</p>\n<p>###（4）TypeError</p>\n<p>TypeError是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。</p>\n<p>###（5）URIError</p>\n<p>URIError是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</p>\n<p>###（6）EvalError</p>\n<p>eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再在ES5中出现了，只是为了保证与以前代码兼容，才继续保留。</p>\n<p>以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，人为生成错误对象的实例。</p>\n<p>上面的实例可以看到，错误对象的构造函数接受一个参数，代表错误提示信息（message）。</p>\n<p>##　自定义错误<br>除了JavaScript内建的7种错误对象，还可以定义自己的错误对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserError</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.message = message || <span class=\"string\">\"默认信息\"</span>;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.name = <span class=\"string\">\"UserError\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">UserError.prototype = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure></p>\n<p>然后，就可以生成这种自定义的错误了。<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"type\">UserError</span>(<span class=\"string\">\"这是自定义的错误！\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>##　throw语句</p>\n<p>throw语句的作用是1.中断程序执行2.抛出一个意外或错误。它接受一个表达式作为参数，可以抛出各种值，包括字符串，数值，布尔值，对象等。</p>\n<p>如果只是简单的错误，返回一条出错信息就可以了，但是如果遇到复杂的情况，就需要在出错以后进一步处理。这时最好的做法是使用throw语句自定义抛出一个Error对象。</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserError</span><span class=\"params\">(message)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.message = message || <span class=\"string\">\"默认信息\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">\"UserError\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">UserError.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">': \"'</span> + <span class=\"keyword\">this</span>.message + <span class=\"string\">'\"'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UserError(<span class=\"string\">\"出错了！\"</span>);</span><br></pre></td></tr></table></figure>\n<p>##　try…catch结构</p>\n<p>为了对错误进行处理，需要使用try…catch结构。</p>\n<p>try代码块一抛出错误（上例用的是throw语句），JavaScript引擎就立即把代码的执行，转到catch代码块。可以看作，错误可以被catch代码块捕获。catch接受一个参数，表示try代码块抛出的值。</p>\n<p>catch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。可循环嵌套try…catch</p>\n<p>为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  foo.bar();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> <span class=\"built_in\">EvalError</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.name + <span class=\"string\">\": \"</span> + e.message);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RangeError</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.name + <span class=\"string\">\": \"</span> + e.message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>try…catch结构是JavaScript语言受到Java语言影响的一个明显的例子。这种结构多多少少是对结构化编程原则一种破坏，处理不当就会变成类似goto语句的效果，应该谨慎使用。</p>\n<h2 id=\"finally-代码块\"><a href=\"#finally-代码块\" class=\"headerlink\" title=\"finally 代码块\"></a>finally 代码块</h2><p>try…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">idle</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'result'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"FINALLY\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">idle(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\"><span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// FINALLY</span></span><br><span class=\"line\"><span class=\"comment\">// \"result\"</span></span><br></pre></td></tr></table></figure>\n<p>即使有return语句在前，finally代码块依然会得到执行，且在其执行完毕后，才会显示return语句的值。</p>\n<p>也就是说return先执行后返回，finally后执行先返回。</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">countUp()</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\">count</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>上面代码很好的说明了上述情况。</p>\n<p>下面是一道经典例题：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">\"bug\"</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 这句原本会延迟到finally代码块结束再执行</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 这句会覆盖掉前面那句return</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = f();</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">result</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<p>从catch转入finally的标志，不仅有return语句，还有throw语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">'出错了！'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'捕捉到内部错误'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e; <span class=\"comment\">// 这句原本会等到finally结束再执行</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 直接返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此处不会执行</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'caught outer \"bogus\"'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  捕捉到内部错误</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，进入catch代码块之后，一遇到throw语句，就会去执行finally代码块，其中有return false语句，因此就直接返回了，不再会回去执行catch代码块剩下的部分了。</p>\n<hr>\n<p>学习参考：<br><a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">JavaScript 标准参考教程 阮一峰</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"Error对象\"><a href=\"#Error对象\" class=\"headerlink\" title=\"Error对象\"></a>Error对象</h2><p>JavaScript解析或执行时，一旦发生错误，引擎就会抛出一个错误对象。JavaScript原生提供一个Error构造函数，所有抛出的错误都是这个构造函数的实例。<br></p>","more":"<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> err = <span class=\"keyword\">new</span> <span class=\"type\">Error</span>(<span class=\"string\">'出错了'</span>);</span><br><span class=\"line\">err.message <span class=\"comment\">// \"出错了\"</span></span><br></pre></td></tr></table></figure><p></p>\n<p>上面代码中，我们调用Error构造函数，生成一个err实例。</p>\n<p>Error构造函数接受一个参数，表示错误提示，可以从实例的message属性读到这个参数。</p>\n<p>Error对象的实例必须有message属性，表示出错时的提示信息，其他属性则没有提及。大多数JavaScript引擎，对Error实例还提供name和stack属性，分别表示错误的名称和错误的堆栈，但它们是非标准的，不是每种实现都有。</p>\n<p>利用name和message这两个属性，可以对发生什么错误有一个大概的了解。</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"keyword\">error</span>.<span class=\"built_in\">name</span>)&#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(<span class=\"keyword\">error</span>.<span class=\"built_in\">name</span> + <span class=\"string\">\": \"</span> + <span class=\"keyword\">error</span>.message);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>stack属性用来查看错误发生时的堆栈。</p>\n<h2 id=\"JavaScript的原生错误类型\"><a href=\"#JavaScript的原生错误类型\" class=\"headerlink\" title=\"JavaScript的原生错误类型\"></a>JavaScript的原生错误类型</h2><p>Error对象是最一般的错误类型，在它的基础上，JavaScript还定义了其他6种错误，也就是说，存在Error的6个派生对象。</p>\n<h3 id=\"（1）SyntaxError\"><a href=\"#（1）SyntaxError\" class=\"headerlink\" title=\"（1）SyntaxError\"></a>（1）SyntaxError</h3><p>SyntaxError是解析代码时发生的语法错误。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 变量名错误</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> <span class=\"number\">1</span>a;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 缺少括号</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log <span class=\"string\">'hello'</span>);</span><br></pre></td></tr></table></figure>\n<p>###（2）ReferenceError</p>\n<p>ReferenceError是引用一个不存在的变量时发生的错误。</p>\n<p>ReferenceError: unknownVariable is not defined</p>\n<p>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。</p>\n<p>###（3）RangeError</p>\n<p>RangeError是当一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</p>\n<p>###（4）TypeError</p>\n<p>TypeError是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。</p>\n<p>###（5）URIError</p>\n<p>URIError是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</p>\n<p>###（6）EvalError</p>\n<p>eval函数没有被正确执行时，会抛出EvalError错误。该错误类型已经不再在ES5中出现了，只是为了保证与以前代码兼容，才继续保留。</p>\n<p>以上这6种派生错误，连同原始的Error对象，都是构造函数。开发者可以使用它们，人为生成错误对象的实例。</p>\n<p>上面的实例可以看到，错误对象的构造函数接受一个参数，代表错误提示信息（message）。</p>\n<p>##　自定义错误<br>除了JavaScript内建的7种错误对象，还可以定义自己的错误对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserError</span>(<span class=\"params\">message</span>) </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.message = message || <span class=\"string\">\"默认信息\"</span>;</span><br><span class=\"line\">   <span class=\"keyword\">this</span>.name = <span class=\"string\">\"UserError\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">UserError.prototype = <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure></p>\n<p>然后，就可以生成这种自定义的错误了。<br><figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"type\">UserError</span>(<span class=\"string\">\"这是自定义的错误！\"</span>);</span><br></pre></td></tr></table></figure></p>\n<p>##　throw语句</p>\n<p>throw语句的作用是1.中断程序执行2.抛出一个意外或错误。它接受一个表达式作为参数，可以抛出各种值，包括字符串，数值，布尔值，对象等。</p>\n<p>如果只是简单的错误，返回一条出错信息就可以了，但是如果遇到复杂的情况，就需要在出错以后进一步处理。这时最好的做法是使用throw语句自定义抛出一个Error对象。</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">UserError</span><span class=\"params\">(message)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.message = message || <span class=\"string\">\"默认信息\"</span>;</span><br><span class=\"line\">  <span class=\"keyword\">this</span>.name = <span class=\"string\">\"UserError\"</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">UserError.prototype.toString = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.name + <span class=\"string\">': \"'</span> + <span class=\"keyword\">this</span>.message + <span class=\"string\">'\"'</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UserError(<span class=\"string\">\"出错了！\"</span>);</span><br></pre></td></tr></table></figure>\n<p>##　try…catch结构</p>\n<p>为了对错误进行处理，需要使用try…catch结构。</p>\n<p>try代码块一抛出错误（上例用的是throw语句），JavaScript引擎就立即把代码的执行，转到catch代码块。可以看作，错误可以被catch代码块捕获。catch接受一个参数，表示try代码块抛出的值。</p>\n<p>catch代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。可循环嵌套try…catch</p>\n<p>为了捕捉不同类型的错误，catch代码块之中可以加入判断语句。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  foo.bar();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (e) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> <span class=\"built_in\">EvalError</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.name + <span class=\"string\">\": \"</span> + e.message);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (e <span class=\"keyword\">instanceof</span> <span class=\"built_in\">RangeError</span>) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(e.name + <span class=\"string\">\": \"</span> + e.message);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>try…catch结构是JavaScript语言受到Java语言影响的一个明显的例子。这种结构多多少少是对结构化编程原则一种破坏，处理不当就会变成类似goto语句的效果，应该谨慎使用。</p>\n<h2 id=\"finally-代码块\"><a href=\"#finally-代码块\" class=\"headerlink\" title=\"finally 代码块\"></a>finally 代码块</h2><p>try…catch结构允许在最后添加一个finally代码块，表示不管是否出现错误，都必需在最后运行的语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">idle</span>(<span class=\"params\">x</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">'result'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">\"FINALLY\"</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">idle(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\"><span class=\"comment\">// hello</span></span><br><span class=\"line\"><span class=\"comment\">// FINALLY</span></span><br><span class=\"line\"><span class=\"comment\">// \"result\"</span></span><br></pre></td></tr></table></figure>\n<p>即使有return语句在前，finally代码块依然会得到执行，且在其执行完毕后，才会显示return语句的值。</p>\n<p>也就是说return先执行后返回，finally后执行先返回。</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> count = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">countUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    count++;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">countUp()</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\">count</span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>上面代码很好的说明了上述情况。</p>\n<p>下面是一道经典例题：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">0</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">\"bug\"</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">true</span>; <span class=\"comment\">// 这句原本会延迟到finally代码块结束再执行</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 这句会覆盖掉前面那句return</span></span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">4</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"number\">5</span>); <span class=\"comment\">// 不会运行</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = f();</span><br><span class=\"line\"><span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"comment\">// 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">result</span><br><span class=\"line\"><span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure></p>\n<p>从catch转入finally的标志，不仅有return语句，还有throw语句。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">'出错了！'</span>;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">'捕捉到内部错误'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> e; <span class=\"comment\">// 这句原本会等到finally结束再执行</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">false</span>; <span class=\"comment\">// 直接返回</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">  f();</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span>(e) &#123;</span><br><span class=\"line\">  <span class=\"comment\">// 此处不会执行</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'caught outer \"bogus\"'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  捕捉到内部错误</span></span><br></pre></td></tr></table></figure>\n<p>上面代码中，进入catch代码块之后，一遇到throw语句，就会去执行finally代码块，其中有return false语句，因此就直接返回了，不再会回去执行catch代码块剩下的部分了。</p>\n<hr>\n<p>学习参考：<br><a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">JavaScript 标准参考教程 阮一峰</a></p>"},{"title":"JavaScript学习(1)基础概念","date":"2016-08-22T14:14:50.000Z","_content":"\n### 什么是JavaScript？\n\nJavaScript是一种运行在浏览器中的解释型的编程语言。你在电脑、手机、平板上浏览的所有的网页，以及无数基于HTML5的手机App，交互逻辑都是由JavaScript驱动的。\n<!-- more -->\n### 为什么我们要学JavaScript？\n\n因为只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。。相反，随着HTML5在PC和移动端越来越流行，JavaScript变得更加重要了。并且，新兴的Node.js把JavaScript引入到了服务器端，JavaScript变得非常全能\n\n### JavaScript与Java的关系\n\n当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。\n\n### ECMAScript\n\nECMAScript是为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript(简称ES)标准。大多数时候与JavaScript相同。因为JavaScript已经被网景注册。\n\n###　JavaScript入门\n\nJavaScript嵌入网页：\n\n1.通常我们都把JavaScript代码放到`<head>`中。用`<script>...</script>`包含\n2.把JavaScript代码放到一个单独的.js文件，然后在HTML中通过`<script src=\"...\"></script>`引入这个文件,这样有利于维护。在页面中存在多行，则按顺序执行。\n\n`<script>`有个`type=\"text/javascript\"`属性，默认如此，不写也罢。\n\n### 编写JavaScript的工具\n\n1.Sublime Text\n2.Notepad++\n3.atom\n\n均是免费的，推荐Sublime Text，插件丰富，个性化自己的编辑器，不过时而会跳出购买界面，不购买也可以继续使用，不过支持一下也好。\n\n### 如何调试JavaScript\n\n首先安装`chrome`,同样也是插件丰富，可以完美个性化。\n\n安装后，按`F12`进入开发者模式，点击`控制台(Console)`,可以直接执行JavaScript代码。\n也可在点击`源码(Sources)`,进行断点，单步调试。\n\n**请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。**\n\n\n\n----\n学习参考：\n[廖雪峰的JavaScript教程](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)\n[JavaScript 标准参考教程 阮一峰](http://javascript.ruanyifeng.com/)\n[李炎恢的JavaScript视频教程](http://www.ycku.com/javascript/?utm_source=caibaojian.com)","source":"_posts/前端相关学习/js/javascript学习(1).md","raw":"---\ntitle: JavaScript学习(1)基础概念\ndate: 2016-08-22 22:14:50\ntags: \n- JavaScript\ncategories: 总结\n---\n\n### 什么是JavaScript？\n\nJavaScript是一种运行在浏览器中的解释型的编程语言。你在电脑、手机、平板上浏览的所有的网页，以及无数基于HTML5的手机App，交互逻辑都是由JavaScript驱动的。\n<!-- more -->\n### 为什么我们要学JavaScript？\n\n因为只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。。相反，随着HTML5在PC和移动端越来越流行，JavaScript变得更加重要了。并且，新兴的Node.js把JavaScript引入到了服务器端，JavaScript变得非常全能\n\n### JavaScript与Java的关系\n\n当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。\n\n### ECMAScript\n\nECMAScript是为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript(简称ES)标准。大多数时候与JavaScript相同。因为JavaScript已经被网景注册。\n\n###　JavaScript入门\n\nJavaScript嵌入网页：\n\n1.通常我们都把JavaScript代码放到`<head>`中。用`<script>...</script>`包含\n2.把JavaScript代码放到一个单独的.js文件，然后在HTML中通过`<script src=\"...\"></script>`引入这个文件,这样有利于维护。在页面中存在多行，则按顺序执行。\n\n`<script>`有个`type=\"text/javascript\"`属性，默认如此，不写也罢。\n\n### 编写JavaScript的工具\n\n1.Sublime Text\n2.Notepad++\n3.atom\n\n均是免费的，推荐Sublime Text，插件丰富，个性化自己的编辑器，不过时而会跳出购买界面，不购买也可以继续使用，不过支持一下也好。\n\n### 如何调试JavaScript\n\n首先安装`chrome`,同样也是插件丰富，可以完美个性化。\n\n安装后，按`F12`进入开发者模式，点击`控制台(Console)`,可以直接执行JavaScript代码。\n也可在点击`源码(Sources)`,进行断点，单步调试。\n\n**请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。**\n\n\n\n----\n学习参考：\n[廖雪峰的JavaScript教程](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)\n[JavaScript 标准参考教程 阮一峰](http://javascript.ruanyifeng.com/)\n[李炎恢的JavaScript视频教程](http://www.ycku.com/javascript/?utm_source=caibaojian.com)","slug":"前端相关学习/js/javascript学习(1)","published":1,"updated":"2019-03-22T14:44:36.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn2w00by4l3n802d8eix","content":"<h3 id=\"什么是JavaScript？\"><a href=\"#什么是JavaScript？\" class=\"headerlink\" title=\"什么是JavaScript？\"></a>什么是JavaScript？</h3><p>JavaScript是一种运行在浏览器中的解释型的编程语言。你在电脑、手机、平板上浏览的所有的网页，以及无数基于HTML5的手机App，交互逻辑都是由JavaScript驱动的。<br><a id=\"more\"></a></p>\n<h3 id=\"为什么我们要学JavaScript？\"><a href=\"#为什么我们要学JavaScript？\" class=\"headerlink\" title=\"为什么我们要学JavaScript？\"></a>为什么我们要学JavaScript？</h3><p>因为只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。。相反，随着HTML5在PC和移动端越来越流行，JavaScript变得更加重要了。并且，新兴的Node.js把JavaScript引入到了服务器端，JavaScript变得非常全能</p>\n<h3 id=\"JavaScript与Java的关系\"><a href=\"#JavaScript与Java的关系\" class=\"headerlink\" title=\"JavaScript与Java的关系\"></a>JavaScript与Java的关系</h3><p>当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</p>\n<h3 id=\"ECMAScript\"><a href=\"#ECMAScript\" class=\"headerlink\" title=\"ECMAScript\"></a>ECMAScript</h3><p>ECMAScript是为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript(简称ES)标准。大多数时候与JavaScript相同。因为JavaScript已经被网景注册。</p>\n<p>###　JavaScript入门</p>\n<p>JavaScript嵌入网页：</p>\n<p>1.通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中。用<code>&lt;script&gt;...&lt;/script&gt;</code>包含<br>2.把JavaScript代码放到一个单独的.js文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件,这样有利于维护。在页面中存在多行，则按顺序执行。</p>\n<p><code>&lt;script&gt;</code>有个<code>type=&quot;text/javascript&quot;</code>属性，默认如此，不写也罢。</p>\n<h3 id=\"编写JavaScript的工具\"><a href=\"#编写JavaScript的工具\" class=\"headerlink\" title=\"编写JavaScript的工具\"></a>编写JavaScript的工具</h3><p>1.Sublime Text<br>2.Notepad++<br>3.atom</p>\n<p>均是免费的，推荐Sublime Text，插件丰富，个性化自己的编辑器，不过时而会跳出购买界面，不购买也可以继续使用，不过支持一下也好。</p>\n<h3 id=\"如何调试JavaScript\"><a href=\"#如何调试JavaScript\" class=\"headerlink\" title=\"如何调试JavaScript\"></a>如何调试JavaScript</h3><p>首先安装<code>chrome</code>,同样也是插件丰富，可以完美个性化。</p>\n<p>安装后，按<code>F12</code>进入开发者模式，点击<code>控制台(Console)</code>,可以直接执行JavaScript代码。<br>也可在点击<code>源码(Sources)</code>,进行断点，单步调试。</p>\n<p><strong>请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。</strong></p>\n<hr>\n<p>学习参考：<br><a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\" target=\"_blank\" rel=\"noopener\">廖雪峰的JavaScript教程</a><br><a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">JavaScript 标准参考教程 阮一峰</a><br><a href=\"http://www.ycku.com/javascript/?utm_source=caibaojian.com\" target=\"_blank\" rel=\"noopener\">李炎恢的JavaScript视频教程</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是JavaScript？\"><a href=\"#什么是JavaScript？\" class=\"headerlink\" title=\"什么是JavaScript？\"></a>什么是JavaScript？</h3><p>JavaScript是一种运行在浏览器中的解释型的编程语言。你在电脑、手机、平板上浏览的所有的网页，以及无数基于HTML5的手机App，交互逻辑都是由JavaScript驱动的。<br></p>","more":"<p></p>\n<h3 id=\"为什么我们要学JavaScript？\"><a href=\"#为什么我们要学JavaScript？\" class=\"headerlink\" title=\"为什么我们要学JavaScript？\"></a>为什么我们要学JavaScript？</h3><p>因为只有JavaScript能跨平台、跨浏览器驱动网页，与用户交互。。相反，随着HTML5在PC和移动端越来越流行，JavaScript变得更加重要了。并且，新兴的Node.js把JavaScript引入到了服务器端，JavaScript变得非常全能</p>\n<h3 id=\"JavaScript与Java的关系\"><a href=\"#JavaScript与Java的关系\" class=\"headerlink\" title=\"JavaScript与Java的关系\"></a>JavaScript与Java的关系</h3><p>当时Java语言非常红火，所以网景公司希望借Java的名气来推广，但事实上JavaScript除了语法上有点像Java，其他部分基本上没啥关系。</p>\n<h3 id=\"ECMAScript\"><a href=\"#ECMAScript\" class=\"headerlink\" title=\"ECMAScript\"></a>ECMAScript</h3><p>ECMAScript是为了让JavaScript成为全球标准，几个公司联合ECMA（European Computer Manufacturers Association）组织定制了JavaScript语言的标准，被称为ECMAScript(简称ES)标准。大多数时候与JavaScript相同。因为JavaScript已经被网景注册。</p>\n<p>###　JavaScript入门</p>\n<p>JavaScript嵌入网页：</p>\n<p>1.通常我们都把JavaScript代码放到<code>&lt;head&gt;</code>中。用<code>&lt;script&gt;...&lt;/script&gt;</code>包含<br>2.把JavaScript代码放到一个单独的.js文件，然后在HTML中通过<code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code>引入这个文件,这样有利于维护。在页面中存在多行，则按顺序执行。</p>\n<p><code>&lt;script&gt;</code>有个<code>type=&quot;text/javascript&quot;</code>属性，默认如此，不写也罢。</p>\n<h3 id=\"编写JavaScript的工具\"><a href=\"#编写JavaScript的工具\" class=\"headerlink\" title=\"编写JavaScript的工具\"></a>编写JavaScript的工具</h3><p>1.Sublime Text<br>2.Notepad++<br>3.atom</p>\n<p>均是免费的，推荐Sublime Text，插件丰富，个性化自己的编辑器，不过时而会跳出购买界面，不购买也可以继续使用，不过支持一下也好。</p>\n<h3 id=\"如何调试JavaScript\"><a href=\"#如何调试JavaScript\" class=\"headerlink\" title=\"如何调试JavaScript\"></a>如何调试JavaScript</h3><p>首先安装<code>chrome</code>,同样也是插件丰富，可以完美个性化。</p>\n<p>安装后，按<code>F12</code>进入开发者模式，点击<code>控制台(Console)</code>,可以直接执行JavaScript代码。<br>也可在点击<code>源码(Sources)</code>,进行断点，单步调试。</p>\n<p><strong>请注意，JavaScript严格区分大小写，如果弄错了大小写，程序将报错或者运行不正常。</strong></p>\n<hr>\n<p>学习参考：<br><a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\" target=\"_blank\" rel=\"noopener\">廖雪峰的JavaScript教程</a><br><a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">JavaScript 标准参考教程 阮一峰</a><br><a href=\"http://www.ycku.com/javascript/?utm_source=caibaojian.com\" target=\"_blank\" rel=\"noopener\">李炎恢的JavaScript视频教程</a></p>"},{"title":"JavaScript学习(2)数据类型转换","date":"2016-08-24T14:14:50.000Z","_content":"\n## JavaScript基本语法\n\n### 变量\n```\nvar a = 1;\n```\n上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，也称为将数值1“赋值”给变量a。以后，引用变量a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。\n\n<!-- more -->\nJavaScirpt是一种动态类型语言，也就是说，变量的类型没有限制，可以赋予各种类型的值。\n\n可重新赋值，但无需重新声明。\n\n#### null和undefined\n如果只是声明变量而没有赋值，则该变量的值是`undefined`。`undefined`是一个JavaScript关键字，表示“无定义，不存在的值”。而不是`null`(理解为无值)。\n\n`null`表示一个“空”的值，它和0以及空字符串''不同，0是一个数值，''表示长度为0的字符串，而`null`表示“空”。\n\n在其他语言中，也有类似JavaScript的`null`的表示，例如Java也用`null`，Swift用`nil`，Python用`None`表示。但是，在JavaScript中，还有一个和`null`类似的`undefined`，它表示“未定义”。\n\nJavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。\n\n\n### 变量提升\n\nJavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。\n\n### 标识符\n\n标识符（identifier）是用来识别具体对象的一个名称。\n\n标识符命名规则：\n\n>第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。\n>第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字0-9\n\n注意不要用保留字，有`arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。`\n\n另外，还有三个词虽然不是保留字，但是因为具有特别含义，也不应该用作标识符。分别是`Infinity(无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity)、NaN(表示Not a Number，当无法计算结果时用NaN表示)、undefined(未定义)。`\n\n### 注释符\n```\n// 这是单行注释\n\n/*\n 这是\n 多行\n 注释\n*/\n```\n此外，由于历史上JavaScript兼容HTML代码的注释，所以`<\\!--和-->`也被视为单行注释。\n\n### 区块\n\nJavaScript使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。\n\n与大多数编程语言不一样，JavaScript的区块不构成单独的作用域（scope）。也就是说，区块中的变量与区块外的变量，属于同一个作用域。\n\n\n### 标签(label)\n\nJavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。\n```\nlabel:\n  statement\n```\n\n## 数据类型转换\n\nJavaScript是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。虽然变量没有类型，但是数据本身和各种运算符是有类型的。如果运算符发现，数据的类型与预期不符，就会自动转换类型。当然有些时候也会出现需要强制转换的时候。\n\n### 强制转换\n\n强制转换主要指使用`Number`、`String`和`Boolean`三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。\n\n#### Number()\n\n可以将任意类型的值转化成数值。\n##### (1)原始类型值的转换规则\n```\n// 数值：转换后还是原来的值\nNumber(324) // 324\n\n// 字符串：如果可以被解析为数值，则转换为相应的数值\nNumber('\\t\\v\\r324\\n') // 324\n\n// 字符串：如果不可以被解析为数值，返回NaN\nNumber('abc') // NaN\n\n// 空字符串转为0\nNumber('') // 0\n\n// undefined：转成 NaN\nNumber(undefined) // NaN\n\n// null：转成0\nNumber(null) // 0\n\nparseInt('42 abc') // 42\n\n```\n`parseInt`逐个解析字符，而`Number`函数整体转换字符串的类型。\n另外，`Number`函数会自动过滤一个字符串前导和后缀的空格。\n\n##### (2)对象的转换规则\n\nNumber方法的参数是对象时，将返回NaN。\n\n>1.调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。\n\n>2.如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。\n\n>3.如果toString方法返回的是对象，就报错。\n\n#### String()\n\n可以将任意类型的值转化成字符串。\n\n##### (1)原始类型值的转换规则\n\n>数值：转为相应的字符串。\n>字符串：转换后还是原来的值。\n>布尔值：true转为\"true\"，false转为\"false\"。\n>undefined：转为\"undefined\"。\n>null：转为\"null\"。\n\n\n##### String()对象的转换规则\n\n`String`方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。\n\n```\nString({a: 1}) // \"[object Object]\"\nString([1, 2, 3]) // \"1,2,3\"\n```\n\n`String`方法背后的转换规则，优先`toString`方法，后`valueOf`方法。\n\n#### Boolean()\n\n使用Boolean函数，可以将任意类型的变量转为布尔值。\n\n它的转换规则相对简单：除了以下六个值的转换结果为false，其他的值全部为true。\n```\nundefined\nnull\n-0\n0或+0\nNaN\n''（空字符串）\n```\n\n**注意**:所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。\n\n\n### 自动转换\n\n下面介绍自动转换，它是以强制转换为基础的。\n\n遇到以下三种情况时，JavaScript会自动转换数据类型，即转换是自动完成的，对用户不可见。\n\n```\n// 1. 不同类型的数据互相运算\n123 + 'abc' // \"123abc\"\n\n// 2. 对非布尔值类型的数据求布尔值\nif ('abc') {\n  console.log('hello')\n}  // \"hello\"\n\n// 3. 对非数值类型的数据使用一元运算符（即“+”和“-”）\n+ {foo: 'bar'} // NaN\n- [1, 2, 3] // NaN\n```\n自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。\n\n由于自动转换具有不确定性，而且不易出错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。\n\n除了加法运算符有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。\n```\nfalse / '5' // 0\n'abc' - 1   // NaN\n```\n----\n学习参考：\n[廖雪峰的JavaScript教程](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)\n[JavaScript 标准参考教程 阮一峰](http://javascript.ruanyifeng.com/)\n[李炎恢的JavaScript视频教程](http://www.ycku.com/javascript/?utm_source=caibaojian.com)","source":"_posts/前端相关学习/js/javascript学习(2).md","raw":"---\ntitle: JavaScript学习(2)数据类型转换\ndate: 2016-08-24 22:14:50\ntags: \n- JavaScript\ncategories: 总结\n---\n\n## JavaScript基本语法\n\n### 变量\n```\nvar a = 1;\n```\n上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，也称为将数值1“赋值”给变量a。以后，引用变量a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。\n\n<!-- more -->\nJavaScirpt是一种动态类型语言，也就是说，变量的类型没有限制，可以赋予各种类型的值。\n\n可重新赋值，但无需重新声明。\n\n#### null和undefined\n如果只是声明变量而没有赋值，则该变量的值是`undefined`。`undefined`是一个JavaScript关键字，表示“无定义，不存在的值”。而不是`null`(理解为无值)。\n\n`null`表示一个“空”的值，它和0以及空字符串''不同，0是一个数值，''表示长度为0的字符串，而`null`表示“空”。\n\n在其他语言中，也有类似JavaScript的`null`的表示，例如Java也用`null`，Swift用`nil`，Python用`None`表示。但是，在JavaScript中，还有一个和`null`类似的`undefined`，它表示“未定义”。\n\nJavaScript的设计者希望用`null`表示一个空的值，而`undefined`表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用`null`。`undefined`仅仅在判断函数参数是否传递的情况下有用。\n\n\n### 变量提升\n\nJavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。\n\n### 标识符\n\n标识符（identifier）是用来识别具体对象的一个名称。\n\n标识符命名规则：\n\n>第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。\n>第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字0-9\n\n注意不要用保留字，有`arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。`\n\n另外，还有三个词虽然不是保留字，但是因为具有特别含义，也不应该用作标识符。分别是`Infinity(无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity)、NaN(表示Not a Number，当无法计算结果时用NaN表示)、undefined(未定义)。`\n\n### 注释符\n```\n// 这是单行注释\n\n/*\n 这是\n 多行\n 注释\n*/\n```\n此外，由于历史上JavaScript兼容HTML代码的注释，所以`<\\!--和-->`也被视为单行注释。\n\n### 区块\n\nJavaScript使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。\n\n与大多数编程语言不一样，JavaScript的区块不构成单独的作用域（scope）。也就是说，区块中的变量与区块外的变量，属于同一个作用域。\n\n\n### 标签(label)\n\nJavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。\n```\nlabel:\n  statement\n```\n\n## 数据类型转换\n\nJavaScript是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。虽然变量没有类型，但是数据本身和各种运算符是有类型的。如果运算符发现，数据的类型与预期不符，就会自动转换类型。当然有些时候也会出现需要强制转换的时候。\n\n### 强制转换\n\n强制转换主要指使用`Number`、`String`和`Boolean`三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。\n\n#### Number()\n\n可以将任意类型的值转化成数值。\n##### (1)原始类型值的转换规则\n```\n// 数值：转换后还是原来的值\nNumber(324) // 324\n\n// 字符串：如果可以被解析为数值，则转换为相应的数值\nNumber('\\t\\v\\r324\\n') // 324\n\n// 字符串：如果不可以被解析为数值，返回NaN\nNumber('abc') // NaN\n\n// 空字符串转为0\nNumber('') // 0\n\n// undefined：转成 NaN\nNumber(undefined) // NaN\n\n// null：转成0\nNumber(null) // 0\n\nparseInt('42 abc') // 42\n\n```\n`parseInt`逐个解析字符，而`Number`函数整体转换字符串的类型。\n另外，`Number`函数会自动过滤一个字符串前导和后缀的空格。\n\n##### (2)对象的转换规则\n\nNumber方法的参数是对象时，将返回NaN。\n\n>1.调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。\n\n>2.如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。\n\n>3.如果toString方法返回的是对象，就报错。\n\n#### String()\n\n可以将任意类型的值转化成字符串。\n\n##### (1)原始类型值的转换规则\n\n>数值：转为相应的字符串。\n>字符串：转换后还是原来的值。\n>布尔值：true转为\"true\"，false转为\"false\"。\n>undefined：转为\"undefined\"。\n>null：转为\"null\"。\n\n\n##### String()对象的转换规则\n\n`String`方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。\n\n```\nString({a: 1}) // \"[object Object]\"\nString([1, 2, 3]) // \"1,2,3\"\n```\n\n`String`方法背后的转换规则，优先`toString`方法，后`valueOf`方法。\n\n#### Boolean()\n\n使用Boolean函数，可以将任意类型的变量转为布尔值。\n\n它的转换规则相对简单：除了以下六个值的转换结果为false，其他的值全部为true。\n```\nundefined\nnull\n-0\n0或+0\nNaN\n''（空字符串）\n```\n\n**注意**:所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。\n\n\n### 自动转换\n\n下面介绍自动转换，它是以强制转换为基础的。\n\n遇到以下三种情况时，JavaScript会自动转换数据类型，即转换是自动完成的，对用户不可见。\n\n```\n// 1. 不同类型的数据互相运算\n123 + 'abc' // \"123abc\"\n\n// 2. 对非布尔值类型的数据求布尔值\nif ('abc') {\n  console.log('hello')\n}  // \"hello\"\n\n// 3. 对非数值类型的数据使用一元运算符（即“+”和“-”）\n+ {foo: 'bar'} // NaN\n- [1, 2, 3] // NaN\n```\n自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。\n\n由于自动转换具有不确定性，而且不易出错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。\n\n除了加法运算符有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。\n```\nfalse / '5' // 0\n'abc' - 1   // NaN\n```\n----\n学习参考：\n[廖雪峰的JavaScript教程](http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000)\n[JavaScript 标准参考教程 阮一峰](http://javascript.ruanyifeng.com/)\n[李炎恢的JavaScript视频教程](http://www.ycku.com/javascript/?utm_source=caibaojian.com)","slug":"前端相关学习/js/javascript学习(2)","published":1,"updated":"2019-03-22T14:44:36.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn2x00c24l3n1fc927xt","content":"<h2 id=\"JavaScript基本语法\"><a href=\"#JavaScript基本语法\" class=\"headerlink\" title=\"JavaScript基本语法\"></a>JavaScript基本语法</h2><h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var a</span> = 1;</span><br></pre></td></tr></table></figure>\n<p>上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，也称为将数值1“赋值”给变量a。以后，引用变量a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。</p>\n<a id=\"more\"></a>\n<p>JavaScirpt是一种动态类型语言，也就是说，变量的类型没有限制，可以赋予各种类型的值。</p>\n<p>可重新赋值，但无需重新声明。</p>\n<h4 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h4><p>如果只是声明变量而没有赋值，则该变量的值是<code>undefined</code>。<code>undefined</code>是一个JavaScript关键字，表示“无定义，不存在的值”。而不是<code>null</code>(理解为无值)。</p>\n<p><code>null</code>表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而<code>null</code>表示“空”。</p>\n<p>在其他语言中，也有类似JavaScript的<code>null</code>的表示，例如Java也用<code>null</code>，Swift用<code>nil</code>，Python用<code>None</code>表示。但是，在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</p>\n<p>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p>\n<h3 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h3><p>标识符（identifier）是用来识别具体对象的一个名称。</p>\n<p>标识符命名规则：</p>\n<blockquote>\n<p>第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。<br>第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字0-9</p>\n</blockquote>\n<p>注意不要用保留字，有<code>arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</code></p>\n<p>另外，还有三个词虽然不是保留字，但是因为具有特别含义，也不应该用作标识符。分别是<code>Infinity(无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity)、NaN(表示Not a Number，当无法计算结果时用NaN表示)、undefined(未定义)。</code></p>\n<h3 id=\"注释符\"><a href=\"#注释符\" class=\"headerlink\" title=\"注释符\"></a>注释符</h3><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是单行注释</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> 这是</span></span><br><span class=\"line\"><span class=\"comment\"> 多行</span></span><br><span class=\"line\"><span class=\"comment\"> 注释</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>此外，由于历史上JavaScript兼容HTML代码的注释，所以<code>&lt;\\!--和--&gt;</code>也被视为单行注释。</p>\n<h3 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a>区块</h3><p>JavaScript使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。</p>\n<p>与大多数编程语言不一样，JavaScript的区块不构成单独的作用域（scope）。也就是说，区块中的变量与区块外的变量，属于同一个作用域。</p>\n<h3 id=\"标签-label\"><a href=\"#标签-label\" class=\"headerlink\" title=\"标签(label)\"></a>标签(label)</h3><p>JavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">label</span><span class=\"bash\">:</span></span><br><span class=\"line\">  statement</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h2><p>JavaScript是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。虽然变量没有类型，但是数据本身和各种运算符是有类型的。如果运算符发现，数据的类型与预期不符，就会自动转换类型。当然有些时候也会出现需要强制转换的时候。</p>\n<h3 id=\"强制转换\"><a href=\"#强制转换\" class=\"headerlink\" title=\"强制转换\"></a>强制转换</h3><p>强制转换主要指使用<code>Number</code>、<code>String</code>和<code>Boolean</code>三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。</p>\n<h4 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number()\"></a>Number()</h4><p>可以将任意类型的值转化成数值。</p>\n<h5 id=\"1-原始类型值的转换规则\"><a href=\"#1-原始类型值的转换规则\" class=\"headerlink\" title=\"(1)原始类型值的转换规则\"></a>(1)原始类型值的转换规则</h5><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数值：转换后还是原来的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(<span class=\"number\">324</span>)</span></span> <span class=\"comment\">// 324</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(<span class=\"string\">'\\t\\v\\r324\\n'</span>)</span></span> <span class=\"comment\">// 324</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串：如果不可以被解析为数值，返回NaN</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(<span class=\"string\">'abc'</span>)</span></span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空字符串转为0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(<span class=\"string\">''</span>)</span></span> <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// undefined：转成 NaN</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(undefined)</span></span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// null：转成0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(null)</span></span> <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">parseInt</span><span class=\"params\">(<span class=\"string\">'42 abc'</span>)</span></span> <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<p><code>parseInt</code>逐个解析字符，而<code>Number</code>函数整体转换字符串的类型。<br>另外，<code>Number</code>函数会自动过滤一个字符串前导和后缀的空格。</p>\n<h5 id=\"2-对象的转换规则\"><a href=\"#2-对象的转换规则\" class=\"headerlink\" title=\"(2)对象的转换规则\"></a>(2)对象的转换规则</h5><p>Number方法的参数是对象时，将返回NaN。</p>\n<blockquote>\n<p>1.调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。</p>\n</blockquote>\n<blockquote>\n<p>2.如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。</p>\n</blockquote>\n<blockquote>\n<p>3.如果toString方法返回的是对象，就报错。</p>\n</blockquote>\n<h4 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String()\"></a>String()</h4><p>可以将任意类型的值转化成字符串。</p>\n<h5 id=\"1-原始类型值的转换规则-1\"><a href=\"#1-原始类型值的转换规则-1\" class=\"headerlink\" title=\"(1)原始类型值的转换规则\"></a>(1)原始类型值的转换规则</h5><blockquote>\n<p>数值：转为相应的字符串。<br>字符串：转换后还是原来的值。<br>布尔值：true转为”true”，false转为”false”。<br>undefined：转为”undefined”。<br>null：转为”null”。</p>\n</blockquote>\n<h5 id=\"String-对象的转换规则\"><a href=\"#String-对象的转换规则\" class=\"headerlink\" title=\"String()对象的转换规则\"></a>String()对象的转换规则</h5><p><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">String</span><span class=\"params\">(&#123;a: <span class=\"number\">1</span>&#125;)</span></span> <span class=\"comment\">// \"[object Object]\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">String</span><span class=\"params\">([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span></span> <span class=\"comment\">// \"1,2,3\"</span></span><br></pre></td></tr></table></figure>\n<p><code>String</code>方法背后的转换规则，优先<code>toString</code>方法，后<code>valueOf</code>方法。</p>\n<h4 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean()\"></a>Boolean()</h4><p>使用Boolean函数，可以将任意类型的变量转为布尔值。</p>\n<p>它的转换规则相对简单：除了以下六个值的转换结果为false，其他的值全部为true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"number\">-0</span></span><br><span class=\"line\"><span class=\"number\">0</span>或+<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span></span><br><span class=\"line\"><span class=\"string\">''</span>（空字符串）</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意</strong>:所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。</p>\n<h3 id=\"自动转换\"><a href=\"#自动转换\" class=\"headerlink\" title=\"自动转换\"></a>自动转换</h3><p>下面介绍自动转换，它是以强制转换为基础的。</p>\n<p>遇到以下三种情况时，JavaScript会自动转换数据类型，即转换是自动完成的，对用户不可见。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"number\">1</span>. 不同类型的数据互相运算</span><br><span class=\"line\"><span class=\"number\">123</span> + <span class=\"string\">'abc'</span> <span class=\"regexp\">//</span> <span class=\"string\">\"123abc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"number\">2</span>. 对非布尔值类型的数据求布尔值</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'abc'</span>) &#123;</span><br><span class=\"line\">  console.log(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\">&#125;  <span class=\"regexp\">//</span> <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"number\">3</span>. 对非数值类型的数据使用一元运算符（即“+”和“-”）</span><br><span class=\"line\">+ &#123;foo: <span class=\"string\">'bar'</span>&#125; <span class=\"regexp\">//</span> NaN</span><br><span class=\"line\">- [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>] <span class=\"regexp\">//</span> NaN</span><br></pre></td></tr></table></figure>\n<p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。</p>\n<p>由于自动转换具有不确定性，而且不易出错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。</p>\n<p>除了加法运算符有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">false</span> / <span class=\"string\">'5'</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span> - <span class=\"number\">1</span>   <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>学习参考：<br><a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\" target=\"_blank\" rel=\"noopener\">廖雪峰的JavaScript教程</a><br><a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">JavaScript 标准参考教程 阮一峰</a><br><a href=\"http://www.ycku.com/javascript/?utm_source=caibaojian.com\" target=\"_blank\" rel=\"noopener\">李炎恢的JavaScript视频教程</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"JavaScript基本语法\"><a href=\"#JavaScript基本语法\" class=\"headerlink\" title=\"JavaScript基本语法\"></a>JavaScript基本语法</h2><h3 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h3><figure class=\"highlight ebnf\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attribute\">var a</span> = 1;</span><br></pre></td></tr></table></figure>\n<p>上面的代码先声明变量a，然后在变量a与数值1之间建立引用关系，也称为将数值1“赋值”给变量a。以后，引用变量a就会得到数值1。最前面的var，是变量声明命令。它表示通知解释引擎，要创建一个变量a。</p>","more":"<p>JavaScirpt是一种动态类型语言，也就是说，变量的类型没有限制，可以赋予各种类型的值。</p>\n<p>可重新赋值，但无需重新声明。</p>\n<h4 id=\"null和undefined\"><a href=\"#null和undefined\" class=\"headerlink\" title=\"null和undefined\"></a>null和undefined</h4><p>如果只是声明变量而没有赋值，则该变量的值是<code>undefined</code>。<code>undefined</code>是一个JavaScript关键字，表示“无定义，不存在的值”。而不是<code>null</code>(理解为无值)。</p>\n<p><code>null</code>表示一个“空”的值，它和0以及空字符串’’不同，0是一个数值，’’表示长度为0的字符串，而<code>null</code>表示“空”。</p>\n<p>在其他语言中，也有类似JavaScript的<code>null</code>的表示，例如Java也用<code>null</code>，Swift用<code>nil</code>，Python用<code>None</code>表示。但是，在JavaScript中，还有一个和<code>null</code>类似的<code>undefined</code>，它表示“未定义”。</p>\n<p>JavaScript的设计者希望用<code>null</code>表示一个空的值，而<code>undefined</code>表示值未定义。事实证明，这并没有什么卵用，区分两者的意义不大。大多数情况下，我们都应该用<code>null</code>。<code>undefined</code>仅仅在判断函数参数是否传递的情况下有用。</p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p>JavaScript引擎的工作方式是，先解析代码，获取所有被声明的变量，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p>\n<h3 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h3><p>标识符（identifier）是用来识别具体对象的一个名称。</p>\n<p>标识符命名规则：</p>\n<blockquote>\n<p>第一个字符，可以是任意Unicode字母（包括英文字母和其他语言的字母），以及美元符号（$）和下划线（_）。<br>第二个字符及后面的字符，除了Unicode字母、美元符号和下划线，还可以用数字0-9</p>\n</blockquote>\n<p>注意不要用保留字，有<code>arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</code></p>\n<p>另外，还有三个词虽然不是保留字，但是因为具有特别含义，也不应该用作标识符。分别是<code>Infinity(无限大，当数值超过了JavaScript的Number所能表示的最大值时，就表示为Infinity)、NaN(表示Not a Number，当无法计算结果时用NaN表示)、undefined(未定义)。</code></p>\n<h3 id=\"注释符\"><a href=\"#注释符\" class=\"headerlink\" title=\"注释符\"></a>注释符</h3><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 这是单行注释</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> 这是</span></span><br><span class=\"line\"><span class=\"comment\"> 多行</span></span><br><span class=\"line\"><span class=\"comment\"> 注释</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br></pre></td></tr></table></figure>\n<p>此外，由于历史上JavaScript兼容HTML代码的注释，所以<code>&lt;\\!--和--&gt;</code>也被视为单行注释。</p>\n<h3 id=\"区块\"><a href=\"#区块\" class=\"headerlink\" title=\"区块\"></a>区块</h3><p>JavaScript使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。</p>\n<p>与大多数编程语言不一样，JavaScript的区块不构成单独的作用域（scope）。也就是说，区块中的变量与区块外的变量，属于同一个作用域。</p>\n<h3 id=\"标签-label\"><a href=\"#标签-label\" class=\"headerlink\" title=\"标签(label)\"></a>标签(label)</h3><p>JavaScript语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">label</span><span class=\"bash\">:</span></span><br><span class=\"line\">  statement</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"数据类型转换\"><a href=\"#数据类型转换\" class=\"headerlink\" title=\"数据类型转换\"></a>数据类型转换</h2><p>JavaScript是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。虽然变量没有类型，但是数据本身和各种运算符是有类型的。如果运算符发现，数据的类型与预期不符，就会自动转换类型。当然有些时候也会出现需要强制转换的时候。</p>\n<h3 id=\"强制转换\"><a href=\"#强制转换\" class=\"headerlink\" title=\"强制转换\"></a>强制转换</h3><p>强制转换主要指使用<code>Number</code>、<code>String</code>和<code>Boolean</code>三个构造函数，手动将各种类型的值，转换成数字、字符串或者布尔值。</p>\n<h4 id=\"Number\"><a href=\"#Number\" class=\"headerlink\" title=\"Number()\"></a>Number()</h4><p>可以将任意类型的值转化成数值。</p>\n<h5 id=\"1-原始类型值的转换规则\"><a href=\"#1-原始类型值的转换规则\" class=\"headerlink\" title=\"(1)原始类型值的转换规则\"></a>(1)原始类型值的转换规则</h5><figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 数值：转换后还是原来的值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(<span class=\"number\">324</span>)</span></span> <span class=\"comment\">// 324</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串：如果可以被解析为数值，则转换为相应的数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(<span class=\"string\">'\\t\\v\\r324\\n'</span>)</span></span> <span class=\"comment\">// 324</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 字符串：如果不可以被解析为数值，返回NaN</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(<span class=\"string\">'abc'</span>)</span></span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 空字符串转为0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(<span class=\"string\">''</span>)</span></span> <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// undefined：转成 NaN</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(undefined)</span></span> <span class=\"comment\">// NaN</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// null：转成0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">Number</span><span class=\"params\">(null)</span></span> <span class=\"comment\">// 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">parseInt</span><span class=\"params\">(<span class=\"string\">'42 abc'</span>)</span></span> <span class=\"comment\">// 42</span></span><br></pre></td></tr></table></figure>\n<p><code>parseInt</code>逐个解析字符，而<code>Number</code>函数整体转换字符串的类型。<br>另外，<code>Number</code>函数会自动过滤一个字符串前导和后缀的空格。</p>\n<h5 id=\"2-对象的转换规则\"><a href=\"#2-对象的转换规则\" class=\"headerlink\" title=\"(2)对象的转换规则\"></a>(2)对象的转换规则</h5><p>Number方法的参数是对象时，将返回NaN。</p>\n<blockquote>\n<p>1.调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。</p>\n</blockquote>\n<blockquote>\n<p>2.如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。</p>\n</blockquote>\n<blockquote>\n<p>3.如果toString方法返回的是对象，就报错。</p>\n</blockquote>\n<h4 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String()\"></a>String()</h4><p>可以将任意类型的值转化成字符串。</p>\n<h5 id=\"1-原始类型值的转换规则-1\"><a href=\"#1-原始类型值的转换规则-1\" class=\"headerlink\" title=\"(1)原始类型值的转换规则\"></a>(1)原始类型值的转换规则</h5><blockquote>\n<p>数值：转为相应的字符串。<br>字符串：转换后还是原来的值。<br>布尔值：true转为”true”，false转为”false”。<br>undefined：转为”undefined”。<br>null：转为”null”。</p>\n</blockquote>\n<h5 id=\"String-对象的转换规则\"><a href=\"#String-对象的转换规则\" class=\"headerlink\" title=\"String()对象的转换规则\"></a>String()对象的转换规则</h5><p><code>String</code>方法的参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">String</span><span class=\"params\">(&#123;a: <span class=\"number\">1</span>&#125;)</span></span> <span class=\"comment\">// \"[object Object]\"</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">String</span><span class=\"params\">([<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>])</span></span> <span class=\"comment\">// \"1,2,3\"</span></span><br></pre></td></tr></table></figure>\n<p><code>String</code>方法背后的转换规则，优先<code>toString</code>方法，后<code>valueOf</code>方法。</p>\n<h4 id=\"Boolean\"><a href=\"#Boolean\" class=\"headerlink\" title=\"Boolean()\"></a>Boolean()</h4><p>使用Boolean函数，可以将任意类型的变量转为布尔值。</p>\n<p>它的转换规则相对简单：除了以下六个值的转换结果为false，其他的值全部为true。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">undefined</span></span><br><span class=\"line\"><span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"number\">-0</span></span><br><span class=\"line\"><span class=\"number\">0</span>或+<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span></span><br><span class=\"line\"><span class=\"string\">''</span>（空字符串）</span><br></pre></td></tr></table></figure></p>\n<p><strong>注意</strong>:所有对象（包括空对象）的转换结果都是true，甚至连false对应的布尔对象new Boolean(false)也是true。</p>\n<h3 id=\"自动转换\"><a href=\"#自动转换\" class=\"headerlink\" title=\"自动转换\"></a>自动转换</h3><p>下面介绍自动转换，它是以强制转换为基础的。</p>\n<p>遇到以下三种情况时，JavaScript会自动转换数据类型，即转换是自动完成的，对用户不可见。</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"number\">1</span>. 不同类型的数据互相运算</span><br><span class=\"line\"><span class=\"number\">123</span> + <span class=\"string\">'abc'</span> <span class=\"regexp\">//</span> <span class=\"string\">\"123abc\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"number\">2</span>. 对非布尔值类型的数据求布尔值</span><br><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"string\">'abc'</span>) &#123;</span><br><span class=\"line\">  console.log(<span class=\"string\">'hello'</span>)</span><br><span class=\"line\">&#125;  <span class=\"regexp\">//</span> <span class=\"string\">\"hello\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"regexp\">//</span> <span class=\"number\">3</span>. 对非数值类型的数据使用一元运算符（即“+”和“-”）</span><br><span class=\"line\">+ &#123;foo: <span class=\"string\">'bar'</span>&#125; <span class=\"regexp\">//</span> NaN</span><br><span class=\"line\">- [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>] <span class=\"regexp\">//</span> NaN</span><br></pre></td></tr></table></figure>\n<p>自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。</p>\n<p>由于自动转换具有不确定性，而且不易出错，建议在预期为布尔值、数值、字符串的地方，全部使用Boolean、Number和String函数进行显式转换。</p>\n<p>除了加法运算符有可能把运算子转为字符串，其他运算符都会把运算子自动转成数值。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">false</span> / <span class=\"string\">'5'</span> <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"string\">'abc'</span> - <span class=\"number\">1</span>   <span class=\"comment\">// NaN</span></span><br></pre></td></tr></table></figure></p>\n<hr>\n<p>学习参考：<br><a href=\"http://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000\" target=\"_blank\" rel=\"noopener\">廖雪峰的JavaScript教程</a><br><a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">JavaScript 标准参考教程 阮一峰</a><br><a href=\"http://www.ycku.com/javascript/?utm_source=caibaojian.com\" target=\"_blank\" rel=\"noopener\">李炎恢的JavaScript视频教程</a></p>"},{"title":"JavaScript学习(4)函数","date":"2016-09-16T03:51:23.000Z","_content":"\n\n## 概述\n\n函数就是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。\n\n### 函数的声明\n\nJavaScript有三种方法，可以声明一个函数。\n\n如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。\n\n\n<!-- more -->\n#### （1）function命令\nfunction命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。\n```\nfunction print(s) {\n  console.log(s);\n}\n```\n#### （2）函数表达式\n除了用function命令声明函数，还可以采用变量赋值的写法。\n```\nvar print = function(s) {\n  console.log(s);\n};\n```\n这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。\n\n采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。\n\n当然，这种写法也有两个好处。\n1.可以在函数体内部调用自身\n2.方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。\n\n#### （3）Function构造函数\n```\nvar add = new Function(\n  'x',\n  'y',\n  'return (x + y)'\n);\n\n// 等同于\n\nfunction add(x, y) {\n  return (x + y);\n}\n```\n你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。\n\n### 第一等公民\nJavaScript语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。\n\n由于函数与其他数据类型地位平等，所以在JavaScript语言中又称函数为第一等公民。\n```\nfunction add(x, y) {\n  return x + y;\n}\n\n// 将函数赋值给一个变量\nvar operator = add;\n\n// 将函数作为参数和返回值\nfunction a(op){\n  return op;\n}\na(add)(1, 1)\n// 2\n```\n### 函数名的提升\n\nJavaScript引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。\n\n如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。\n\n```\nvar f = function() {\n  console.log('1');\n}\n\nfunction f() {\n  console.log('2');\n}\n\nf() // 1\n```\n\n###　不能在条件语句中声明函数\n\n```\nif (false) {\n  function f() {}\n}\n\nf() // 不报错\n```\n\n上面代码的原始意图是不声明函数f，但是由于f的提升，导致if语句无效，所以上面的代码不会报错。要达到在条件语句中定义函数的目的，只有使用函数表达式。\n```\nif (false) {\n  var f = function () {};\n}\n\nf() // undefined\n```\n## 函数的属性和方法\n\n### name属性\n\nname属性返回紧跟在function关键字之后的那个函数名。\n```\nvar f2 = function () {};\nf2.name // ''\nvar f3 = function myName() {};\nf3.name // 'myName'\n```\n对于f2来说，返回空字符串，匿名函数的name属性总是为空字符串；对于f3来说，返回函数表达式的名字（真正的函数名还是f3，myName这个名字只在函数体内部可用）。\n\n### length属性\n\nlength属性返回函数预期传入的参数个数，即函数定义之中的参数个数。\n```\nfunction f(a, b) {}\nf.length // 2\n```\n上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。\n\nlength属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。\n\n### toString()\n\n函数的toString方法返回函数的源码。函数内部的注释也可以返回。\n\n利用这一点，可以变相实现多行字符串。\n```\nvar multiline = function (fn) {\n  var arr = fn.toString().split('\\n');\n  return arr.slice(1, arr.length - 1).join('\\n');\n};\n\nfunction f() {/*\n  这是一个\n  多行注释\n*/}\n\nmultiline(f);\n// \" 这是一个\n//   多行注释\"\n```\n## 函数作用域\n\n### 定义\n\n作用域（scope）指的是变量存在的范围。Javascript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。\n\n在函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。\n\n函数内部定义的变量，会在该作用域内覆盖同名全局变量。\n\n注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。\n\n### 函数内部的变量提升\n\n与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。\n\n### 函数本身的作用域\n\n函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。\n\n总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。\n\n同样的，函数体内部声明的函数，作用域绑定函数体内部。\n```\nfunction foo() {\n  var x = 1;\n  function bar() {\n    console.log(x);\n  }\n  return bar;\n}\n\nvar x = 2;\nvar f = foo();\nf() // 1\n```\n上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。\n\n## 参数\n\n### 概述\n\n函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。\n\n### 参数的省略\n\n尽管例如函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript都不会报错。\n\n但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。\n```\nfunction f(a, b) {\n  return a;\n}\n\nf( , 1) // SyntaxError: Unexpected token ,(…)\nf(undefined, 1) // undefined\n```\n\n### 默认值\n||表示“或运算”，即如果a有值，则返回a，否则返回事先设定的默认值。\n\n这种写法会对a进行一次布尔运算，只有为true时，才会返回a。可是，除了undefined以外，0、空字符、null等的布尔值也是false。也就是说，在上面的函数中，不能让a等于0或空字符串，否则在明明有参数的情况下，也会返回默认值。\n\n更精准的写法：\n```\n(a !== undefined && a !== null) ? a = a : a = 1;\n```\n函数f的参数是空字符或0，都不会触发参数的默认值。\n\n### 传递方式\n函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。\n\n但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。\n```\nvar obj = {p: 1};\n\nfunction f(o) {\n  o.p = 2;\n}\nf(obj);\n\nobj.p // 2\n```\n某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。\n```\nvar a = 1;\n\nfunction f(p) {\n  window[p] = 2;\n}\nf('a');\n\na // 2\n```\n上面代码中，变量a本来是传值传递，但是写成window对象的属性，就达到了传址传递的效果。\n\n### 同名参数\n如果有同名的参数，则取最后出现的那个值。\n\n调用函数f(1)的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。\n```\nfunction f(a, a){\n  console.log(arguments[0]);\n}\n\nf(1) // 1\n```\n\n### arguments对象\n\n#### (1)定义\n由于JavaScript允许函数有不定数目的参数，所以我们需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。\n\narguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。\n\narguments对象除了可以读取参数，还可以为参数赋值（严格模式不允许这种用法）。\n```\nvar f = function(a, b) {\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1)\n// 5\n```\n可以通过arguments对象的length属性，判断函数调用时到底带几个参数。\n\n#### (2)与数组的关系\n需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。\n\n要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。\n\n```\nvar args = Array.prototype.slice.call(arguments);\n\n// or\n\nvar args = [];\nfor (var i = 0; i < arguments.length; i++) {\n  args.push(arguments[i]);\n}\n```\n\n#### (3)callee属性\narguments对象带有一个callee属性，返回它所对应的原函数。\n\n可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。\n\n## 函数的其他知识点\n\n### 闭包\n\n闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。\n\n要理解闭包，首先必须理解变量作用域。前面提到，JavaScript有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。\n```\nfunction f1() {\n  var n = 999;\n  function f2() {\n　　console.log(n); // 999\n  }\n}\n```\n函数f1内部声明的变量n，函数外是无法读取的。\n\n如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。\n\n上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是JavaScript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n\n既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！\n```\nfunction f1() {\n  var n = 999;\n  function f2() {\n    console.log(n);\n  }\n  return f2;\n}\n\nvar result = f1();\nresult(); // 999\n```\n闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n\n闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。\n```\nfunction createIncrementor(start) {\n  return function () {\n    return start++;\n  };\n}\n\nvar inc = createIncrementor(5);\n\ninc() // 5\ninc() // 6\ninc() // 7\n```\n上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。\n\n为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。\n\n闭包的另一个用处，是封装对象的私有属性和私有方法。\n\n```\nfunction Person(name) {\n  var _age;\n  function setAge(n) {\n    _age = n;\n  }\n  function getAge() {\n    return _age;\n  }\n\n  return {\n    name: name,\n    getAge: getAge,\n    setAge: setAge\n  };\n}\n\nvar p1 = Person('张三');\np1.setAge(25);\np1.getAge() // 25\n```\n\n注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。\n\n### 立即调用的函数表达式（IIFE）\n在Javascript中，一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。\n\n有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。\n```\nfunction(){ /* code */ }();\n// SyntaxError: Unexpected token (\n```\n\n产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。\n\n为了避免解析上的歧义，JavaScript引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。\n\n解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。\n```\n(function(){ /* code */ }());\n// 或者\n(function(){ /* code */ })();\n```\n\n上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称IIFE。\n\n注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个IIFE，可能就会报错。\n\n当然，还有一些别的写法。\n```\nvar i = function(){ return 10; }();\ntrue && function(){ /* code */ }();\n0, function(){ /* code */ }();\n\n!function(){ /* code */ }();\n~function(){ /* code */ }();\n-function(){ /* code */ }();\n+function(){ /* code */ }();\n\nnew function(){ /* code */ }\n\nnew function(){ /* code */ }()\n// 只有传递参数时，才需要最后那个圆括号\n```\n通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。\n\n```\n// 写法一\nvar tmp = newData;\nprocessData(tmp);\nstoreData(tmp);\n\n// 写法二\n(function (){\n  var tmp = newData;\n  processData(tmp);\n  storeData(tmp);\n}());\n```\n上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。\n\n## eval命令\neval命令的作用是，将字符串当作语句执行。\n```\neval('var a = 1;');\na // 1\n```\neval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。\n\n此外，eval的命令字符串不会得到JavaScript引擎的优化，运行速度较慢。这也是一个不应该使用它的理由。\n\n通常情况下，eval最常见的场合是解析JSON数据字符串，不过正确的做法应该是使用浏览器提供的JSON.parse方法。\n\navaScript引擎内部，eval实际上是一个引用，默认调用一个内部方法。这使得eval的使用分成两种情况，一种是像上面这样的调用eval(expression)，这叫做“直接使用”，这种情况下eval的作用域就是当前作用域。除此之外的调用方法，都叫“间接调用”，此时eval的作用域总是全局作用域。\n```\nvar a = 1;\n\nfunction f() {\n  var a = 2;\n  var e = eval;\n  e('console.log(a)');\n}\n\nf() // 1\n```\n上面代码中，eval是间接调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的a为全局变量。\n\neval的间接调用的形式五花八门，只要不是直接调用，都属于间接调用。\n\n与eval作用类似的还有Function构造函数。利用它生成一个函数，然后调用该函数，也能将字符串当作命令执行。\n```\nvar jsonp = 'foo({\"id\": 42})';\n\nvar f = new Function( \"foo\", jsonp );\n// 相当于定义了如下函数\n// function f(foo) {\n//   foo({\"id\":42});\n// }\n\nf(function(json){\n  console.log( json.id ); // 42\n})\n```\n\n上面代码中，jsonp是一个字符串，Function构造函数将这个字符串，变成了函数体。调用该函数的时候，jsonp就会执行。这种写法的实质是将代码放到函数作用域执行，避免对全局作用域造成影响。\n\n不过，new Function()的写法也可以读写全局作用域，所以也是应该避免使用它。\n\n----\n学习参考：\n[JavaScript 标准参考教程 阮一峰](http://javascript.ruanyifeng.com/)","source":"_posts/前端相关学习/js/javascript学习(4)函数.md","raw":"---\ntitle: JavaScript学习(4)函数\ndate: 2016-09-16 11:51:23\ntags: \n- JavaScript\ncategories: 总结\n---\n\n\n## 概述\n\n函数就是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。\n\n### 函数的声明\n\nJavaScript有三种方法，可以声明一个函数。\n\n如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。\n\n\n<!-- more -->\n#### （1）function命令\nfunction命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。\n```\nfunction print(s) {\n  console.log(s);\n}\n```\n#### （2）函数表达式\n除了用function命令声明函数，还可以采用变量赋值的写法。\n```\nvar print = function(s) {\n  console.log(s);\n};\n```\n这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。\n\n采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。\n\n当然，这种写法也有两个好处。\n1.可以在函数体内部调用自身\n2.方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。\n\n#### （3）Function构造函数\n```\nvar add = new Function(\n  'x',\n  'y',\n  'return (x + y)'\n);\n\n// 等同于\n\nfunction add(x, y) {\n  return (x + y);\n}\n```\n你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。\n\n### 第一等公民\nJavaScript语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。\n\n由于函数与其他数据类型地位平等，所以在JavaScript语言中又称函数为第一等公民。\n```\nfunction add(x, y) {\n  return x + y;\n}\n\n// 将函数赋值给一个变量\nvar operator = add;\n\n// 将函数作为参数和返回值\nfunction a(op){\n  return op;\n}\na(add)(1, 1)\n// 2\n```\n### 函数名的提升\n\nJavaScript引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。\n\n如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。\n\n```\nvar f = function() {\n  console.log('1');\n}\n\nfunction f() {\n  console.log('2');\n}\n\nf() // 1\n```\n\n###　不能在条件语句中声明函数\n\n```\nif (false) {\n  function f() {}\n}\n\nf() // 不报错\n```\n\n上面代码的原始意图是不声明函数f，但是由于f的提升，导致if语句无效，所以上面的代码不会报错。要达到在条件语句中定义函数的目的，只有使用函数表达式。\n```\nif (false) {\n  var f = function () {};\n}\n\nf() // undefined\n```\n## 函数的属性和方法\n\n### name属性\n\nname属性返回紧跟在function关键字之后的那个函数名。\n```\nvar f2 = function () {};\nf2.name // ''\nvar f3 = function myName() {};\nf3.name // 'myName'\n```\n对于f2来说，返回空字符串，匿名函数的name属性总是为空字符串；对于f3来说，返回函数表达式的名字（真正的函数名还是f3，myName这个名字只在函数体内部可用）。\n\n### length属性\n\nlength属性返回函数预期传入的参数个数，即函数定义之中的参数个数。\n```\nfunction f(a, b) {}\nf.length // 2\n```\n上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。\n\nlength属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。\n\n### toString()\n\n函数的toString方法返回函数的源码。函数内部的注释也可以返回。\n\n利用这一点，可以变相实现多行字符串。\n```\nvar multiline = function (fn) {\n  var arr = fn.toString().split('\\n');\n  return arr.slice(1, arr.length - 1).join('\\n');\n};\n\nfunction f() {/*\n  这是一个\n  多行注释\n*/}\n\nmultiline(f);\n// \" 这是一个\n//   多行注释\"\n```\n## 函数作用域\n\n### 定义\n\n作用域（scope）指的是变量存在的范围。Javascript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。\n\n在函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。\n\n函数内部定义的变量，会在该作用域内覆盖同名全局变量。\n\n注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。\n\n### 函数内部的变量提升\n\n与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。\n\n### 函数本身的作用域\n\n函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。\n\n总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。\n\n同样的，函数体内部声明的函数，作用域绑定函数体内部。\n```\nfunction foo() {\n  var x = 1;\n  function bar() {\n    console.log(x);\n  }\n  return bar;\n}\n\nvar x = 2;\nvar f = foo();\nf() // 1\n```\n上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。\n\n## 参数\n\n### 概述\n\n函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。\n\n### 参数的省略\n\n尽管例如函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript都不会报错。\n\n但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。\n```\nfunction f(a, b) {\n  return a;\n}\n\nf( , 1) // SyntaxError: Unexpected token ,(…)\nf(undefined, 1) // undefined\n```\n\n### 默认值\n||表示“或运算”，即如果a有值，则返回a，否则返回事先设定的默认值。\n\n这种写法会对a进行一次布尔运算，只有为true时，才会返回a。可是，除了undefined以外，0、空字符、null等的布尔值也是false。也就是说，在上面的函数中，不能让a等于0或空字符串，否则在明明有参数的情况下，也会返回默认值。\n\n更精准的写法：\n```\n(a !== undefined && a !== null) ? a = a : a = 1;\n```\n函数f的参数是空字符或0，都不会触发参数的默认值。\n\n### 传递方式\n函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。\n\n但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。\n```\nvar obj = {p: 1};\n\nfunction f(o) {\n  o.p = 2;\n}\nf(obj);\n\nobj.p // 2\n```\n某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。\n```\nvar a = 1;\n\nfunction f(p) {\n  window[p] = 2;\n}\nf('a');\n\na // 2\n```\n上面代码中，变量a本来是传值传递，但是写成window对象的属性，就达到了传址传递的效果。\n\n### 同名参数\n如果有同名的参数，则取最后出现的那个值。\n\n调用函数f(1)的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。\n```\nfunction f(a, a){\n  console.log(arguments[0]);\n}\n\nf(1) // 1\n```\n\n### arguments对象\n\n#### (1)定义\n由于JavaScript允许函数有不定数目的参数，所以我们需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。\n\narguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。\n\narguments对象除了可以读取参数，还可以为参数赋值（严格模式不允许这种用法）。\n```\nvar f = function(a, b) {\n  arguments[0] = 3;\n  arguments[1] = 2;\n  return a + b;\n}\n\nf(1, 1)\n// 5\n```\n可以通过arguments对象的length属性，判断函数调用时到底带几个参数。\n\n#### (2)与数组的关系\n需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。\n\n要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。\n\n```\nvar args = Array.prototype.slice.call(arguments);\n\n// or\n\nvar args = [];\nfor (var i = 0; i < arguments.length; i++) {\n  args.push(arguments[i]);\n}\n```\n\n#### (3)callee属性\narguments对象带有一个callee属性，返回它所对应的原函数。\n\n可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。\n\n## 函数的其他知识点\n\n### 闭包\n\n闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。\n\n要理解闭包，首先必须理解变量作用域。前面提到，JavaScript有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。\n```\nfunction f1() {\n  var n = 999;\n  function f2() {\n　　console.log(n); // 999\n  }\n}\n```\n函数f1内部声明的变量n，函数外是无法读取的。\n\n如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。\n\n上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是JavaScript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。\n\n既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！\n```\nfunction f1() {\n  var n = 999;\n  function f2() {\n    console.log(n);\n  }\n  return f2;\n}\n\nvar result = f1();\nresult(); // 999\n```\n闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n\n闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。\n```\nfunction createIncrementor(start) {\n  return function () {\n    return start++;\n  };\n}\n\nvar inc = createIncrementor(5);\n\ninc() // 5\ninc() // 6\ninc() // 7\n```\n上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。\n\n为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。\n\n闭包的另一个用处，是封装对象的私有属性和私有方法。\n\n```\nfunction Person(name) {\n  var _age;\n  function setAge(n) {\n    _age = n;\n  }\n  function getAge() {\n    return _age;\n  }\n\n  return {\n    name: name,\n    getAge: getAge,\n    setAge: setAge\n  };\n}\n\nvar p1 = Person('张三');\np1.setAge(25);\np1.getAge() // 25\n```\n\n注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。\n\n### 立即调用的函数表达式（IIFE）\n在Javascript中，一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。\n\n有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。\n```\nfunction(){ /* code */ }();\n// SyntaxError: Unexpected token (\n```\n\n产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。\n\n为了避免解析上的歧义，JavaScript引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。\n\n解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。\n```\n(function(){ /* code */ }());\n// 或者\n(function(){ /* code */ })();\n```\n\n上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称IIFE。\n\n注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个IIFE，可能就会报错。\n\n当然，还有一些别的写法。\n```\nvar i = function(){ return 10; }();\ntrue && function(){ /* code */ }();\n0, function(){ /* code */ }();\n\n!function(){ /* code */ }();\n~function(){ /* code */ }();\n-function(){ /* code */ }();\n+function(){ /* code */ }();\n\nnew function(){ /* code */ }\n\nnew function(){ /* code */ }()\n// 只有传递参数时，才需要最后那个圆括号\n```\n通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。\n\n```\n// 写法一\nvar tmp = newData;\nprocessData(tmp);\nstoreData(tmp);\n\n// 写法二\n(function (){\n  var tmp = newData;\n  processData(tmp);\n  storeData(tmp);\n}());\n```\n上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。\n\n## eval命令\neval命令的作用是，将字符串当作语句执行。\n```\neval('var a = 1;');\na // 1\n```\neval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。\n\n此外，eval的命令字符串不会得到JavaScript引擎的优化，运行速度较慢。这也是一个不应该使用它的理由。\n\n通常情况下，eval最常见的场合是解析JSON数据字符串，不过正确的做法应该是使用浏览器提供的JSON.parse方法。\n\navaScript引擎内部，eval实际上是一个引用，默认调用一个内部方法。这使得eval的使用分成两种情况，一种是像上面这样的调用eval(expression)，这叫做“直接使用”，这种情况下eval的作用域就是当前作用域。除此之外的调用方法，都叫“间接调用”，此时eval的作用域总是全局作用域。\n```\nvar a = 1;\n\nfunction f() {\n  var a = 2;\n  var e = eval;\n  e('console.log(a)');\n}\n\nf() // 1\n```\n上面代码中，eval是间接调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的a为全局变量。\n\neval的间接调用的形式五花八门，只要不是直接调用，都属于间接调用。\n\n与eval作用类似的还有Function构造函数。利用它生成一个函数，然后调用该函数，也能将字符串当作命令执行。\n```\nvar jsonp = 'foo({\"id\": 42})';\n\nvar f = new Function( \"foo\", jsonp );\n// 相当于定义了如下函数\n// function f(foo) {\n//   foo({\"id\":42});\n// }\n\nf(function(json){\n  console.log( json.id ); // 42\n})\n```\n\n上面代码中，jsonp是一个字符串，Function构造函数将这个字符串，变成了函数体。调用该函数的时候，jsonp就会执行。这种写法的实质是将代码放到函数作用域执行，避免对全局作用域造成影响。\n\n不过，new Function()的写法也可以读写全局作用域，所以也是应该避免使用它。\n\n----\n学习参考：\n[JavaScript 标准参考教程 阮一峰](http://javascript.ruanyifeng.com/)","slug":"前端相关学习/js/javascript学习(4)函数","published":1,"updated":"2019-03-22T14:44:36.737Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6cbwn5500cf4l3n55tb6wty","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>函数就是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。</p>\n<h3 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h3><p>JavaScript有三种方法，可以声明一个函数。</p>\n<p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</p>\n<a id=\"more\"></a>\n<h4 id=\"（1）function命令\"><a href=\"#（1）function命令\" class=\"headerlink\" title=\"（1）function命令\"></a>（1）function命令</h4><p>function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。<br><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span></span> <span class=\"built_in\">print</span>(s) &#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"（2）函数表达式\"><a href=\"#（2）函数表达式\" class=\"headerlink\" title=\"（2）函数表达式\"></a>（2）函数表达式</h4><p>除了用function命令声明函数，还可以采用变量赋值的写法。<br><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var <span class=\"built_in\">print</span> = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(s)</span></span> &#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(s);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。</p>\n<p>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>\n<p>当然，这种写法也有两个好处。<br>1.可以在函数体内部调用自身<br>2.方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。</p>\n<h4 id=\"（3）Function构造函数\"><a href=\"#（3）Function构造函数\" class=\"headerlink\" title=\"（3）Function构造函数\"></a>（3）Function构造函数</h4><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">Function</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"string\">'x'</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"string\">'y'</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"string\">'return (x + y)'</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (x + y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。</p>\n<h3 id=\"第一等公民\"><a href=\"#第一等公民\" class=\"headerlink\" title=\"第一等公民\"></a>第一等公民</h3><p>JavaScript语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。</p>\n<p>由于函数与其他数据类型地位平等，所以在JavaScript语言中又称函数为第一等公民。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将函数赋值给一个变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> operator = add;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将函数作为参数和返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span><span class=\"params\">(op)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> op;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(add)(<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"函数名的提升\"><a href=\"#函数名的提升\" class=\"headerlink\" title=\"函数名的提升\"></a>函数名的提升</h3><p>JavaScript引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。</p>\n<p>如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>###　不能在条件语句中声明函数</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// 不报错</span></span><br></pre></td></tr></table></figure>\n<p>上面代码的原始意图是不声明函数f，但是由于f的提升，导致if语句无效，所以上面的代码不会报错。要达到在条件语句中定义函数的目的，只有使用函数表达式。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数的属性和方法\"><a href=\"#函数的属性和方法\" class=\"headerlink\" title=\"函数的属性和方法\"></a>函数的属性和方法</h2><h3 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h3><p>name属性返回紧跟在function关键字之后的那个函数名。<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f2 = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> <span class=\"comment\">&#123;&#125;</span>;</span></span><br><span class=\"line\">f2.<span class=\"keyword\">name</span> <span class=\"comment\">// ''</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f3 = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myName</span><span class=\"params\">()</span> <span class=\"comment\">&#123;&#125;</span>;</span></span><br><span class=\"line\">f3.<span class=\"keyword\">name</span> <span class=\"comment\">// 'myName'</span></span><br></pre></td></tr></table></figure></p>\n<p>对于f2来说，返回空字符串，匿名函数的name属性总是为空字符串；对于f3来说，返回函数表达式的名字（真正的函数名还是f3，myName这个名字只在函数体内部可用）。</p>\n<h3 id=\"length属性\"><a href=\"#length属性\" class=\"headerlink\" title=\"length属性\"></a>length属性</h3><p>length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。<br><figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(a, b)</span> &#123;&#125;</span></span><br><span class=\"line\">f.<span class=\"built_in\">length</span> <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。</p>\n<p>length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。</p>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>函数的toString方法返回函数的源码。函数内部的注释也可以返回。</p>\n<p>利用这一点，可以变相实现多行字符串。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> multiline = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(fn)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = fn.toString().split(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.slice(<span class=\"number\">1</span>, arr.length - <span class=\"number\">1</span>).join(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  这是一个</span></span><br><span class=\"line\"><span class=\"comment\">  多行注释</span></span><br><span class=\"line\"><span class=\"comment\">*/</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">multiline(f);</span><br><span class=\"line\"><span class=\"comment\">// \" 这是一个</span></span><br><span class=\"line\"><span class=\"comment\">//   多行注释\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>作用域（scope）指的是变量存在的范围。Javascript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。</p>\n<p>在函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。</p>\n<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</p>\n<p>注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。</p>\n<h3 id=\"函数内部的变量提升\"><a href=\"#函数内部的变量提升\" class=\"headerlink\" title=\"函数内部的变量提升\"></a>函数内部的变量提升</h3><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p>\n<h3 id=\"函数本身的作用域\"><a href=\"#函数本身的作用域\" class=\"headerlink\" title=\"函数本身的作用域\"></a>函数本身的作用域</h3><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p>\n<p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p>\n<p>同样的，函数体内部声明的函数，作用域绑定函数体内部。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = foo();</span><br><span class=\"line\">f() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</p>\n<h3 id=\"参数的省略\"><a href=\"#参数的省略\" class=\"headerlink\" title=\"参数的省略\"></a>参数的省略</h3><p>尽管例如函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript都不会报错。</p>\n<p>但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(a, b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f( , <span class=\"number\">1</span>) <span class=\"comment\">// SyntaxError: Unexpected token ,(…)</span></span><br><span class=\"line\">f(<span class=\"literal\">undefined</span>, <span class=\"number\">1</span>) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><p>||表示“或运算”，即如果a有值，则返回a，否则返回事先设定的默认值。</p>\n<p>这种写法会对a进行一次布尔运算，只有为true时，才会返回a。可是，除了undefined以外，0、空字符、null等的布尔值也是false。也就是说，在上面的函数中，不能让a等于0或空字符串，否则在明明有参数的情况下，也会返回默认值。</p>\n<p>更精准的写法：<br><figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a <span class=\"comment\">!== undefined &amp;&amp; a !== null) ? a = a : a = 1;</span></span><br></pre></td></tr></table></figure></p>\n<p>函数f的参数是空字符或0，都不会触发参数的默认值。</p>\n<h3 id=\"传递方式\"><a href=\"#传递方式\" class=\"headerlink\" title=\"传递方式\"></a>传递方式</h3><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</p>\n<p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"comment\">&#123;p: 1&#125;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(o)</span> <span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">  o.p = 2;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">&#125;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">f</span><span class=\"params\">(obj)</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.p <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(p)</span> <span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">  window[p] = 2;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">&#125;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">f</span><span class=\"params\">(<span class=\"string\">'a'</span>)</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，变量a本来是传值传递，但是写成window对象的属性，就达到了传址传递的效果。</p>\n<h3 id=\"同名参数\"><a href=\"#同名参数\" class=\"headerlink\" title=\"同名参数\"></a>同名参数</h3><p>如果有同名的参数，则取最后出现的那个值。</p>\n<p>调用函数f(1)的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a, a</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"arguments对象\"><a href=\"#arguments对象\" class=\"headerlink\" title=\"arguments对象\"></a>arguments对象</h3><h4 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"(1)定义\"></a>(1)定义</h4><p>由于JavaScript允许函数有不定数目的参数，所以我们需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。</p>\n<p>arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>\n<p>arguments对象除了可以读取参数，还可以为参数赋值（严格模式不允许这种用法）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></p>\n<p>可以通过arguments对象的length属性，判断函数调用时到底带几个参数。</p>\n<h4 id=\"2-与数组的关系\"><a href=\"#2-与数组的关系\" class=\"headerlink\" title=\"(2)与数组的关系\"></a>(2)与数组的关系</h4><p>需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。</p>\n<p>要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> <span class=\"built_in\">args</span> = Array.prototype.slice.call(arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">// <span class=\"keyword\">or</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> <span class=\"built_in\">args</span> = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>; i &lt; arguments.<span class=\"built_in\">length</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">args</span>.<span class=\"built_in\">push</span>(arguments[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-callee属性\"><a href=\"#3-callee属性\" class=\"headerlink\" title=\"(3)callee属性\"></a>(3)callee属性</h4><p>arguments对象带有一个callee属性，返回它所对应的原函数。</p>\n<p>可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p>\n<h2 id=\"函数的其他知识点\"><a href=\"#函数的其他知识点\" class=\"headerlink\" title=\"函数的其他知识点\"></a>函数的其他知识点</h2><h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>\n<p>要理解闭包，首先必须理解变量作用域。前面提到，JavaScript有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 999</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数f1内部声明的变量n，函数外是无法读取的。</p>\n<p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p>\n<p>上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是JavaScript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>\n<p>既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = f1();</span><br><span class=\"line\">result(); <span class=\"comment\">// 999</span></span><br></pre></td></tr></table></figure></p>\n<p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>\n<p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createIncrementor</span><span class=\"params\">(start)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> start++;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> inc = createIncrementor(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">inc() <span class=\"comment\">// 5</span></span><br><span class=\"line\">inc() <span class=\"comment\">// 6</span></span><br><span class=\"line\">inc() <span class=\"comment\">// 7</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p>\n<p>为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p>\n<p>闭包的另一个用处，是封装对象的私有属性和私有方法。</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span><span class=\"params\">(name)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _age;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setAge</span><span class=\"params\">(n)</span> </span>&#123;</span><br><span class=\"line\">    _age = n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: name,</span><br><span class=\"line\">    getAge: getAge,</span><br><span class=\"line\">    setAge: setAge</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = Person(<span class=\"string\">'张三'</span>);</span><br><span class=\"line\">p1.setAge(<span class=\"number\">25</span>);</span><br><span class=\"line\">p1.getAge() <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n<p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>\n<h3 id=\"立即调用的函数表达式（IIFE）\"><a href=\"#立即调用的函数表达式（IIFE）\" class=\"headerlink\" title=\"立即调用的函数表达式（IIFE）\"></a>立即调用的函数表达式（IIFE）</h3><p>在Javascript中，一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。</p>\n<p>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure></p>\n<p>产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。</p>\n<p>为了避免解析上的歧义，JavaScript引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</p>\n<p>解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;());</span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称IIFE。</p>\n<p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个IIFE，可能就会报错。</p>\n<p>当然，还有一些别的写法。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">10</span>; &#125;();</span><br><span class=\"line\"><span class=\"literal\">true</span> &amp;&amp; <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\"><span class=\"number\">0</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">!<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\">~<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\">-<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\">+<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;()</span><br><span class=\"line\"><span class=\"comment\">// 只有传递参数时，才需要最后那个圆括号</span></span><br></pre></td></tr></table></figure></p>\n<p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span><span class=\"type\">Data</span>;</span><br><span class=\"line\">processData(tmp);</span><br><span class=\"line\">storeData(tmp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> </span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span><span class=\"type\">Data</span>;</span><br><span class=\"line\">  processData(tmp);</span><br><span class=\"line\">  storeData(tmp);</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。</p>\n<h2 id=\"eval命令\"><a href=\"#eval命令\" class=\"headerlink\" title=\"eval命令\"></a>eval命令</h2><p>eval命令的作用是，将字符串当作语句执行。<br><figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval<span class=\"comment\">('var a = 1;')</span>;</span><br><span class=\"line\">a <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。</p>\n<p>此外，eval的命令字符串不会得到JavaScript引擎的优化，运行速度较慢。这也是一个不应该使用它的理由。</p>\n<p>通常情况下，eval最常见的场合是解析JSON数据字符串，不过正确的做法应该是使用浏览器提供的JSON.parse方法。</p>\n<p>avaScript引擎内部，eval实际上是一个引用，默认调用一个内部方法。这使得eval的使用分成两种情况，一种是像上面这样的调用eval(expression)，这叫做“直接使用”，这种情况下eval的作用域就是当前作用域。除此之外的调用方法，都叫“间接调用”，此时eval的作用域总是全局作用域。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> e = <span class=\"built_in\">eval</span>;</span><br><span class=\"line\">  e(<span class=\"string\">'console.log(a)'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，eval是间接调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的a为全局变量。</p>\n<p>eval的间接调用的形式五花八门，只要不是直接调用，都属于间接调用。</p>\n<p>与eval作用类似的还有Function构造函数。利用它生成一个函数，然后调用该函数，也能将字符串当作命令执行。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> jsonp = <span class=\"string\">'foo(&#123;\"id\": 42&#125;)'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">Function</span><span class=\"params\">( <span class=\"string\">\"foo\"</span>, jsonp )</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于定义了如下函数</span></span><br><span class=\"line\"><span class=\"comment\">// function f(foo) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   foo(&#123;\"id\":42&#125;);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(json)</span></span>&#123;</span><br><span class=\"line\">  console.log( json.id ); <span class=\"comment\">// 42</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，jsonp是一个字符串，Function构造函数将这个字符串，变成了函数体。调用该函数的时候，jsonp就会执行。这种写法的实质是将代码放到函数作用域执行，避免对全局作用域造成影响。</p>\n<p>不过，new Function()的写法也可以读写全局作用域，所以也是应该避免使用它。</p>\n<hr>\n<p>学习参考：<br><a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">JavaScript 标准参考教程 阮一峰</a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>函数就是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。</p>\n<h3 id=\"函数的声明\"><a href=\"#函数的声明\" class=\"headerlink\" title=\"函数的声明\"></a>函数的声明</h3><p>JavaScript有三种方法，可以声明一个函数。</p>\n<p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</p>","more":"<h4 id=\"（1）function命令\"><a href=\"#（1）function命令\" class=\"headerlink\" title=\"（1）function命令\"></a>（1）function命令</h4><p>function命令声明的代码区块，就是一个函数。function命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。<br><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span></span> <span class=\"built_in\">print</span>(s) &#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"（2）函数表达式\"><a href=\"#（2）函数表达式\" class=\"headerlink\" title=\"（2）函数表达式\"></a>（2）函数表达式</h4><p>除了用function命令声明函数，还可以采用变量赋值的写法。<br><figure class=\"highlight fortran\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var <span class=\"built_in\">print</span> = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(s)</span></span> &#123;</span><br><span class=\"line\">  console.<span class=\"built_in\">log</span>(s);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式。</p>\n<p>采用函数表达式声明函数时，function命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>\n<p>当然，这种写法也有两个好处。<br>1.可以在函数体内部调用自身<br>2.方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。</p>\n<h4 id=\"（3）Function构造函数\"><a href=\"#（3）Function构造函数\" class=\"headerlink\" title=\"（3）Function构造函数\"></a>（3）Function构造函数</h4><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> add = <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">Function</span><span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"string\">'x'</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"string\">'y'</span>,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">  <span class=\"string\">'return (x + y)'</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等同于</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (x + y);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。</p>\n<h3 id=\"第一等公民\"><a href=\"#第一等公民\" class=\"headerlink\" title=\"第一等公民\"></a>第一等公民</h3><p>JavaScript语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。</p>\n<p>由于函数与其他数据类型地位平等，所以在JavaScript语言中又称函数为第一等公民。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">add</span><span class=\"params\">(x, y)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> x + y;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将函数赋值给一个变量</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> operator = add;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 将函数作为参数和返回值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">a</span><span class=\"params\">(op)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> op;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(add)(<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"函数名的提升\"><a href=\"#函数名的提升\" class=\"headerlink\" title=\"函数名的提升\"></a>函数名的提升</h3><p>JavaScript引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。</p>\n<p>如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'1'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'2'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure>\n<p>###　不能在条件语句中声明函数</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// 不报错</span></span><br></pre></td></tr></table></figure>\n<p>上面代码的原始意图是不声明函数f，但是由于f的提升，导致if语句无效，所以上面的代码不会报错。要达到在条件语句中定义函数的目的，只有使用函数表达式。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (<span class=\"literal\">false</span>) &#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;&#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数的属性和方法\"><a href=\"#函数的属性和方法\" class=\"headerlink\" title=\"函数的属性和方法\"></a>函数的属性和方法</h2><h3 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h3><p>name属性返回紧跟在function关键字之后的那个函数名。<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f2 = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> <span class=\"comment\">&#123;&#125;</span>;</span></span><br><span class=\"line\">f2.<span class=\"keyword\">name</span> <span class=\"comment\">// ''</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> f3 = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myName</span><span class=\"params\">()</span> <span class=\"comment\">&#123;&#125;</span>;</span></span><br><span class=\"line\">f3.<span class=\"keyword\">name</span> <span class=\"comment\">// 'myName'</span></span><br></pre></td></tr></table></figure></p>\n<p>对于f2来说，返回空字符串，匿名函数的name属性总是为空字符串；对于f3来说，返回函数表达式的名字（真正的函数名还是f3，myName这个名字只在函数体内部可用）。</p>\n<h3 id=\"length属性\"><a href=\"#length属性\" class=\"headerlink\" title=\"length属性\"></a>length属性</h3><p>length属性返回函数预期传入的参数个数，即函数定义之中的参数个数。<br><figure class=\"highlight scilab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(a, b)</span> &#123;&#125;</span></span><br><span class=\"line\">f.<span class=\"built_in\">length</span> <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码定义了空函数f，它的length属性就是定义时的参数个数。不管调用时输入了多少个参数，length属性始终等于2。</p>\n<p>length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的”方法重载“（overload）。</p>\n<h3 id=\"toString-NaN\"><a href=\"#toString-NaN\" class=\"headerlink\" title=\"toString()\"></a>toString()</h3><p>函数的toString方法返回函数的源码。函数内部的注释也可以返回。</p>\n<p>利用这一点，可以变相实现多行字符串。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> multiline = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(fn)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> arr = fn.toString().split(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.slice(<span class=\"number\">1</span>, arr.length - <span class=\"number\">1</span>).join(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">()</span> </span>&#123;<span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">  这是一个</span></span><br><span class=\"line\"><span class=\"comment\">  多行注释</span></span><br><span class=\"line\"><span class=\"comment\">*/</span>&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">multiline(f);</span><br><span class=\"line\"><span class=\"comment\">// \" 这是一个</span></span><br><span class=\"line\"><span class=\"comment\">//   多行注释\"</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><p>作用域（scope）指的是变量存在的范围。Javascript只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。</p>\n<p>在函数外部声明的变量就是全局变量（global variable），它可以在函数内部读取。</p>\n<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</p>\n<p>注意，对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。</p>\n<h3 id=\"函数内部的变量提升\"><a href=\"#函数内部的变量提升\" class=\"headerlink\" title=\"函数内部的变量提升\"></a>函数内部的变量提升</h3><p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p>\n<h3 id=\"函数本身的作用域\"><a href=\"#函数本身的作用域\" class=\"headerlink\" title=\"函数本身的作用域\"></a>函数本身的作用域</h3><p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p>\n<p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p>\n<p>同样的，函数体内部声明的函数，作用域绑定函数体内部。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">foo</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> x = <span class=\"number\">1</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bar</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(x);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bar;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> x = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">var</span> f = foo();</span><br><span class=\"line\">f() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，函数foo内部声明了一个函数bar，bar的作用域绑定foo。当我们在foo外部取出bar执行时，变量x指向的是foo内部的x，而不是foo外部的x。正是这种机制，构成了下文要讲解的“闭包”现象。</p>\n<h2 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h2><h3 id=\"概述-1\"><a href=\"#概述-1\" class=\"headerlink\" title=\"概述\"></a>概述</h3><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</p>\n<h3 id=\"参数的省略\"><a href=\"#参数的省略\" class=\"headerlink\" title=\"参数的省略\"></a>参数的省略</h3><p>尽管例如函数f定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript都不会报错。</p>\n<p>但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(a, b)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f( , <span class=\"number\">1</span>) <span class=\"comment\">// SyntaxError: Unexpected token ,(…)</span></span><br><span class=\"line\">f(<span class=\"literal\">undefined</span>, <span class=\"number\">1</span>) <span class=\"comment\">// undefined</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><p>||表示“或运算”，即如果a有值，则返回a，否则返回事先设定的默认值。</p>\n<p>这种写法会对a进行一次布尔运算，只有为true时，才会返回a。可是，除了undefined以外，0、空字符、null等的布尔值也是false。也就是说，在上面的函数中，不能让a等于0或空字符串，否则在明明有参数的情况下，也会返回默认值。</p>\n<p>更精准的写法：<br><figure class=\"highlight tp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(a <span class=\"comment\">!== undefined &amp;&amp; a !== null) ? a = a : a = 1;</span></span><br></pre></td></tr></table></figure></p>\n<p>函数f的参数是空字符或0，都不会触发参数的默认值。</p>\n<h3 id=\"传递方式\"><a href=\"#传递方式\" class=\"headerlink\" title=\"传递方式\"></a>传递方式</h3><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</p>\n<p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> obj = <span class=\"comment\">&#123;p: 1&#125;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(o)</span> <span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">  o.p = 2;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">&#125;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">f</span><span class=\"params\">(obj)</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">obj.p <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>某些情况下，如果需要对某个原始类型的变量，获取传址传递的效果，可以将它写成全局对象的属性。<br><figure class=\"highlight delphi\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span><span class=\"params\">(p)</span> <span class=\"comment\">&#123;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">  window[p] = 2;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">&#125;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">f</span><span class=\"params\">(<span class=\"string\">'a'</span>)</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">a <span class=\"comment\">// 2</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，变量a本来是传值传递，但是写成window对象的属性，就达到了传址传递的效果。</p>\n<h3 id=\"同名参数\"><a href=\"#同名参数\" class=\"headerlink\" title=\"同名参数\"></a>同名参数</h3><p>如果有同名的参数，则取最后出现的那个值。</p>\n<p>调用函数f(1)的时候，没有提供第二个参数，a的取值就变成了undefined。这时，如果要获得第一个a的值，可以使用arguments对象。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\">a, a</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>]);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>) <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<h3 id=\"arguments对象\"><a href=\"#arguments对象\" class=\"headerlink\" title=\"arguments对象\"></a>arguments对象</h3><h4 id=\"1-定义\"><a href=\"#1-定义\" class=\"headerlink\" title=\"(1)定义\"></a>(1)定义</h4><p>由于JavaScript允许函数有不定数目的参数，所以我们需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。</p>\n<p>arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>\n<p>arguments对象除了可以读取参数，还可以为参数赋值（严格模式不允许这种用法）。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">a, b</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">0</span>] = <span class=\"number\">3</span>;</span><br><span class=\"line\">  <span class=\"built_in\">arguments</span>[<span class=\"number\">1</span>] = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a + b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"number\">1</span>, <span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">// 5</span></span><br></pre></td></tr></table></figure></p>\n<p>可以通过arguments对象的length属性，判断函数调用时到底带几个参数。</p>\n<h4 id=\"2-与数组的关系\"><a href=\"#2-与数组的关系\" class=\"headerlink\" title=\"(2)与数组的关系\"></a>(2)与数组的关系</h4><p>需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用。</p>\n<p>要让arguments对象使用数组方法，真正的解决方法是将arguments转为真正的数组。下面是两种常用的转换方法：slice方法和逐一填入新数组。</p>\n<figure class=\"highlight maxima\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">var</span> <span class=\"built_in\">args</span> = Array.prototype.slice.call(arguments);</span><br><span class=\"line\"></span><br><span class=\"line\">// <span class=\"keyword\">or</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">var</span> <span class=\"built_in\">args</span> = [];</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">var</span> i = <span class=\"number\">0</span>; i &lt; arguments.<span class=\"built_in\">length</span>; i++) &#123;</span><br><span class=\"line\">  <span class=\"built_in\">args</span>.<span class=\"built_in\">push</span>(arguments[i]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"3-callee属性\"><a href=\"#3-callee属性\" class=\"headerlink\" title=\"(3)callee属性\"></a>(3)callee属性</h4><p>arguments对象带有一个callee属性，返回它所对应的原函数。</p>\n<p>可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p>\n<h2 id=\"函数的其他知识点\"><a href=\"#函数的其他知识点\" class=\"headerlink\" title=\"函数的其他知识点\"></a>函数的其他知识点</h2><h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><p>闭包（closure）是Javascript语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>\n<p>要理解闭包，首先必须理解变量作用域。前面提到，JavaScript有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">　　<span class=\"built_in\">console</span>.log(n); <span class=\"comment\">// 999</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>函数f1内部声明的变量n，函数外是无法读取的。</p>\n<p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p>\n<p>上面代码中，函数f2就在函数f1内部，这时f1内部的所有局部变量，对f2都是可见的。但是反过来就不行，f2内部的局部变量，对f1就是不可见的。这就是JavaScript语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>\n<p>既然f2可以读取f1的局部变量，那么只要把f2作为返回值，我们不就可以在f1外部读取它的内部变量了吗！<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f1</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> n = <span class=\"number\">999</span>;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f2</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(n);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> result = f1();</span><br><span class=\"line\">result(); <span class=\"comment\">// 999</span></span><br></pre></td></tr></table></figure></p>\n<p>闭包就是函数f2，即能够读取其他函数内部变量的函数。由于在JavaScript语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如f2记住了它诞生的环境f1，所以从f2可以得到f1的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>\n<p>闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createIncrementor</span><span class=\"params\">(start)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> start++;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> inc = createIncrementor(<span class=\"number\">5</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">inc() <span class=\"comment\">// 5</span></span><br><span class=\"line\">inc() <span class=\"comment\">// 6</span></span><br><span class=\"line\">inc() <span class=\"comment\">// 7</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，start是函数createIncrementor的内部变量。通过闭包，start的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包inc使得函数createIncrementor的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p>\n<p>为什么会这样呢？原因就在于inc始终在内存中，而inc的存在依赖于createIncrementor，因此也始终在内存中，不会在调用结束后，被垃圾回收机制回收。</p>\n<p>闭包的另一个用处，是封装对象的私有属性和私有方法。</p>\n<figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span><span class=\"params\">(name)</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> _age;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setAge</span><span class=\"params\">(n)</span> </span>&#123;</span><br><span class=\"line\">    _age = n;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _age;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    name: name,</span><br><span class=\"line\">    getAge: getAge,</span><br><span class=\"line\">    setAge: setAge</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> p1 = Person(<span class=\"string\">'张三'</span>);</span><br><span class=\"line\">p1.setAge(<span class=\"number\">25</span>);</span><br><span class=\"line\">p1.getAge() <span class=\"comment\">// 25</span></span><br></pre></td></tr></table></figure>\n<p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>\n<h3 id=\"立即调用的函数表达式（IIFE）\"><a href=\"#立即调用的函数表达式（IIFE）\" class=\"headerlink\" title=\"立即调用的函数表达式（IIFE）\"></a>立即调用的函数表达式（IIFE）</h3><p>在Javascript中，一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数。比如，print()就表示调用print函数。</p>\n<p>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\"><span class=\"comment\">// SyntaxError: Unexpected token (</span></span><br></pre></td></tr></table></figure></p>\n<p>产生这个错误的原因是，function这个关键字即可以当作语句，也可以当作表达式。</p>\n<p>为了避免解析上的歧义，JavaScript引擎规定，如果function关键字出现在行首，一律解释成语句。因此，JavaScript引擎看到行首是function关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</p>\n<p>解决方法就是不要让function出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;());</span><br><span class=\"line\"><span class=\"comment\">// 或者</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;)();</span><br></pre></td></tr></table></figure></p>\n<p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表示式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称IIFE。</p>\n<p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个IIFE，可能就会报错。</p>\n<p>当然，还有一些别的写法。<br><figure class=\"highlight actionscript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> i = <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"keyword\">return</span> <span class=\"number\">10</span>; &#125;();</span><br><span class=\"line\"><span class=\"literal\">true</span> &amp;&amp; <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\"><span class=\"number\">0</span>, <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\"></span><br><span class=\"line\">!<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\">~<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\">-<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\">+<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span></span>&#123; <span class=\"comment\">/* code */</span> &#125;()</span><br><span class=\"line\"><span class=\"comment\">// 只有传递参数时，才需要最后那个圆括号</span></span><br></pre></td></tr></table></figure></p>\n<p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是IIFE内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p>\n<figure class=\"highlight haxe\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 写法一</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span><span class=\"type\">Data</span>;</span><br><span class=\"line\">processData(tmp);</span><br><span class=\"line\">storeData(tmp);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 写法二</span></span><br><span class=\"line\">(<span class=\"function\"><span class=\"keyword\">function</span> </span>()&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> tmp = <span class=\"keyword\">new</span><span class=\"type\">Data</span>;</span><br><span class=\"line\">  processData(tmp);</span><br><span class=\"line\">  storeData(tmp);</span><br><span class=\"line\">&#125;());</span><br></pre></td></tr></table></figure>\n<p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。</p>\n<h2 id=\"eval命令\"><a href=\"#eval命令\" class=\"headerlink\" title=\"eval命令\"></a>eval命令</h2><p>eval命令的作用是，将字符串当作语句执行。<br><figure class=\"highlight gcode\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval<span class=\"comment\">('var a = 1;')</span>;</span><br><span class=\"line\">a <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。</p>\n<p>此外，eval的命令字符串不会得到JavaScript引擎的优化，运行速度较慢。这也是一个不应该使用它的理由。</p>\n<p>通常情况下，eval最常见的场合是解析JSON数据字符串，不过正确的做法应该是使用浏览器提供的JSON.parse方法。</p>\n<p>avaScript引擎内部，eval实际上是一个引用，默认调用一个内部方法。这使得eval的使用分成两种情况，一种是像上面这样的调用eval(expression)，这叫做“直接使用”，这种情况下eval的作用域就是当前作用域。除此之外的调用方法，都叫“间接调用”，此时eval的作用域总是全局作用域。<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">f</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> a = <span class=\"number\">2</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> e = <span class=\"built_in\">eval</span>;</span><br><span class=\"line\">  e(<span class=\"string\">'console.log(a)'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">f() <span class=\"comment\">// 1</span></span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，eval是间接调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的a为全局变量。</p>\n<p>eval的间接调用的形式五花八门，只要不是直接调用，都属于间接调用。</p>\n<p>与eval作用类似的还有Function构造函数。利用它生成一个函数，然后调用该函数，也能将字符串当作命令执行。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> jsonp = <span class=\"string\">'foo(&#123;\"id\": 42&#125;)'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> f = <span class=\"keyword\">new</span> <span class=\"function\"><span class=\"keyword\">Function</span><span class=\"params\">( <span class=\"string\">\"foo\"</span>, jsonp )</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 相当于定义了如下函数</span></span><br><span class=\"line\"><span class=\"comment\">// function f(foo) &#123;</span></span><br><span class=\"line\"><span class=\"comment\">//   foo(&#123;\"id\":42&#125;);</span></span><br><span class=\"line\"><span class=\"comment\">// &#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">f(<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">(json)</span></span>&#123;</span><br><span class=\"line\">  console.log( json.id ); <span class=\"comment\">// 42</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>上面代码中，jsonp是一个字符串，Function构造函数将这个字符串，变成了函数体。调用该函数的时候，jsonp就会执行。这种写法的实质是将代码放到函数作用域执行，避免对全局作用域造成影响。</p>\n<p>不过，new Function()的写法也可以读写全局作用域，所以也是应该避免使用它。</p>\n<hr>\n<p>学习参考：<br><a href=\"http://javascript.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">JavaScript 标准参考教程 阮一峰</a></p>"}],"PostAsset":[{"_id":"source/_posts/学做操盘手/K线的基础知识/头肩底.png","slug":"头肩底.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/浪形宽度.png","slug":"浪形宽度.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/mysql/一条SQL查询是如何执行的/MySQL逻辑.png","slug":"MySQL逻辑.png","post":"ck6cbwmw9001m4l3nt2qw7819","modified":1,"renderable":0},{"_id":"source/_posts/架构学习/RabbitMQ的高可用性/Kafka.png","post":"ck6cbwmxi004p4l3n9wuo2qya","slug":"Kafka.png","modified":1,"renderable":1},{"_id":"source/_posts/架构学习/RabbitMQ的高可用性/RabbitMQ普通集群.png","post":"ck6cbwmxi004p4l3n9wuo2qya","slug":"RabbitMQ普通集群.png","modified":1,"renderable":1},{"_id":"source/_posts/架构学习/RabbitMQ的高可用性/RabbitMQ镜像模式.png","post":"ck6cbwmxi004p4l3n9wuo2qya","slug":"RabbitMQ镜像模式.png","modified":1,"renderable":1},{"_id":"source/_posts/架构学习/消息队列/system.png","post":"ck6cbwmxg004i4l3nujsxdmqt","slug":"system.png","modified":1,"renderable":1},{"_id":"source/_posts/架构学习/消息队列/systemAfter.png","post":"ck6cbwmxg004i4l3nujsxdmqt","slug":"systemAfter.png","modified":1,"renderable":1},{"_id":"source/_posts/架构学习/消息队列/systemTiming.png","post":"ck6cbwmxg004i4l3nujsxdmqt","slug":"systemTiming.png","modified":1,"renderable":1},{"_id":"source/_posts/架构学习/消息队列/systemTimingAfter.png","post":"ck6cbwmxg004i4l3nujsxdmqt","slug":"systemTimingAfter.png","modified":1,"renderable":1},{"_id":"source/_posts/学做操盘手/K线的基础知识/四浪.png","slug":"四浪.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/箱体.png","slug":"箱体.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/趋势线.png","slug":"趋势线.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/三角形.png","slug":"三角形.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/BOLL.png","slug":"BOLL.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/KDJ.png","slug":"KDJ.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/MACD.png","slug":"MACD.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/MACD背离.png","slug":"MACD背离.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/Wdi.png","slug":"Wdi.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/个股盘口.png","slug":"个股盘口.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/二浪.png","slug":"二浪.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/委买委卖.png","slug":"委买委卖.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/底背离.png","slug":"底背离.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/整个二浪.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","slug":"整个二浪.png","modified":1,"renderable":1},{"_id":"source/_posts/学做操盘手/K线的基础知识/波浪.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","slug":"波浪.png","modified":1,"renderable":1},{"_id":"source/_posts/学做操盘手/K线的基础知识/看大盘.png","slug":"看大盘.png","post":"ck6cbwn0v00ad4l3nk8o1wkvi","modified":1,"renderable":0},{"_id":"source/_posts/学做操盘手/K线的基础知识/葛南维八大买卖法.jpeg","post":"ck6cbwn0v00ad4l3nk8o1wkvi","slug":"葛南维八大买卖法.jpeg","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ck6cbwmva00054l3naxsu8gs7","category_id":"ck6cbwmvh00074l3n6ayumw3j","_id":"ck6cbwmvr000h4l3ntzuwbjie"},{"post_id":"ck6cbwmvp000f4l3n2yfrtjlw","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmvw000n4l3nptesptiy"},{"post_id":"ck6cbwmvf00064l3nh8d2dy52","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmvy000r4l3n3yc8rxmr"},{"post_id":"ck6cbwmvq000g4l3ndv34i5yv","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmvz000u4l3n6fpg82j4"},{"post_id":"ck6cbwmvu000k4l3nnnqlp2sw","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmw0000y4l3nyy7o39u6"},{"post_id":"ck6cbwmvk00094l3nob0xl898","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmw100114l3n2y84wa0d"},{"post_id":"ck6cbwmvv000m4l3npkjqa4lr","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmw200154l3nqwzbzzvx"},{"post_id":"ck6cbwmvx000q4l3nl9bgqbsd","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmw300184l3n6g0wurc5"},{"post_id":"ck6cbwmvl000a4l3n29wwvsz5","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmw4001b4l3nl8t7bo14"},{"post_id":"ck6cbwmvz000x4l3nj5m5r3hb","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmw6001f4l3n4dgazw78"},{"post_id":"ck6cbwmvo000b4l3ne01blqch","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmw7001h4l3nbx0wdi4r"},{"post_id":"ck6cbwmw200144l3ngveiic8g","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmw9001l4l3nu454y7rg"},{"post_id":"ck6cbwmvy000t4l3nhz5rlk3r","category_id":"ck6cbwmw100124l3n18jn89lt","_id":"ck6cbwmwa001n4l3n2xt0v8n8"},{"post_id":"ck6cbwmw300174l3nqfp4p6ox","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwb001q4l3n5sc9fb86"},{"post_id":"ck6cbwmw4001a4l3nokaarpwk","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwc001t4l3nu9yjee6o"},{"post_id":"ck6cbwmw000104l3nwwvqxcam","category_id":"ck6cbwmw100124l3n18jn89lt","_id":"ck6cbwmwe001x4l3n5zv2vuwt"},{"post_id":"ck6cbwmw5001e4l3n0swfytyc","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwe001z4l3ncszvinj4"},{"post_id":"ck6cbwmw6001g4l3n485fk38v","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwg00234l3nov6teeg6"},{"post_id":"ck6cbwmw8001k4l3ndo1cdns1","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwh00264l3n9g4lm0fj"},{"post_id":"ck6cbwmw9001m4l3nt2qw7819","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwi002a4l3n5g3ma1ib"},{"post_id":"ck6cbwmwb001p4l3nwerfylmp","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwj002d4l3n2uixl6vr"},{"post_id":"ck6cbwmwc001s4l3n4dagzpi7","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwl002g4l3nw9gz8i2c"},{"post_id":"ck6cbwmwe001y4l3nd7mhk7rs","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwm002j4l3n82y687qv"},{"post_id":"ck6cbwmwf00224l3ne8ge9ogj","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwo002m4l3nm33800kw"},{"post_id":"ck6cbwmwg00254l3nnnlpksyj","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwp002p4l3n4szzjitb"},{"post_id":"ck6cbwmwd001w4l3nx8r80990","category_id":"ck6cbwmwf00214l3n3aaz6h39","_id":"ck6cbwmws002s4l3n7prq0fy0"},{"post_id":"ck6cbwmwi00294l3n7wbfks1o","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwt002v4l3ned05vslr"},{"post_id":"ck6cbwmwj002c4l3nr4g6twxm","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmww002y4l3n57diyo10"},{"post_id":"ck6cbwmwk002f4l3num7g3zir","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwx00324l3nim2vukcz"},{"post_id":"ck6cbwmwl002i4l3no2revc5v","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwy00354l3n1igogyet"},{"post_id":"ck6cbwmwn002l4l3n4k011915","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmwz00394l3nyahdm7jn"},{"post_id":"ck6cbwmwo002o4l3n7ocyxggo","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmx0003c4l3n3xe4ejya"},{"post_id":"ck6cbwmwr002r4l3nxhloh25h","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmx1003f4l3nk6etkugl"},{"post_id":"ck6cbwmwx00314l3nx295dkgt","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmx2003j4l3nuhrsftpj"},{"post_id":"ck6cbwmwy00344l3n67l2k5iv","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmx3003l4l3nseubpnwg"},{"post_id":"ck6cbwmws002u4l3n7x6nxqok","category_id":"ck6cbwmwx00304l3nqm7kgltp","_id":"ck6cbwmx4003o4l3nhbsau0zr"},{"post_id":"ck6cbwmwz00374l3na0xswmga","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmx7003r4l3ny90jrh2q"},{"post_id":"ck6cbwmwu002x4l3n5ewve0s8","category_id":"ck6cbwmwz00384l3nosq3gzbz","_id":"ck6cbwmx8003v4l3nre6w5cmu"},{"post_id":"ck6cbwmx1003e4l3nnnjo33p9","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmx9003y4l3nrrpucqo2"},{"post_id":"ck6cbwmx2003i4l3n5p5acp3c","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmxa00414l3n3w4zc9cd"},{"post_id":"ck6cbwmx3003k4l3n76uw9odp","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmxc00454l3nwtwmbw7m"},{"post_id":"ck6cbwmx0003b4l3nllmakys7","category_id":"ck6cbwmx1003g4l3n72xqwxfe","_id":"ck6cbwmxd00494l3nqpg2qwju"},{"post_id":"ck6cbwmx9003x4l3nxectwfcg","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmxe004d4l3nepq91wmx"},{"post_id":"ck6cbwmx3003n4l3nh191so8h","category_id":"ck6cbwmx7003t4l3n4onasplt","_id":"ck6cbwmxf004f4l3n5wl5pomp"},{"post_id":"ck6cbwmx5003q4l3nbo2videt","category_id":"ck6cbwmx7003t4l3n4onasplt","_id":"ck6cbwmxg004j4l3n4hubr2wu"},{"post_id":"ck6cbwmxc00474l3neghwoe2t","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmxh004m4l3ng1lwhs6o"},{"post_id":"ck6cbwmx7003u4l3nwcar9o6z","category_id":"ck6cbwmxd00484l3n2pwpf6p1","_id":"ck6cbwmxi004q4l3nnf7kxwtw"},{"post_id":"ck6cbwmx9003z4l3nl5cbfna2","category_id":"ck6cbwmxf004g4l3ntat2rdyi","_id":"ck6cbwmxj004u4l3n774kfx5h"},{"post_id":"ck6cbwmxb00444l3nucgj1h43","category_id":"ck6cbwmxf004g4l3ntat2rdyi","_id":"ck6cbwmxl004z4l3ny7z7y34q"},{"post_id":"ck6cbwmxd004c4l3n210ftg1t","category_id":"ck6cbwmxj004t4l3nezky3u8a","_id":"ck6cbwmxo00564l3n8useyvip"},{"post_id":"ck6cbwmxk004y4l3ngvovwday","category_id":"ck6cbwmx7003t4l3n4onasplt","_id":"ck6cbwmxr005a4l3nqzas1qrq"},{"post_id":"ck6cbwmxl00524l3n1gaohfpf","category_id":"ck6cbwmx7003t4l3n4onasplt","_id":"ck6cbwmxr005c4l3np61ao5is"},{"post_id":"ck6cbwmxe004e4l3n8405a5w8","category_id":"ck6cbwmxj004t4l3nezky3u8a","_id":"ck6cbwmxt005g4l3nxk9uivon"},{"post_id":"ck6cbwmxp00584l3nhy0l027x","category_id":"ck6cbwmx7003t4l3n4onasplt","_id":"ck6cbwmxu005i4l3nkyjjyz96"},{"post_id":"ck6cbwmxg004i4l3nujsxdmqt","category_id":"ck6cbwmxo00554l3nji8g9ady","_id":"ck6cbwmxv005m4l3n5x4mi8hw"},{"post_id":"ck6cbwmxs005e4l3n4z6q1iop","category_id":"ck6cbwmx7003t4l3n4onasplt","_id":"ck6cbwmxw005p4l3nkomtst2i"},{"post_id":"ck6cbwmxt005h4l3nft348wgo","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmxx005u4l3n8f2bpuag"},{"post_id":"ck6cbwmxh004l4l3n4c7doiql","category_id":"ck6cbwmxs005f4l3nfxxuvrfy","_id":"ck6cbwmxy005x4l3ng3xa75br"},{"post_id":"ck6cbwmxu005j4l3nvyiohtus","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmxz00604l3nup6lixf0"},{"post_id":"ck6cbwmxv005o4l3no2tdgt1r","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmxz00614l3nbdm5ylh0"},{"post_id":"ck6cbwmxi004p4l3n9wuo2qya","category_id":"ck6cbwmxo00554l3nji8g9ady","_id":"ck6cbwmy000644l3npy4w6nes"},{"post_id":"ck6cbwmxw005r4l3n7m3m2krh","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwmy000664l3nklss7can"},{"post_id":"ck6cbwmxi004s4l3n6ejblz8k","category_id":"ck6cbwmxs005f4l3nfxxuvrfy","_id":"ck6cbwmy0006a4l3nryb8odgt"},{"post_id":"ck6cbwmxj004w4l3ngk2qfjjd","category_id":"ck6cbwmxs005f4l3nfxxuvrfy","_id":"ck6cbwmy1006b4l3n69859uj1"},{"post_id":"ck6cbwmxn00544l3nn193pnfd","category_id":"ck6cbwmxs005f4l3nfxxuvrfy","_id":"ck6cbwmy1006e4l3nvpebkbas"},{"post_id":"ck6cbwmxr005b4l3njpwywsc7","category_id":"ck6cbwmxs005f4l3nfxxuvrfy","_id":"ck6cbwmy1006h4l3nkuntdiij"},{"post_id":"ck6cbwmxx005w4l3nzpefgfwh","category_id":"ck6cbwmy1006c4l3n32qek509","_id":"ck6cbwmy2006j4l3ng2m3aehh"},{"post_id":"ck6cbwmzz00904l3ngh7q6tyt","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0800964l3n7kpthphd"},{"post_id":"ck6cbwn0300914l3ndf8khi3m","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0c00994l3nt4ns0om4"},{"post_id":"ck6cbwn0400934l3nyn3d3yho","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0f009c4l3n561d1mc5"},{"post_id":"ck6cbwn0600954l3nl41ajhlm","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0h009f4l3nd4mtpyxu"},{"post_id":"ck6cbwn0900984l3nsfn6zhc3","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0j009i4l3nfm6axc1g"},{"post_id":"ck6cbwn0d009b4l3ncn38ym5y","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0l009l4l3njvkv248v"},{"post_id":"ck6cbwn0g009e4l3netjp79ff","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0m009o4l3nykx7ic6m"},{"post_id":"ck6cbwn0i009h4l3nd021wacz","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0n009s4l3ng6cuk87w"},{"post_id":"ck6cbwn0l009n4l3nvh6j2wv0","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0q009x4l3n5wd6rqpf"},{"post_id":"ck6cbwn0n009r4l3nld07uo67","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0r00a04l3nh773zicb"},{"post_id":"ck6cbwn0o009u4l3nz7wh0ket","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0s00a34l3nriwbayzo"},{"post_id":"ck6cbwn0k009k4l3nllp8sjcw","category_id":"ck6cbwn0m009p4l3n6zbecaim","_id":"ck6cbwn0t00a64l3nc9gpl3k8"},{"post_id":"ck6cbwn0p009w4l3nm9yhba7u","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0v00ab4l3n4w7f065x"},{"post_id":"ck6cbwn0q009z4l3npqcl1wo0","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0w00ae4l3njriji87f"},{"post_id":"ck6cbwn0t00a54l3ntajn1tvg","category_id":"ck6cbwmy1006c4l3n32qek509","_id":"ck6cbwn0x00ai4l3njez2vgr2"},{"post_id":"ck6cbwn0u00aa4l3nflv2sn0g","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn0z00am4l3n8cndthe0"},{"post_id":"ck6cbwn0r00a24l3nf2ezmk0w","category_id":"ck6cbwn0u00a74l3nb8topg2r","_id":"ck6cbwn1000ap4l3n2h36qtou"},{"post_id":"ck6cbwn0w00ag4l3nag738qfc","category_id":"ck6cbwmx7003t4l3n4onasplt","_id":"ck6cbwn1100at4l3nehg2mtqw"},{"post_id":"ck6cbwn0y00al4l3n8wh6a4n2","category_id":"ck6cbwmx7003t4l3n4onasplt","_id":"ck6cbwn1300aw4l3nwt3b9q0g"},{"post_id":"ck6cbwn0z00ao4l3nv0sijb0d","category_id":"ck6cbwmx7003t4l3n4onasplt","_id":"ck6cbwn1500b04l3nnalm5bsq"},{"post_id":"ck6cbwn0v00ad4l3nk8o1wkvi","category_id":"ck6cbwn0y00aj4l3n66kwvb5j","_id":"ck6cbwn1600b24l3nq000zufi"},{"post_id":"ck6cbwn1100as4l3nm3n2lkpq","category_id":"ck6cbwmx7003t4l3n4onasplt","_id":"ck6cbwn1600b54l3n3z4hqg0e"},{"post_id":"ck6cbwn1200av4l3n5377gstg","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn1700b74l3nazfvvtuy"},{"post_id":"ck6cbwn1400az4l3nv5y4wahd","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn1700ba4l3nqgtvqh2i"},{"post_id":"ck6cbwn2m00bh4l3n7l224047","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn2r00bn4l3nes80sive"},{"post_id":"ck6cbwn2n00bi4l3nnkq04fm3","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn2s00bq4l3n3s6k4g0d"},{"post_id":"ck6cbwn2p00bk4l3nngqleax4","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn2u00bt4l3nd2c2ztod"},{"post_id":"ck6cbwn2q00bm4l3nszs3rj54","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn2v00bw4l3nwluj3y5f"},{"post_id":"ck6cbwn2s00bp4l3n1ksp8lgm","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn2w00bz4l3n1cgq6eez"},{"post_id":"ck6cbwn2t00bs4l3n6qbt65wf","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn2x00c34l3noavqezbm"},{"post_id":"ck6cbwn2u00bv4l3ny8u8rtc3","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn2x00c54l3nlx01m58y"},{"post_id":"ck6cbwn2w00by4l3n802d8eix","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn2y00c84l3nwws7cr7y"},{"post_id":"ck6cbwn2x00c24l3n1fc927xt","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn2y00ca4l3nrfcv47ke"},{"post_id":"ck6cbwn5500cf4l3n55tb6wty","category_id":"ck6cbwmvo000c4l3n7y7qiqxm","_id":"ck6cbwn5600ch4l3n485z6w4u"}],"PostTag":[{"post_id":"ck6cbwmva00054l3naxsu8gs7","tag_id":"ck6cbwmvk00084l3nhlhl9abk","_id":"ck6cbwmvp000e4l3npdrhpeha"},{"post_id":"ck6cbwmvf00064l3nh8d2dy52","tag_id":"ck6cbwmvo000d4l3nhog6n3u9","_id":"ck6cbwmvv000l4l3n1fs4u57u"},{"post_id":"ck6cbwmvk00094l3nob0xl898","tag_id":"ck6cbwmvo000d4l3nhog6n3u9","_id":"ck6cbwmvy000s4l3neo5t8xpm"},{"post_id":"ck6cbwmvl000a4l3n29wwvsz5","tag_id":"ck6cbwmvx000p4l3n3zhkcxrs","_id":"ck6cbwmw0000z4l3n5qwixtwl"},{"post_id":"ck6cbwmvo000b4l3ne01blqch","tag_id":"ck6cbwmvz000w4l3nyk0mkgp7","_id":"ck6cbwmw200164l3nk45rrp4i"},{"post_id":"ck6cbwmvp000f4l3n2yfrtjlw","tag_id":"ck6cbwmw100134l3nzw0kiegy","_id":"ck6cbwmw5001d4l3nbrwvig7m"},{"post_id":"ck6cbwmw5001e4l3n0swfytyc","tag_id":"ck6cbwmw100134l3nzw0kiegy","_id":"ck6cbwmw8001j4l3nm7ohoawe"},{"post_id":"ck6cbwmvq000g4l3ndv34i5yv","tag_id":"ck6cbwmw100134l3nzw0kiegy","_id":"ck6cbwmwb001r4l3nlr5rg6ym"},{"post_id":"ck6cbwmvq000g4l3ndv34i5yv","tag_id":"ck6cbwmw7001i4l3nnfhd93ya","_id":"ck6cbwmwd001u4l3nqihgvb6q"},{"post_id":"ck6cbwmvu000k4l3nnnqlp2sw","tag_id":"ck6cbwmw100134l3nzw0kiegy","_id":"ck6cbwmwg00244l3np0gk91p2"},{"post_id":"ck6cbwmvu000k4l3nnnqlp2sw","tag_id":"ck6cbwmw7001i4l3nnfhd93ya","_id":"ck6cbwmwh00274l3nuczpdkdj"},{"post_id":"ck6cbwmvv000m4l3npkjqa4lr","tag_id":"ck6cbwmw100134l3nzw0kiegy","_id":"ck6cbwmwi002b4l3nn4o8nbnh"},{"post_id":"ck6cbwmvx000q4l3nl9bgqbsd","tag_id":"ck6cbwmw100134l3nzw0kiegy","_id":"ck6cbwmwl002h4l3naz08x0tw"},{"post_id":"ck6cbwmvy000t4l3nhz5rlk3r","tag_id":"ck6cbwmw100134l3nzw0kiegy","_id":"ck6cbwmwo002n4l3na9vhhqoe"},{"post_id":"ck6cbwmvz000x4l3nj5m5r3hb","tag_id":"ck6cbwmw100134l3nzw0kiegy","_id":"ck6cbwmws002t4l3nhe38b9pz"},{"post_id":"ck6cbwmw000104l3nwwvqxcam","tag_id":"ck6cbwmw100134l3nzw0kiegy","_id":"ck6cbwmww002z4l3n2bardopn"},{"post_id":"ck6cbwmw200144l3ngveiic8g","tag_id":"ck6cbwmwt002w4l3n2ve7tq2m","_id":"ck6cbwmwy00364l3nz6dvxf1o"},{"post_id":"ck6cbwmw300174l3nqfp4p6ox","tag_id":"ck6cbwmwy00334l3nclmvykp2","_id":"ck6cbwmx0003d4l3nr2rk1l09"},{"post_id":"ck6cbwmw4001a4l3nokaarpwk","tag_id":"ck6cbwmwy00334l3nclmvykp2","_id":"ck6cbwmx5003p4l3nn3xd8jdj"},{"post_id":"ck6cbwmw4001a4l3nokaarpwk","tag_id":"ck6cbwmwt002w4l3n2ve7tq2m","_id":"ck6cbwmx7003s4l3ns2d671gi"},{"post_id":"ck6cbwmw6001g4l3n485fk38v","tag_id":"ck6cbwmx3003m4l3nf6lcaf2x","_id":"ck6cbwmxb00434l3ntw918ujj"},{"post_id":"ck6cbwmw6001g4l3n485fk38v","tag_id":"ck6cbwmwt002w4l3n2ve7tq2m","_id":"ck6cbwmxc00464l3n5hb6l1st"},{"post_id":"ck6cbwmw8001k4l3ndo1cdns1","tag_id":"ck6cbwmwt002w4l3n2ve7tq2m","_id":"ck6cbwmxd004b4l3nl75eaqcg"},{"post_id":"ck6cbwmw9001m4l3nt2qw7819","tag_id":"ck6cbwmxd004a4l3nebpyn9v6","_id":"ck6cbwmxg004k4l3nzhhd3s2x"},{"post_id":"ck6cbwmwb001p4l3nwerfylmp","tag_id":"ck6cbwmwy00334l3nclmvykp2","_id":"ck6cbwmxi004r4l3nfdr2j2rp"},{"post_id":"ck6cbwmwc001s4l3n4dagzpi7","tag_id":"ck6cbwmxh004n4l3nmkb8rv8m","_id":"ck6cbwmxk004x4l3npi80h5ue"},{"post_id":"ck6cbwmwd001w4l3nx8r80990","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwmxn00534l3n0woohzlb"},{"post_id":"ck6cbwmwe001y4l3nd7mhk7rs","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwmxr00594l3ntfckani4"},{"post_id":"ck6cbwmwf00224l3ne8ge9ogj","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwmxv005n4l3n67cp5oxp"},{"post_id":"ck6cbwmwf00224l3ne8ge9ogj","tag_id":"ck6cbwmxs005d4l3nhy3w35jo","_id":"ck6cbwmxw005q4l3npfqmefrx"},{"post_id":"ck6cbwmwg00254l3nnnlpksyj","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwmxx005v4l3ngz3mvpnp"},{"post_id":"ck6cbwmwi00294l3n7wbfks1o","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwmy000654l3nxix4s2rk"},{"post_id":"ck6cbwmwi00294l3n7wbfks1o","tag_id":"ck6cbwmxs005d4l3nhy3w35jo","_id":"ck6cbwmy000674l3ncn9ikbjx"},{"post_id":"ck6cbwmwj002c4l3nr4g6twxm","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwmy1006f4l3nlf847jmi"},{"post_id":"ck6cbwmwj002c4l3nr4g6twxm","tag_id":"ck6cbwmy000684l3n9so0u798","_id":"ck6cbwmy1006g4l3n313srhwi"},{"post_id":"ck6cbwmwk002f4l3num7g3zir","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwmy2006l4l3njx8hcnmi"},{"post_id":"ck6cbwmwk002f4l3num7g3zir","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwmy2006m4l3ndws3pkf4"},{"post_id":"ck6cbwmwl002i4l3no2revc5v","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwmy3006p4l3niyzouklb"},{"post_id":"ck6cbwmwl002i4l3no2revc5v","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwmy3006q4l3n7fx6g3gv"},{"post_id":"ck6cbwmwn002l4l3n4k011915","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwmy3006t4l3n8pnooa73"},{"post_id":"ck6cbwmwn002l4l3n4k011915","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwmy3006u4l3nd3wvbn6g"},{"post_id":"ck6cbwmwo002o4l3n7ocyxggo","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwmy4006x4l3npu5ppqmi"},{"post_id":"ck6cbwmwo002o4l3n7ocyxggo","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwmy4006y4l3n31tzutuy"},{"post_id":"ck6cbwmwr002r4l3nxhloh25h","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwmy500714l3nuruw0on6"},{"post_id":"ck6cbwmwr002r4l3nxhloh25h","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwmy500724l3nb3609m5u"},{"post_id":"ck6cbwmws002u4l3n7x6nxqok","tag_id":"ck6cbwmy400704l3ntzg6rqwd","_id":"ck6cbwmy500744l3nwf7qhscy"},{"post_id":"ck6cbwmwu002x4l3n5ewve0s8","tag_id":"ck6cbwmy500734l3nagw0catd","_id":"ck6cbwmy500764l3na07kvwcd"},{"post_id":"ck6cbwmwx00314l3nx295dkgt","tag_id":"ck6cbwmy500754l3nmddx7h89","_id":"ck6cbwmy500784l3nnzce4hrp"},{"post_id":"ck6cbwmwy00344l3n67l2k5iv","tag_id":"ck6cbwmy500774l3nlvua9l6n","_id":"ck6cbwmy6007a4l3no7h9z4fr"},{"post_id":"ck6cbwmwz00374l3na0xswmga","tag_id":"ck6cbwmy600794l3n9awajw03","_id":"ck6cbwmy6007d4l3n09nk3bra"},{"post_id":"ck6cbwmwz00374l3na0xswmga","tag_id":"ck6cbwmy6007b4l3ne1wxj6wa","_id":"ck6cbwmy6007e4l3nxk2vojkh"},{"post_id":"ck6cbwmx0003b4l3nllmakys7","tag_id":"ck6cbwmy6007c4l3nn10a3jt6","_id":"ck6cbwmy6007g4l3ns54i1xeb"},{"post_id":"ck6cbwmx1003e4l3nnnjo33p9","tag_id":"ck6cbwmy6007f4l3nuhl73qi2","_id":"ck6cbwmy7007i4l3ntlabgrkw"},{"post_id":"ck6cbwmx2003i4l3n5p5acp3c","tag_id":"ck6cbwmy6007h4l3nprgsw07g","_id":"ck6cbwmy7007k4l3n025g9a6n"},{"post_id":"ck6cbwmx3003k4l3n76uw9odp","tag_id":"ck6cbwmy6007h4l3nprgsw07g","_id":"ck6cbwmy7007m4l3n4rvvk75p"},{"post_id":"ck6cbwmx3003n4l3nh191so8h","tag_id":"ck6cbwmy7007l4l3n6bkyp1se","_id":"ck6cbwmy7007o4l3ns1yq3ilj"},{"post_id":"ck6cbwmx5003q4l3nbo2videt","tag_id":"ck6cbwmy7007l4l3n6bkyp1se","_id":"ck6cbwmy8007q4l3nqd1zzu8v"},{"post_id":"ck6cbwmx7003u4l3nwcar9o6z","tag_id":"ck6cbwmy8007p4l3nq9jdvcvp","_id":"ck6cbwmy8007s4l3ns746gvzg"},{"post_id":"ck6cbwmx9003x4l3nxectwfcg","tag_id":"ck6cbwmy8007r4l3nmverw26w","_id":"ck6cbwmy8007u4l3ngnw9otaw"},{"post_id":"ck6cbwmx9003z4l3nl5cbfna2","tag_id":"ck6cbwmy8007t4l3ni21th5wq","_id":"ck6cbwmy8007w4l3nxg05swan"},{"post_id":"ck6cbwmxb00444l3nucgj1h43","tag_id":"ck6cbwmy8007t4l3ni21th5wq","_id":"ck6cbwmy9007y4l3n3z6dgmbz"},{"post_id":"ck6cbwmxc00474l3neghwoe2t","tag_id":"ck6cbwmy9007x4l3nsb063uej","_id":"ck6cbwmy900804l3nlrxaw0ie"},{"post_id":"ck6cbwmxd004c4l3n210ftg1t","tag_id":"ck6cbwmy9007z4l3npacoq3u5","_id":"ck6cbwmy900824l3njtifo4mx"},{"post_id":"ck6cbwmxe004e4l3n8405a5w8","tag_id":"ck6cbwmy9007z4l3npacoq3u5","_id":"ck6cbwmya00844l3nirmvvv3h"},{"post_id":"ck6cbwmxg004i4l3nujsxdmqt","tag_id":"ck6cbwmy900834l3nlfdpmtxv","_id":"ck6cbwmya00864l3n0814huu1"},{"post_id":"ck6cbwmxh004l4l3n4c7doiql","tag_id":"ck6cbwmya00854l3n3nih44p3","_id":"ck6cbwmya00884l3negnd5alv"},{"post_id":"ck6cbwmxi004p4l3n9wuo2qya","tag_id":"ck6cbwmy900834l3nlfdpmtxv","_id":"ck6cbwmyb008a4l3noda4zz2z"},{"post_id":"ck6cbwmxi004s4l3n6ejblz8k","tag_id":"ck6cbwmya00854l3n3nih44p3","_id":"ck6cbwmyb008c4l3n1ycypt76"},{"post_id":"ck6cbwmxj004w4l3ngk2qfjjd","tag_id":"ck6cbwmya00854l3n3nih44p3","_id":"ck6cbwmyb008e4l3nmmqqruf6"},{"post_id":"ck6cbwmxk004y4l3ngvovwday","tag_id":"ck6cbwmyb008d4l3nkyvhwtta","_id":"ck6cbwmyb008g4l3ncg6k8zxp"},{"post_id":"ck6cbwmxl00524l3n1gaohfpf","tag_id":"ck6cbwmyb008d4l3nkyvhwtta","_id":"ck6cbwmyc008i4l3nb9et2b2t"},{"post_id":"ck6cbwmxn00544l3nn193pnfd","tag_id":"ck6cbwmya00854l3n3nih44p3","_id":"ck6cbwmyc008k4l3n2le4e028"},{"post_id":"ck6cbwmxp00584l3nhy0l027x","tag_id":"ck6cbwmyb008d4l3nkyvhwtta","_id":"ck6cbwmyd008m4l3nwfazw5uw"},{"post_id":"ck6cbwmxr005b4l3njpwywsc7","tag_id":"ck6cbwmya00854l3n3nih44p3","_id":"ck6cbwmyd008o4l3n2ayiyq0f"},{"post_id":"ck6cbwmxs005e4l3n4z6q1iop","tag_id":"ck6cbwmyb008d4l3nkyvhwtta","_id":"ck6cbwmyd008q4l3nuc8sfqkp"},{"post_id":"ck6cbwmxt005h4l3nft348wgo","tag_id":"ck6cbwmyd008p4l3nzbnqvs7p","_id":"ck6cbwmye008s4l3n9a90viha"},{"post_id":"ck6cbwmxu005j4l3nvyiohtus","tag_id":"ck6cbwmy8007r4l3nmverw26w","_id":"ck6cbwmye008u4l3n5xmo08an"},{"post_id":"ck6cbwmxv005o4l3no2tdgt1r","tag_id":"ck6cbwmye008t4l3na30l10ei","_id":"ck6cbwmye008w4l3nblb717ab"},{"post_id":"ck6cbwmxw005r4l3n7m3m2krh","tag_id":"ck6cbwmye008v4l3nb4779zax","_id":"ck6cbwmyf008y4l3n3tln0q18"},{"post_id":"ck6cbwmxx005w4l3nzpefgfwh","tag_id":"ck6cbwmye008x4l3ndiojzwt5","_id":"ck6cbwmyg008z4l3n0cvy5ow7"},{"post_id":"ck6cbwn0300914l3ndf8khi3m","tag_id":"ck6cbwmxh004n4l3nmkb8rv8m","_id":"ck6cbwn0600944l3ntffy2sku"},{"post_id":"ck6cbwn0400934l3nyn3d3yho","tag_id":"ck6cbwmxh004n4l3nmkb8rv8m","_id":"ck6cbwn0900974l3nhnu5rp57"},{"post_id":"ck6cbwn0600954l3nl41ajhlm","tag_id":"ck6cbwmw100134l3nzw0kiegy","_id":"ck6cbwn0d009a4l3nkfmx7rw2"},{"post_id":"ck6cbwmzz00904l3ngh7q6tyt","tag_id":"ck6cbwmvk00084l3nhlhl9abk","_id":"ck6cbwn0g009d4l3no7sfnd68"},{"post_id":"ck6cbwmzz00904l3ngh7q6tyt","tag_id":"ck6cbwmwt002w4l3n2ve7tq2m","_id":"ck6cbwn0i009g4l3nozyd3o8g"},{"post_id":"ck6cbwmzz00904l3ngh7q6tyt","tag_id":"ck6cbwn0400924l3negw1ewep","_id":"ck6cbwn0j009j4l3ny1jt6vsa"},{"post_id":"ck6cbwn0900984l3nsfn6zhc3","tag_id":"ck6cbwmw100134l3nzw0kiegy","_id":"ck6cbwn0l009m4l3nkr7hude5"},{"post_id":"ck6cbwn0d009b4l3ncn38ym5y","tag_id":"ck6cbwmwy00334l3nclmvykp2","_id":"ck6cbwn0m009q4l3nyr5naenr"},{"post_id":"ck6cbwn0g009e4l3netjp79ff","tag_id":"ck6cbwmwt002w4l3n2ve7tq2m","_id":"ck6cbwn0o009t4l3no37zmyru"},{"post_id":"ck6cbwn0i009h4l3nd021wacz","tag_id":"ck6cbwmwy00334l3nclmvykp2","_id":"ck6cbwn0p009v4l3n2t06mkcm"},{"post_id":"ck6cbwn0k009k4l3nllp8sjcw","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwn0q009y4l3n4dl6idpq"},{"post_id":"ck6cbwn0l009n4l3nvh6j2wv0","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwn0r00a14l3np6ezh6j8"},{"post_id":"ck6cbwn0l009n4l3nvh6j2wv0","tag_id":"ck6cbwmxs005d4l3nhy3w35jo","_id":"ck6cbwn0s00a44l3nol0uozoz"},{"post_id":"ck6cbwn0n009r4l3nld07uo67","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwn0u00a94l3nnsmxmmjr"},{"post_id":"ck6cbwn0n009r4l3nld07uo67","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwn0v00ac4l3namasqgy1"},{"post_id":"ck6cbwn0o009u4l3nz7wh0ket","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwn0w00af4l3nlqzkjcm0"},{"post_id":"ck6cbwn0o009u4l3nz7wh0ket","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwn0y00ak4l3nqumbv6fz"},{"post_id":"ck6cbwn0p009w4l3nm9yhba7u","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwn0z00an4l3n57gbig3w"},{"post_id":"ck6cbwn0p009w4l3nm9yhba7u","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwn1100ar4l3n34y3luug"},{"post_id":"ck6cbwn0q009z4l3npqcl1wo0","tag_id":"ck6cbwmy500774l3nlvua9l6n","_id":"ck6cbwn1200au4l3ng3x1y5rb"},{"post_id":"ck6cbwn0t00a54l3ntajn1tvg","tag_id":"ck6cbwmy8007p4l3nq9jdvcvp","_id":"ck6cbwn1300ay4l3n141h0blt"},{"post_id":"ck6cbwn0w00ag4l3nag738qfc","tag_id":"ck6cbwmyb008d4l3nkyvhwtta","_id":"ck6cbwn1600b14l3necth08ra"},{"post_id":"ck6cbwn0y00al4l3n8wh6a4n2","tag_id":"ck6cbwmyb008d4l3nkyvhwtta","_id":"ck6cbwn1600b44l3nao4ampn1"},{"post_id":"ck6cbwn0r00a24l3nf2ezmk0w","tag_id":"ck6cbwn0u00a84l3nn4nuz4xu","_id":"ck6cbwn1700b64l3nwfojnjc5"},{"post_id":"ck6cbwn0r00a24l3nf2ezmk0w","tag_id":"ck6cbwn0x00ah4l3niavhcrg7","_id":"ck6cbwn1700b84l3n2bixdd73"},{"post_id":"ck6cbwn0z00ao4l3nv0sijb0d","tag_id":"ck6cbwmyb008d4l3nkyvhwtta","_id":"ck6cbwn1700bb4l3npi9nueio"},{"post_id":"ck6cbwn1100as4l3nm3n2lkpq","tag_id":"ck6cbwmyb008d4l3nkyvhwtta","_id":"ck6cbwn1700bc4l3nayhg5bxh"},{"post_id":"ck6cbwn0u00aa4l3nflv2sn0g","tag_id":"ck6cbwn1000aq4l3n9r1ugk19","_id":"ck6cbwn1700bd4l3nlw7m44qg"},{"post_id":"ck6cbwn0v00ad4l3nk8o1wkvi","tag_id":"ck6cbwn1300ax4l3ned01kg2b","_id":"ck6cbwn1800be4l3nd1p2zdct"},{"post_id":"ck6cbwn1200av4l3n5377gstg","tag_id":"ck6cbwn1600b34l3n6bfhy3zo","_id":"ck6cbwn1800bf4l3nugiofyb9"},{"post_id":"ck6cbwn1400az4l3nv5y4wahd","tag_id":"ck6cbwn1700b94l3n8q1ysypa","_id":"ck6cbwn1800bg4l3nh6700l5t"},{"post_id":"ck6cbwn2m00bh4l3n7l224047","tag_id":"ck6cbwmxh004n4l3nmkb8rv8m","_id":"ck6cbwn2o00bj4l3ngazq259d"},{"post_id":"ck6cbwn2n00bi4l3nnkq04fm3","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwn2q00bl4l3n5b5ns1c5"},{"post_id":"ck6cbwn2n00bi4l3nnkq04fm3","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwn2r00bo4l3npq041cuf"},{"post_id":"ck6cbwn2p00bk4l3nngqleax4","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwn2t00br4l3n6i4ovgwi"},{"post_id":"ck6cbwn2p00bk4l3nngqleax4","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwn2u00bu4l3nwp8vr50b"},{"post_id":"ck6cbwn2q00bm4l3nszs3rj54","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwn2w00bx4l3nic083cfi"},{"post_id":"ck6cbwn2q00bm4l3nszs3rj54","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwn2x00c14l3nulowauf8"},{"post_id":"ck6cbwn2s00bp4l3n1ksp8lgm","tag_id":"ck6cbwmxj004v4l3novxo5b3s","_id":"ck6cbwn2x00c44l3nfgw8qbed"},{"post_id":"ck6cbwn2s00bp4l3n1ksp8lgm","tag_id":"ck6cbwmy1006i4l3n478v9upt","_id":"ck6cbwn2y00c64l3nlsftreqy"},{"post_id":"ck6cbwn2t00bs4l3n6qbt65wf","tag_id":"ck6cbwmwy00334l3nclmvykp2","_id":"ck6cbwn2y00c94l3ntl83cy7g"},{"post_id":"ck6cbwn2u00bv4l3ny8u8rtc3","tag_id":"ck6cbwn2w00c04l3nso2g8zkn","_id":"ck6cbwn2y00cb4l3nyyzlhn4n"},{"post_id":"ck6cbwn2w00by4l3n802d8eix","tag_id":"ck6cbwn2w00c04l3nso2g8zkn","_id":"ck6cbwn2z00cd4l3ngicac4yr"},{"post_id":"ck6cbwn2x00c24l3n1fc927xt","tag_id":"ck6cbwn2w00c04l3nso2g8zkn","_id":"ck6cbwn2z00ce4l3nuz45xr6l"},{"post_id":"ck6cbwn5500cf4l3n55tb6wty","tag_id":"ck6cbwn2w00c04l3nso2g8zkn","_id":"ck6cbwn5600cg4l3nodkoksdl"}],"Tag":[{"name":"c#","_id":"ck6cbwmvk00084l3nhlhl9abk"},{"name":"C++","_id":"ck6cbwmvo000d4l3nhog6n3u9"},{"name":"javaweb","_id":"ck6cbwmvx000p4l3n3zhkcxrs"},{"name":"WEB交互","_id":"ck6cbwmvz000w4l3nyk0mkgp7"},{"name":"java","_id":"ck6cbwmw100134l3nzw0kiegy"},{"name":"spring","_id":"ck6cbwmw7001i4l3nnfhd93ya"},{"name":"mysql","_id":"ck6cbwmwt002w4l3n2ve7tq2m"},{"name":"数据库","_id":"ck6cbwmwy00334l3nclmvykp2"},{"name":"存储过程","_id":"ck6cbwmx3003m4l3nf6lcaf2x"},{"name":"MySQL","_id":"ck6cbwmxd004a4l3nebpyn9v6"},{"name":"协议","_id":"ck6cbwmxh004n4l3nmkb8rv8m"},{"name":"python","_id":"ck6cbwmxj004v4l3novxo5b3s"},{"name":"爬虫","_id":"ck6cbwmxs005d4l3nhy3w35jo"},{"name":"趣玩","_id":"ck6cbwmy000684l3n9so0u798"},{"name":"python教程","_id":"ck6cbwmy1006i4l3n478v9upt"},{"name":"项目管理","_id":"ck6cbwmy400704l3ntzg6rqwd"},{"name":"计算机科学","_id":"ck6cbwmy500734l3nagw0catd"},{"name":"财务报表","_id":"ck6cbwmy500754l3nmddx7h89"},{"name":"金融业务","_id":"ck6cbwmy500774l3nlvua9l6n"},{"name":"html","_id":"ck6cbwmy600794l3n9awajw03"},{"name":"bootstrap","_id":"ck6cbwmy6007b4l3ne1wxj6wa"},{"name":"Hexo","_id":"ck6cbwmy6007c4l3nn10a3jt6"},{"name":"博客优化","_id":"ck6cbwmy6007f4l3nuhl73qi2"},{"name":"TED","_id":"ck6cbwmy6007h4l3nprgsw07g"},{"name":"杂谈","_id":"ck6cbwmy7007l4l3n6bkyp1se"},{"name":"摘录","_id":"ck6cbwmy8007p4l3nq9jdvcvp"},{"name":"总结","_id":"ck6cbwmy8007r4l3nmverw26w"},{"name":"数字货币","_id":"ck6cbwmy8007t4l3ni21th5wq"},{"name":"框架","_id":"ck6cbwmy9007x4l3nsb063uej"},{"name":"目标","_id":"ck6cbwmy9007z4l3npacoq3u5"},{"name":"Java进阶","_id":"ck6cbwmy900834l3nlfdpmtxv"},{"name":"心法","_id":"ck6cbwmya00854l3n3nih44p3"},{"name":"通向自由之路","_id":"ck6cbwmyb008d4l3nkyvhwtta"},{"name":"github","_id":"ck6cbwmyd008p4l3nzbnqvs7p"},{"name":"敏捷开发","_id":"ck6cbwmye008t4l3na30l10ei"},{"name":"投资","_id":"ck6cbwmye008v4l3nb4779zax"},{"name":"胡思","_id":"ck6cbwmye008x4l3ndiojzwt5"},{"name":"串口","_id":"ck6cbwn0400924l3negw1ewep"},{"name":"hexo","_id":"ck6cbwn0u00a84l3nn4nuz4xu"},{"name":"nexT优化","_id":"ck6cbwn0x00ah4l3niavhcrg7"},{"name":"读书","_id":"ck6cbwn1000aq4l3n9r1ugk19"},{"name":"K线","_id":"ck6cbwn1300ax4l3ned01kg2b"},{"name":"正则表达式","_id":"ck6cbwn1600b34l3n6bfhy3zo"},{"name":"算法","_id":"ck6cbwn1700b94l3n8q1ysypa"},{"name":"JavaScript","_id":"ck6cbwn2w00c04l3nso2g8zkn"}]}}